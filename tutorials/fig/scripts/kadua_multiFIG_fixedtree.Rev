
####################################################
# IMPORTANT: set `tensorphylo_fp` to the directory #
# containing your `libTensorPhylo.a/dylib` library #
####################################################


###########################
# LOAD TENSORPHYLO PLUGIN #
###########################

#tensorphylo_fp = "/Users/mlandis/.local/lib/tensorphylo"
#if (!exists("tensorphylo_fp")) {
#  tensorphylo_fp = "~/.plugins/"
#}
#loadPlugin("TensorPhylo", tensorphylo_fp)

loadPlugin("TensorPhylo")

#######################
# INITIALIZE SETTINGS # 
#######################

# RNG seed
if (!exists("my_seed"))           my_seed = 1
seed(my_seed)

# Toggle a default settings with `!`, e.g. `!true` is `false`
# The analysis filename will indicate non-default settings
if (!exists("init_parameters"))   init_parameters  = true

if (!exists("use_features"))      use_features     = true
if (!exists("under_prior"))       under_prior      = false

if (!exists("use_rj"))            use_rj           = true
if (!exists("move_schedule"))     move_schedule    = v("random","single")[1]

# benchmarking
if (!exists("rel_tol"))           rel_tol = 1e-7
if (!exists("abs_tol"))           abs_tol = 1e-7

# param init
if (!exists("rho_d_init"))        rho_d_init   = 0.1
if (!exists("rho_e_init"))        rho_e_init   = 0.1
if (!exists("rho_w_init"))        rho_w_init   = 0.1
if (!exists("rho_b_init"))        rho_b_init   = 0.1
if (!exists("phi_d_init"))        phi_d_init   = 0.0
if (!exists("phi_e_init"))        phi_e_init   = 0.0
if (!exists("phi_w_init"))        phi_w_init   = 0.0
if (!exists("phi_b_init"))        phi_b_init   = 0.0
if (!exists("sigma_d_init"))      sigma_d_init = 0.0
if (!exists("sigma_b_init"))      sigma_b_init = 0.0
if (!exists("sigma_e_init"))      sigma_e_init = 0.0
if (!exists("sigma_w_init"))      sigma_w_init = 0.0

# dataset constraints
if (!exists("max_subrange_split_size")) max_subrange_split_size = 7
if (!exists("max_range_size"))    max_range_size = 4

# analysis string name
analysis                                    = "multiFIG_model"
if (!use_features)                analysis += "_noFeatures"
if (under_prior)                  analysis += "_underPrior"
if (!use_rj)                      analysis += "_noRjmcmc"
analysis += "_seed" + my_seed

print("Analysis name: ", analysis)

# analysis settings
n_proc          = 6
n_iter          = 10000
print_gen       = 1
stoch_print_gen = 20

# filesystem
clade_name    = "kadua"
fp            = "./"
dat_fp        = fp + "data/kadua/"
geo_fp        = fp + "data/hawaii/"
code_fp       = fp + "scripts/"
feature_fn    = geo_fp + "feature_summary.csv"
phy_fn        = dat_fp + clade_name + ".tre"
bg_fn         = dat_fp + clade_name + "_range_n7.nex"
label_fn      = dat_fp + clade_name + "_range_label.csv"

# model source files
geo_code_fn   = code_fp + "geo_multiFIG.Rev"
phylo_code_fn = code_fp + "phylo_multiFIG.Rev"

# get phylogenetic data
phy          <- readTrees(phy_fn)[1]
phy.rescale( 5./phy.rootAge() )
tree_height  <- phy.rootAge()
taxa         = phy.taxa()
num_taxa     = taxa.size()
num_branches = 2 * num_taxa - 2

# get biogeographic data
dat_01       = readDiscreteCharacterData(bg_fn)
num_regions  = dat_01.nchar()
num_ranges   = 0
for (k in 1:max_range_size) {
    num_ranges += choose(num_regions, k)
}
dat_nn       = formatDiscreteCharacterData(dat_01, format="GeoSSE", numStates=num_ranges)
desc         = dat_nn.getStateDescriptions()

write("index,range\n", filename=label_fn)
for (i in 1:desc.size()) {
    write((i-1) + "," + desc[i] + "\n", filename=label_fn, append=true)
}

# load geography model script
source( geo_code_fn )

# load phylogeny model script
source( phylo_code_fn )

# associate phylo/biogeo data with model
timetree.setValue(phy)
timetree.clampCharData(dat_nn)

print("Creating moves...")

# create moves
moves = VectorMoves()

# base rates
moves.append( mvScale(rho_d, weight=5) )
moves.append( mvScale(rho_e, weight=5) )
moves.append( mvScale(rho_w, weight=5) )
moves.append( mvScale(rho_b, weight=5) )

if (use_features) {
    for (i in 1:sigma_e.size()) {
        moves.append( mvScale(sigma_e[i], weight=2) )
        moves.append( mvScale(sigma_w[i], weight=2) )
        moves.append( mvSlide(sigma_e[i], weight=2) )
        moves.append( mvSlide(sigma_w[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(sigma_e[i], weight=3) )
            moves.append( mvRJSwitch(sigma_w[i], weight=3) )
            use_sigma_e[i] := ifelse(sigma_e[i] == 0.0, 0, 1)
            use_sigma_w[i] := ifelse(sigma_w[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:sigma_d.size()) {
        moves.append( mvScale(sigma_d[i], weight=2) )
        moves.append( mvScale(sigma_b[i], weight=2) )
        moves.append( mvSlide(sigma_d[i], weight=2) )
        moves.append( mvSlide(sigma_b[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(sigma_d[i], weight=3) )
            moves.append( mvRJSwitch(sigma_b[i], weight=3) )
            use_sigma_d[i] := ifelse(sigma_d[i] == 0.0, 0, 1)
            use_sigma_b[i] := ifelse(sigma_b[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:phi_e.size()) {
        moves.append( mvScale(phi_e[i], weight=2) )
        moves.append( mvScale(phi_w[i], weight=2) )
        moves.append( mvSlide(phi_e[i], weight=2) )
        moves.append( mvSlide(phi_w[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(phi_e[i], weight=3) )
            moves.append( mvRJSwitch(phi_w[i], weight=3) )
            use_phi_e[i] := ifelse(phi_e[i] == 0.0, 0, 1)
            use_phi_w[i] := ifelse(phi_w[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:phi_d.size()) {
        moves.append( mvScale(phi_d[i], weight=2) )
        moves.append( mvScale(phi_b[i], weight=2) )
        moves.append( mvSlide(phi_d[i], weight=2) )
        moves.append( mvSlide(phi_b[i], weight=2) )   
     if (use_rj) {
            moves.append( mvRJSwitch(phi_d[i], weight=3) )
            moves.append( mvRJSwitch(phi_b[i], weight=3) )
            use_phi_d[i] := ifelse(phi_d[i] == 0.0, 0, 1)
            use_phi_b[i] := ifelse(phi_b[i] == 0.0, 0, 1)
        }
    }
} else {
    # set all feature effect parameters to zero;
    # do not add moves to update during MCMC
    for (i in 1:sigma_e.size()) {
        sigma_e[i].setValue(0.0)
        sigma_w[i].setValue(0.0)
    }
    for (i in 1:sigma_d.size()) {
        sigma_d[i].setValue(0.0)
        sigma_b[i].setValue(0.0)
    }
    for (i in 1:phi_e.size()) {
        phi_e[i].setValue(0.0)
        phi_w[i].setValue(0.0)
    }
    for (i in 1:phi_d.size()) {
        phi_d[i].setValue(0.0)
        phi_b[i].setValue(0.0)
    }
}

############
# Monitors #
############

print("Creating monitors...")
# create monitor vector
monitors = VectorMonitors()
# screen monitor, so you don't get bored
monitors.append( mnScreen(root_age, printgen=print_gen) )
# file monitor for all simple model variables
monitors.append( mnModel(printgen=print_gen, file="output/" + analysis + ".model.txt") )
# file monitor for biogeographic model
bg_mon_filename = "output/" + analysis + ".bg.txt"
monitors.append( mnFile(filename = bg_mon_filename, printgen=print_gen,
                        rho_e, rho_w, rho_d, rho_b, r_e[1], r_w[1], r_d[1][1], r_d[1][2], r_d[1][3], r_d[1][4], r_d[1][5], r_d[1][6], r_b[1][1], r_b[1][2], r_b[1][3], r_b[1][4], r_b[1][5], r_b[1][6], m_e[1][1], m_w[1][1], m_d[1][1], m_d[1][2], m_d[1][3], m_d[1][4], m_d[1][5], m_d[1][6], m_b[1][1], m_b[1][2], m_b[1][3], m_b[1][4], m_b[1][5], m_b[1][6]))
monitors.append( mnFile(filename="output/"+analysis+".param.json", printgen=print_gen, format="json",
                        rho_e, rho_w, rho_d, rho_b, r_e, r_w, r_d, r_b, m_e, m_w, m_d, m_b) )

# ancestral estimates
monitors.append( mnJointConditionalAncestralState(tree=timetree, glhbdsp=timetree, printgen=print_gen*stoch_print_gen, filename="output/" + analysis + ".states.txt", withTips=true, withStartStates=true, type="NaturalNumbers") ) 
monitors.append( mnStochasticCharacterMap(glhbdsp=timetree, printgen=print_gen*stoch_print_gen, filename="output/" + analysis + ".stoch.txt",use_simmap_default=false) )

# create model object
print("Creating model...")
mymodel = model(timetree)

# create MCMC object
print("Creating MCMC...")
mymcmc = mcmc(mymodel, moves, monitors, moveschedule=move_schedule)
mymcmc.operatorSummary()

# run MCMC
print("Running MCMC...")
mymcmc.run(n_iter, underPrior=under_prior)

# ancestral state tree
f_burn = 0.2
x_stoch = readAncestralStateTrace(file="output/" + analysis + ".stoch.txt")
x_states = readAncestralStateTrace(file="output/" + analysis + ".states.txt")
summarizeCharacterMaps(x_stoch,timetree,file="output/" + analysis + ".events.txt",burnin=f_burn)
state_tree = ancestralStateTree(
    tree=timetree,
    ancestral_state_trace_vector=x_states,
    include_start_states=true,
    file="output/" + analysis + ".ase.tre",
    summary_statistic="MAP",
    reconstruction="marginal",
    burnin=f_burn,
    nStates=num_ranges,
    site=1)
writeNexus(state_tree,filename="output/" + analysis + ".ase.tre")

# done!
quit()
