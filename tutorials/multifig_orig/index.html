<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Feature-informed diversification with the MultiFIG model</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Feature-informed diversification with the MultiFIG model</h1>
	<h3 class="subtitle">Using multiple regional features to inform rates of dispersal, extinction, within-region speciation, and between-region speciation</h3>
	<h4 class="authors">Sarah Swiston</h4>
  <h5>Last modified on May 24, 2024</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/sse/bisse-intro.html">Background on state-dependent diversification rate estimation</a></li>
          
            <li><a href="/tutorials/sse/classe.html">State-dependent diversification with the ClaSSE model</a></li>
          
            <li><a href="/tutorials/geosse_orig/">State-dependent diversification with GeoSSE</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/multifig_orig/data/features/adjacency.csv">adjacency.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/features/alt_classification.csv">alt_classification.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/features/alt_mean.csv">alt_mean.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/features/alt_mean_diff.csv">alt_mean_diff.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/features/alt_sameness.csv">alt_sameness.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/features/area_classification.csv">area_classification.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/features/areas.csv">areas.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/features/dist_mean.csv">dist_mean.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/feature_summary.csv">feature_summary.csv</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/full_ranges.nex">full_ranges.nex</a></li>
        
          <li><a href="/tutorials/multifig_orig/data/tree.mcc.tre">tree.mcc.tre</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/multifig_orig/scripts/multifig.R">multifig.R</a></li>
        
          <li><a href="/tutorials/multifig_orig/scripts/multifig.Rev">multifig.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="introduction">Introduction</h2>
<hr class="section" />

<p>In the previous examples, we used a GeoSSE model <a class="citation" href="#Goldberg2011">(Goldberg et al. 2011)</a> to investigate the evolution of the South American lizard genus <em>Liolaemus</em>. The GeoSSE model allows us to estimate rates of within-region speciation, extinction, between-region speciation, and dispersal that differ among regions. Biologically, we expect that these different rates are informed by features of the regions where the species are evolving. For example, we might expect that species disperse at a lower rate between more distant regions, or go extinct at a higher rate in smaller regions. The FIG model <a class="citation" href="#Landis2022">(Landis et al. 2022)</a> and the Multiple Feature-Informed GeoSSE (MultiFIG) model <a class="citation" href="#Swiston2023">(Swiston and Landis 2023)</a> address this. Rather than giving each region its own evolutionary rate parameters, it uses functions to link features of those regions to evolutionary rates. This allows us to test hypotheses about the importance of certain environmental features on evolutionary processes. It also has the benefit of reducing the number of parameters that need to be estimated. The number of parameters in the MultiFIG model is constant with respect to the number of regions, so we can investigate systems with more regions. In this tutorial, we will model the evolution and biogeography of <em>Liolaemus</em> using six regions <a class="citation" href="#Esquerré2019">(Esquerré et al. 2019)</a> and eight regional features.</p>

<figure id="map"><p><img src="figures/map.png" width="50%" /></p>
<figcaption>Six regions of southern South America used in the analysis of <em>Liolaemus</em> with abbreviations: Aa (Altiplanic Andes), Ca (Central Andes), Pa (Patagonia), Cc (Central Chile), Ad (Atacama Desert), El (Eastern Lowlands).</figcaption>
</figure>

<h3 class="subsection" id="the-multifig-model">The MultiFIG model</h3>
<hr class="subsection" />

<p>Much like the GeoSSE model, MultiFIG uses four core processes: within-region speciation, extinction, between-region speciation, and dispersal. However, instead of assigning each region or region pair its own rate for each process, MultiFIG uses regional feature data and a series of strength parameters and functions to construct rates.</p>

<figure id="model"><p><img src="figures/model.png" width="95%" /></p>
<figcaption>Graphical model of MultiFIG. Square nodes represent constant values (data). Circle nodes with solid lines represent stochastic variables (model parameters, and the phylogeny, which is fixed in this analysis). Circle nodes with dotted lines represent deterministic variables (functions). Large rectangles indicate iterative plates.</figcaption>
</figure>

<p>The FIG model incorporates geographical features with two value types as model variables: quantitative features and categorical features. Quantitative features have continuous real values while categorical features have discrete values. MultiFIG also separates data by dimensionality type, incorporating one-dimensional within-region data and two-dimensional between-region data. We use four containers to store this data: $w_c$, $w_q$, $b_c$, and $b_q$.</p>

<p>Each regional feature is assigned a “feature effect” parameter that measures the strength and direction of the effect of a particular feature on a particular process. Note that “effect” refers to a mathematical relationship here, but does <em>not</em> indicate causality. These strength parameters are referred to as $\sigma$ and $\phi$, representing the effects of categorical and quantitative features respectively. There is one $\sigma$ or $\phi$ parameter per feature per process. For example, $\phi_w^{Altitude}$ would represent the relationship between region altitude and within-region speciation.</p>

<p>For each process, the categorical and quantitative feature effects (with feature data modified by strength parameters) are gathered into $c$ and $q$ vectors, then ultimately combined into an $m$ vector. The $m$ vector represents the total effects of all regional features on a particular process, with entries representing each region (or region pair for between-region processes). The $m$ vector represents relative rates among regions, but to obtain absolute rates, the $m$ vector for each process is multiplied by a process-specific base rate parameter $\rho$. This constructs the $r$ vectors that are analogous to GeoSSE rates: $r_w$ for within-region speciation rates, $r_e$ for extinction rates, and $r_d$ for dispersal rates (calculating $r_b$ for between-region speciation rates also requires the use of a range split score, as in <a class="citation" href="#Landis2022">(Landis et al. 2022)</a>). This tutorial will not describe the details of these intermediate functions, but they can be found in <a class="citation" href="#Swiston2023">(Swiston and Landis 2023)</a>.</p>

<p>In this analysis, we are examining 8 regional features. 4 are quantitative: area, mean altitude, distance, and difference in mean altitude. The other 4 are categorical: size, height, adjacency, and height sameness. While the categorical features are closely related to the quantitative features in this analysis, this is not a requirement of the model. Because each within-region feature acts on 2 processes and each between-region feature acts on 2 processes, this creates a total of 16 parameters. Adding one $\rho$ parameter for each process results in a total of 20 model parameters to be estimated. We will use a time-calibrated phylogeny and present-day ranges for <em>Liolaemus</em> to estimate these parameters, and use those estimates to determine which regional features are most strongly related to particular processes.</p>

<figure id="map"><p><img src="figures/features.png" width="95%" /></p>
<figcaption>The 8 regional features investigated in this analysis and the 16 associated parameters relating these features to core biogeographic processes.</figcaption>
</figure>

<h3 class="subsection" id="setup">Setup</h3>
<hr class="subsection" />

<blockquote class="info">
  <h2 id="important-version-info">Important version info!!</h2>
  <p>This tutorial is the one of a series of lessons explaining how to build increasingly powerful but computationally demanding GeoSSE-type models for biogeographic analyses. Inference under these models is powered by the Tensorphylo plugin for RevBayes, located here: <a href="https://bitbucket.org/mrmay/tensorphylo/src/master/">bitbucket.org/mrmay/tensorphylo/src/master</a> <a class="citation" href="#May2022">(May and Meyer)</a>.
This tutorial, and following tutorials for GeoSSE-type models, will also require a development version of RevBayes built from the <code class="language-plaintext highlighter-rouge">hawaii_fix</code> branch (this message will be removed when the branch is merged).
As an alternative to building the development version of RevBayes and installing Tensorphylo, you can instead use the RevBayes Docker image, which comes pre-configured with Tensorphylo enabled. The RevBayes Docker tutorial is located here: <a href="https://revbayes.github.io/tutorials/docker.html">revbayes.github.io/tutorials/docker</a>.</p>
</blockquote>

<p>Running a MultiFIG analysis in RevBayes requires several important data files, including a file representing the time-calibrated phylogeny and a biogeographic data matrix describing the ranges for each species. <code class="language-plaintext highlighter-rouge">tree.mcc.tre</code> is a time-calibrated phylogeny of <em>Liolaemus</em>. <code class="language-plaintext highlighter-rouge">full_ranges.nex</code> assigns ranges to each species for a six-region system: Altiplanic Andes, Central Andes, Patagonia, Central Chile, Atacama Desert, and Eastern Lowlands. For each species (row) and region (column), the file reports if the species is present (1) or absent (0) in that region. There are also feature files that contain regional feature data, and a <code class="language-plaintext highlighter-rouge">feature_summary.csv</code> file that describes all the regional feature files (where they are found and what kind of data they contain).</p>

<p>If you prefer to run a single script instead of entering each command manually, the RevBayes script called <code class="language-plaintext highlighter-rouge">multifig.Rev</code> contains all of the commands that are used in the tutorial. There is also an R script for plotting the analysis results. The data and script can be found in the <code class="language-plaintext highlighter-rouge">Data files and scripts</code> box in the left sidebar of the tutorial page. Somewhere on your computer, you should create a directory (folder) for this tutorial. Inside the tutorial directory, you should create a <code class="language-plaintext highlighter-rouge">scripts</code> directory. This is the directory where you will run RevBayes commands, or where you will put the <code class="language-plaintext highlighter-rouge">multifig.Rev</code> and <code class="language-plaintext highlighter-rouge">multifig.R</code> scripts. Then, you should create a <code class="language-plaintext highlighter-rouge">data</code> directory inside the tutorial directory. The scripts/commands for the tutorial expect that the primary data files (<code class="language-plaintext highlighter-rouge">tree.mcc.tre</code>, <code class="language-plaintext highlighter-rouge">full_ranges.nex</code>, and <code class="language-plaintext highlighter-rouge">feature_summary.csv</code>) will be in this directory, while the feature files (the data, not the summary file) will be in a subdirectory called <code class="language-plaintext highlighter-rouge">features</code>. However, you can always modify the filepaths to locate the data wherever you choose to download it.</p>

<h2 class="section" id="multifig-in-revbayes">MultiFIG in RevBayes</h2>
<hr class="section" />

<h3 class="subsection" id="getting-started">Getting started</h3>
<hr class="subsection" />

<p>After starting up RevBayes from within your local <code class="language-plaintext highlighter-rouge">scripts</code> directory, you can load the TensorPhylo plugin. You will need to know where you downloaded the plugin. For example, if you cloned the TensorPhylo directory into your home directory at <code class="language-plaintext highlighter-rouge">~/tensorphylo</code>, you would use the following command to load the plugin:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loadPlugin("TensorPhylo", "~/tensorphylo/build/installer/lib")
</code></pre></div></div>

<p>Note that if you’re using the RevBayes Docker image, then the Tensorphylo plugin is installed in the <code class="language-plaintext highlighter-rouge">/</code> (root) directory:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loadPlugin("TensorPhylo", "/tensorphylo/build/installer/lib")
</code></pre></div></div>

<p>It is also a good idea to set a seed. If you want to exactly replicate the results of the tutorial, you should use the seed <code class="language-plaintext highlighter-rouge">1</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seed(1)
</code></pre></div></div>

<p>We also want to tell RevBayes where to find our data (and where to save our output later). If you have set up your tutorial directory in a different way than suggested, you will need to modify the filepaths.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fp          = "../"
dat_fp      = fp + "data/"
out_fp      = fp + "output/"
bg_fn       = dat_fp + "full_ranges.nex"
phy_fn      = dat_fp + "tree.mcc.tre"
feature_fn  = dat_fp + "feature_summary.csv"
</code></pre></div></div>

<h3 class="subsection" id="data">Data</h3>
<hr class="subsection" />

<p>Next, we will read in the data. Let’s start with the phylogenetic tree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phy &lt;- readTrees(phy_fn)[1]
</code></pre></div></div>

<p>In order to set up our analysis, we will want to know some information about this tree: the root age, the taxa, and the number of taxa.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree_height &lt;- phy.rootAge()
taxa = phy.taxa()
num_taxa = taxa.size()
</code></pre></div></div>

<p>We also want to read in the range data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bg_01 = readDiscreteCharacterData(bg_fn)
</code></pre></div></div>

<p>We want to get some information about this range data: how many regions there are, how many ranges can be constructed from these regions, and how many region pairs there are.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num_regions = bg_01.nchar()
num_ranges = abs(2^num_regions - 1)
num_pairs = num_regions^2 - num_regions
</code></pre></div></div>

<p>We want to format the range data to be used in a GeoSSE-type analysis. This will take the binary range data and output integer states.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bg_dat = formatDiscreteCharacterData(bg_01, format="GeoSSE", numStates=num_ranges)
</code></pre></div></div>

<p>We also want to get our feature data. Using the RevBayes function <code class="language-plaintext highlighter-rouge">readRegionalFeatures</code>, we can look at the <code class="language-plaintext highlighter-rouge">feature_summary.csv</code> file and automatically look for feature data. The <code class="language-plaintext highlighter-rouge">feature_summary.csv</code> file is specially formated to be read by RevBayes, consisting of 5 columns. The first column is <code class="language-plaintext highlighter-rouge">time_index</code>. More advanced analyses, like TimeFIG, may involve time-heterogenous region features, in which case we would need to index our feature data by time slices. However, in this analysis, we are only using present-day data, so all of our features will have a <code class="language-plaintext highlighter-rouge">time_index</code> of 1. The second column is <code class="language-plaintext highlighter-rouge">feature_index</code>. Each feature type (within-region categorical, within-region quantitative, between-region categorical, and between-region quantitative) has a container that can contain several features, so we want to index the features within those containers. For example, in this analysis, each container has two features, indexed 1 and 2. Keep in mind that Feature 1 in one container does not have to be related to Feature 1 in another container. It’s important to keep track of these indices so you know which output corresponds to which feature. For this analysis, we’ve listed the features in order on the feature table – for example, Quantitative Between-Region Feature 1 is Mean Distance Between Points (km). The third column is <code class="language-plaintext highlighter-rouge">feature_relationship</code>. This column is for indicating whether the feature is a within-region feature or a between-region feature, with options ‘within’ or ‘between’. The fourth column is <code class="language-plaintext highlighter-rouge">feature_type</code>, for indicating whether the feature is quantitative of categorical. Finally, the fifth column is <code class="language-plaintext highlighter-rouge">feature_path</code>, which gives a filepath for the actual file containing the data for that feature.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>geo_features &lt;- readRegionalFeatures(feature_fn, delimiter=",",nonexistent_region_token="nan")
</code></pre></div></div>

<p>Next, we transform the feature data into feature layers, a RevBayes object that we will use later for informing our biogeographic rates. First, we normalize the features (important for scaling reasons). Then we pull each feature type out of our <code class="language-plaintext highlighter-rouge">geo_features</code> object. Finally, we create the layers.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>geo_features.normalize("within")
geo_features.normalize("between")
feature_CW &lt;- geo_features.get("within","categorical",1)
feature_QW &lt;- geo_features.get("within","quantitative",1)
feature_CB &lt;- geo_features.get("between","categorical",1)
feature_QB &lt;- geo_features.get("between","quantitative",1)
for (i in 1:feature_CW.size()) {layer_CW[i] &lt;- feature_CW[i].get()}
for (i in 1:feature_QW.size()) {layer_QW[i] &lt;- feature_QW[i].get()}
for (i in 1:feature_CB.size()) {layer_CB[i] &lt;- feature_CB[i].get()}
for (i in 1:feature_QB.size()) {layer_QB[i] &lt;- feature_QB[i].get()}
</code></pre></div></div>

<h3 class="subsection" id="model-setup">Model setup</h3>
<hr class="subsection" />

<p>In the MultiFIG model, there are four processes: within-region speciation, extinction, between-region speciation, and dispersal. Rates per region or region pair are calculated using feature data, feature effect parameters, and base rate parameters. We will set the prior on base rate parameters to the exponential distribution <code class="language-plaintext highlighter-rouge">dnExp(1)</code>. We will set the prior on feature effect parameters to the normal distribution <code class="language-plaintext highlighter-rouge">dnNormal(0,1)</code>. Then we will use the RevBayes function <code class="language-plaintext highlighter-rouge">fnFeatureInformedRates</code> to combine the feature data and feature effect parameters to create $m$ vectors/matrices, representing relative rates per region or region pair. Finally, we will multiply $m$ by the base rate parameter to get model rates $r_w$, $r_e$, $r_b$, and $r_d$.</p>

<p>Let’s start by creating distributions that we will use for all $\rho$, $\phi$, and $\sigma$ parameters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigma_dist  = dnNormal(0,1)
phi_dist    = dnNormal(0,1)
rho_dist    = dnExp(1)
</code></pre></div></div>

<p>Now we will set up our rates for the four core processes. We will set up within-region speciation rates first. We won’t worry about multiplying $m_w$ by the base rate yet, because the <code class="language-plaintext highlighter-rouge">fnBiogeographyCladoEventsBD</code> function will do this later.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rho_w ~ rho_dist
for (i in 1:feature_CW.size()) sigma_w[i] ~ sigma_dist
for (i in 1:feature_QW.size()) phi_w[i] ~ phi_dist
m_w := fnFeatureInformedRates(layer_CW, layer_QW, sigma_w, phi_w, null_rate=0)
</code></pre></div></div>

<p>Extinction rates are set up similarly, and we will incorporate $\rho$ this time. From these extinction rates (which are actually single-region extinction rates), we will set up global extinction rates for each possible range in the state space. In the MultiFIG model, lineage-level extincion events occur when a species goes globally extinct (i.e. it loses the last region from its range). Therefore, we will assign all multi-region ranges an extinction rate of 0, and we will assign all single-region ranges an extinction rate equal to the local extirpation rate. Note, ranges are numbered such that indices <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, through <code class="language-plaintext highlighter-rouge">num_regions</code> correspond to ranges that respectively contain only region 1, region 2, up through the last region in the system.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rho_e ~ rho_dist
for (i in 1:feature_CW.size()) sigma_e[i] ~ sigma_dist
for (i in 1:feature_QW.size()) phi_e[i] ~ phi_dist
m_e := fnFeatureInformedRates(layer_CW, layer_QW, sigma_e, phi_e, null_rate=1e3)
r_e := rho_e * m_e[1]
for (i in 1:num_ranges) {
    mu[i] &lt;- abs(0)
    if (i &lt;= num_regions) {
        mu[i] := r_e[i]
    }
}
</code></pre></div></div>

<p>Between-region speciation rates are set up similarly. Again, we do not need to incorporate $\rho$ yet. We also don’t have to worry about incorporating range split score; RevBayes will do this automatically when we create the cladogenetic probability matrix.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rho_b ~ rho_dist
for (i in 1:feature_CB.size()) sigma_b[i] ~ sigma_dist
for (i in 1:feature_QB.size()) phi_b[i] ~ phi_dist
m_b := fnFeatureInformedRates(layer_CB, layer_QB, sigma_b, phi_b, null_rate=1)
</code></pre></div></div>

<p>Finally, for dispersal rates, we will set up dispersal rates.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rho_d ~ rho_dist
for (i in 1:feature_CB.size()) sigma_d[i] ~ sigma_dist
for (i in 1:feature_QB.size()) phi_d[i] ~ phi_dist
m_d := fnFeatureInformedRates(layer_CB, layer_QB, sigma_d, phi_d, null_rate=0)
for (i in 1:num_regions) {r_d[i] := rho_d * m_d[i]}
</code></pre></div></div>

<p>From these rates, we can use RevBayes functions to construct the rate matrices used by the analysis. The first is an anagenetic rate matrix, which gives rates of anagenetic processes. We are not restricting the number of regions that a species can live in at any given time, so we set the <code class="language-plaintext highlighter-rouge">maxRangeSize</code> equal to the number of regions. Settings <code class="language-plaintext highlighter-rouge">maxRangeSize</code> may be used to reduce the number of range patterns in the model, particularly when <code class="language-plaintext highlighter-rouge">num_regions</code> is large.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_bg := fnBiogeographyRateMatrix(
    dispersalRates=r_d,
    extirpationRates=r_e,
    maxRangeSize=num_regions)
</code></pre></div></div>

<p>We also construct a cladogenetic event matrix, describing the absolute rates of different cladogenetic events. We are not restricting the sizes of ‘split’ subranges following between-region speciation, so we set the <code class="language-plaintext highlighter-rouge">max_subrange_split_size</code> equal to the number of regions. From this matrix, we can obtain the total speciation rates per state, as well as a cladogenetic probability matrix.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clado_map := fnBiogeographyCladoEventsBD(
    speciation_rates=[ rho_w, rho_b ],
    within_region_features=m_w[1],
    between_region_features=m_b,
    max_range_size=num_regions,
    max_subrange_split_size=num_regions)
lambda := clado_map.getSpeciationRateSumPerState()
omega  := clado_map.getCladogeneticProbabilityMatrix()
</code></pre></div></div>

<p>Lastly, we need to assign a probability distribution to range of the most recent common ancestor of all species, prior to the first speciation event. In this analysis, we will assume all ranges were equally likely for that ancestor.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi_base &lt;- rep(1,num_ranges)
pi &lt;- simplex(pi_base)
</code></pre></div></div>

<p>With all of the rates constructed, we can create a stochastic variable drawn from this MultiFIG model with state-dependent birth, death, and speciation processes. This establishes how the various processes interact to generate a tree with a topology, divergence times, and terminal taxon states (ranges). Then we can clamp the variable with the fixed tree and present-day range states, allowing us to infer model parameters based on our observed data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timetree ~ dnGLHBDSP(
    rootAge     = tree_height,
    lambda      = lambda,
    mu          = mu,
    eta         = Q_bg,
    omega       = omega,
    pi          = pi,
    rho         = 1,
    condition   = "time",
    taxa        = taxa,
    nStates     = num_ranges,
    nProc       = 4)
timetree.clamp(phy)
timetree.clampCharData(bg_dat)
</code></pre></div></div>

<h3 class="subsection" id="mcmc">MCMC</h3>
<hr class="subsection" />

<p>For this analysis, we will perform a short MCMC of 1000 generations, with 100 generations of hyperparameter-tuning burnin. An analysis of this length may not achieve convergence, so these settings should only be used for testing purposes. You can alter this MCMC by changing the number of iterations, the length of the burnin period, or the move schedule. We will also set up the MCMC to record every 10 iterations.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_gen = 1000
n_burn = n_gen/10
printgen = 10
</code></pre></div></div>

<p>We want MCMC to update all of the base rate $\rho$ parameters, as well as the $\sigma$ and $\phi$ parameters. We will use a scaling move for the base rates, since they should always have positive values. These moves will each be performed once per iteration. We will use a sliding move for the feature effect parameters, since they can have positive or negative values. These moves will also be performed once per iteration.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvi = 1
mv[mvi++] = mvScale(rho_w, weight=1)
mv[mvi++] = mvScale(rho_e, weight=1)
mv[mvi++] = mvScale(rho_b, weight=1)
mv[mvi++] = mvScale(rho_d, weight=1)
for (i in 1:sigma_d.size()) {mv[mvi++] = mvSlide(sigma_d[i])}
for (i in 1:sigma_b.size()) {mv[mvi++] = mvSlide(sigma_b[i])}
for (i in 1:sigma_e.size()) {mv[mvi++] = mvSlide(sigma_e[i])}
for (i in 1:sigma_w.size()) {mv[mvi++] = mvSlide(sigma_w[i])}
for (i in 1:phi_d.size()) {mv[mvi++] = mvSlide(phi_d[i])}
for (i in 1:phi_b.size()) {mv[mvi++] = mvSlide(phi_b[i])}
for (i in 1:phi_e.size()) {mv[mvi++] = mvSlide(phi_e[i])}
for (i in 1:phi_w.size()) {mv[mvi++] = mvSlide(phi_w[i])}
</code></pre></div></div>

<p>We also want MCMC to keep track of certain things while it runs. We want it to print some output to the screen so we can see how it is running (<code class="language-plaintext highlighter-rouge">mnScreen</code>). We also want it to save model parameters to a file (<code class="language-plaintext highlighter-rouge">mnModel</code>). Finally, if we want to use the output for ancestral state reconstruction, we want to save states and stochastic character mappings (<code class="language-plaintext highlighter-rouge">mnJointConditionalAncestralStates</code> and <code class="language-plaintext highlighter-rouge">mnStochasticCharacterMap</code>). All of the output files will be saved in the <code class="language-plaintext highlighter-rouge">output</code> directory so that it can be accessed later.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mni = 1
mn[mni++] = mnScreen(printgen=printgen)
mn[mni++] = mnModel(printgen=printgen, filename=out_fp+"model.log")
mn[mni++] = mnJointConditionalAncestralState(glhbdsp=timetree, tree=timetree, printgen=printgen, filename=out_fp+"states.log", withTips=true, withStartStates=true, type="NaturalNumbers")
mn[mni++] = mnStochasticCharacterMap(glhbdsp=timetree, printgen=printgen, filename=out_fp+"stoch.log")
</code></pre></div></div>

<p>Then we can start up the MCMC. It doesn’t matter which model parameter you use to initialize the model, so we will use m_w. RevBayes will find all the other parameters that are connected to m_w and include them in the model as well. Then we create an MCMC object with the moves, monitors, and model, add burnin, and run the MCMC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mdl = model(m_w)
ch = mcmc(mv, mn, mdl)
ch.burnin(n_burn, tuningInterval=10)
ch.run(n_gen)
</code></pre></div></div>

<p>After the MCMC analysis has concluded, we can summarize the ancestral states we obtained, creating an ancestral state tree. This tree will be written to the file <code class="language-plaintext highlighter-rouge">ase.tre </code>. It may take a little while.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f_burn = 0.2
x_stoch = readAncestralStateTrace(file=out_fp+"stoch.log")
x_states = readAncestralStateTrace(file=out_fp+"states.log")
summarizeCharacterMaps(x_stoch,timetree,file=out_fp+"events.tsv",burnin=f_burn)
state_tree = ancestralStateTree(
    tree=timetree,
    ancestral_state_trace_vector=x_states,
    include_start_states=true,
    file=out_fp+"ase.tre",
    summary_statistic="MAP",
    reconstruction="marginal",
    burnin=f_burn,
    nStates=3,
    site=1)
writeNexus(state_tree,filename=out_fp+"ase.tre")
</code></pre></div></div>

<h3 class="subsection" id="output">Output</h3>
<hr class="subsection" />

<p>One interesting thing we can do with the output of the MultiFIG analysis is plot ancestral states. This can be done using RevGadgets, an R packages that processes RevBayes output. You can use R to generate a tree with ancestral states by running the <code class="language-plaintext highlighter-rouge">multifig.R</code> script, or by executing the following code in R. Before plotting the ancestral state tree, we create two vectors. The vector <code class="language-plaintext highlighter-rouge">labels</code> is useful because it maps actual region labels onto state numbers, so the legend can be easily interpreted. If you used your own data, you would have to provide your own state labels. The vector <code class="language-plaintext highlighter-rouge">colors</code> is necessary in this case because RevGadgets does not automatically generate color schemes with more than 12 colors, and there are more than 12 states on the reconstructed tree. If you use your own data, you may need more colors or fewer colors (the <code class="language-plaintext highlighter-rouge">colors</code> vector is allowed to have more colors than states).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>labels &lt;- c("0" = "Aa","1" = "Ca","2" = "Pa","3" = "Cc","4" = "Ad","5" = "El","6" = "AaCa","7" = "AaPa","8" = "CaPa","9" = "AaCc","10" = "CaCc","11" = "PaCc","12" = "AaAd","13" = "CaAd","14" = "PaAd","15" = "CcAd","16" = "AaEl","17" = "CaEl","18" = "PaEl","19" = "CcEl","20" = "AdEl","21" = "AaCaPa","22" = "AaCaCc","23" = "AaPaCc","24" = "CaPaCc","25" = "AaCaAd","26" = "AaPaAd","27" = "CaPaAd","28" = "AaCcAd","29" = "CaCcAd","30" = "PaCcAd","31" = "AaCaEl","32" = "AaPaEl","33" = "CaPaEl","34" = "AaCcEl","35" = "CaCcEl","36" = "PaCcEl","37" = "AaAdEl","38" = "CaAdEl","39" = "PaAdEl","40" = "CcAdEl","41" = "AaCaPaCc","42" = "AaCaPaAd","43" = "AaCaCcAd","44" = "AaPaCcAd","45" = "CaPaCcAd","46" = "AaCaPaEl","47" = "AaCaCcEl","48" = "AaPaCcEl","49" = "CaPaCcEl","50" = "AaCaAdEl","51" = "AaPaAdEl","52" = "CaPaAdEl","53" = "AaCcAdEl","54" = "CaCcAdEl","55" = "PaCcAdEl","56" = "AaCaPaCcAd","57" = "AaCaPaCcEl","58" = "AaCaPaAdEl","59" = "AaCaCcAdEl","60" = "AaPaCcAdEl","61" = "CaPaCcAdEl","62" = "AaCaPaCcAdEl")

colors &lt;- c("#FD3216", "#00FE35", "#6A76FC", "#FED4C4", "#FE00CE", "#0DF9FF", "#F6F926", "#FF9616", "#479B55", "#EEA6FB", "#DC587D", "#D626FF", "#6E899C", "#00B5F7", "#B68E00", "#C9FBE5", "#FF0092", "#22FFA7", "#E3EE9E", "#86CE00", "#BC7196", "#7E7DCD", "#FC6955", "#E48F72")

library(RevGadgets)
library(ggplot2)
tree_file = "../output/ase.tre"
output_file = "../output/states.png"
states &lt;- processAncStates(tree_file, state_labels=labels)
plotAncStatesMAP(t=states,
                 tree_layout="circular",
                 node_size=1.5,
                 node_color_as="state",
                 node_color=colors,
                 node_size_as=NULL) +
                 ggplot2::theme(legend.position="bottom",
                                legend.title=element_blank())
ggsave(output_file, width = 9, height = 9)
</code></pre></div></div>

<figure id="states"><p><img src="figures/states.png" width="95%" /></p>
<figcaption>Ancestral state reconstruction of <em>Liolaemus</em>.</figcaption>
</figure>

<p>You can also examine the output files, like <code class="language-plaintext highlighter-rouge">model.log</code>, to assess the relationships between regional features and biogeographic processes, or to compare relative rates of different event types. This can also be done using RevGadgets. Here, we show a posterior plot for a single parameter ($\phi_d^{Distance}$) as an example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trace &lt;- readTrace(path=log_file)
plotTrace(trace, vars=c("phi_d[1]"))
ggsave(posterior_file, width = 9, height = 9)
</code></pre></div></div>

<figure id="states"><p><img src="figures/posterior.png" width="95%" /></p>
<figcaption>Posterior for the parameter $\phi_d^{Distance}$, which relates quantitative distances between regions to the process of dispersal. The 95% Highest Posterior Density (HPD) interval is shaded in dark blue. Note that 0 (a null effect) falls outside this interval. Therefore, distance is likely related to dispersal. A negative value indicates a negative relationship; more distance between regions reduces dispersal.</figcaption>
</figure>

<ol class="bibliography"><li><span id="Esquerré2019">Esquerré D., Brennan I.G., Catullo R.A., Torres-Pérez F., Keogh J.S. 2019. How mountains shape biodiversity: The role of the Andes in biogeography, diversification, and reproductive biology in South America’s most species-rich lizard radiation (Squamata: Liolaemidae). Evolution. 73:214–230.</span>

<a href="https://doi.org/10.1111/evo.13657">10.1111/evo.13657</a>

</li>
<li><span id="Goldberg2011">Goldberg E.E., Lancaster L.T., Ree R.H. 2011. Phylogenetic Inference of Reciprocal Effects between Geographic Range Evolution and Diversification. Systematic Biology. 60:451–465.</span>

<a href="https://doi.org/10.1093/sysbio/syr046">10.1093/sysbio/syr046</a>

</li>
<li><span id="Landis2022">Landis M.J., Quintero I., Muñoz M.M., Zapata F., Donoghue M.J. 2022. Phylogenetic inference of where species spread or split across barriers. Proceedings of the National Academy of Sciences. 119.</span>

</li>
<li><span id="May2022">May M.R., Meyer X. TensorPhylo. .</span>


<a href="https://bitbucket.org/mrmay/tensorphylo/src/master/">https://bitbucket.org/mrmay/tensorphylo/src/master/</a>
</li>
<li><span id="Swiston2023">Swiston S.K., Landis M.J. 2023. Testing relationships between multiple regional features and
             biogeographic processes of speciation, extinction, and dispersal. BioRxiv.</span>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://github.com/revbayes/revbayes/discussions">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
