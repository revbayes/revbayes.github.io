<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Polymorphism-aware phylogenetic models</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Polymorphism-aware phylogenetic models</h1>
	<h3 class="subtitle">Species tree inference with allele frequency data in RevBayes</h3>
	<h4 class="authors"> Rui Borges, Sebastian Höhna, Bastien Boussau, and Carolin Kosiol</h4>
  <h5>Last modified on October 13, 2024</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/pomos/data/great_apes_1000.cf">great_apes_1000.cf</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/pomos/scripts/great_apes_pomothree.Rev">great_apes_pomothree.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<p>This tutorial uses functions implemented in the developmental branch <code class="language-plaintext highlighter-rouge">dev_PoMo_SNP</code>. To download and install <strong>RevBayes</strong> from source, please follow the instructions <a href="https://revbayes.github.io/download">here</a>.</p>

<!-- This tutorial comes with a recorded video walkthrough. The video corresponding to each section of the exercise is linked next to the section title. The full playlist is available here: [![Walkthrough playlist](/assets/img/YouTube_icon.svg){: height="36" width="36"}](https://www.youtube.com/playlist?list=PLztACvN0g42ue0Y1cbcyTq3r6cMaTYpvg). -->

<h2 class="section" id="PoMo">Polymorphism-aware phylogenetic models <!--[![Walkthrough video](/assets/img/YouTube_icon.svg){: height="36" width="36"}](https://youtu.be/i8XPJbhIuEQ)--></h2>
<hr class="section" />

<p>The polymorphism-aware phylogenetic models (PoMos) are alternative approaches to species tree estimation <a class="citation" href="#DeMaio2013">(De Maio et al. 2013)</a> that add a new layer of complexity to the standard substitution models by accounting for population-level forces to describe the process of sequence evolution <a class="citation" href="#DeMaio2015">(De Maio et al. 2015; Schrempf et al. 2016; Borges et al. 2019)</a>. PoMos model the evolution of a population of individuals in which changes in allele content (e.g., due to mutations) and frequency (e.g., due to genetic drift or selection) are both possible (<a href="#pomos"></a>).</p>

<figure id="pomos"><p><img src="figures/pomos.png" width="500" /></p>
<figcaption>PoMoTwo and Three state-spaces. The tetrahedron represents the PoMos state-space for the four-allelic case, which in this case are the A, C, G and T nucleotide bases. The fixed sites \(\{Na_i\}\) are represented in the vertices of the tetrahedron, while the polymorphic states \(\{na_i,(N −n)a_j\}\) are represented on its edges. The black and gray arrows distinguish mutations from frequency shifts (i.e., due to genetic drift and selection).</figcaption>
</figure>

<p>PoMos stand out from the standard phylogenetic substitution models and other species tree methods because they:</p>
<ul>
  <li>allow to disentangle the contribution of evolutionary forces to the evolutionary process (e.g., genetic drift, mutational biases, and selection);</li>
  <li>consider polymorphisms, thus permitting inferences with data from multiple individuals and populations;</li>
  <li>naturally account for incomplete lineage sorting (i.e., the persistence of ancestral polymorphisms during speciation events), a known source of phylogenetic discord;</li>
  <li>are computationally efficient by directly estimate the species tree, thus circumventing the many constraints between the species tree and the genealogical histories.</li>
</ul>

<p>Overall, PoMos constitute a full-likelihood yet computationally efficient approach to species tree inference. PoMos are designed to cope with recent radiations, including incomplete lineage sorting, and long divergence times.</p>

<h2 class="section" id="PoMo_model">Polymorphism-aware phylogenetic models: the model <!--[![Walkthrough video](/assets/img/YouTube_icon.svg){: height="36" width="36"}](https://youtu.be/Kp0P9cMcf6o)--></h2>
<hr class="section" />

<p>PoMos model the evolution of a population of $N$ individuals and $K$ alleles in which changes in allele content and frequency occur. These are mediated by population forces such as mutation, genetic drift, and selection. The PoMo state-space includes fixed (or boundary) states \(\{Na_i\}\), in which all $N$ individuals have the same allele \(i \in \{0,1,...,K-1\}\), and polymorphic states \(\{na_i,(N-n)a_j\}\), in which two alleles $a_i$ and $a_j$ are present in the population with absolute frequencies $n$ and $N-n$.</p>

<ul>
  <li>Mutations occur at a rate of $\mu_{a_ia_j}$. Mutations govern the allele content and only occur in the fixed states:
\(q_{\{Na_i\} \rightarrow \{(N-1)a_i,1a_j\}}=\mu_{a_ia_j} \label{equation1}\tag{1}\)
Often, a reversible mutational model is considered. In this case, we break the mutations into a base composition $\pi$ and an exchangeability parameter $\rho$ (i.e., $\mu_{a_ia_j}=\rho_{a_ia_j}\pi_{a_j}$) just like the GTR. However, in PoMos, these do not represent substitutions but mutations. Such an assumption can still model mutational biases quite well and simplifies obtaining formal quantities with PoMos. Another assumption of PoMos is that mutations can only occur in fixed states. This corresponds to the assumption that mutation rates are low, which is verified for the majority of multicellular eukaryotes.</li>
  <li>Genetic drift is modeled according to the Moran model, in which one individual is chosen to die and one individual is chosen to reproduce at each time step. Selection acts to (dis)favor alleles by differentiated fitnesses: $\phi_{a_i}$. Together, genetic drift and selection govern the allele frequency changes:
\(q_{\{na_i,(N-n)a_j\} \rightarrow \{(n+1)a_i,(N-n-1)a_j\}}=\frac{n(N-n)}{N}\phi_{a_i} \label{equation2}\tag{2}\)</li>
</ul>

<p>Like the standard substitution models, PoMos are continuous-time Markov models and are fully characterized by their rate matrices. The rates in \ref{equation1} and \ref{equation2} define the PoMos rate matrices. <strong>RevBayes</strong> includes the <code class="language-plaintext highlighter-rouge">fnPoMoKN</code> rate matrices that permit modeling population dynamics with any number of alleles, reversible mutations (i.e., $\mu_{a_ia_j}=\rho_{a_ia_j}\pi_{a_j}$) and selection. You can check the input parameters of this function by typing its name right after the question mark: <code class="language-plaintext highlighter-rouge">?fnPoMoKN</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Arguments
   
         K : Number of alleles
             Type:       Natural, &lt;any&gt;, value
         V : Number of virtual individuals
             Type:       Natural, &lt;any&gt;, value
         N : Number of effective individuals
             Type:       RealPos, &lt;any&gt;, const reference
             Default:    NULL
        mu : Vector of mutation rates: mu=(mu_a0a1,mu_a1a0,mu_a0a2,mu_a2a0,...)
             Type:       RealPos[], &lt;any&gt;, const reference
       phi : Vector of fitness coefficients: phi=(phi_0,phi_1,...,phi_ak)
             Type:       RealPos[], &lt;any&gt;, const reference

</code></pre></div></div>

<p>This tutorial demonstrates how to set up and perform analyses using polymorphism-aware phylogenetic models. You will perform phylogeny inference using the virtual PoMo Three. We will do this by setting the number of virtual (and effective) individuals to 3. These models allow for very efficient species tree inferences under selection because they operate on a small state space (missing reference). You will perform a Markov chain Monte Carlo (MCMC) analysis to estimate phylogeny and other model parameters. By the end of this tutorial, we leave as an exercise to run the neutral version (PoMoTwo) and compare the resulting trees. The graphical model representation under PoMoThree is depicted in figure <a href="#pomos_graphical_model"></a>.</p>

<figure id="pomos_graphical_model"><p><img src="figures/dag_pomos.png" /></p>
<figcaption>Graphical model representation of PoMos. The graphical model shows the dependencies among parameters <a class="citation" href="#Hoehna2014b">(Höhna et al. 2014)</a>. Here, the rate matrix $Q$ is a deterministic variable because it depends on the mutation rates and fitness coefficients. The same applies to the phylogenetic tree $\Psi$, which depends on the topology and branch lengths.</figcaption>
</figure>

<h2 class="section" id="Count_files">Count files <!--[![Walkthrough video](/assets/img/YouTube_icon.svg){: height="36" width="36"}](https://youtu.be/MQjs08HH2VY)--></h2>
<hr class="section" />

<p>PoMos perform inferences based on allele frequency data, which is stored in count files. These files contain two header lines. The first line indicates the number of taxa and the number of sites (or loci) in the sequence alignment. You might have noticed that NPOP stands for the number of populations, but this is not necessarily the case. PoMos can be used to infer the evolutionary history of different species or even other systematic units of interest, such as species, subspecies, communities, and so forth.</p>

<p>The second line specifies the genomic position of each locus (chromosome and location) and the taxon names. The first two columns are not used for inference, so if you’re working with taxa for which this information is unavailable, you can input these columns with dummy values (e.g., NA or ?). The remaining lines  the other lines in the count file include allelic counts separated by commas. All elements in the count file are separated by white spaces. Here is an example of some lines from the great ape count file we will analyze in this tutorial:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COUNTSFILE NPOP 3 NSITES 5
CHROM POS       Gorilla_beringei_graueri Gorilla_gorilla_dielhi Gorilla_gorilla_gorilla
chr1  41275799  6,0,0,0                  2,0,0,0                54,0,0,0 
chr2  120104878 6,0,0,0                  2,0,0,0                54,0,0,0 
chr11 61364549  0,6,0,0                  0,2,0,0                0,54,0,0 
chr17 44837427  6,0,0,0                  2,0,0,0                54,0,0,0 
chr19 7495905   4,0,2,0                  2,0,0,0                10,0,44,0 
</code></pre></div></div>

<p>The four allelic counts in this count file represent the allelic counts of the A, C, G, and T, respectively. Therefore, we know that the <code class="language-plaintext highlighter-rouge">Gorilla_gorilla_gorilla</code> has an AG polymorphism at position 7 495 905 on chromosome 19. The order of alleles in the allelic counts can vary, but it is important to remember that the vectors of mutation rates, exchangeabilities, base frequencies, and fitness coefficients all follow the order of the allele counts in the count file:</p>
<ul>
  <li>the base frequencies and the fitness vectors are in the same order as in the counts: i.e., \(\{a_0,a_1,\dots,a_{K-1}\}\);</li>
  <li>the mutation rate vector is \(\{a_0a_1, a_1a_0, a_0a_2, a_2a_0,\dots\}\);</li>
  <li>the exchangeability vector follows a similar pattern as for the mutation rates, but without the reversed mutation: i.e., \(\{a_0a_1, a_0a_2, \dots\}\).</li>
</ul>

<h2 class="section" id="loading_data">Loading the data <!--[![Walkthrough video](/assets/img/YouTube_icon.svg){: height="36" width="36"}](https://youtu.be/acjouysOU04)--></h2>
<hr class="section" />

<p>The first step in this tutorial is to convert the allelic counts into PoMo states. Open the terminal and navigate to your working directory, which we will call <strong>PoMos</strong> (but you can choose any name you prefer). Inside <strong>PoMos</strong>, create the usual <strong>data</strong> and <strong>output</strong> folders. Before loading the data, run <strong>RevBayes</strong> by typing <code class="language-plaintext highlighter-rouge">./rb</code> (or <code class="language-plaintext highlighter-rouge">./rb-mpi</code>) in the console. Open the <code class="language-plaintext highlighter-rouge">great_apes_pomothree.Rev</code> file using a suitable text editor so you can follow what each command is doing. Once you understand the <code class="language-plaintext highlighter-rouge">.Rev</code> script in detail, you can run it automatically as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./rb great_apes_pomothree.Rev

</code></pre></div></div>

<p>As mentioned earlier, the PoMo state space includes both fixed and polymorphic population states. However, allele counts are typically sampled from a small number of individuals. For example, sampled fixed sites may not actually be fixed in the original population. It is possible that we only sampled individuals with the same allele from polymorphic locus, leading to an inaccurate representation of the population’s true genetic diversity. The fewer individuals sampled, or the rarer the allele in the original population (e.g., singletons or doubletons), the more likely we are to observe false fixed sites in the sequence alignment.</p>

<p>There are methods that help us correct for this bias by attributing to each of the allelic counts an appropriate PoMo state. One such method is the weighted-method <a class="citation" href="#Schrempf2016">(Schrempf et al. 2016)</a>, which weights each PoMo state based on binomial sampling. In <strong>RevBayes</strong>, this is done automatically when we use the <code class="language-plaintext highlighter-rouge">readPoMoCountFile</code> function and set the weighting to <code class="language-plaintext highlighter-rouge">Binomial</code>. Alternatively, you can assign the PoMo state closest to the observed frequency. This method is called <code class="language-plaintext highlighter-rouge">Fixed</code>. In this tutorial, we will use <code class="language-plaintext highlighter-rouge">Fixed</code>. To use the <code class="language-plaintext highlighter-rouge">readPoMoCountFile</code> function, define the location of the counts file, set the virtual population size (which we set to <code class="language-plaintext highlighter-rouge">3</code>, as we are using the virtual PoMo Three), specify the data type format <code class="language-plaintext highlighter-rouge">PoMo</code> and apply the <code class="language-plaintext highlighter-rouge">Fixed</code> correction as shown below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N &lt;- 3
data &lt;- readPoMoCountFile(countFile="data/great_apes_1000.cf", virtualPopulationSize=N, format="PoMo", samplingCorrection="Fixed")
</code></pre></div></div>

<p>Information about the alignment can be obtained by typing <code class="language-plaintext highlighter-rouge">data</code>. </p>

<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;data
   PoMo character matrix with 12 taxa and 1000 characters
   ======================================================
   Origination:                   
   Number of taxa:                12
   Number of included taxa:       12
   Number of characters:          1000
   Number of included characters: 1000
   Datatype:                      PoMo
</code></pre></div></div>

<p>If, instead of a count file, you have a list of sequences per individual (in either fasta or nexus format), <strong>RevBayes</strong> can still convert it to PoMo data format. To do this, you need to read the sequences, provide a file with the taxon names, and perform the conversion to PoMo state space using <code class="language-plaintext highlighter-rouge">pomoStateConvert</code>. Please ensure that individual sequences belonging to the same taxon have the same name. Here are the commands you will need:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data_char = readDiscreteCharacterData("data/individual_sequences.nex")
taxa = readTaxonData("data/taxon_names.txt")
data = pomoStateConvert(aln=data_char, k=4, virtualNe=N, taxa)
</code></pre></div></div>

<p>Next, we define some useful variables. These include the number of taxa, taxa names, and the number of branches, which will be important for setting up our model in later steps.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_taxa     &lt;- data.ntaxa()
n_branches &lt;- 2*n_taxa-3
taxa       &lt;- data.taxa()
</code></pre></div></div>

<p>Additionally, we will set up a variable that holds all the moves and monitors for our analysis. Recall that moves are algorithms used to propose new parameter values during the MCMC simulation, while monitors print the values of model parameters to the screen and/or log files during the MCMC analysis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves    = VectorMoves()  
monitors = VectorMonitors()
</code></pre></div></div>

<h2 class="section" id="model_setup">Setting up the model <!--[![Walkthrough video](/assets/img/YouTube_icon.svg){: height="36" width="36"}](https://youtu.be/izCH8lQY-AY)--></h2>
<hr class="section" />

<p>Estimating an unrooted tree under the virtual PoMos requires specifying two main components:</p>
<ul>
  <li>the PoMo model, which in our case is PoMoThree;</li>
  <li>the tree topology and branch lengths.</li>
</ul>

<p>A given PoMo model is defined by its corresponding instantaneous rate matrix, <code class="language-plaintext highlighter-rouge">Q</code> which depends on the virtual population size <code class="language-plaintext highlighter-rouge">N</code>, the mutation rates, assumed to be reversible and dependent on the allele frequencies <code class="language-plaintext highlighter-rouge">pi</code>, and the exchangeabilities <code class="language-plaintext highlighter-rouge">rho</code>. PoMoThree additionally includes allele fitnesses <code class="language-plaintext highlighter-rouge">phi</code>, as it accounts for selection. We will set up the virtual PoMoThree using the function <code class="language-plaintext highlighter-rouge">fnPoMoKN</code>. In particular, we set <code class="language-plaintext highlighter-rouge">N</code> to 3. Note that <code class="language-plaintext highlighter-rouge">N</code> is a fixed node, as we had previously defined. </p>

<p>Since <code class="language-plaintext highlighter-rouge">pi</code>, <code class="language-plaintext highlighter-rouge">rho</code>, and <code class="language-plaintext highlighter-rouge">gamma</code> are stochastic variables, we must specify a move to propose updates to them. A good move for variables drawn from a Dirichlet distribution (i.e., <code class="language-plaintext highlighter-rouge">pi</code>) is the <code class="language-plaintext highlighter-rouge">mvBetaSimplex</code> move. This move randomly selects an element from the allele frequency vector <code class="language-plaintext highlighter-rouge">pi</code>, proposes a new value drawn from a beta distribution, and then rescales all values to sum to 1. The <code class="language-plaintext highlighter-rouge">weight</code> option inside the moves specifies how often the move will be applied, either on average per iteration or relative to all other moves.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># allele frequencies
pi_prior &lt;- [1,1,1,1]
pi ~ dnDirichlet(pi_prior)
moves.append( mvBetaSimplex(pi, weight=2) )
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">rho</code> and <code class="language-plaintext highlighter-rouge">phi</code> parameters must be positive real numbers and a natural choice for their prior distributions is the exponential distribution. Again, we need to specify a move for these stochastic variables, and a simple scaling move, <code class="language-plaintext highlighter-rouge">mvScale</code>, typically works. In this tutorial, we want our model to capture the effect of GC-bias gene conversion. For that, we define <code class="language-plaintext highlighter-rouge">gamma</code>, the GC-bias rate. The allele fitnesses <code class="language-plaintext highlighter-rouge">phi</code> for G and C will be represented by <code class="language-plaintext highlighter-rouge">gamma</code>, while those for A and T by 1.0. Note that <code class="language-plaintext highlighter-rouge">phi</code> is a deterministic node that depends on the GC-bias rate <code class="language-plaintext highlighter-rouge">gamma</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># exchangeabilities
for (i in 1:6){
  rho[i] ~ dnExponential(10.0)
  moves.append(mvScale( rho[i], weight=2 ))
}

# fitness coefficients
gamma ~ dnExponential(1.0)
moves.append(mvScale( gamma, weight=2 ))
phi := [1.0,1.0+gamma,1.0+gamma,1.0]
</code></pre></div></div>

<p>Because we want the mutations to be reversible, we build the mutation rate vector as a deterministic variable depending on <code class="language-plaintext highlighter-rouge">pi</code> and <code class="language-plaintext highlighter-rouge">rho</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mutation rates
K &lt;- 4
mu := fnPoMoReversibleMutationRates(K,pi,rho)
</code></pre></div></div>

<p>Alternatively, if we wanted to define a nonreversible mutation rate vector, we could have set <code class="language-plaintext highlighter-rouge">mu</code> directly, similar to how we set <code class="language-plaintext highlighter-rouge">rho</code>.</p>

<p>The function <code class="language-plaintext highlighter-rouge">fnPoMoKN</code> will create an instantaneous rate matrix. This function requires that an effective population size be input, but in most cases, you will not know it. Therefore, simply set it to the virtual population size.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># rate matrix
Q := fnPoMoKN(K,N,N,mu,phi)
</code></pre></div></div>

<p>The tree topology and branch lengths are stochastic nodes in our phylogenetic model. We will assume that all possible labeled, unrooted tree topologies have equal probability. For an unrooted tree topology, we use the nearest-neighbor interchange move <code class="language-plaintext highlighter-rouge">mvNNI</code> (a subtree-prune and regrafting move <code class="language-plaintext highlighter-rouge">mvSPR</code> could also be used).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># topology
topology ~ dnUniformTopology(taxa)
moves.append( mvNNI(topology, weight=2*n_taxa) )
</code></pre></div></div>

<p>Next, we create a stochastic node representing the length of each of the <code class="language-plaintext highlighter-rouge">2*n_taxa−3</code> branches in our tree. We can use a “for” loop to create a vector of branch lengths and assign a move to it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># branch lengths
for (i in 1:n_branches) {
   branch_lengths[i] ~ dnExponential(10.0)
   moves.append( mvScale(branch_lengths[i]) )
}
</code></pre></div></div>

<p>Finally, we combine the tree topology and branch lengths using the <code class="language-plaintext highlighter-rouge">treeAssembly</code> function, which applies the value of the ith member of the <code class="language-plaintext highlighter-rouge">branch_lengths</code> vector to the branch leading to the ith node in the topology. Thus, the <code class="language-plaintext highlighter-rouge">psi</code> variable is a deterministic node:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi := treeAssembly(topology, branch_lengths)
</code></pre></div></div>

<p>We have now fully specified all of the parameters of our phylogenetic model:</p>
<ul>
  <li>the tree with branch lengths <code class="language-plaintext highlighter-rouge">psi</code>;</li>
  <li>the PoMo instantaneous rate matrix <code class="language-plaintext highlighter-rouge">Q</code>;</li>
  <li>the type of character data: i.e., <code class="language-plaintext highlighter-rouge">PoMo</code>.</li>
</ul>

<p>Collectively, these parameters comprise a distribution called the phylogenetic continuous-time Markov chain, and we use the <code class="language-plaintext highlighter-rouge">dnPhyloCTMC</code> function to create this node. This distribution requires several input arguments:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sequences ~ dnPhyloCTMC(psi,Q=Q,type="PoMo")
</code></pre></div></div>

<p>Once the <code class="language-plaintext highlighter-rouge">PhyloCTMC</code> model is created, we can attach our sequence data to the tip nodes of the tree. Although we assume that our sequence data are random variables, they are realizations of our phylogenetic model. For inference, we assume that the sequence data are <em>clamped</em> to their observed values.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sequences.clamp(data)
</code></pre></div></div>

<p>When this function is called, <strong>RevBayes</strong> sets each of the stochastic nodes representing the tree’s tips to the corresponding nucleotide sequence in the alignment, indicating that those sequences have been observed.</p>

<p>Finally, we wrap the entire model in a single object. To do this, we simply pass <code class="language-plaintext highlighter-rouge">model</code> function one of the nodes previously defined.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pomo_model = model(pi)
</code></pre></div></div>

<h2 class="section" id="mcmc">Setting, running, and summarizing the MCMC simulation <!--[![Walkthrough video](/assets/img/YouTube_icon.svg){: height="36" width="36"}](https://youtu.be/5b1FmykQ37o)--></h2>
<hr class="section" />

<p>For our MCMC analysis, we need to set up a vector of monitors to record the states of our Markov chain. First, we will initialize the model monitor using the <code class="language-plaintext highlighter-rouge">mnModel</code> function. This creates a monitor variable that will output the states for all model parameters when passed into an MCMC function. We will sample every 10th generation, and the resulting file will be found in the <strong>output</strong> folder.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/great_apes_pomothree.log", printgen=10) )
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mnFile</code> monitor will record the states for only the parameters passed as arguments. We use this monitor to specify the output for our sampled trees and branch lengths. Again, we sample every 10th generation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnFile(filename="output/great_apes_pomothree.trees", printgen=10, psi) )
</code></pre></div></div>

<p>Next, we create a screen monitor that will report the states of specified variables to the screen using <code class="language-plaintext highlighter-rouge">mnScreen</code>. This monitor helps us track the progress of the MCMC run.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(printgen=10) )
</code></pre></div></div>

<p>With a fully specified model, a set of monitors, and a set of moves, we can now set up the MCMC algorithm that will sample parameter values in proportion to their posterior probability. The <code class="language-plaintext highlighter-rouge">mcmc</code> function will create our MCMC object. Additionally, we will perform two independent MCMC runs to ensure proper convergence and mixing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pomo_mcmc = mcmc(pomo_model, monitors, moves, nruns=2, combine="mixed")
</code></pre></div></div>

<p>Now, we can start the MCMC run.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pomo_mcmc.run( generations=100000 )
</code></pre></div></div>

<p>Once the analysis is complete, you will find the monitored files in your output directory. Software like <a href="https://github.com/beast-dev/tracer/releases/tag/v1.7.2"><strong>Tracer</strong></a> allows you to evaluate convergence and mixing. Look at the file <code class="language-plaintext highlighter-rouge">output/great_apes_pomothree.log</code> in <strong>Tracer</strong>. There, you will see the posterior distribution of the continuous parameters. Let us examine the posterior distribution of the GC-bias rate $\gamma$. Is there any evidence of GC-bias in these great ape sequences?</p>

<figure id="gamma"><p><img src="figures/gamma_mcmc.png" /></p>
<figcaption><strong>Left</strong>: Posterior distribution of the great apes GC-bias rate ($\gamma$) under a PoMoThree model. <strong>Right</strong>: Trace of the GC-bias rate ($\gamma$) samples for one MCMC run. You will also notice that the effective sample size is much larger than 200.</figcaption>
</figure>

<p>In addition to continuous parameters, we also need to summarize the trees sampled from the posterior distribution. <strong>RevBayes</strong> can summarize the sampled trees by reading in the tree trace file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trace = readTreeTrace("output/great_apes_pomothree.trees", treetype="non-clock", burnin= 0.2)
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mapTree</code> function will summarize the tree samples and write the maximum a posteriori (MAP) tree to the specified file. The MAP tree can be found in the <strong>output</strong> folder.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mapTree(trace, file="output/great_apes_pomothree_MAP.tree" )
</code></pre></div></div>

<figure id="tree"><p><img src="figures/great_apes_pomo_three.png" /></p>
<figcaption>Maximum a posteriori estimate of the great ape phylogeny under the PoMoThree model. The numbers next to each node represent posterior probabilities. We have rooted the tree using the orangutans clade. The inferred tree does not align with our expectations for the great ape species tree, and some clades show low posterior probabilities. This is due to our multiple sequence alignment containing only 1000 sites.</figcaption>
</figure>

<p>You can look at the file <code class="language-plaintext highlighter-rouge">output/great_apes_pomothree_MAP.tree</code> and open it in FigTree. The maximum a posteriori estimate of the great ape phylogeny under the PoMoThree model should look like that of <a href="#tree"></a>.</p>

<p>We note that while visual inspection might be a good exercise to evaluate the convergence and mixing of the MCMC samples, quantitative methods exist and are recommended. These are implemented in R and ready to use; check tutorial <a href="https://revbayes.github.io/tutorials/convergence/"><strong>Convergence assessment</strong></a>.</p>

<h2 class="section" id="some-questions">Some questions</h2>
<hr class="section" />

<ol>
  <li>
    <p>What is the GC-bias rate (this is the selection coefficient) for the great ape populations? Rescale it to its real value by assuming the great apes have an effective population size of about 10 000 individuals. Use the relation $(1+\gamma’)^{N-1}=(1+\gamma)^{N_e-1}$ to rescale $\gamma$, where $N$ and $N_e$ represent the virtual and effective population sizes, and $\gamma’$ and $\gamma$ are the GC-bias rates for the virtual and effective populations.</p>
  </li>
  <li>
    <p>Using <a href="#pomos_graphical_model"></a> as your guide, draw the probabilistic graphical model of the neutral PoMoTwo model.</p>
  </li>
  <li>
    <p>What changes are necessary in the <code class="language-plaintext highlighter-rouge">great_apes_pomothree.Rev</code> file to make inferences under the neutral PoMoTwo model?</p>
  </li>
  <li>
    <p>Run an MCMC analysis to estimate the posterior distribution under the PoMoTwo model. Are the resulting estimates of mutation rates (base frequencies and exchangeabilities) equal? If not, how much do they differ?</p>
  </li>
  <li>
    <p>Compare the MAP trees estimated under PoMoTwo and PoMoThree. Are they equal? If not, how much do they differ?</p>
  </li>
</ol>

<ol class="bibliography"><li><span id="Borges2019">Borges R., Szöllősi G.J., Kosiol C. 2019. Quantifying GC-Biased Gene Conversion in Great Ape Genomes Using Polymorphism-Aware Models. Genetics. 212:1321–1336.</span>

<a href="https://doi.org/10.1534/genetics.119.302074">10.1534/genetics.119.302074</a>

</li>
<li><span id="Hoehna2014b">Höhna S., Heath T.A., Boussau B., Landis M.J., Ronquist F., Huelsenbeck J.P. 2014. Probabilistic Graphical Model Representation in Phylogenetics. Systematic Biology. 63:753–771.</span>

<a href="https://doi.org/10.1093/sysbio/syu039">10.1093/sysbio/syu039</a>

</li>
<li><span id="Schrempf2016">Schrempf D., Minh B.Q., De Maio N., Haeseler A. von, Kosiol C. 2016. Reversible polymorphism-aware phylogenetic models and their application to tree inference. Journal of Theoretical Biology. 407:362–370.</span>

<a href="https://doi.org/10.1016/j.jtbi.2016.07.042">10.1016/j.jtbi.2016.07.042</a>

</li>
<li><span id="DeMaio2013">De Maio N., Schlötterer C., Kosiol C. 2013. Linking great apes genome evolution across time scales using polymorphism-aware phylogenetic models. 30:2249–2262.</span>

<a href="https://doi.org/10.1093/molbev/mst131">10.1093/molbev/mst131</a>

</li>
<li><span id="DeMaio2015">De Maio N., Schrempf D., Kosiol C. 2015. PoMo: An Allele Frequency-Based Approach for Species Tree Estimation. Systematic Biology. 64:1018–1031.</span>

<a href="https://doi.org/10.1093/sysbio/syv048">10.1093/sysbio/syv048</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
