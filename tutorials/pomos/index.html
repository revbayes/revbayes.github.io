<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Polymorphism-aware phylogenetic models</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Polymorphism-aware phylogenetic models</h1>
	<h3 class="subtitle">Species tree inference with allele frequency data in RevBayes</h3>
	<h4 class="authors"> Rui Borges, Sebastian Höhna, Bastien Boussau, and Carolin Kosiol</h4>
  <h5>Last modified on October  3, 2024</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/pomos/data/great_apes_1000.cf">great_apes_1000.cf</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/pomos/scripts/great_apes_pomothree.Rev">great_apes_pomothree.Rev</a></li>
        
          <li><a href="/tutorials/pomos/scripts/great_apes_pomotwo.Rev">great_apes_pomotwo.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<p>This tutorial comes with a recorded video walkthrough. The video corresponding to each section of the exercise is linked next to the section title. The full playlist is available here: <a href="https://www.youtube.com/playlist?list=PLztACvN0g42ue0Y1cbcyTq3r6cMaTYpvg"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough playlist" height="36" width="36" /></a></p>

<h2 class="section" id="PoMo">Polymorphism-aware phylogenetic models <a href="https://youtu.be/i8XPJbhIuEQ"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></h2>
<hr class="section" />

<p>The polymorphism-aware phylogenetic models (PoMos) are alternative approaches to species tree estimation <a class="citation" href="#DeMaio2013">(De Maio et al. 2013)</a> that add a new layer of complexity to the standard substitution models by accounting for population-level forces to describe the process of sequence evolution <a class="citation" href="#DeMaio2015">(De Maio et al. 2015; Schrempf et al. 2016; Borges et al. 2019)</a>. PoMos model the evolution of a population of individuals in which changes in allele content (e.g., due to mutations) and frequency (e.g., due to genetic drift or selection) are both possible (<a href="#pomos"></a>).</p>

<figure id="pomos"><p><img src="figures/pomos.png" width="500" /></p>
<figcaption>PoMoTwo and Three state-spaces. The tetrahedron represents the PoMos state-space for the four-allelic case (A, C, G and T). The fixed sites \(\{Na_i\}\) are represented in the vertices of the tetrahedron, while the polymorphic states \(\{na_i,(N −n)a_j\}\) are represented in its edges. The black and gray arrows distinguish mutations from frequency shifts (i.e., due to genetic drift and selection).</figcaption>
</figure>

<p>PoMos stand out from the standard phylogenetic substitution models and other species tree methods because they:</p>
<ul>
  <li>permit to disentangle the contribution of evolutionary forces to the evolutionary process (e.g., genetic drift, mutational biases, and selection);</li>
  <li>consider polymorphisms, thus permitting inferences with data from multiple individuals and populations;</li>
  <li>naturally account for incomplete lineage sorting (i.e., the persistence of ancestral polymorphisms during speciation events), a known process of phylogenetic discord;</li>
  <li>directly estimate the species tree and is computationally efficient by circumventing the many constraints between the species tree and the genealogical histories.</li>
</ul>

<p>Overall, PoMos constitute a full-likelihood yet computationally efficient approach to species tree inference. PoMos are designed to cope with recent radiations, including incomplete lineage sorting, and long divergence times.</p>

<h2 class="section" id="PoMo_model">Polymorphism-aware phylogenetic models: the model <a href="https://youtu.be/Kp0P9cMcf6o"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></h2>
<hr class="section" />

<p>PoMos model the evolution of a population of $N$ individuals and $K$ alleles in which changes in allele content and frequency occur. These are mediated by population forces such as mutation, genetic drift, and selection. The PoMo state-space includes fixed (or boundary) states \(\{Na_i\}\), in which all $N$ individuals have the same allele \(i \in \{0,1,...,K-1\}\), and polymorphic states \(\{na_i,(N-n)a_j\}\), in which two alleles $a_i$ and $a_j$ are present in the population with absolute frequencies $n$ and $N-n$.</p>

<ul>
  <li>Mutations occur with rate $\mu_{a_ia_j}$. Mutations govern the allele content and only occur in the fixed states:
\(q_{\{Na_i\} \rightarrow \{(N-1)a_i,1a_j\}}=\mu_{a_ia_j} \label{equation1}\tag{1}\)
Often, a reversible mutational model is considered. In this case, we break the mutations into a base composition $\pi$ and exchangeability parameter $\rho$ (i.e., $\mu_{a_ia_j}=\rho_{a_ia_j}\pi_{a_j}$) just like the GTR. However, in PoMos, these do not represent substitutions but mutations. Such an assumption can still model mutational biases quite well and simplifies obtaining formal quantities with PoMos. Another assumption of PoMos is that mutations can only occur in fixed states. This corresponds to the assumption that mutation rates are low, which is verified for the majority of multicellular eukaryotes.</li>
  <li>Genetic drift is modeled according to the Moran model, in which one individual is chosen to die and one individual is chosen to reproduce at each time step. Selection acts to (dis)favor alleles by differentiated fitnesses: $\phi_{a_i}$. Together, genetic drift and selection govern the allele frequency changes:
\(q_{\{na_i,(N-n)a_j\} \rightarrow \{(n+1)a_i,(N-n-1)a_j\}}=\frac{n(N-n)}{N}\phi_{a_i} \label{equation2}\tag{2}\)</li>
</ul>

<p>Like the standard substitution models, PoMos are continuous-time Markov models and are fully characterized by their rate matrices. The rates in \ref{equation1} and \ref{equation2} define the PoMos rate matrices. RevBayes includes a plethora of PoMo rate matrices that permit modeling population dynamics with any number of alleles, reversible mutations (i.e., $\mu_{a_ia_j}=\rho_{a_ia_j}\pi_{a_j}$) and selection. These are described in <a href="#tab_pomo_models"></a>.</p>

<figure id="tab_pomo_models" class="table"><figcaption class="table">Specific functions for PoMos are available in RevBayes. For an overview of the specificities and possible applications of these models, please consult <a class="citation" href="#Borges2022b">(Borges et al. 2022)</a>. </figcaption>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>Function</strong></th>
      <th style="text-align: center"><strong>Description</strong></th>
      <th style="text-align: center"><strong>Parameters</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">fnPoMoKN</td>
      <td style="text-align: center">Describes the evolution of a population with $K$ alleles and $N$ individuals subjected to mutational bias and selection</td>
      <td style="text-align: center">$K$, $N$, $\mu$, $\phi$  </td>
    </tr>
    <tr>
      <td style="text-align: center">fnReversiblePoMoKN</td>
      <td style="text-align: center">Particular case of PoMoKN when mutations are considered reversible.</td>
      <td style="text-align: center">$K$, $N$, $\pi$, $\rho$, $\phi$  </td>
    </tr>
    <tr>
      <td style="text-align: center">fnPoMo4N</td>
      <td style="text-align: center">Describes the evolution of a population with 4 alleles (typically the A, C, G, and T nucleotides) and $N$ individuals subjected to mutational bias and selection</td>
      <td style="text-align: center">$N$, $\mu$, $\phi$  </td>
    </tr>
    <tr>
      <td style="text-align: center">fnReversiblePoMo4N</td>
      <td style="text-align: center">Particular case of PoMo4N when mutations are considered reversible.</td>
      <td style="text-align: center">$N$, $\pi$, $\rho$, $\phi$  </td>
    </tr>
    <tr>
      <td style="text-align: center">fnPoMo2N</td>
      <td style="text-align: center">Describes the evolution of a population with 2 alleles and $N$ individuals subjected to mutational bias and selection</td>
      <td style="text-align: center">$N$, $\mu$, $\phi$  </td>
    </tr>
    <tr>
      <td style="text-align: center">fnReversiblePoMo2N</td>
      <td style="text-align: center">Particular case of PoMo2N when mutations are considered reversible.</td>
      <td style="text-align: center">$N$, $\pi$, $\rho$, $\phi$  </td>
    </tr>
    <tr>
      <td style="text-align: center">fnReversiblePoMoTwo4N</td>
      <td style="text-align: center">Describes the evolution of a virtual population with 4 alleles of 2 individuals (hence PoMoTwo) subjected to mutational bias</td>
      <td style="text-align: center">$N$, $\pi$, $\rho$  </td>
    </tr>
    <tr>
      <td style="text-align: center">fnReversiblePoMoThree4N</td>
      <td style="text-align: center">Describes the evolution of a virtual population with 4 alleles of 3 individuals (hence PoMoThree) subjected to mutational bias and selection</td>
      <td style="text-align: center">$N$, $\pi$, $\rho$, $\phi$  </td>
    </tr>
  </tbody>
</table>
</figure>

<p>This tutorial demonstrates how to set up and perform analyses using polymorphism-aware phylogenetic models. You will perform phylogeny inference using the virtual PoMos Two and Three. These models allow for very efficient species tree inferences under neutrality (PoMoTwo) and selection (PoMoThree) because they operate on a smaller state space (missing reference). You will perform a Markov chain Monte Carlo (MCMC) analysis to estimate phylogeny and other model parameters. The graphical model representation under PoMoThree is depicted in figure <a href="#pomos_graphical_model"></a>.</p>

<figure id="pomos_graphical_model"><p><img src="figures/dag_pomos.png" /></p>
<figcaption>Graphical model representation of PoMos. The graphical model shows the dependencies among parameters <a class="citation" href="#Hoehna2014b">(Höhna et al. 2014)</a>. Here, the rate matrix $Q$ is a deterministic variable because it depends on the mutation rates and fitness coefficients. The same applies to the phylogenetic tree $\Psi$, which depends on the topology and branch lengths.</figcaption>
</figure>

<h2 class="section" id="Count_files">Count files <a href="https://youtu.be/MQjs08HH2VY"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></h2>
<hr class="section" />

<p>PoMos perform inferences based on allele frequency data. Count files are the files where we store such data. They contain two header lines. The first line indicates the number of taxa and the number of sites (or loci) in the sequence alignment. You might have noticed that NPOP stands for the number of populations, but this is not necessarily the case. PoMos can be employed to infer the evolutionary history of different species or even other systematic units that one might be interested in studying (e.g., subspecies, communities, etc.).</p>

<p>A second line states the genomic position of every locus (chromosome and location) and the taxon names. The first two columns are not used for inference, which means that if you are working with taxa for which such information is not available, you can input these columns with dummy values (e.g., NA or ?). All the other lines in the count file include allelic counts separated by commas. White spaces separate all the elements in the count file. Let us have a look at some lines of the great ape count file we will analyze in this tutorial:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COUNTSFILE NPOP 3 NSITES 5
CHROM POS       Gorilla_beringei_graueri Gorilla_gorilla_dielhi Gorilla_gorilla_gorilla
chr1  41275799  6,0,0,0                  2,0,0,0                54,0,0,0 
chr2  120104878 6,0,0,0                  2,0,0,0                54,0,0,0 
chr11 61364549  0,6,0,0                  0,2,0,0                0,54,0,0 
chr17 44837427  6,0,0,0                  2,0,0,0                54,0,0,0 
chr19 7495905   4,0,2,0                  2,0,0,0                10,0,44,0 
</code></pre></div></div>

<p>The four allelic counts in this count file represent the allelic counts of the A, C, G, and T, respectively. Thus, we know that the <code class="language-plaintext highlighter-rouge">Gorilla_gorilla_gorilla</code> has an AG polymorphism at position 7 495 905 of chromosome 19. The allele order in the allelic counts can be any. However, you have to keep in mind that the vector of mutation rates, exchangeabilities, base frequencies, and fitness coefficients all follow the order of the allele counts in the count file:</p>
<ul>
  <li>the base frequencies and the fitness vectors are in the same order as in the counts: i.e., \(\{a_0,a_1,...,a_{K-1}\}\);</li>
  <li>the vector mutation rates (this vector is used in the non-reversible models) are \(\{a_0a_1, a_1a_0, a_0a_2, a_2a_0,...\}\);</li>
  <li>the vector of exchangeabilities follows a similar pattern as for the mutation rates, but without the reversed mutation: i.e., \(\{a_0a_1, a_0a_2, ...\}\).</li>
</ul>

<h2 class="section" id="loading_data">Loading the data <a href="https://youtu.be/acjouysOU04"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></h2>
<hr class="section" />

<p>The first step in this tutorial is to convert the allelic counts into PoMo states. Open the terminal and place it in your working directory, let us call it <strong>PoMos</strong>, but you can use a name of your preference. Inside <strong>PoMos</strong> create the usual <strong>data</strong> and <strong>output</strong> folders. Before starting to actually load the data, run <strong>RevBayes</strong> by typing <code class="language-plaintext highlighter-rouge">./rb</code> (or <code class="language-plaintext highlighter-rouge">./rb-mpi</code>) in the console. Open the <code class="language-plaintext highlighter-rouge">great_apes_pomothree.Rev</code> file using an appropriate text editor so you can follow what each command is doing. Once you know what this <code class="language-plaintext highlighter-rouge">.Rev</code> script is doing in detail, you can automatically run it as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./rb great_apes_pomothree.Rev

</code></pre></div></div>

<p>We mentioned previously that the PoMo state space includes fixed and polymorphic states. However, allele counts are samples of (usually) a few individuals from the population. For example, sampled fixed sites might not necessarily be fixed in the original population. We might just have been unlucky and only sampled individuals with the same allele from a locus that is polymorphic. It is typically the case that real genetic diversity is undersampled in population genetic studies. The fewer the number of sampled individuals or the rarer the alleles in the original population (i.e., singletons or doubletons), the more likely we are to observe fake fixed sites in the sequence alignment. There are methods that help us correct for such bias by attributing to each of the allelic counts an appropriate PoMo state. One such method is the weighted-method <a class="citation" href="#Schrempf2016">(Schrempf et al. 2016)</a>, which weights each PoMo state based on binomial sampling. This is automatically done in RevBayes when we use  the function <code class="language-plaintext highlighter-rouge">readPoMoCountFile</code>. We just need to define the location of the counts file, the virtual population size, which, as we will be using the virtual PoMo three for inferences, we set to <code class="language-plaintext highlighter-rouge">3</code>, and the data type format, which is PoMo.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N &lt;- 3
data &lt;- readPoMoCountFile(countFile="data/great_apes_1000.cf", virtualPopulationSize=N, format="PoMo")
</code></pre></div></div>

<p>Information about the alignment can be obtained by typing <code class="language-plaintext highlighter-rouge">data</code>. </p>

<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;data
   PoMo character matrix with 12 taxa and 1000 characters
   ======================================================
   Origination:                   
   Number of taxa:                12
   Number of included taxa:       12
   Number of characters:          1000
   Number of included characters: 1000
   Datatype:                      PoMo
</code></pre></div></div>

<p>If, instead of a count file, you have a list of sequences per individual (either in a fasta or nexus file), RevBayes can still convert it to PoMo data format. To do that, you will need to read the sequences, provide a file with the taxon names, and then perform the conversion to the PoMo state space with <code class="language-plaintext highlighter-rouge">pomoStateConver</code>. To identify individual sequences as belonging to the same taxon, just use the same name. These are the commands you will need:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data_char = readDiscreteCharacterData("data/individual_sequences.nex")
taxa = readTaxonData("data/taxon_names.txt")
data = pomoStateConvert(aln=data_char, k=4, virtualNe=N, taxa)
</code></pre></div></div>

<p>Next, we will specify some useful variables. These include the number of taxa, taxa names, and the number of branches. We will need that information for setting up our model in subsequent steps.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_taxa     &lt;- data.ntaxa()
n_branches &lt;- 2*n_taxa-3
taxa       &lt;- data.taxa()
</code></pre></div></div>

<p>Additionally, we set up a variable that holds all the moves and monitors them for our analysis. Recall that moves are algorithms used to propose new parameter values during the MCMC simulation. Monitors print the values of model parameters to the screen and/or log files during the MCMC analysis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves    = VectorMoves()  
monitors = VectorMonitors()
</code></pre></div></div>

<h2 class="section" id="model_setup">Setting up the model <a href="https://youtu.be/izCH8lQY-AY"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></h2>
<hr class="section" />

<p>Estimating an unrooted tree under the virtual PoMos requires specifying two main components:</p>
<ul>
  <li>the PoMo model, which in our case is PoMoTwo or PoMoThree;</li>
  <li>the tree topology and branch lengths.</li>
</ul>

<p>A given PoMo model is defined by its corresponding instantaneous-rate matrix, <code class="language-plaintext highlighter-rouge">Q</code>. PoMoTwo and PoMoThree have three free parameters in common: the population size <code class="language-plaintext highlighter-rouge">N</code>, the allele frequencies <code class="language-plaintext highlighter-rouge">pi</code>, and the exchangeabilities <code class="language-plaintext highlighter-rouge">rho</code>. PoMoThree additionally includes the allele fitnesses <code class="language-plaintext highlighter-rouge">phi</code>, as it accounts for selection. We will set up the virtual PoMoTwo and Three using the function <code class="language-plaintext highlighter-rouge">fnReversiblePoMo4N</code>. You can check the input parameters of any PoMo function by typing its name right after the question mark: <code class="language-plaintext highlighter-rouge">?fnReversiblePoMo4N</code>.</p>

<p>As expected, this function has as input parameters the population size <code class="language-plaintext highlighter-rouge">N</code>, base frequencies, exchangeabilities <code class="language-plaintext highlighter-rouge">rho</code> and fitnesses <code class="language-plaintext highlighter-rouge">phi</code>. We will first set out the PoMoThree, which we can do by setting $N$ to 3. Similarly, if you wanted to set out the neutral PoMo (i.e., PoMoTwo), you could set <code class="language-plaintext highlighter-rouge">N</code> to 2 instead. Thus, <code class="language-plaintext highlighter-rouge">N</code> is a fixed node, as we had previously defined. </p>

<p>Since <code class="language-plaintext highlighter-rouge">pi</code>, <code class="language-plaintext highlighter-rouge">rho</code>, and <code class="language-plaintext highlighter-rouge">gamma</code> are stochastic variables, we must specify a move to propose updates to them. A good move on variables drawn from a Dirichlet distribution (i.e., <code class="language-plaintext highlighter-rouge">pi</code>) is the <code class="language-plaintext highlighter-rouge">mvBetaSimplex</code>. This move randomly takes an element from the allele frequencies vector <code class="language-plaintext highlighter-rouge">pi</code>, proposes a new value drawn from a beta distribution, and then rescales all values to sum to 1. The weight option inside the moves specifies how often the move will be applied, either on average per iteration or relative to all other moves.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># allele frequencies
pi_prior &lt;- [1,1,1,1]
pi ~ dnDirichlet(pi_prior)
moves.append( mvBetaSimplex(pi, weight=2) )
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">rho</code> and <code class="language-plaintext highlighter-rouge">phi</code> parameters must be a positive real number and a natural choice for their prior distributions is the exponential distribution. Again, we need to specify a move for these stochastic variables, and a simple scaling move <code class="language-plaintext highlighter-rouge">mvScale</code> typically works. In this tutorial, we want our model to capture the effect of GC-bias gene conversion. For that, we define <code class="language-plaintext highlighter-rouge">gamma</code>, which will represent the GC-bias rate. The allele fitnesses <code class="language-plaintext highlighter-rouge">phi</code> of G and C will thus be represented by <code class="language-plaintext highlighter-rouge">gamma</code>, while those of A and T by 1.0. Note that <code class="language-plaintext highlighter-rouge">phi</code> is a deterministic node that depends on the GC-bias rate <code class="language-plaintext highlighter-rouge">gamma</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># exchangeabilities
for (i in 1:6){
  rho[i] ~ dnExponential(10.0)
  moves.append(mvScale( rho[i], weight=2 ))
}

# fitness coefficients
gamma ~ dnExponential(1.0)
moves.append(mvScale( gamma, weight=2 ))
phi := [1.0,1.0+gamma,1.0+gamma,1.0]
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">fnReversiblePoMo4N</code> will create an instantaneous-rate matrix.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># rate matrix
Q := fnReversiblePoMo4N(N,pi,rho,phi)
</code></pre></div></div>

<p>An important note: We could similarly have used the functions <code class="language-plaintext highlighter-rouge">fnReversiblePoMoTwo4N</code> and <code class="language-plaintext highlighter-rouge">fnReversiblePoMoThree4N</code>, to set the rate matrices. These are particularly useful when one has information about mutation or the GC-bias gene conversion rate (for some model organisms, this information might be available) and wants to include it via informative priors. In such a case, the population size is not a fixed node, and it can be jointly estimated. In this tutorial, we are assuming that no prior information is available for the mutation or GC-bias rates. Note that selection is not identifiable with two virtual individuals, so the vector of fitness coefficients cannot be inputted for the <code class="language-plaintext highlighter-rouge">fnReversiblePoMoTwo4N</code>: it is by default equal to the unitary vector (i.e., the neutral scenario). To check the input parameters of PoMoTwo, you can type <code class="language-plaintext highlighter-rouge">?fnReversiblePoMoTwo4N</code> ; you will see that the fitness coefficient <code class="language-plaintext highlighter-rouge">phi</code> is missing. As a consequence, if we want to employ the PoMoTwo model with the general <code class="language-plaintext highlighter-rouge">fnReversiblePoMoTwo4N</code>, we have to set the fitness coefficients to 1.0.</p>

<p>The tree topology and branch lengths are stochastic nodes in our phylogenetic model. We will assume that all possible labeled, unrooted tree topologies have equal probability. In the case of an unrooted tree topology, we use the nearest-neighbor interchange move <code class="language-plaintext highlighter-rouge">mvNNI</code> (a subtree-prune and regrafting move <code class="language-plaintext highlighter-rouge">mvSPR</code> could also be used).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># topology
topology ~ dnUniformTopology(taxa)
moves.append( mvNNI(topology, weight=2*n_taxa) )
</code></pre></div></div>

<p>Next, we have to create a stochastic node representing the length of each of the <code class="language-plaintext highlighter-rouge">2*n_taxa−3</code> branches in our tree. We can do this using a for loop. In this loop, we can create each of the branch-length nodes and assign each move.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># branch lengths
for (i in 1:n_branches) {
   branch_lengths[i] ~ dnExponential(10.0)
   moves.append( mvScale(branch_lengths[i]) )
}
</code></pre></div></div>

<p>Finally, we combine the tree topology and branch lengths. We do this using the <code class="language-plaintext highlighter-rouge">treeAssembly</code> function, which applies the value of the ith member of the <code class="language-plaintext highlighter-rouge">branch_lengths</code> vector to the branch leading to the ith node in the topology. Thus, the psi variable is a deterministic node:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi := treeAssembly(topology, branch_lengths)
</code></pre></div></div>

<p>We have fully specified all of the parameters of our phylogenetic model:</p>
<ul>
  <li>the tree with branch lengths of <code class="language-plaintext highlighter-rouge">psi</code>;</li>
  <li>the PoMo instantaneous-rate matrix <code class="language-plaintext highlighter-rouge">Q</code>;</li>
  <li>the type of character data: i.e., <code class="language-plaintext highlighter-rouge">PoMo</code>.</li>
</ul>

<p>Collectively, these parameters comprise a distribution called the phylogenetic continuous-time Markov chain, and we use the <code class="language-plaintext highlighter-rouge">dnPhyloCTMC</code> function to create this node. This distribution requires several input arguments:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sequences ~ dnPhyloCTMC(psi,Q=Q,type="PoMo")
</code></pre></div></div>

<p>Once the <code class="language-plaintext highlighter-rouge">PhyloCTMC</code> model has been created, we can attach our sequence data to the tip nodes in the tree. Although we assume that our sequence data are random variables, they are realizations of our phylogenetic model. For inference purposes, we assume that the sequence data are <em>clamped</em> to their observed values.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sequences.clamp(data)
</code></pre></div></div>

<p>When this function is called, <strong>RevBayes</strong> sets each of the stochastic nodes representing the tree’s tips to the corresponding nucleotide sequence in the alignment. This essentially tells the program that we have observed sequence data at the tree tips.</p>

<p>Finally, we wrap the entire model in a single object. To do this, we only need to give the <code class="language-plaintext highlighter-rouge">model</code> function a single node.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pomo_model = model(pi)
</code></pre></div></div>

<h2 class="section" id="mcmc">Setting, running, and summarizing the MCMC simulation <a href="https://youtu.be/5b1FmykQ37o"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></h2>
<hr class="section" />

<p>For our MCMC analysis, we need to set up a vector of monitors to record the states of our Markov chain. First, we will initialize the model monitor using the <code class="language-plaintext highlighter-rouge">mnModel</code> function. This creates a new monitor variable that will output the states for all model parameters when passed into an MCMC function. We will sample every 10th generation, and the resulting file can be found in the <strong>output</strong> folder.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/great_apes_pomothree.log", printgen=10) )
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mnFile</code> monitor will record the states for only the parameters passed in as arguments. We use this monitor to specify the output for our sampled trees and branch lengths. Again, we sample every 10th generation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnFile(filename="output/great_apes_pomothree.trees", printgen=10, psi) )
</code></pre></div></div>

<p>Finally, create a screen monitor that will report the states of specified variables to the screen with <code class="language-plaintext highlighter-rouge">mnScreen</code>. This monitor mostly helps us follow the progress of the MCMC run.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(printgen=10) )
</code></pre></div></div>

<p>With a fully specified model, a set of monitors, and a set of moves, we can now set up the MCMC algorithm that will sample parameter values in proportion to their posterior probability. The <code class="language-plaintext highlighter-rouge">mcmc</code> function will create our MCMC object. Furthermore, we will perform two independent MCMC runs to ensure proper convergence and mixing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pomo_mcmc = mcmc(pomo_model, monitors, moves, nruns=2, combine="mixed")
</code></pre></div></div>

<p>Now, we can start the MCMC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pomo_mcmc.run( generations=10000 )
</code></pre></div></div>

<p>When the analysis is complete, you will have the monitored files in your output directory. Software like <a href="https://github.com/beast-dev/tracer/releases/tag/v1.7.2"><strong>Tracer</strong></a> or the R package <a href="https://revbayes.github.io/tutorials/convergence/"><strong>Convenient</strong></a> allow evaluating convergence and mixing. Look at the file called <code class="language-plaintext highlighter-rouge">output/great_apes_pomothree.log</code> in <strong>Tracer</strong>. There you see the posterior distribution of the continuous parameters. Let us look at the posterior distribution of the GC-bias rate $\gamma$. Is there any evidence of GC-bias in these great apes sequences?</p>

<figure id="gamma"><p><img src="figures/gamma_mcmc.png" /></p>
<figcaption><strong>Left</strong>: Trace of the GC-bias rate ($\gamma$) samples for one MCMC run. You will also see that the effective sample size is comparably large, i.e., much larger than 200. <strong>Right</strong>: Posterior distribution of the great apes GC-bias rate ($\gamma$) under a PoMoThree model.</figcaption>
</figure>

<p>Apart from the continuous parameters, we need to summarize the trees sampled from the posterior distribution. RevBayes can summarize the sampled trees by reading in the tree trace file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trace = readTreeTrace("output/great_apes_pomothree.trees", treetype="non-clock", burnin= 0.2)
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mapTree</code> function will summarize the tree samples and write the maximum a posteriori (MAP) tree to the specified file. The MAP tree can be found in the <strong>output</strong> folder.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mapTree(trace, file="output/great_apes_pomothree_MAP.tree" )
</code></pre></div></div>

<figure id="tree"><p><img src="figures/great_apes_pomo_three.png" /></p>
<figcaption>Maximum a posteriori estimate of the great ape phylogeny under the PoMoThree model. The numbers at the nodes show the posterior probabilities for the clades. We have rooted the tree at the Oran-Utans clade.</figcaption>
</figure>

<p>Look at the file called <code class="language-plaintext highlighter-rouge">output/great_apes_pomothree_MAP.tree</code> and open it in FigTree. The maximum a posteriori estimate of the great ape phylogeny under the PoMoThree model should look like that of <a href="#tree"></a>.</p>

<h2 class="section" id="some-questions">Some questions</h2>
<hr class="section" />

<ol>
  <li>
    <p>What is the GC-bias rate (this is the selection coefficient) for the great ape populations? Rescale to its real value by assuming that the great apes have an effective population size of about 10 000 individuals. You should use the relation $(1+\gamma’)^{M-1}=(1+\gamma)^{N-1}$ to rescale $\gamma$.  $M$ and $N$ are the virtual and effective population sizes, and $\gamma’$ and $\gamma$ are the GC-bias rates on the virtual and effective populations.</p>
  </li>
  <li>
    <p>With <a href="#pomos_graphical_model"></a> as your guide, draw the probabilistic graphical model of the PoMoTwo model.</p>
  </li>
  <li>
    <p>What changes have to be made to the <code class="language-plaintext highlighter-rouge">great_apes_pomothree.Rev</code> to make inferences under the PoMoTwo model?</p>
  </li>
  <li>
    <p>Run an MCMC analysis to estimate the posterior distribution under the PoMoTwo model. Are the resulting estimates of the mutation rates (base frequencies and exchangeabilities) equal? If not, how much do they differ?</p>
  </li>
  <li>
    <p>Compare the MAP trees estimated under PoMoTwo and PoMoThree. Are they equal, and if not, how much do they differ?</p>
  </li>
</ol>

<ol class="bibliography"><li><span id="Borges2022b">Borges R., Boussau B., Höhna S., Pereira R.J., Kosiol C. 2022. Polymorphism‐aware estimation of species trees and evolutionary forces from genomic sequences with RevBayes. Methods in Ecology and Evolution.</span>

<a href="https://doi.org/10.1111/2041-210X.13980">10.1111/2041-210X.13980</a>

</li>
<li><span id="Borges2019">Borges R., Szöllősi G.J., Kosiol C. 2019. Quantifying GC-Biased Gene Conversion in Great Ape Genomes Using Polymorphism-Aware Models. Genetics. 212:1321–1336.</span>

<a href="https://doi.org/10.1534/genetics.119.302074">10.1534/genetics.119.302074</a>

</li>
<li><span id="Hoehna2014b">Höhna S., Heath T.A., Boussau B., Landis M.J., Ronquist F., Huelsenbeck J.P. 2014. Probabilistic Graphical Model Representation in Phylogenetics. Systematic Biology. 63:753–771.</span>

<a href="https://doi.org/10.1093/sysbio/syu039">10.1093/sysbio/syu039</a>

</li>
<li><span id="Schrempf2016">Schrempf D., Minh B.Q., De Maio N., Haeseler A. von, Kosiol C. 2016. Reversible polymorphism-aware phylogenetic models and their application to tree inference. Journal of Theoretical Biology. 407:362–370.</span>

<a href="https://doi.org/10.1016/j.jtbi.2016.07.042">10.1016/j.jtbi.2016.07.042</a>

</li>
<li><span id="DeMaio2013">De Maio N., Schlötterer C., Kosiol C. 2013. Linking great apes genome evolution across time scales using polymorphism-aware phylogenetic models. 30:2249–2262.</span>

<a href="https://doi.org/10.1093/molbev/mst131">10.1093/molbev/mst131</a>

</li>
<li><span id="DeMaio2015">De Maio N., Schrempf D., Kosiol C. 2015. PoMo: An Allele Frequency-Based Approach for Species Tree Estimation. Systematic Biology. 64:1018–1031.</span>

<a href="https://doi.org/10.1093/sysbio/syv048">10.1093/sysbio/syv048</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
