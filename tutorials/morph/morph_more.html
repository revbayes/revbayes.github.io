<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Discrete morphology - Ancestral State Estimation</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/software">Software</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Discrete morphology - Ancestral State Estimation</h1>
	<h3 class="subtitle">Ancestral State Estimation and Testing for Irreversibility</h3>
	<h4 class="authors">Sebastian Höhna, Will Freyman, April M. Wright and Michael J. Landis</h4>
  <h5>Last modified on May 31, 2019</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/intro_rev/">Basic introduction to Rev & MCMC</a></li>
          
            <li><a href="/tutorials/mcmc_archery/">Introduction to MCMC using RevBayes</a></li>
          
            <li><a href="/tutorials/mcmc_binomial/">Introduction to MCMC using RevBayes</a></li>
          
            <li><a href="/tutorials/ctmc/">Substitution Models</a></li>
          
            <li><a href="/tutorials/morph/">Discrete morphology - Tree Inference</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/morph/data/mammals_thinned.tree">mammals_thinned.tree</a></li>
        
          <li><a href="/tutorials/morph/data/mammals_thinned_placenta_type.nex">mammals_thinned_placenta_type.nex</a></li>
        
          <li><a href="/tutorials/morph/data/primates_activity_period.nex">primates_activity_period.nex</a></li>
        
          <li><a href="/tutorials/morph/data/primates_mating_system.nex">primates_mating_system.nex</a></li>
        
          <li><a href="/tutorials/morph/data/primates_solitariness.nex">primates_solitariness.nex</a></li>
        
          <li><a href="/tutorials/morph/data/primates_tree.nex">primates_tree.nex</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/morph/scripts/mcmc_ase_freeK.Rev">mcmc_ase_freeK.Rev</a></li>
        
          <li><a href="/tutorials/morph/scripts/mcmc_ase_freeK_RJ.Rev">mcmc_ase_freeK_RJ.Rev</a></li>
        
          <li><a href="/tutorials/morph/scripts/mcmc_ase_mk.Rev">mcmc_ase_mk.Rev</a></li>
        
          <li><a href="/tutorials/morph/scripts/mcmc_corr.Rev">mcmc_corr.Rev</a></li>
        
          <li><a href="/tutorials/morph/scripts/plot_anc_states.R">plot_anc_states.R</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="introduction">Introduction</h2>
<hr class="section" />

<p>Discrete morphological models are not only useful for tree estimation, 
as was done in Tutorial <a href="/tutorials/morph/">Discrete morphology - Tree Inference</a>, but also to ask specific questions about 
the evolution of the morphological character of interest.
Specifically, there are two types of analyses that we might be interest in. 
First, we can test different model of morphological evolution, 
such as reversible and irreversible models, and estimate rates under these models.
Using an irreversible model of evolution, we can test, for example, 
for Dollo’s law of a complex character that can be lost but not gained again <a href="#Goldberg2008">(Goldberg and Igić 2008)</a>.</p>

<p>Additionally, we might be interest in ancestral state estimation, 
or mapping transition on the phylogeny.
Commonly the central problem in statistical phylogenetics concerns <em>marginalizing</em> over 
all unobserved character histories that evolved along the branches of a given 
phylogenetic tree according to some model, $M$, under some parameters, $\theta$.
This marginalization yields the probability of observing the tip states, $X_\text{tip}$, 
given the model and its parameters, 
$P( X_\text{tip} | \theta, M ) = \sum_{X_\text{internal}} P( X_\text{internal}, X_\text{tip} \mid \theta, M )$.
One might also wish to find the probability distribution of ancestral state 
configurations that are consistent with the tip state distribution, 
$P( X_\text{internal} \mid X_\text{tip}, \theta, M )$, and to sample 
ancestral states from that distribution.
This procedure is known as <em>ancestral state estimation</em>.</p>

<p>This tutorial will provide a discussion of modeling morphological characters 
and ancestral state estimation, and will demonstrate how to perform such 
Bayesian phylogenetic analysis using RevBayes <a href="#Hoehna2016b">(Höhna et al. 2016)</a>.</p>

<h2 class="section" id="sec_irreversible_matrix">Overview of Discrete Morphology Models: Unequal rate models and irreversible models</h2>
<hr class="section" />

<p>The instantaneous rate matrix encodes the transition rates between all pairs of evolutionary states.
It is important to emphasize that all rate matrices are assertions about how morphological evolution operates.
Depending on how one populates the rate matrix elements, different evolutionary hypotheses may be expressed.</p>

<p>When we model the evolution of morphological data, unlike nucleotide data, each change may require a sequence of intermediate changes.
Getting to one state may require going through another.
In short, it is probably not likely that one single model describes all characters well.</p>

<h3 class="subsection" id="symmetric-unordered">Symmetric unordered</h3>
<hr class="subsection" />

<p>The standard Mk model of character evolution, where M denotes it is a Markov model and $K$ denotes the number of states for the character.
The lineage may transition directly from state 1 to state 4 without going through states 2 and 3, which is representative of a character with 
<em>unordered</em> states.
In addition, all transition rates are equal as they are in the Jukes-Cantor rate matrix <a href="#Jukes1969">(Jukes and Cantor 1969)</a>.
Here is an example of a symmetric unordered Mk model for $k=3$.</p>

<script type="math/tex; mode=display">% <![CDATA[
Q = \begin{pmatrix}
- & r & r \\
r & - & r \\
r & r & - 
\end{pmatrix} %]]></script>

<p>Define the single shared rate parameter</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mu &lt;- 1.0
</code></pre></div></div>

<p>Define the rates</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rates := [ [0.0,  mu,  mu],
           [ mu, 0.0,  mu],
           [ mu,  mu, 0.0] ]
</code></pre></div></div>

<p>Create the rate matrix</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnFreeK(rates)
Q
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   [ [ -1.0000, 0.5000, 0.5000 ] ,
     0.5000, -1.0000, 0.5000 ] ,
     0.5000, 0.5000, -1.0000 ] ]
</code></pre></div></div>

<p>Now, let’s compute the transition probability matrix for a branch length of 0.1.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P &lt;- Q.getTransitionProbabilities(0.1)
P
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ 0.907, 0.046, 0.046 ], 
  [ 0.046, 0.907, 0.046 ], 
  [ 0.046, 0.046, 0.907 ] ]
</code></pre></div></div>

<p>If we believed that, for example, for a couple of states, some transitions are strongly 
more likely, we could add a multiplier between those two states:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rates := [ [  0.0,  mu,   mu],
           [ 2*mu, 0.0, 2*mu],
           [   mu,  mu,   mu] ]
Q := fnFreeK(rates)
Q
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   [ [ -0.8333, 0.4167, 0.4167 ] ,
     0.8333, -1.6667, 0.8333 ] ,
     0.4167, 0.4167, -0.8333 ] ]
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> P &lt;- Q.getTransitionProbabilities(0.1)
 P
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   [ [ 0.922, 0.038, 0.040 ], 
     [ 0.075, 0.850, 0.075 ], 
     [ 0.040, 0.038, 0.922 ] ]
</code></pre></div></div>

<p>If we then get our transition probabilities, we see that this changes our probability of observing the not simply our two state transitions that we changed the rate for, but others as well.</p>

<p>This type of approach is common in parsimony, where it is one of several things referred to as weighted parsimony. 
This approach to using different matrices requires you to, <em>a priori</em> specify your matrix.
But in reality, there is often fairly little guidance or information by which we decide if a weight applied to a transition is appropriate.
Biologists still use models of this type - the Dollo model, in which a character is assumed not to be able to re-evolve once lost, is an extreme version of penalizing one change.</p>

<p>Because the transition rates between all differing pairs of states are the same, so are the transition probabilities.
Similarly, the probability of remaining in any given state is also equal across states.</p>

<h3 class="subsection" id="asymmetric-ordered">Asymmetric ordered</h3>
<hr class="subsection" />

<p>Character states that are ordered imply that evolutionary transitions occur in particular sequences.
For example, the number of digits on a foot might vary by gaining and losing single digits, meaning the transition from three to five digits cannot occur without going through the evolutionary state of possessing four digits.
Below, we assume that gain events ( $n \rightarrow n+1$ ) occur at rate $\lambda$ and loss events ($n \rightarrow n-1$) occur at rate $\mu$.
The zeroes indicate that there is no immediate evolutionary path between states $1$ and $4$: states $2$ and $3$ must be used to reach $4$ from $1$.</p>

<script type="math/tex; mode=display">% <![CDATA[
Q = \begin{pmatrix}
- & \lambda & 0 & 0 \\
\mu & -   & \lambda & 0 \\
0 & \mu & -   & \lambda \\
0 & 0 & \mu & - 
\end{pmatrix} %]]></script>

<p>Create two rate parameters, $\lambda$ for gain and $\mu$ loss events.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lambda ~ dnExponential( 1 )
mu ~ dnExponential( 1 )
lambda.setValue( 3 )
mu.setValue( 1 )
</code></pre></div></div>

<p>Create a tridiagonal matrix of transition rates, meaning state $i$ may only transition to states $i-1$ and $i+1$</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diag_rates := [ [  0.0, lambda,    0.0,    0.0],
                [   mu,    0.0, lambda,    0.0],
                [  0.0,     mu,    0.0, lambda],
                [  0.0,    0.0,     mu,    0.0] ]
</code></pre></div></div>

<p>Create the rate matrix</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnFreeK(diag_rates)
Q
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ -1.5385, 1.5385, 0.0000, 0.0000 ] ,
     0.5128, -2.0513, 1.5385, 0.0000 ] ,
     0.0000, 0.5128, -2.0513, 1.5385 ] ,
     0.0000, 0.0000, 0.5128, -0.5128 ] ]
</code></pre></div></div>

<p>Compute the transition probability matrix for a branch length of 0.1.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P &lt;- Q.getTransitionProbabilities(rate=0.1)
P
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ 0.861, 0.129, 0.010, 0.001],
  [ 0.043, 0.821, 0.126, 0.010],
  [ 0.001, 0.042, 0.821, 0.136],
  [ 0.000, 0.001, 0.045, 0.954]]
</code></pre></div></div>

<p>Note that $P[1][2] &gt; P[1][3] &gt; P[1][4]$, primarily because those transitions require a minimum of one, two, and three events, respectively.
In addition, note that assigning asymmetric transition rates causes $P[1][2] &gt; P[2][1]$ because $rates[1][2] &gt; rates[2][1]$.</p>

<blockquote class="instruction">
  <p>In RevBayes we have also the specific rate matrix for this model: <code class="highlighter-rouge">fnOrderedRateMatrix(maxState, lambda, mu)</code>.</p>
</blockquote>

<h3 class="subsection" id="correlated-binary-characters">Correlated binary characters</h3>
<hr class="subsection" />

<p>Two characters do not necessarily evolve independently of one another.
Take two characters in plants: the presence or absence of toothed leaf margins (character X) is thought to be ecologically correlated with the presence of absence of leaf lobing (character Y).
For a single binary character, there are two states (0 and 1), but there are four states for a pair of non-independent binary characters (00, 10, 01, and 11).
(missing reference) introduced a general framework for modeling the evolution of joint sets of characters.
These models require that only one evolutionary event can occur in a moment of time, which is enforced with the 0 terms.
In addition, the transition rate that, say, character X goes from 0 to 1 depends on the current value of character Y.</p>

<h4 class="subsubsection" id="seven-free-parameters">Seven free parameters</h4>
<hr class="subsubsection" />

<p>In the first case, all possible transitions might be assigned their own parameter.
Here, we’ll assign a simplex over all rates, leaving seven free parameters (plus an eighth parameter that scales the rate matrix).</p>

<script type="math/tex; mode=display">% <![CDATA[
Q = \begin{pmatrix}
                      - & \mu_{00 \rightarrow 10} & \mu_{00 \rightarrow 01} &                       0 \\
\mu_{10 \rightarrow 00} &                       - &                       0 & \mu_{10 \rightarrow 11} \\
\mu_{01 \rightarrow 00} &                       0 &                       - & \mu_{01 \rightarrow 11} \\
                      0 & \mu_{11 \rightarrow 10} & \mu_{11 \rightarrow 01} &                       - \\
\end{pmatrix} %]]></script>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r ~ dnDirichlet( [1,1,1,1,1,1,1,1] )
r.setValue( simplex(1,1,3,3,3,3,1,1) )
</code></pre></div></div>

<p>Create an array of zeroes for the four states (00, 10, 01, 11)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:4) {
    for (j in 1:4) {
        rates[i][j] &lt;- 0.0
    }
}
</code></pre></div></div>

<p>Populate the elements of <code class="highlighter-rouge">rates</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rates[1][2] := r[1] # 00-&gt;10
rates[1][3] := r[2] # 00-&gt;01
rates[2][1] := r[3] # 10-&gt;00
rates[2][4] := r[4] # 10-&gt;11
rates[3][1] := r[5] # 01-&gt;00
rates[3][4] := r[6] # 01-&gt;11
rates[4][2] := r[7] # 11-&gt;10
rates[4][3] := r[8] # 11-&gt;01
</code></pre></div></div>

<p>Create the rate matrix</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnFreeK(rates)
Q
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ -0.6667, 0.3333, 0.3333, 0.0000 ] ,
     1.0000, -2.0000, 0.0000, 1.0000 ] ,
     1.0000, 0.0000, -2.0000, 1.0000 ] ,
     0.0000, 0.3333, 0.3333, -0.6667 ] ]
</code></pre></div></div>

<p>Compute the transition probability matrix for a branch length of 0.1.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P &lt;- Q.getTransitionProbabilities(rate=0.1)
P
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ 0.938, 0.029, 0.029, 0.003],
  [ 0.088, 0.822, 0.003, 0.088],
  [ 0.088, 0.003, 0.822, 0.088],
  [ 0.003, 0.029, 0.029, 0.938] ]
</code></pre></div></div>
<p>Note that the probability of remaining in state 10 or state 01 is less than the probability of remaining in state 00 or state 11.
In this toy example, these probabilities reflect that states 10 an 01 are less evolutionarily stable than states 00 and 11.</p>

<h4 class="subsubsection" id="four-free-parameters">Four free parameters</h4>
<hr class="subsubsection" />

<p>Alternatively, characters X and Y might share state frequencies, $\pi_j$, and transition rates $\mu_{ij}^{(k)}$, where $i$ is the starting state for the character undergoing change, $j$ is the ending state, and $k$ is the state of the other character.
This results in two stationary frequencies (one free parameter), four transition rates for $0 \rightarrow 1$ and $1 \rightarrow 0$ given that the other character is in state 0 or state 1 (three free parameters), plus one free parameter to scale the rate matrix.</p>

<script type="math/tex; mode=display">% <![CDATA[
Q = \begin{pmatrix}
- & \mu_{01}^{(0)} \pi_1 \pi_0 & \mu_{01}^{(0)} \pi_0 \pi_1 & 0 \\
\mu_{10}^{(0)} \pi_0 \pi_0 & -   & 0 & \mu_{01}^{(1)} \pi_1 \pi_1 \\
\mu_{10}^{(0)} \pi_0 \pi_0 & 0   & - & \mu_{01}^{(1)} \pi_1 \pi_1 \\
0 & \mu_{10}^{(1)} \pi_1 \pi_0 & \mu_{10}^{(1)} \pi_0 \pi_1 & - \\
\end{pmatrix} %]]></script>

<p>Assign the stationary frequencies of being in state 0 or state 1 shared by both characters X and Y.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi ~ dnDirichlet([1,1])
pi.setValue( simplex(1,3) )
</code></pre></div></div>
<p>Assign the relative transition rates for gain and loss provided that the other character is in state 0 or 1.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r ~ dnDirichlet( [1,1,1,1] )
r.setValue( simplex(1,3,3,1) )
</code></pre></div></div>
<p>Create an array of zeroes for the four states (00, 10, 01, 11)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:4) {
    for (j in 1:4) {
        rates[i][j] &lt;- 0.0
    }
}
</code></pre></div></div>
<p>Populate the elements of {\tt rates}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rates[1][2] := r[1] * pi[2] * pi[1] # 00-&gt;10
rates[1][3] := r[1] * pi[1] * pi[2] # 00-&gt;01
rates[2][1] := r[3] * pi[1] * pi[1] # 10-&gt;00
rates[2][4] := r[2] * pi[2] * pi[2] # 10-&gt;11
rates[3][1] := r[2] * pi[1] * pi[1] # 01-&gt;00
rates[3][4] := r[3] * pi[2] * pi[2] # 01-&gt;11
rates[4][2] := r[4] * pi[2] * pi[1] # 11-&gt;10
rates[4][3] := r[4] * pi[1] * pi[2] # 11-&gt;01
</code></pre></div></div>
<p>Create the rate matrix</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnFreeK(rates)
Q
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ -0.6333, 0.3167, 0.3167, 0.0000 ] ,
     0.4750, -2.3750, 0.0000, 1.9000 ] ,
     0.4750, 0.0000, -2.3750, 1.9000 ] ,
     0.0000, 0.3167, 0.3167, -0.6333 ] ]
</code></pre></div></div>

<p>Compute the transition probability matrix for a branch length of 0.1.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P &lt;- Q.getTransitionProbabilities(0.1)
P
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ 0.940, 0.027, 0.027, 0.005],
  [ 0.041, 0.792, 0.003, 0.164],
  [ 0.041, 0.003, 0.792, 0.164],
  [ 0.001, 0.027, 0.027, 0.944] ]
</code></pre></div></div>

<p>Note that this model has a tendency towards state 11.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P_10 &lt;- Q.getTransitionProbabilities(10.0)
P_10
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ 0.159, 0.105, 0.105, 0.630],
  [ 0.158, 0.105, 0.105, 0.632],
  [ 0.158, 0.105, 0.105, 0.632],
  [ 0.158, 0.105, 0.105, 0.632] ]
</code></pre></div></div>

<h3 class="subsection" id="covarion">Covarion</h3>
<hr class="subsection" />

<p>Covarion models <a href="#Tuffley1998">(Tuffley and Steel 1998)</a> capture the possibility that a ``hidden’’ (unobserved or unmeasurable) states cause evolutionary processes to vary in tempo and modes.
For example, phylogenetically local clusters of plant lineages appear to transition between herbaceous and woody habits at relatively high rates, so one might want to quantify where these bursts occur <a href="#Beaulieu2013">(Beaulieu et al. 2013)</a>.
While similar in structure to the correlated character model of <a href="#Pagel1994">(Pagel 1994)</a>, covarion models do not observe the hidden state that induce the mode-shifts.
Instead, covarion models expand the character’s state space by a factor of $K$, and observe the character once for each of the $K$ categories.
For example, take a binary character modeled with $K=2$ hidden state classes.
The model would treat a character that is observed as being in state 0 as possibly being in either of the $K=2$ classes (0,1) and (0,2).
In practice, this is done by setting the likelihood of observing those $0k$ states to equal 1.</p>

<p>The expanded structure of a simple covarion rate matrix with $K=2$ is</p>

<script type="math/tex; mode=display">% <![CDATA[
Q = \left(
\begin{array}{cc|cc}
- & r_1 q_{01}^{(1)} & s_{12} & 0 \\
r_1 q_{10}^{(1)} & - & 0 & s_{12} \\
\hline
s_{21} & 0 & - & r_2 q_{01}^{(2)} \\
0 & s_{21} & r_2 q_{10}^{(2)} & -  \\

\end{array}
\right) %]]></script>

<p>This form can be reduced to a simpler block-matrix representation
<script type="math/tex">% <![CDATA[
Q = \left(
\begin{array}{c|c}
r_1 Q^{(1)} & s_{12} I  \\
\hline
s_{21} I & r_2 Q^{(2)} \\
\end{array}
\right) %]]></script></p>

<p>where $Q^{(i)}$ is the rate matrix for the $i$th class, $r_i \in r$ is the clock rate for the $i$th class, and $S$ is the rate matrix to switch between classes.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sr ~ dnDirichlet([1,1])
sr.setValue( simplex(1,2) )
switch_rates := [ [   0.0, sr[1] ],
                  [ sr[2],   0.0 ] ]
Q_switch := fnFreeK(switch_rates)
</code></pre></div></div>

<p>Create an array of zeroes for the four states (00, 10, 01, 11)</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cr[1] ~ dnExp(1)
cr[2] ~ dnExp(1)
cr[1].setValue(3)
cr[2].setValue(1)
</code></pre></div></div>

<p>Populate the elements of <code class="highlighter-rouge">rates</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_class[1] := fnJC(2)

bf ~ dnDirichlet( [1,1] )
bf.setValue( simplex(1,3) )
Q_class[2] := fnF81( bf )
</code></pre></div></div>

<p>Create the rate matrix</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnCovarionRateMatrix(Q=Q_class, switch_rates=Q_switch, clock_rates=cr)
Q
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ -1.1126, 0.8901, 0.2225, 0.0000 ] ,
     0.8901, -1.1126, 0.0000, 0.2225 ] ,
     0.4451, 0.0000, -1.0385, 0.5934 ] ,
     0.0000, 0.4451, 0.1978, -0.6429 ] ]
</code></pre></div></div>

<p>Compute the transition probability matrix for a branch length of 0.1.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P &lt;- Q.getTransitionProbabilities(0.1)
P &lt;- Q.getTransitionProbabilities(1)
P
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ [ 0.899, 0.080, 0.020, 0.002],
  [ 0.080, 0.899, 0.001, 0.020],
  [ 0.040, 0.003, 0.902, 0.055],
  [ 0.002, 0.041, 0.018, 0.939] ]
</code></pre></div></div>

<p>The rows and columns correspond to (in order): state 0 evolving by $r_1 Q^{(1)}$, state 1 evolving by $r_1 Q^{(1)}$, state 1 evolving by $r_2 Q^{(2)}$, and state 2 evolving by $r_2 Q^{(2)}$.
Note that $P[1][2] &gt; P[3][4]$, which is largely due to the fact that $r_1 &gt; r_2$.</p>

<h2 class="section" id="sec_ase_example">Example: Ancestral state estimation with a simple equal rates model</h2>
<hr class="section" />

<p>In this example we will look at the evolution of morphological character <em>placenta type</em> in placental mammals.
We have three different types of placenta: Epitheliochorial(1), Endotheliochorial(2), Hemochorial(3) (<a href="#fig_placenta_types"></a> (missing reference)).
We are interested, in general, in the evolution of placenta type in placental mammals.
Specifically, we want to know what the ancestral state of all placental mammals is.
Furthermore, we want to know if placenta type is evolving under an equal-rates model, an unequal rates model, an irreversible model, or any other type of transition model.</p>

<figure id="fig_placenta_types"><p><img src="figures/placenta_types.png" /></p>
<figcaption>Visualization of different placenta types. Reproduced from (missing reference).</figcaption>
</figure>

<h3 class="subsection" id="specifying-the-mk-model">Specifying the Mk Model</h3>
<hr class="subsection" />

<p>We will start this tutorial with the simple Mk model with three states, $k=3$ <a href="#Lewis2001">(Lewis 2001)</a>.
Thus, we will follow the <a href="/tutorials/morph/">Discrete morphology - Tree Inference</a> Tutorial very closely and refer you to that tutorial for more information.</p>

<p>Let us start with defining the rate matrix $Q$ for this 3-state model:
<script type="math/tex">% <![CDATA[
Q = \begin{pmatrix} -\mu_1 & \mu_{12} & \mu_{13} \\
\mu_{21} & -\mu_2  & \mu_{23} \\
\mu_{31} & \mu_{32} & -\mu_3 
\end{pmatrix} \mbox{  .} %]]></script></p>

<p>Remember, the Mk model sets transitions to be equal from any state to any other state. 
In that sense, our 3-state matrix really looks like this:
<script type="math/tex">% <![CDATA[
Q = \begin{pmatrix} -(k-1)\mu & \mu & \mu \\
\mu & -(k-1)\mu  & \mu \\
\mu & \mu & -(k-1)\mu \\
\end{pmatrix} \mbox{  .} %]]></script></p>

<p>Because this is a Jukes-Cantor-like model <a href="#Jukes1969">(Jukes and Cantor 1969)</a>, state frequencies do not vary as a model parameter.
A visualization of this simple model can be seen in <a href="#fig_gm_m3"></a>.</p>

<figure id="fig_gm_m3"><p><img src="figures/tikz/Mk_model.png" /></p>
<figcaption>Graphical model showing the Mk model (left panel). Rev code specifying the Mk model is on the right-hand panel.</figcaption>
</figure>

<p>We will first perform a phylogenetic analysis using the Mk model.
In further sections, we will explore how to relax key assumptions of the Mk model.</p>

<h2 class="section" id="sec_dm_simple">Example: Ancestral State Estimation Using the Mk Model</h2>
<hr class="section" />

<p>In this example, we will use the placenta type data applied to a thinned phylogeny of placental mammals. 
We have thinned the phylogeny only so that it will run considerably fast for this tutorial.
Our actual analysis uses the full dataset of $\sim 5000$ taxa.</p>

<h3 class="subsection" id="subsec_data_files">Data and Files</h3>
<hr class="subsection" />

<blockquote class="instruction">
  <p>Create a directory called <code class="highlighter-rouge">RB_DiscreteMorphology_RateASE_Tutorial</code> (or any name you like).</p>

  <p>Make sure that you have the data files copied into a subdirectory called <code class="highlighter-rouge">data</code>: .</p>
</blockquote>

<h3 class="subsection" id="subsec_get_start">Getting Started</h3>
<hr class="subsection" />

<blockquote class="instruction">
  <p>Create a new directory (in <code class="highlighter-rouge">RB_DiscreteMorphology_RateASE_Tutorial) called </code>scripts`. 
(If you do not have this folder, please refer to the directions in section <a href="#subsec_data_files"></a>.)</p>
</blockquote>

<p>When you execute RevBayes in this exercise, you will do so within the main directory you created (<code class="highlighter-rouge">RB_DiscreteMorphology_RateASE_Tutorial</code>).</p>

<h3 class="subsection" id="subsec_creating_files">Creating Rev Files</h3>
<hr class="subsection" />

<p>For complex models and analyses, it is best to create Rev script files that will contain all of the model parameters, moves, and functions. 
In this exercise, you will work primarily in your text editor and create a set of files that will be easily managed and interchanged.
In this first section, you will write the following files from scratch and save them in the <code class="highlighter-rouge">scripts</code> directory:</p>
<ul>
  <li><code class="highlighter-rouge">mcmc_ase_mk.Rev</code>: the Rev-script file that loads the data, specifies the model describing discrete morphological character change (binary characters), and specifies the monitors and MCMC sampler.</li>
</ul>

<p>All of the files that you will create are also provided in the this RevBayes tutorial. 
Please refer to these files to verify or troubleshoot your own scripts.</p>

<blockquote class="instruction">
  <p>Open your text editor and create the master Rev file called <code class="highlighter-rouge">mcmc_ase_Mk.Rev</code> in the <code class="highlighter-rouge">scripts</code> directory.</p>

  <p>Enter the Rev code provided in this section in the new model file.</p>
</blockquote>

<p>The file you will begin in this section will be the one you load into RevBayes when you have completed all of the components of the analysis.
In this section you will begin the file and write the Rev commands for loading in the taxon list and managing the data matrices.
Then, starting in section <a href="#subsec_Mk_Model"></a>, you will move on to writing module files for each of the model components. 
Once the model files are complete, you will return to editing <code class="highlighter-rouge">mcmc_ase_Mk.Rev</code> and complete the Rev script with the instructions given in section <a href="#subsec_complete_MCMC"></a>.</p>

<h4 class="subsubsection" id="subsubsec_load_data">Load Data Matrices</h4>
<hr class="subsubsection" />

<p>RevBayes uses the function <code class="highlighter-rouge">readDiscreteCharacterData()</code> to load a data matrix to the workspace from a formatted file. 
This function can be used for both molecular sequences and discrete morphological characters.
Import the morphological character matrix and assign it to the variable <code class="highlighter-rouge">morpho</code>.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>morpho &lt;- readDiscreteCharacterData("data/mammals_thinned_placenta_type.nex")
</code></pre></div></div>

<h4 class="subsubsection" id="subsubsec_var">Create Helper Variables</h4>
<hr class="subsubsection" />

<p>Before we begin writing the Rev scripts for each of the model components, we need to instantiate a couple ``helper variables’’ that will be used by downstream parts of our model specification files. 
Create vectors of moves and monitors</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves = VectorMoves()
monitors = VectorMonitors()
</code></pre></div></div>

<h3 class="subsection" id="subsec_Mk_Model">The Mk Model</h3>
<hr class="subsection" />

<p>First, we read in the tree topology:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phylogeny &lt;- readTrees("data/mammals_thinned.tree")[1]
</code></pre></div></div>

<p>Next, we will create a Q matrix. 
Recall that the Mk model is simply a generalization of the JC model.
Therefore, we will create a 3x3 Q matrix using <code class="highlighter-rouge">fnJC</code>, which initializes $Q$-matrices with equal transition probabilities between all states.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_morpho &lt;- fnJC(3)
</code></pre></div></div>

<p>Now that we have the basics of the model specified, we will specify the only parameter of the model, $\mu$.
The parameter specifies all the rates of morphological evolution:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mu_morpho ~ dnExponential( 1.0 )
</code></pre></div></div>
<p>Since $\mu$ is a rate parameter, we will apply a scaling move to update it.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale(mu_morpho,lambda=1, weight=2.0) )
</code></pre></div></div>

<p>Lastly, we set up the CTMC. 
This should be familiar from the <a href="/tutorials/ctmc/">Substitution Models</a> tutorial.
We see some familiar pieces: tree and Q matrix.
We also have two new keywords: data type and coding.
The data type argument specifies the type of data - in our case, “Standard”, the specification for morphology.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phyMorpho ~ dnPhyloCTMC(tree=phylogeny, branchRates=mu_morpho, Q=Q_morpho, type="Standard")
phyMorpho.clamp(morpho)
</code></pre></div></div>

<p>All of the components of the model are now specified.</p>

<h3 class="subsection" id="subsec_complete_MCMC">Complete MCMC Analysis</h3>
<hr class="subsection" />

<h4 class="subsubsection" id="subsubsec_Mod_Obj">Create Model Object</h4>
<hr class="subsubsection" />

<p>We can now create our workspace model variable with our fully specified model DAG. 
We will do this with the <code class="highlighter-rouge">model()</code> function and provide a single node in the graph (<code class="highlighter-rouge">phylogeny</code>).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(phylogeny)
</code></pre></div></div>

<p>The object <code class="highlighter-rouge">mymodel</code> is a wrapper around the entire model graph and allows us to pass the model to various functions that are specific to our MCMC analysis.</p>

<h4 class="subsubsection" id="subsubsec_Monitors">Specify Monitors and Output Filenames</h4>
<hr class="subsubsection" />

<p>The next important step for our Rev script file is to specify the monitors and output file names.
The first monitor we will create will monitor every named random variable in our model graph. 
This will include every stochastic and deterministic node using the <code class="highlighter-rouge">mnModel</code> monitor.
In this case, it will only be our rate variable $\mu$.
It is still useful to specify the model monitor this way for later extensions of the model.
We will also name the output file for this monitor and indicate that we wish to sample our MCMC every 10 cycles.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/mk.log", printgen=10) )
</code></pre></div></div>

<p>The second monitor we will add to our analysis will print information to the screen.
Like with <code class="highlighter-rouge">mnFile</code> we must tell <code class="highlighter-rouge">mnScreen</code> which parameters we’d like to see updated on the screen.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(printgen=100) )
</code></pre></div></div>

<p>The third and final monitor might be new to you: the <code class="highlighter-rouge">mnJointConditionalAncestralState</code> monitor computes and writes the ancestral states to file.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnJointConditionalAncestralState(tree=phylogeny,
                                                   ctmc=phyMorpho,
                                                   filename="output/mk.states.txt",
                                                   type="Standard",
                                                   printgen=1,
                                                   withTips=true,
                                                   withStartStates=false) )
</code></pre></div></div>

<p>The core arguments this monitor needs are a tree object (<code class="highlighter-rouge">tree=phylogeny</code>), 
the phylogenetic model (<code class="highlighter-rouge">ctmc=phyMorpho</code>), an output filename (<code class="highlighter-rouge">filename="output/mk.states.txt"</code>),
the data type for the characters (<code class="highlighter-rouge">type="Standard"</code>), and the sampling frequency (<code class="highlighter-rouge">printgen=10}</code>.
The final argument, <code class="highlighter-rouge">withTips=true</code>, indicates that we do wish to record the tip states because we didn’t know all tip values and might be interested in the most plausible values.</p>

<p>The monitor will produce a joint sample of ancestral states, where every ancestral state is conditional on the drawn value of its parent node state (except for the root node), 
storing the samples every 10 iterations to the file <code class="highlighter-rouge">"output/mk.states.txt"</code>.
Viewing the states file, we see</p>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Iteration	end_1	end_2	end_3	end_4	end_5	...
0	2	3	3	3	3	...
1	2	3	3	3	3	...
2	2	3	3	3	3	...
3	2	3	3	3	3	...
4	2	3	3	3	3	...
5	2	3	3	3	3	...
6	2	3	3	3	3	...
7	2	3	3	3	3	...
8	2	3	3	3	3	...
9	2	3	3	3	3	...
10	2	3	3	3	3	...
...
</code></pre></div></div>

<h4 class="subsubsection" id="set-up-the-mcmc">Set-Up the MCMC</h4>
<hr class="subsubsection" />

<p>Once we have set up our model, moves, and monitors, we can now create the workspace variable that defines our MCMC run. 
We do this using the <code class="highlighter-rouge">mcmc()</code> function that simply takes the three main analysis components as arguments.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves, nruns=2, combine="mixed")
</code></pre></div></div>

<p>The MCMC object that we named <code class="highlighter-rouge">mymcmc</code> has a member method called <code class="highlighter-rouge">.run()</code>. 
This will execute our analysis and we will set the chain length to <code class="highlighter-rouge">10000</code> cycles using the <code class="highlighter-rouge">generations</code> option.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=10000, tuningInterval=200)
</code></pre></div></div>

<p>Once our Markov chain has terminated, we will process the ancestral state samples.
This function will compute the posterior probabilities of the ancestral states from the samples.
Later we can visuallize our ancestral states.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>anc_states = readAncestralStateTrace("output/mk.states.txt")
anc_tree = ancestralStateTree(tree=phylogeny, ancestral_state_trace_vector=anc_states, include_start_states=false, file="output/ase_mk.tree", burnin=0.25, summary_statistic="MAP", site=1)
writeNexus( anc_tree, filename="output/ase_mk.tree" )
</code></pre></div></div>

<p>Finally we can close RevBayes. 
Tell the program to quit using the <code class="highlighter-rouge">q()</code> function.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q()
</code></pre></div></div>

<blockquote class="instruction">
  <p>You made it! Save your file.</p>
</blockquote>

<h3 class="subsection" id="subsec_run_MCMC">Execute the MCMC Analysis</h3>
<hr class="subsection" />

<p>With all the parameters specified and all analysis components in place, you are now ready to run your analysis. 
The Rev script you just created will be used by RevBayes and loaded in the appropriate order.</p>

<blockquote class="instruction">
  <p>Begin by running the RevBayes executable.</p>
</blockquote>

<p>Provided that you started RevBayes from the correct directory (<code class="highlighter-rouge">RB_DiscreteMorphology_RateASE_Tutorial</code>), 
you can then use the <code class="highlighter-rouge">source()</code> function to feed RevBayes your master script file (<code class="highlighter-rouge">mcmc_ase_mk.Rev</code>).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mcmc_ase_mk.Rev")
</code></pre></div></div>
<p>This will execute the analysis and you should see the following output (though not the exact same values):</p>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Processing file "scripts/mcmc_ase_mk.Rev"
   Successfully read one character matrix from file 'data/mammals_thinned_placenta_type.nex'
   Attempting to read the contents of file "mammals_thinned.tree"
   Successfully read file

   Running MCMC simulation
   This simulation runs 2 independent replicates.
   The simulator uses 1 different moves in a random move schedule with 2 moves per iteration

Iter        |      Posterior   |     Likelihood   |          Prior   |    elapsed   |        ETA   |
----------------------------------------------------------------------------------------------------
0           |       -359.492   |       -359.194   |      -0.298007   |   00:00:00   |   --:--:--   |
100         |       -62.0258   |       -62.0245   |     -0.0013356   |   00:00:03   |   --:--:--   |
200         |       -62.3349   |       -62.3336   |    -0.00123787   |   00:00:05   |   00:02:00   |
300         |        -62.005   |       -62.0024   |    -0.00256593   |   00:00:07   |   00:01:49   |
400         |       -61.3682   |       -61.3664   |    -0.00177658   |   00:00:09   |   00:01:43   |
500         |        -61.683   |       -61.6807   |    -0.00235834   |   00:00:12   |   00:01:48   |

...
</code></pre></div></div>

<p>When the analysis is complete, RevBayes will quit and you will have a new directory called <code class="highlighter-rouge">output</code> that will contain all of the files you specified with the monitors (Section <a href="#subsubsec_Monitors"></a>).</p>

<h2 class="section" id="plotting-the-tree-with-ancestral-states">Plotting the tree with ancestral states</h2>
<hr class="section" />

<p>We will now switch to <code class="highlighter-rouge">R</code> using the package <code class="highlighter-rouge">RevGadgets</code>.
Make sure that you have the package installed, using</p>

<pre><code class="language-{R}">library(devtools)
install_github("GuangchuangYu/ggtree")
install_github("revbayes/RevGadgets")
</code></pre>
<p>Now that we have our posterior distribution of ancestral states, we want to visualize those results.
This section will aim to produce a pdf containing figures for the ancestral state estimates.</p>

<p>We have written a little R package called \RevGadgets that can be used to visualize the output of \RevBayes.</p>

<blockquote class="instruction">
  <p>Start R from the same working directory as you started RevBayes.
This should be the directory where you now have you directory called <code class="highlighter-rouge">output</code> with the MCMC output files.</p>
</blockquote>

<p>First, we need to load the R package RevGadgets</p>
<pre><code class="language-{R}">library(RevGadgets)
</code></pre>

<p>Second, we specify the name of the tree file.</p>
<pre><code class="language-{R}">tree_file = "output/ase_mk.tree"
</code></pre>

<p>Then, you plot the tree with ancestral states nicely mapped onto it.
You may want to experiment with some of the settings to make the plot look prettier.
For example, if you set <code class="highlighter-rouge">show_posterior_legend=TRUE</code> and <code class="highlighter-rouge">node_size_range=c(1, 3)</code>, 
then the size of the circles will represent the posterior probability.</p>
<pre><code class="language-{R}">g &lt;- plot_ancestral_states(tree_file, summary_statistic="MAP",
                      tip_label_size=1,
                      xlim_visible=NULL,
                      node_label_size=0,
                      show_posterior_legend=FALSE,
                      node_size_range=c(2.5, 2.5),
                      alpha=0.75)
</code></pre>

<p>Finally, we save the output into a PDF.</p>
<pre><code class="language-{R}">ggsave("Mammals_ASE_MK.pdf", g, width = 11, height = 9)
</code></pre>

<blockquote class="instruction">
  <p>You can also find all these commands in the file called <strong>plot_anc_states.R</strong> which you can run as a script in R.</p>
</blockquote>

<p><a href="#fig_mk_anc_states"></a> shows the result of this analysis.</p>

<figure id="fig_mk_anc_states"><p><img src="figures/Mammals_ASE_MK.png" /></p>
<figcaption>Ancestral state estimation of the placenta type.</figcaption>
</figure>

<h2 class="section" id="sec_ase_unequal">Example: Unequal Transition Rates</h2>
<hr class="section" />

<blockquote class="instruction">
  <p>Make a copy of the MCMC and model files you just made. 
Call them <code class="highlighter-rouge">mcmc_ase_mk.Rev</code> and `model_ase_FreeK.Rev. 
These will contain the new model parameters and models.</p>
</blockquote>

<p>The Mk model makes a number of assumptions, but one that may strike you as unrealistic 
is the assumption that characters are equally likely to change from any one state to any other state.
That means that a trait is as likely to be gained as lost.
While this may hold true for some traits, we expect that it may be untrue for many others.</p>

<p>RevBayes has functionality to allow us to relax this assumption.</p>

<h3 class="subsection" id="modifying-the-mcmc-section">Modifying the MCMC Section</h3>
<hr class="subsection" />

<p>At each place in which the output files are specified in the MCMC file, change the output path so you don’t overwrite the output from the previous exercise. 
For example, you might call your output file <code class="highlighter-rouge">output/ase_freeK.log</code>.
Change source statement to indicate the new model file.</p>

<h3 class="subsection" id="modifying-the-model-section">Modifying the Model Section</h3>
<hr class="subsection" />

<p>Our goal here is to create a rate matrix with 6 free parameters.
We will assume an exponential prior distribution for each of the rates.
Thus, we start be specifying the rate of this exponential prior distribution.
A good guess might be that 10 events happened along the tree, so the rate should be the tree-length divided by 10.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_pr := phylogeny.treeLength() / 10
</code></pre></div></div>

<p>Now we can create our six independent rate variables drawn from an identical exponential distribution</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_12 ~ dnExponential(rate_pr)
rate_13 ~ dnExponential(rate_pr)
rate_21 ~ dnExponential(rate_pr)
rate_23 ~ dnExponential(rate_pr)
rate_31 ~ dnExponential(rate_pr)
rate_32 ~ dnExponential(rate_pr)
</code></pre></div></div>
<p>As usual, we will apply a scaling move to each of the rate variables.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale( rate_12, weight=2 ) )
moves.append( mvScale( rate_13, weight=2 ) )
moves.append( mvScale( rate_21, weight=2 ) )
moves.append( mvScale( rate_23, weight=2 ) )
moves.append( mvScale( rate_31, weight=2 ) )
moves.append( mvScale( rate_32, weight=2 ) )
</code></pre></div></div>
<p>Next, we put all the rates together into our rate matrix.
Don’t forget to say that we do not rescale the rate matrix (<code class="highlighter-rouge">rescale=false</code>).
We would only rescale if we use relative rates.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_morpho := fnFreeK( [ rate_12, rate_13, rate_21, rate_23, rate_31, rate_32 ], rescale=false )
</code></pre></div></div>

<p>In this model, we also decide to specify an additional parameter for the root state frequencies instead of assuming the root state to be drawn from the stationary distribution. 
We will use a Dirichlet prior distribution for the root state frequencies.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rf_prior &lt;- [1,1,1]
rf ~ dnDirichlet( rf_prior )
moves.append( mvBetaSimplex( rf, weight=2 ) )
moves.append( mvDirichletSimplex( rf, weight=2 ) )
</code></pre></div></div>

<p>We need to modify the <code class="highlighter-rouge">dnPhyloCTMC</code> to pass in our new root frequencies parameter.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phyMorpho ~ dnPhyloCTMC(tree=phylogeny, Q=Q_morpho, rootFrequencies=rf, type="Standard")
</code></pre></div></div>

<blockquote class="instruction">
  <p>Now you are done with your unequal rates model. Give it a run!</p>
</blockquote>

<h2 class="section" id="sec_ase_ir_rj">Reversible-jump MCMC to test for irreversibility</h2>
<hr class="section" />

<p>In the previous section we assumed that there are 6 different rates, which are all $&gt;0$.
Now, we will apply a reversible-jump MCMC (missing reference) to test if any of the rates is significantly larger than $0$.</p>

<blockquote class="instruction">
  <p>Make a copy of the Rev script file you just made. 
Call them `mcmc_ase_freeK_RJ.Rev. 
This will contain the new model parameters and models.</p>
</blockquote>

<h3 class="subsection" id="modifying-the-mcmc-section">Modifying the MCMC Section</h3>
<hr class="subsection" />

<p>At each place in which the output files are specified in the MCMC section, change the output path so you don’t overwrite the output from the previous exercise. 
For example, you might call your output file <code class="highlighter-rouge">output/freeK_ASE.log</code>.</p>

<h3 class="subsection" id="modifying-the-model-section">Modifying the Model Section</h3>
<hr class="subsection" />

<p>The only part in the model section that we are going to modify is the prior distributions and moves on the rate parameters.
We will assume the same rate for the exponential prior distribution as before.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_pr := phylogeny.treeLength() / 10
</code></pre></div></div>
<p>Next, we specify that we have a 0.5 probability, <em>a priori</em>, that a rate is equal to 0.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix_pr &lt;- 0.5
</code></pre></div></div>

<p>Now we can create our reversible-jump distributions, which take in a constant value, 0.0 in this case, and a distribution.
Thus, the value is either drawn to be exactly equal to the constant value (0.0 here), or drawn from the base distribution (the exponential distribution in this case).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_12 ~ dnRJMixture(0.0, dnExponential(rate_pr), p=mix_pr)
rate_13 ~ dnRJMixture(0.0, dnExponential(rate_pr), p=mix_pr)
rate_21 ~ dnRJMixture(0.0, dnExponential(rate_pr), p=mix_pr)
rate_23 ~ dnRJMixture(0.0, dnExponential(rate_pr), p=mix_pr)
rate_31 ~ dnRJMixture(0.0, dnExponential(rate_pr), p=mix_pr)
rate_32 ~ dnRJMixture(0.0, dnExponential(rate_pr), p=mix_pr)
</code></pre></div></div>

<p>Since we are interested in the probability that a rate is equal to 0.0, we want to compute this posterior probability directly.
Therefore, we will use the <code class="highlighter-rouge">ifelse</code> function, which will return 1.0 if the rate is equal to 0.0, and 0.0 otherwise (if the rate is unequal to 0.0).
Hence, the frequency with which we sample a 1.0 gives us the posterior probability that a given rate is equal to 0.0.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prob_rate_12 := ifelse( rate_12 == 0, 1.0, 0.0 )
prob_rate_13 := ifelse( rate_13 == 0, 1.0, 0.0 )
prob_rate_21 := ifelse( rate_21 == 0, 1.0, 0.0 )
prob_rate_23 := ifelse( rate_23 == 0, 1.0, 0.0 )
prob_rate_31 := ifelse( rate_31 == 0, 1.0, 0.0 )
prob_rate_32 := ifelse( rate_32 == 0, 1.0, 0.0 )
</code></pre></div></div>

<p>We also need to specify specific moves that ``jump’’ in parameter dimension.
We will use the <code class="highlighter-rouge">mvRJSwitch</code> move that changes the value to be either equal to the constant value 
provided from the <code class="highlighter-rouge">dnRJMixture</code> or a value drawn from the base distribution (the exponential distribution).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvRJSwitch( rate_12, weight=2 ) )
moves.append( mvRJSwitch( rate_13, weight=2 ) )
moves.append( mvRJSwitch( rate_21, weight=2 ) )
moves.append( mvRJSwitch( rate_23, weight=2 ) )
moves.append( mvRJSwitch( rate_31, weight=2 ) )
moves.append( mvRJSwitch( rate_32, weight=2 ) )
</code></pre></div></div>

<p>Additionally, we also need to specify moves that change the rates if they are not equal to 0.0.
As usual, we use the standard scaling moves.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale( rate_12, weight=2 ) )
moves.append( mvScale( rate_13, weight=2 ) )
moves.append( mvScale( rate_21, weight=2 ) )
moves.append( mvScale( rate_23, weight=2 ) )
moves.append( mvScale( rate_31, weight=2 ) )
moves.append( mvScale( rate_32, weight=2 ) )
</code></pre></div></div>

<blockquote class="instruction">
  <p>This is all that you need to do for this ``fancy’’ reversible-jump model. Give it a try!</p>
</blockquote>

<h2 class="section" id="sec_ase_results">Evaluate and Summarize Your Results</h2>
<hr class="section" />

<h3 class="subsection" id="subsec_ase_plots">Visualizing Ancestral State Estimates</h3>
<hr class="subsection" />

<p>We have previously seen in <a href="#fig_mk_anc_states"></a> how the ancestral states of the simple model look.
You should repeat plotting the ancestral states now also for the <code class="highlighter-rouge">freeK</code> and <code class="highlighter-rouge">freeK_RJ</code> analyses.
My output is shown in <a href="#fig_mk_anc_states_freeK"></a></p>

<figure id="fig_mk_anc_states_freeK"><p><img src="figures/Mammals_ASE_FreeK.png" /></p>
<figcaption>Ancestral state estimates of placenta type under the <code class="highlighter-rouge">freeK</code> model.</figcaption>
</figure>

<p>You should observe that the estimated root states have changed!</p>


<ol class="bibliography"><li><span id="Beaulieu2013">Beaulieu J.M., O’Meara B.C., Donoghue M.J. 2013. Identifying hidden rate changes in the evolution of a binary morphological character: the evolution of plant habit in campanulid angiosperms. Systematic Biology. 62:725–737.</span>

<a href="https://doi.org/10.1093/sysbio/syt034">10.1093/sysbio/syt034</a>

</li>
<li><span id="Goldberg2008">Goldberg E.E., Igić B. 2008. On Phylogenetic Tests of Irreversible Evolution. Evolution. 62:2727–2741.</span>

<a href="https://doi.org/10.1111/j.1558-5646.2008.00505.x">10.1111/j.1558-5646.2008.00505.x</a>

</li>
<li><span id="Hoehna2016b">Höhna S., Landis M.J., Heath T.A., Boussau B., Lartillot N., Moore B.R., Huelsenbeck J.P., Ronquist F. 2016. RevBayes: Bayesian Phylogenetic Inference Using Graphical Models and an Interactive Model-Specification Language. Systematic Biology. 65:726–736.</span>

<a href="https://doi.org/10.1093/sysbio/syw021">10.1093/sysbio/syw021</a>

</li>
<li><span id="Jukes1969">Jukes T.H., Cantor C.R. 1969. Evolution of Protein Molecules. Mammalian Protein Metabolism. 3:21–132.</span>

<a href="https://doi.org/10.1016/B978-1-4832-3211-9.50009-7">10.1016/B978-1-4832-3211-9.50009-7</a>

</li>
<li><span id="Lewis2001">Lewis P.O. 2001. A Likelihood Approach to Estimating Phylogeny from Discrete Morphological Character Data. Systematic Biology. 50:913–925.</span>

<a href="https://doi.org/10.1080/106351501753462876">10.1080/106351501753462876</a>

</li>
<li><span id="Pagel1994">Pagel M. 1994. Detecting correlated evolution on phylogenies: a general method for the comparative analysis of discrete characters. Proceedings of the Royal Society of London B: Biological Sciences. 255:37–45.</span>

<a href="https://doi.org/10.1098/rspb.1994.0006">10.1098/rspb.1994.0006</a>

</li>
<li><span id="Tuffley1998">Tuffley C., Steel M. 1998. Modeling the covarion hypothesis of nucleotide substitution. Mathematical Biosciences. 147:63–91.</span>

<a href="https://doi.org/10.1016/S0025-5564(97)00081-3">10.1016/S0025-5564(97)00081-3</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>

<script src="/assets/js/base.js"></script>

<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

  </body>
</html>
