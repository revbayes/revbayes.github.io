<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Simple Diversification Models & Estimating Time Trees</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container">
          <div class="titlebar">
	<h1 class="maintitle">Simple Diversification Models & Estimating Time Trees</h1>
	<h3 class="subtitle">Comparing diversification models using Bayes factors and estimating a dated phylogeny</h3>
	<h4 class="authors">Tracy A. Heath</h4>
  <h5>Last modified on February  9, 2021</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/clocks/data/bears_dosReis.tre">bears_dosReis.tre</a></li>
        
          <li><a href="/tutorials/clocks/data/bears_irbp.nex">bears_irbp.nex</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/clocks/scripts/compute_BF.Rev">compute_BF.Rev</a></li>
        
          <li><a href="/tutorials/clocks/scripts/full_analysis.Rev">full_analysis.Rev</a></li>
        
          <li><a href="/tutorials/clocks/scripts/m_BDP_bears.Rev">m_BDP_bears.Rev</a></li>
        
          <li><a href="/tutorials/clocks/scripts/m_GMC_bears.Rev">m_GMC_bears.Rev</a></li>
        
          <li><a href="/tutorials/clocks/scripts/m_GTR.Rev">m_GTR.Rev</a></li>
        
          <li><a href="/tutorials/clocks/scripts/m_UCLN_bears.Rev">m_UCLN_bears.Rev</a></li>
        
          <li><a href="/tutorials/clocks/scripts/mcmc_TimeTree_bears.Rev">mcmc_TimeTree_bears.Rev</a></li>
        
          <li><a href="/tutorials/clocks/scripts/mlnl_GMC_bears.Rev">mlnl_GMC_bears.Rev</a></li>
        
          <li><a href="/tutorials/clocks/scripts/mlnl_UCLN_bears.Rev">mlnl_UCLN_bears.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<!-- This tutorial was used for Tracy Heath's Macroevolution 2018 Course -->

<h2 class="section" id="introduction">Introduction</h2>
<hr class="section" />

<p>This tutorial describes how to perform a simple analysis that compares three different birth-death models using Bayes factors. 
The selected model will be used as a tree prior to estimate a new dated phylogeny of all living bears.</p>

<p>For details about the format of this tutorial, please see the <a href="../format">Tutorial Format Guide</a>.</p>

<h2 class="section" id="thedata">Getting Set Up</h2>
<hr class="section" />

<h3 id="software">Software</h3>

<p>This tutorial requires that you <a href="../../software">download and install</a> the current version of RevBayes. 
Additionally, you will need to download and install the program <a href="http://tree.bio.ed.ac.uk/software/tracer/">Tracer</a> <a class="citation" href="#Rambaut2011">(Rambaut and Drummond 2011)</a>.</p>

<h3 id="the-data">The Data</h3>

<p>The various exercises in this tutorial take you through the steps
required to perform phylogenetic analyses of the example dataset.
For this, you will need to download the data files.</p>

<p>To keep things organized, it is recommended that you create a new directory for this tutorial, and then place all of the data files in a subdirectory.</p>

<blockquote class="instruction">
  <p>Create a new directory on your computer called <code class="language-plaintext highlighter-rouge">RB_div_clock_tutorial</code>.</p>

  <p>Within the <code class="language-plaintext highlighter-rouge">RB_div_clock_tutorial</code> directory, create a subdirectory called <code class="language-plaintext highlighter-rouge">data</code>. 
Then, dowload the <a href="https://revbayes.github.io/revbayes-site/tutorials/clocks/data/bears_dosReis.tre"><code class="language-plaintext highlighter-rouge">bears_dosReis.tre</code></a> and <a href="https://revbayes.github.io/revbayes-site/tutorials/clocks/data/bears_irbp.nex"><code class="language-plaintext highlighter-rouge">bears_irbp.nex</code></a> and place them in the <code class="language-plaintext highlighter-rouge">data</code> folder.</p>
</blockquote>

<!-- need to fix the data file links -->

<p>Now you can execute RevBayes.</p>

<blockquote class="instruction">
  <p>Navigate to the <code class="language-plaintext highlighter-rouge">RB_div_clock_tutorial</code> directory and execute the <code class="language-plaintext highlighter-rouge">rb</code> binary. 
One option for doing this is to move the <code class="language-plaintext highlighter-rouge">rb</code> executable to the <code class="language-plaintext highlighter-rouge">RB_div_clock_tutorial</code>
directory.</p>

  <p>Alternatively, if you are on a Unix system, and have added RevBayes to your path, 
you simply have to type <code class="language-plaintext highlighter-rouge">rb</code> in your Terminal to run the program.</p>
</blockquote>

<p>Once you execute RevBayes, you will be in the console. The rest of this tutorial will proceed 
using the interactive console.</p>

<h2 class="section" id="secdiv">Comparing Two Diversification Models using Bayes Factors</h2>
<hr class="section" />

<p>In this first section, we will evaluate two different diversification models: (1) the Yule process and (2) the birth-death process.
To compare the relative fit of the two models, we can use <a href="https://en.wikipedia.org/wiki/Bayes_factor"><em>Bayes factors</em></a> <a class="citation" href="#Suchard2001">(Suchard et al. 2001; Lartillot 2006; Xie et al. 2011; Baele et al. 2012; Baele et al. 2013)</a>.
In Bayesian inference, the Bayes factor is used as a method for model comparison,
allowing us to evaluate the relative support for different models given a single dataset.</p>

<p>Given two models, $M_0$ and $M_1$, the Bayes-factor comparison assessing
the relative fit of each model to the data, $BF(M_0,M_1)$, is:</p>

\[BF(M_0,M_1) = \frac{\mbox{posterior odds}}{\mbox{prior odds}}.\]

<p>The
posterior odds is the posterior probability of $M_0$ given the data,
$\mathbf X$, divided by the posterior odds of $M_1$ given the data:</p>

\[\mbox{posterior odds} = \frac{\mathbb{P}(M_0 \mid \mathbf X)}{\mathbb{P}(M_1 \mid \mathbf X)},\]

<p>and the prior odds is the prior probability of $M_0$ divided by the
prior probability of $M_1$:
\(\mbox{prior odds} = \frac{\mathbb{P}(M_0)}{\mathbb{P}(M_1)}.\) Thus,
the Bayes factor measures the degree to which the data alter our belief
regarding the support for $M_0$ relative to $M_1$ <a class="citation" href="#Lavine1999">(Lavine and Schervish 1999)</a>:</p>

\[\begin{equation}
BF(M_0,M_1) = \frac{\mathbb{P}(M_0 \mid \mathbf X, \theta_0)}{\mathbb{P}(M_1 \mid \mathbf X, \theta_1)} \div \frac{\mathbb{P}(M_0)}{\mathbb{P}(M_1)} \tag{1}\label{eq:one}
\end{equation}\]

<p>Note that interpreting Bayes factors involves some subjectivity. That
is, it is up to <em>you</em> to decide the degree of your belief in $M_0$
relative to $M_1$. Despite the absence of an absolutely objective
model-selection threshold, we can refer to the scale, outlined by
<a class="citation" href="#Jeffreys1961">Jeffreys (1961)</a>,  that provides a “<a href="https://en.wikipedia.org/wiki/Bayes_factor#Interpretation">rule-of-thumb</a>” for interpreting these
measures.</p>

<p>Unfortunately, it is generally not possible to directly calculate the
posterior odds to prior odds ratios. However, we can further define the
posterior odds ratio as:</p>

\[\begin{aligned}
\frac{\mathbb{P}(M_0 \mid \mathbf X)}{\mathbb{P}(M_1 \mid \mathbf X)} = \frac{\mathbb{P}(M_0)}{\mathbb{P}(M_1)} \frac{\mathbb{P}(\mathbf X \mid M_0)}{\mathbb{P}(\mathbf X \mid M_1)},
\end{aligned}\]

<p>where $\mathbb{P}(\mathbf X \mid M_i)$ is the <em>marginal likelihood</em> of
the data (this may be familiar to you as the denominator of Bayes
Theorem, which is variously referred to as the <em>model evidence</em> or
<em>integrated likelihood</em>). Formally, the marginal likelihood is the
probability of the observed data ($\mathbf X$) under a given model
($M_i$) that is averaged over all possible values of the parameters of
the model ($\theta_i$) with respect to the prior density on $\theta_i$</p>

\[\begin{aligned}
\mathbb{P}(\mathbf X \mid M_i) = \int \mathbb{P}(\mathbf X \mid \theta_i) \mathbb{P}(\theta_i)dt.
\end{aligned}\]

<p>This makes it clear that more complex (parameter-rich) models are
penalized by virtue of the associated prior: each additional parameter
entails integration of the likelihood over the corresponding prior
density. If you refer back to equation \eqref{eq:one}, you can see that, with
very little algebra, the ratio of marginal likelihoods is equal to the
Bayes factor:</p>

\[\begin{aligned}
BF(M_0,M_1) = \frac{\mathbb{P}(\mathbf X \mid M_0)}{\mathbb{P}(\mathbf X \mid M_1)} = \frac{\mathbb{P}(M_0 \mid \mathbf X, \theta_0)}{\mathbb{P}(M_1 \mid \mathbf X, \theta_1)} \div \frac{\mathbb{P}(M_0)}{\mathbb{P}(M_1)}. 
\end{aligned}\]

<p>Therefore, we can perform a Bayes factor comparison of two models by
calculating the marginal likelihood for each one. Alas, exact solutions
for calculating marginal likelihoods are not known for phylogenetic
models, thus we must resort to numerical
integration methods to estimate or approximate these values.</p>

<p>In this
exercise, we will estimate the marginal likelihood for each partition
scheme using both the stepping-stone <a class="citation" href="#Xie2011">(Xie et al. 2011; Fan et al. 2011)</a> estimator.
These algorithms are
similar to the familiar MCMC algorithms, which are intended to sample
from (and estimate) the joint posterior probability of the model
parameters. Stepping-stone algorithms are like a series of MCMC
simulations that iteratively sample from a specified number of
distributions that are discrete steps between the posterior and the
prior probability distributions. The basic idea is to estimate the
probability of the data for all points between the posterior and the
prior—effectively summing the probability of the data over the prior
probability of the parameters to estimate the marginal likelihood.
Technically, the steps correspond to a series of power posteriors,
where the likelihood is iteratively raised to a series of numbers
between 1 and 0. When the likelihood is raised to
the power of 1 (typically the first stepping stone), samples are drawn
from the (untransformed) posterior. By contrast, when the likelihood is
raised to the power of 0 (typically the last stepping stone), samples
are drawn from the prior. To perform a stepping-stone simulation, we
need to specify (1) the number of stepping stones (power posteriors)
that we will use to traverse the path between the posterior and the
prior (<em>e.g.,</em> we specify 50 or 100 stones),
(2) the spacing of the stones between the posterior and prior
(<em>e.g.,</em> we may specify that the stones are
distributed according to a beta distribution), (3) the number of samples
(and their thinning) to be drawn from each stepping stone, and (4) the
direction we will take (<em>i.e.,</em> from the
posterior to the prior or vice versa).</p>

<!-- TODO: ^Move this to a reference to the BF tutorial -->

<p>This analysis will assume that the phylogeny of the 8 extant bear species and their speciation times estimated in the study by <a class="citation" href="#DosReis2012">dos Reis et al. (2012)</a> are observed data. 
Of course, it is not possible to observe a diversification process spanning over 30 My, but it is not unreasonable to use a well-supported phylogeny to compare models before analysis of a new dataset.</p>

<h3 class="subsection" id="yulesec">The Yule Model</h3>
<hr class="subsection" />

<p><a class="citation" href="#Yule1925">Yule (1925)</a> described a stochastic process as a generating model for living taxa. 
This model makes the very simple assumption that over the course of diversification, 
there is a constant rate of speciation and the rate of extinction is 0.0.</p>

<h4 id="read-in-the-tree-and-get-some-helper-variables">Read in the tree and get some helper variables</h4>

<p>To start our evaluation of the Yule model, we must first read in the published phylogeny and
the branch lengths (in units of millions of years). 
For this, we will create the variable <code class="language-plaintext highlighter-rouge">T</code> to represent the published tree and use the function <code class="language-plaintext highlighter-rouge">readTrees()</code> to get the tree from the file in the <code class="language-plaintext highlighter-rouge">data</code> folder.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T &lt;- readTrees("data/bears_dosReis.tre")[1]
</code></pre></div></div>

<p>Because the <code class="language-plaintext highlighter-rouge">readTrees()</code> function can read a file with a single tree or many trees, it always returns a vector of trees. Thus, we use the index notation <code class="language-plaintext highlighter-rouge">[1]</code> to indicate that we 
only want the first tree.</p>

<!-- Now we will create a helper variable that simply stores the list of taxon names. 
This list will 

    taxa <- T.taxa()
 -->

<p>Next we need a helper variable to keep track of the index in our list of moves:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvi = 1
</code></pre></div></div>

<h4 id="the-speciation-rate">The speciation rate</h4>

<p>Now we can start constructing our model.
For the Yule process, we do not need very many parameters. The most important one 
is the <em>speciation rate</em>. We will assume that the mean speciation rate is 1.0 and our prior on 
this parameter is an <a href="https://en.wikipedia.org/wiki/Exponential_distribution">exponential distribution</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sp_mean &lt;- 1.0
speciation ~ dnExp(1.0 / sp_mean)
</code></pre></div></div>

<p>The parameter <code class="language-plaintext highlighter-rouge">speciation</code> is a stochastic node. When it is created, RevBayes 
initializes it with a value drawn from the prior. If we wish to estimate its value, 
we must now apply a <em>move</em> that will propose changes to <code class="language-plaintext highlighter-rouge">speciation</code> over the course of our
analysis.</p>

<p>For <code class="language-plaintext highlighter-rouge">speciation</code> we will use the scale move, which is called <code class="language-plaintext highlighter-rouge">mvScale()</code> in RevBayes. 
This move proposes changes to a continuous valued parameter using a multiplier. 
The degree of change from that multiplier is determined by the value of the tuning parameter 
<code class="language-plaintext highlighter-rouge">lambda</code> in the move arguments. If we set the option <code class="language-plaintext highlighter-rouge">tune=true</code>, then the tuning parameter will be optimized for our analysis during the initial burn-in phase of our MCMC.</p>

<p>The move functions also require us to decide how often changes are proposed to this parameter.
This is done by setting the <code class="language-plaintext highlighter-rouge">weight</code> of the move.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvScale(speciation, lambda=1.0, tune=true, weight=3.0)
</code></pre></div></div>

<p>All of our moves are contained in a single vector we are calling <code class="language-plaintext highlighter-rouge">moves</code>. 
In the <code class="language-plaintext highlighter-rouge">Rev</code> code above, we put our first move in the first position of the vector. 
The <code class="language-plaintext highlighter-rouge">++</code> notation indicates that we are incrementing the index variable <code class="language-plaintext highlighter-rouge">mvi</code> by <code class="language-plaintext highlighter-rouge">1</code>. 
By using <code class="language-plaintext highlighter-rouge">mvi++</code> we are using post-incrementation. This means that the variable is increased 
<em>after</em> it is used.</p>

<h4 id="the-probability-of-sampling-an-extant-species">The probability of sampling an extant species</h4>

<p>The other important parameter of the Yule model is the probability of sampling a species 
in the present. In this exercise, we have every living species of bear represented in 
our dataset. Thus, it is reasonable to say that the sampling probability is approximately <code class="language-plaintext highlighter-rouge">1</code>.
We will create a <em>constant</em> node called <code class="language-plaintext highlighter-rouge">sampling</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sampling &lt;- 1.0
</code></pre></div></div>

<h4 id="conditioning-on-the-root-age">Conditioning on the root age</h4>

<p>In this analysis, we will condition the process on the root age. This, we can obtain from 
the tree we imported earlier. The tree object has a method called <code class="language-plaintext highlighter-rouge">.rootAge()</code> which returns
the depth of the tree. We will create a <em>constant</em> node for this value called <code class="language-plaintext highlighter-rouge">root_time</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root_time &lt;- T.rootAge()
</code></pre></div></div>

<h4 id="putting-it-all-together-in-the-birth-death-process-distribution">Putting it all together in the birth-death process distribution</h4>

<p>We now have all of the components of our model. As you can see, we have only applied a move 
to the parameter <code class="language-plaintext highlighter-rouge">speciation</code>. The next step is to create the stochastic node representing 
the phylogeny and branching times. We assume that this time-tree is generated from a Yule 
process, which is the same as a birth-death process with extinction set to <code class="language-plaintext highlighter-rouge">0.0</code>.</p>

<p>In RevBayes, the constant-rate birth-death process is invoked using the syntax <code class="language-plaintext highlighter-rouge">dnBDP()</code>. 
This distribution has the following arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lambda</code>: the speciation rate</li>
  <li><code class="language-plaintext highlighter-rouge">mu</code>: the extinction rate</li>
  <li><code class="language-plaintext highlighter-rouge">rho</code>: the probability of sampling an extant taxon</li>
  <li><code class="language-plaintext highlighter-rouge">rootAge</code>: the age of the most-recent-common ancestor of all taxa in the tree</li>
  <li><code class="language-plaintext highlighter-rouge">samplingStrategy</code>: if sampling of taxa has been <code class="language-plaintext highlighter-rouge">uniform</code> (<em>i.e.</em>, random) or <code class="language-plaintext highlighter-rouge">diversified</code>
(<em>i.e.</em>, one species selected per taxonomic group)</li>
  <li><code class="language-plaintext highlighter-rouge">condition</code>: if the process is conditioned on (1) there being <code class="language-plaintext highlighter-rouge">nTaxa</code> at the time of 
sampling, (2) the <code class="language-plaintext highlighter-rouge">survival</code> of the clade, or (3) the process proceeding for a given amount of <code class="language-plaintext highlighter-rouge">time</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">taxa</code>: the list of species names that are in the tree (this is extracted from the input tree
using <code class="language-plaintext highlighter-rouge">T.taxa()</code>)</li>
</ul>

<p>Now that we have instantiated all of these values, we can create a stochastic node for the 
time tree (let’s call it <code class="language-plaintext highlighter-rouge">timetree</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timetree ~ dnBDP(lambda=speciation, mu=0.0, rho=sampling, rootAge=root_time, samplingStrategy="uniform", condition="nTaxa", taxa=T.taxa())
</code></pre></div></div>

<p>Like other stochastic nodes, RevBayes initializes the value of <code class="language-plaintext highlighter-rouge">timetree</code> by drawing a state from the prior. 
Since we are treating the tree from <a class="citation" href="#DosReis2012">dos Reis et al. (2012)</a> as an “observation”, we now 
have to fix the value of <code class="language-plaintext highlighter-rouge">timetree</code> to be the same as the published phylogeny. 
To do this, we use the member method <code class="language-plaintext highlighter-rouge">.clamp()</code> that is specific to stochastic nodes.
This is how we tell RevBayes that we have observed the value of a stochastic node and it
should be treated as data and fixed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timetree.clamp(T)
</code></pre></div></div>

<h4 id="the-workspace-model-object">The workspace model object</h4>

<p>Now that our model is complete, we can create a model object in our workspace using the 
<code class="language-plaintext highlighter-rouge">model()</code> function. 
This allows us to put a “wrapper” around all of the components of our model so that we can 
use it in analysis functions.
Because our model is a directed-acyclic graph, we only need to give the <code class="language-plaintext highlighter-rouge">model()</code> function 
one node and it will traverse the graph and find all of the linked parameters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(speciation)
</code></pre></div></div>

<p>One useful member method of the model object is the <code class="language-plaintext highlighter-rouge">graph()</code> method. This allows us to 
visualize our graphical model. Unfortunately, this is only a reasonable thing to do 
for relatively small models. This function write graph to a file in the 
<a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">dot</a> 
graph description language. This file can be opened using the program <a href="https://www.graphviz.org/">Graphviz</a>, or you can try pasting the contents of the file in a <a href="http://www.webgraphviz.com/">web version</a> that can 
display the graph.</p>

<p>We will call the graph <code class="language-plaintext highlighter-rouge">yule_graph.dot</code>. You can see the image generated by Graphviz in <a href="#yulegraphv"></a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel.graph("yule_graph.dot")
</code></pre></div></div>

<figure id="yulegraphv"><p><img src="figures/yule_gm.svg" width="400" /></p>
<figcaption>The probabilistic graphical model of the Yule diversification model for the bear phylogeny.
This image was generated by running the <code class="language-plaintext highlighter-rouge">.graph()</code> method fo the model object and opening the
resulting file in the program <a href="https://www.graphviz.org/">Graphviz</a>.</figcaption>
</figure>

<h4 id="setting-up-the-monitors">Setting up the monitors</h4>

<p>For analysis methods in RevBayes, we typically want to save states to a file. 
To do this we create a list of monitors that specify how our samples are saved.</p>

<p>To estimate the marginal likelihood using the stepping-stone approach, we will save the
states sampled for each step. All of the files written will be placed in a new directory
called <code class="language-plaintext highlighter-rouge">output</code> that RevBayes will create in the directory where we are running it (if it 
isn’t there already.)
We also make a screen monitor so that we can see the progress of our analysis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[1] = mnModel(filename="output/bears_yule.log",printgen=10, separator = TAB)
monitors[2] = mnScreen(printgen=1000, speciation)
</code></pre></div></div>

<h4 id="the-analysis-computing-the-marginal-likelihood-of-the-model">The analysis: Computing the marginal likelihood of the model</h4>

<p>Above in the <a href="#secdiv">introduction section</a> of this part of the tutorial, we explained
Bayes factors and the need to compute the marginal likelihoods. 
This approach uses the RevBayes function <code class="language-plaintext highlighter-rouge">powerPosterior()</code> to perform the series of MCMC simulations to estimate the marginal likelihood. 
The function takes the model, list of moves, and list of monitors. 
We must also specify an output file where the power posteriors are saved for each step and the number of steps taken. 
Here we will set the number of steps to <code class="language-plaintext highlighter-rouge">100</code>, using <code class="language-plaintext highlighter-rouge">cats=100</code>, this will result in 101 
power posteriors (or “stones”).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pow_p = powerPosterior(mymodel, moves, monitors, "output/yule_powp.out", cats=100, sampleFreq=10)
</code></pre></div></div>

<p>We can start the power-posterior analysis by first burning in the chain
and and discarding the first 10000 states. This will help ensure that
analysis starts from a region of high posterior probability, rather than
from some random point.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pow_p.burnin(generations=10000,tuningInterval=200)
</code></pre></div></div>

<p>Now we can execute the run.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pow_p.run(generations=10000)
</code></pre></div></div>

<p>Once the power posteriors have been saved to file, create a stepping
stone sampler. This function can read any file of power posteriors and
compute the marginal likelihood using stepping-stone sampling.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ss = steppingStoneSampler(file="output/yule_powp.out", powerColumnName="power", likelihoodColumnName="likelihood")
</code></pre></div></div>

<p>The workspace variable <code class="language-plaintext highlighter-rouge">ss</code> now holds the estimated marginal likelihood. We can view the value
and print it to our screen.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ss.marginal()
</code></pre></div></div>

<p><strong>Write down the value displayed. This is the marginal likelihood of the Yule model ($M_0$).</strong></p>

<h3 class="subsection" id="bdsec">The Birth-Death Model</h3>
<hr class="subsection" />

<p>The Yule model is a simple version of a more general stochastic branching process called the <em>birth-death process</em> <a class="citation" href="#Kendall1948">(Kendall 1948; Nee et al. 1994; Gernhard 2008)</a>.
Under the birth-death process, extinction is assumed to be greater than 0.</p>

<p>We will specify this model and also change the prior assumed for the speciation rate. 
Once we have completed our run of the stepping stone estimator, we can then compare the marginal likelihoods calculated for each.</p>

<p>Before we begin a new model, we should first clear our workspace. This ensures that we 
won’t have any variables left over from the previous section.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear()
</code></pre></div></div>

<h4 id="read-in-the-tree-and-get-some-helper-variables-1">Read in the tree and get some helper variables</h4>

<p>We will initialize the analysis just like we did above.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T &lt;- readTrees("data/bears_dosReis.tre")[1]
mvi = 1
</code></pre></div></div>

<h4 id="the-speciation-rate-1">The speciation rate</h4>

<p>For this model, let’s assume that the speciation rate has a smaller mean value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sp_mean &lt;- 0.2
speciation ~ dnExp(1.0 / sp_mean)
moves[mvi++] = mvScale(speciation, lambda=1.0, tune=true, weight=3.0)
</code></pre></div></div>

<h4 id="the-extinction-rate">The extinction rate</h4>

<p>Now we have to create a new stochastic node for the extinction rate. This we will assume 
has a mean of <code class="language-plaintext highlighter-rouge">0.01</code>. And like the <code class="language-plaintext highlighter-rouge">speciation</code> this variable is drawn from an exponential
distribution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ext_mean &lt;- 0.01
extinction ~ dnExp(1.0 / ext_mean)
moves[mvi++] = mvScale(extinction, lambda=1.0, tune=true, weight=3.0)
</code></pre></div></div>

<h4 id="diversification-and-turnover">Diversification and turnover</h4>

<p>Sometimes, we may be interested parameters that are functions of parameters in our model. 
We can create these as deterministic nodes and monitor these alongside our stochastic nodes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diversification := speciation - extinction
turnover := extinction / speciation
</code></pre></div></div>

<h4 id="the-probability-of-sampling-an-extant-species-1">The probability of sampling an extant species</h4>

<p>As with the Yule model, we will assume that the sampling probability is effectively 1.0.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sampling &lt;- 1.0
</code></pre></div></div>

<h4 id="conditioning-on-the-root-age-1">Conditioning on the root age</h4>

<p>Create the root-age constant node.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root_time &lt;- T.rootAge()
</code></pre></div></div>

<h4 id="putting-it-all-together-in-the-birth-death-process-distribution-1">Putting it all together in the birth-death process distribution</h4>

<p>For this model, we will set <code class="language-plaintext highlighter-rouge">mu=extinction</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timetree ~ dnBDP(lambda=speciation, mu=extinction, rho=sampling, rootAge=root_time, samplingStrategy="uniform", condition="nTaxa", taxa=T.taxa())
timetree.clamp(T)
</code></pre></div></div>

<h4 id="the-workspace-model-object-1">The workspace model object</h4>

<p>Create the model object and write the Graphviz file. You can view the new model in <a href="#birthdeathgraphv"></a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(speciation)
mymodel.graph("bd_graph.dot")
</code></pre></div></div>

<figure id="birthdeathgraphv"><p><img src="figures/bd_gm.svg" width="500" /></p>
<figcaption>The probabilistic graphical model of the birth-death diversification model for the bear phylogeny.
This image was generated by running the <code class="language-plaintext highlighter-rouge">.graph()</code> method fo the model object and opening the
resulting file in the program <a href="https://www.graphviz.org/">Graphviz</a>.</figcaption>
</figure>

<h4 id="setting-up-the-monitors-1">Setting up the monitors</h4>

<p>We will create file and screen monitors like we did for the Yule model. It is important to
remember to give the file monitor a different name than you did for the Yule analysis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[1] = mnModel(filename="output/bears_BDP.log",printgen=10, separator = TAB)
monitors[2] = mnScreen(printgen=1000, speciation, extinction)
</code></pre></div></div>

<h4 id="the-analysis-computing-the-marginal-likelihood-of-the-model-1">The analysis: Computing the marginal likelihood of the model</h4>

<p>Now it is time to setup and run our power posteriors:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pow_p = powerPosterior(mymodel, moves, monitors, "output/BDP_powp.out", cats=100, sampleFreq=10)
pow_p.burnin(generations=10000,tuningInterval=200)
pow_p.run(generations=10000)
</code></pre></div></div>

<p>Use stepping-stone sampling to calculate marginal likelihood and print the value to the screen.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ss = steppingStoneSampler(file="output/BDP_powp.out", powerColumnName="power", likelihoodColumnName="likelihood")
ss.marginal()
</code></pre></div></div>

<p><strong>Write down the value displayed. This is the marginal likelihood of the birth-death model ($M_1$).</strong></p>

<h3 class="subsection" id="bayfacsec">Bayes Factors for Comparing Two Models</h3>
<hr class="subsection" />

<p>Now that we have estimates of the marginal likelihood for each of our
the candidate substitution models, we can evaluate their relative fit to
the datasets using Bayes factors. Phylogenetic programs log-transform
the likelihood values to avoid
<a href="http://en.wikipedia.org/wiki/Arithmetic_underflow">underflow</a>:
multiplying likelihoods (numbers $&lt; 1$) generates numbers that are too
small to be held in computer memory. Accordingly, we need to use a
different form of equation [bfFormula] to calculate the ln-Bayes
factor (we will denote this value $\mathcal{K}$):</p>

\[\begin{aligned}
\mathcal{K}=\ln[BF(M_0,M_1)] = \ln[\mathbb{P}(\mathbf X \mid M_0)]-\ln[\mathbb{P}(\mathbf X \mid M_1)],
\end{aligned}\]

<p>where $\ln[\mathbb{P}(\mathbf X \mid M_0)]$ is the <em>marginal lnL</em>
estimate for model $M_0$. The value resulting from equation
[LNbfFormula] can be converted to a raw Bayes factor by simply taking
the exponent of $\cal{K}$</p>

\[\begin{aligned}
BF(M_0,M_1) = e^{\cal{K}}.
\end{aligned}\]

<p>Alternatively, you can
directly interpret the strength of evidence in favor of $M_0$ in log
space by comparing the values of $\cal{K}$ to the appropriate scale. In this case, we evaluate $\cal{K}$
in favor of model $M_0$ against model $M_1$ so that:</p>

<blockquote class="instruction">
  <p>if $\mathcal{K} &gt; 1$, model $M_0$ is preferred</p>

  <p>if $\mathcal{K} &lt; -1$, model $M_1$ is preferred.</p>
</blockquote>

<p>Thus, values of $\mathcal{K}$ around 0 indicate that there is no
preference for either model.</p>

<p><em>Which is the model preferred after your analysis?</em></p>

<h2 class="section" id="clocktreesec">Estimate a Rooted Tree &amp; Divergence Times</h2>
<hr class="section" />

<p>Now that we have selected a prior tree model. We can use this model to estimate a 
dated phylogeny using molecular data (presumably the data are different from those used to generate the tree used in the previous sections).</p>

<h3 id="setting-up-the-workspace-and-importing-the-data">Setting Up the Workspace and Importing the Data</h3>

<p>As above, we first need to clear the workspace to avoid any issues with re-doing the model.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear()
</code></pre></div></div>

<p>This time, we will not read in a tree (we are going to infer one!), but we will need to 
import our sequence data. For this analysis, we will use a single locus, the interphotoreceptor
retinoid-binding protein (irbp) sequenced for each of the living bear species. 
You should have saved the data file <code class="language-plaintext highlighter-rouge">bears_irbp.nex</code> to the <code class="language-plaintext highlighter-rouge">data</code> folder. 
We will use the <code class="language-plaintext highlighter-rouge">readDiscreteCharacterData()</code> function and assign the sequence alignment to a variable called <code class="language-plaintext highlighter-rouge">data</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data &lt;- readDiscreteCharacterData(file="data/bears_irbp.nex")
</code></pre></div></div>

<p>Create the index to augment the <code class="language-plaintext highlighter-rouge">moves</code> vector.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvi = 1
</code></pre></div></div>

<h3 class="subsection" id="treemodel">The Tree Model</h3>
<hr class="subsection" />

<p>Assuming our previous analysis indicated that the birth-death process is the preferred model, 
we can use the same model specification as in the <a href="#bdsec"></a> section.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Speciation rate
sp_mean &lt;- 0.02
speciation ~ dnExp(1.0 / sp_mean)
moves[mvi++] = mvScale(speciation, lambda=1.0, tune=true, weight=3.0)
# Extinction rate
ext_mean &lt;- 0.01
extinction ~ dnExp(1.0 / ext_mean)
moves[mvi++] = mvScale(extinction, lambda=1.0, tune=true, weight=3.0)
# Deterministic nodes
diversification := speciation - extinction
turnover := extinction / speciation
# Sampling
sampling &lt;- 1.0
</code></pre></div></div>

<p>One main difference is that now we would like to infer the node ages, 
instead of using the values estimated by an earlier study. 
The first thing we need to do is create a stochastic node for the root of the tree. 
The prior distribution on the root age will come from our previous knowledge about that node.</p>

<p>The oldest crown fossil bear is <em>Kretzoiarctos beatrix</em>, a member of the giant panda clade 
<a class="citation" href="#abella12">(Abella et al. 2012)</a> that is approximately 11.2 to 11.8 My old. Thus, we can use 
this age as a minimum bound on the age of the root 
of the tree. We will start by making a variable called <code class="language-plaintext highlighter-rouge">tKretzoiarctos</code> and assigning it the value of <code class="language-plaintext highlighter-rouge">11.2</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tKretzoiarctos &lt;- 11.2
</code></pre></div></div>

<p>Let’s use a <a href="https://en.wikipedia.org/wiki/Log-normal_distribution">log-normal distribution</a> as a prior on the root time. For this, we can specify 
parameters for the mean of the distribution and the standard deviation.
In the paper by <a class="citation" href="#DosReis2012">dos Reis et al. (2012)</a>, they estimated the age of the MRCA of all bears to be 33.24. 
We will use an “off-set” lognormal distribution, so then we have to set the mean ($M$) to be $M = 33.24 - 11.2$, where 11.2 is the age of the oldest crown fossil.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mean_ra &lt;- 33.24 - tKretzoiarctos
</code></pre></div></div>

<p>We will use a standard deviation of <code class="language-plaintext highlighter-rouge">0.25</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stdv_ra &lt;- 0.25
</code></pre></div></div>

<p>The lognormal distribution has two parameters: $\mu$ is the location parameter and $\sigma$ is the standard deviation. Importantly, $\mu$ is <em>not</em> the same as the mean for the lognormal.
We can compute $\mu$ easily by:</p>

\[\mu = log(M) - \frac{\sigma^2}{2}.\]

<p>If we plug in <code class="language-plaintext highlighter-rouge">mean_ra</code> and <code class="language-plaintext highlighter-rouge">stdv_ra</code> into the equation above, we get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mu_ra &lt;- ln(mean_ra) - ((stdv_ra*stdv_ra) * 0.5)
</code></pre></div></div>

<p>Now we can define a stochastic node for the root age (called <code class="language-plaintext highlighter-rouge">root_time</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root_time ~ dnLnorm(mu_ra, stdv_ra, offset=tKretzoiarctos)
</code></pre></div></div>

<p>Just like in the <a href="#bdsec"></a> section above, we specify a stochastic node for the <code class="language-plaintext highlighter-rouge">timetree</code> using the <code class="language-plaintext highlighter-rouge">dnBDP()</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timetree ~ dnBDP(lambda=speciation, mu=extinction, rho=sampling, rootAge=root_time, samplingStrategy="uniform", condition="nTaxa", taxa=data.taxa())
</code></pre></div></div>

<p>This time we will not treat a published tree as an observation.
Instead, we will consider the <code class="language-plaintext highlighter-rouge">timetree</code> a stochastic node that we are interested in estimating. 
Thus, we will have to apply MCMC moves to the tree parameter so that we can sample the posterior distribution of trees.</p>

<p>First, we can apply all the moves that propose changes to the node ages:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvNodeTimeSlideUniform(timetree, weight=30.0)
moves[mvi++] = mvTreeScale(tree=timetree, rootAge=root_time, delta=1.0, tune=true, weight=3.0)
moves[mvi++] = mvSlide(root_time, delta=2.0, tune=true, weight=10.0)
moves[mvi++] = mvScale(root_time, lambda=2.0, tune=true, weight=10.0)
</code></pre></div></div>

<p>Then, we can add moves that alter the tree topology:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvNNI(timetree, weight=8.0)
moves[mvi++] = mvNarrow(timetree, weight=8.0)
moves[mvi++] = mvFNPR(timetree, weight=8.0)
</code></pre></div></div>

<h3 class="subsection" id="clockmodel">The Relaxed Clock Model</h3>
<hr class="subsection" />

<p>Next we must specify a model describing how substitution rates vary among branches. Under
these models we will create a stochastic node for every branch. We will assume an <strong>uncorrelated</strong> model where the substitution rate for each branch is drawn independently from an exponential distribution.</p>

<p>Remember that the exponential distribution has a single rate parameter $\delta$ and the mean 
of an exponential is $\delta^{-1}$. If we do not know the mean branch rate, we can 
apply a <em>hyperprior</em> to $\delta$ and account for our uncertainty in that parameter. 
We will use another exponential distribution with a mean of $10^{-1}$. The node representing
this parameter will be called <code class="language-plaintext highlighter-rouge">branch_rates_mean</code>. Since it will be a stochastic node, 
we will also propose changes to it during our MCMC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>branch_rates_mean ~ dnExponential(10.0)
moves[mvi++] = mvScale(branch_rates_mean, lambda=1.0, tune=true, weight=2.0)
</code></pre></div></div>

<p>Now that we have a hyperprior defining the mean of the prior on the branch rates, we can 
instantiate the stochastic nodes for each of the branches. To do this, we can use a <code class="language-plaintext highlighter-rouge">for</code> loop.
This will perform a set of instructions for every branch in the tree. First, we need to know
how many branches there are. This value is a function of the number of taxa. We can get the 
number of taxa from sequence <code class="language-plaintext highlighter-rouge">data</code> variable. And for any rooted tree, the number of branches<br />
(we will call this <code class="language-plaintext highlighter-rouge">n_branches</code>) is simply:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_branches &lt;- 2 * data.ntaxa() - 2
</code></pre></div></div>

<p>Now we can loop over every branch and, for each one, we will create a stochastic node and add a
scale move to our <code class="language-plaintext highlighter-rouge">moves</code> list.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(i in 1:n_branches){
    branch_rates[i] ~ dnExp(1/branch_rates_mean)
    moves[mvi++] = mvScale(branch_rates[i], lambda=1.0, tune=true, weight=2.0)
}
</code></pre></div></div>

<p>The variable <code class="language-plaintext highlighter-rouge">branch_rates</code> is now a vector of stochastic nodes. We can add an additional
move that will operate on the whole vector by scaling it up or down. Adding multiple moves
to parameters can help with mixing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvVectorScale(branch_rates, lambda=1.0, tune=true, weight=4.0)
</code></pre></div></div>

<h3 class="subsection" id="gtrmodelsec">The Substitution Model</h3>
<hr class="subsection" />

<p>Now let’s define our substitution model. We will use a GTR model that assumes that each
type of substitution has a different rate of exchangeability and that the stationary frequencies
are unequal.</p>

<p>The stationary frequencies for each of the four nucleotides (A, C, G, T) must sum to $1.0$. 
This means we can use a variable type called a <em>simplex</em> as our stochastic node. A simplex
is a vector that sums to $1.0$. A distribution that returns a simplex is a 
<a href="https://en.wikipedia.org/wiki/Dirichlet_distribution">Dirichlet distribution</a>. 
We also need to add a move that will proposed changes to the <code class="language-plaintext highlighter-rouge">sf</code> simplex.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sf_hp &lt;- v(1,1,1,1)
sf ~ dnDirichlet(sf_hp)
moves[mvi++] = mvSimplexElementScale(sf, alpha=10.0, tune=true, weight=3.0)
</code></pre></div></div>

<p>The exchangeability rates are parameterized in a similar way as the stationary frequencies, 
except here there are 6 elements instead of 4.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>er_hp &lt;- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_hp)
moves[mvi++] = mvSimplexElementScale(er, alpha=10.0, tune=true, weight=3.0)
</code></pre></div></div>

<p>With the parameters of our substitution models defined, we can create a <em>deterministic</em> node 
for the instantaneous rate matrix, <em>i.e.</em>, the <code class="language-plaintext highlighter-rouge">Q</code> matrix. In RevBayes, there are functions
defined for all of the named rate matrices. Here, we will use the <code class="language-plaintext highlighter-rouge">fnGTR()</code> function, which
takes the exchangeability rates and stationary frequencies and calculates the elements in the
matrix.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnGTR(er,sf)
</code></pre></div></div>

<p>For more details on the substitution models, please see the 
<a href="../ctmc#the-general-time-reversible-gtr-substitution-model">Substitution Model Tutorial</a>.</p>

<h3 class="subsection" id="phyloctmcsec">Putting it All Together</h3>
<hr class="subsection" />

<p>Now we can link all of the elements in our graphical model. We will define a stochastic node
representing the sequence alignment. The distribution that generated our sequence data is 
a <em>phylogenetic continuous time Markov chain</em>. In RevBayes, this distribution is called 
<code class="language-plaintext highlighter-rouge">dnPhyloCTMC()</code>. For this model, the <code class="language-plaintext highlighter-rouge">dnPhyloCTMC()</code> expects the following arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tree</code>: a tree with branch lengths</li>
  <li><code class="language-plaintext highlighter-rouge">Q</code>: the instantaneous rate matrix</li>
  <li><code class="language-plaintext highlighter-rouge">branchRates</code>: the rate of substitution for each branch in the tree</li>
  <li><code class="language-plaintext highlighter-rouge">nSites</code>: the number of characters in our data matrix</li>
  <li><code class="language-plaintext highlighter-rouge">type</code>: the type of data, <em>i.e.</em>, <code class="language-plaintext highlighter-rouge">DNA</code>, <code class="language-plaintext highlighter-rouge">RNA</code>, <code class="language-plaintext highlighter-rouge">binary</code>, etc.</li>
</ul>

<p>We will call the stochastic node for our sequence data <code class="language-plaintext highlighter-rouge">phySeq</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phySeq ~ dnPhyloCTMC(tree=timetree, Q=Q, branchRates=branch_rates, nSites=data.nchar(), type="DNA")
</code></pre></div></div>

<p>This node represents <em>observed data</em>. Thus, we will not perform any moves on this stochastic
node. Instead, we will “clamp” the node to the observed value. The <code class="language-plaintext highlighter-rouge">.clamp()</code> method will fix
<code class="language-plaintext highlighter-rouge">phySeq</code> to the observed <code class="language-plaintext highlighter-rouge">data</code> matrix we imported in the section <a href="#setting-up-the-workspace-and-importing-the-data">above</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phySeq.clamp(data)
</code></pre></div></div>

<p>All of the parameters are now defined and linked via the phylogenetic CTMC. We can create a
model object to use the model in our workspace. It is also possible to visualize this model
using <code class="language-plaintext highlighter-rouge">mymodel.graph("timetree_gm.dot")</code> (<a href="#timetreegv"></a>). However, this model
involves many more parameters than in the previous sections, so this tool becomes less useful.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(speciation)
</code></pre></div></div>

<figure id="timetreegv"><p><img src="figures/timetree_gm.svg" width="100%" /></p>
<figcaption>The probabilistic graphical model of all parameters in the phylogenetic analysis.
This image was generated by running the <code class="language-plaintext highlighter-rouge">.graph()</code> method fo the model object and opening the
resulting file in the program <a href="https://www.graphviz.org/">Graphviz</a>.</figcaption>
</figure>

<h3 class="subsection" id="mcmcsec">Run the MCMC</h3>
<hr class="subsection" />

<p>Now that we have our full model, we can set up and run our MCMC. First, we will define a list 
monitors for our parameters. Since we are now dealing with a tree object, we have to 
be sure to save the sampled trees to file. The <code class="language-plaintext highlighter-rouge">mnModel()</code> function will log all of the 
numerical parameters, but not the tree. We can use the <code class="language-plaintext highlighter-rouge">mnFile()</code> monitor to write our 
MCMC samples of the tree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append(mnModel(filename="output/TimetTree_bears_mcmc.log",
printgen=10))
monitors.append(mnFile(filename="output/TimeTree_bears_mcmc.trees",
printgen=10, timetree))
monitors.append(mnScreen(printgen=10, root_time, tmrca_Ursidae))
</code></pre></div></div>

<p>Create the MCMC object:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves)
</code></pre></div></div>

<p>Run the burn-in:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.burnin(generations=5000,tuningInterval=100)
</code></pre></div></div>

<p>This will give you the following output.</p>

<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Running burn-in phase of Monte Carlo sampler for 5000 iterations.
   This simulation runs 1 independent replicate.
   The simulator uses 27 different moves in a random move schedule with 123 moves per iteration

Progress:
0---------------25---------------50---------------75--------------100
****************************************
</code></pre></div></div>

<p>Once the burn-in phase is completed, run the MCMC</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=40000)
</code></pre></div></div>

<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Running MCMC simulation
   This simulation runs 1 independent replicate.
   The simulator uses 27 different moves in a random move schedule with 123 moves per iteration

Iter        |      Posterior   |     Likelihood   |          Prior   |      root_time   |    elapsed   |        ETA   |
-----------------------------------------------------------------------------------------------------------------------
0           |       -1890.92   |       -1980.98   |        90.0529   |       27.01989   |   00:00:00   |   --:--:--   |
100         |       -1895.17   |       -1979.32   |        84.1559   |       31.20937   |   00:00:00   |   --:--:--   |
200         |       -1894.08   |       -1977.15   |        83.0738   |       30.89059   |   00:00:00   |   00:00:00   |
300         |       -1893.08   |       -1980.07   |        86.9973   |       29.60776   |   00:00:01   |   00:02:12   |
...
</code></pre></div></div>

<h3 class="subsection" id="summarysec">Summarize the MCMC</h3>
<hr class="subsection" />

<h4 id="inspect-the-mcmc">Inspect the MCMC</h4>

<p>Now that our MCMC has completed, we need to evaluate the output. The first thing we can do is 
to visually inspect the sampled numerical parameters in our <code class="language-plaintext highlighter-rouge">TimeTree_bears_mcmc.log</code> file. To 
do this, we can use the handy program <a href="http://tree.bio.ed.ac.uk/software/tracer/">Tracer</a> <a class="citation" href="#Rambaut2011">(Rambaut and Drummond 2011)</a>.</p>

<blockquote class="instruction">
  <p>Open the program Tracer and load the <code class="language-plaintext highlighter-rouge">TimeTree_bears_mcmc.log</code> from the <code class="language-plaintext highlighter-rouge">output</code> folder</p>
</blockquote>

<figure id="tracer1"><p><img src="figures/tracer_screen1.png" width="100%" /></p>
<figcaption>The histogram of the <strong><em>Posterior</em></strong> statistic in <a href="http://tree.bio.ed.ac.uk/software/tracer/">Tracer</a>.</figcaption>
</figure>

<p>Looking at the list of parameters in <a href="#tracer1"></a>, you can see that all have high 
<strong><em>ESS</em></strong> values. This column is the <em>effective sample size</em> of your MCMC for that parameter
and indicates the level of correlation among samples. In Tracer, if this value is colored
red for any parameter, it means that there may have been issues with mixing.</p>

<blockquote class="instruction">
  <p>Browse through the various views and parameters in Tracer like <a href="#tracer2"></a>. Does it appear
as though your MCMC had good or bad mixing?</p>
</blockquote>

<figure id="tracer2"><p><img src="figures/tracer_screen2.png" width="100%" /></p>
<figcaption>The trace plot of the <code class="language-plaintext highlighter-rouge">root_time</code> parameter in Tracer.</figcaption>
</figure>

<p>It is important to perform multiple independent MCMC runs so that you can determine if your 
chains converged on the same stationary distribution. Additionally, you should also run
you chain under the prior to diagnose any issues with your model or MCMC and identify parameters
for which your data are not informative. However, given limited time for this tutorial, we will
only conduct one run.</p>

<h4 id="summarize-the-tree">Summarize the Tree</h4>

<p>Assuming we did our due diligence to ensure that our MCMC sampled joint posterior distribution
effectively, we can now summarize the sampled trees. If we return to RevBayes, we can read in 
the sampled trees in <code class="language-plaintext highlighter-rouge">output/TimeTree_bears_mcmc.trees</code>. The <code class="language-plaintext highlighter-rouge">readTreeTrace()</code> function returns
a tree-trace object that we will call <code class="language-plaintext highlighter-rouge">tt</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tt = readTreeTrace("output/TimeTree_bears_mcmc.trees", "clock")
</code></pre></div></div>

<p>We will find the maximum <em>a posteriori</em> tree in our MCMC sample. This is the tree with the 
highest posterior probability. To do this we can use the <code class="language-plaintext highlighter-rouge">mapTree()</code> function on the tree-trace
object.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mapTree(tt, "output/TimeTree_bears_mcmc_MAP.tre")
</code></pre></div></div>

<p>To view this tree, we can use the online tree-viewer <a href="https://icytree.org/">IcyTree</a> developed by <a href="https://github.com/tgvaughan">Tim Vaughan</a>.</p>

<blockquote class="instruction">
  <p>Open your web browser and go to <a href="https://icytree.org">https://icytree.org</a>.</p>

  <p>You can load the <code class="language-plaintext highlighter-rouge">TimeTree_bears_mcmc_MAP.tre</code> file by going to 
the <strong><em>File -&gt; Load from file…</em></strong> in the menu, or by simpling dragging and dropping your
file into the browser window.</p>

  <p>Look through the options in IcyTree and try to replicate the tree in <a href="#mapicy"></a>.</p>
</blockquote>

<figure id="mapicy"><p><img src="figures/map_icy.svg" width="100%" /></p>
<figcaption>The maximum <em>a posteriori</em> tree plotted in <a href="https://icytree.org/">IcyTree</a>. The node bars indicate
the 95% credible interval of the node age and the internal node labels denote the bipartition
posterior probability.</figcaption>
</figure>


<ol class="bibliography"><li><span id="abella12">Abella J., Alba D.M., Robles J.M., Valenciano A., Rotgers C., Carmona R., Montoya P., Morales J. 2012. <i>Kretzoiarctos</i> gen. nov., the Oldest Member of the Giant Panda Clade. PLoS One. 17:e48985.</span>

</li>
<li><span id="Baele2012">Baele G., Lemey P., Bedford T., Rambaut A., Suchard M.A., Alekseyenko A.V. 2012. Improving the Accuracy of Demographic and Molecular Clock Model Comparison while Accommodating Phylogenetic Uncertainty. Molecular Biology and Evolution. 29:2157–2167.</span>

<a href="https://doi.org/10.1093/molbev/mss084">10.1093/molbev/mss084</a>

</li>
<li><span id="Baele2013">Baele G., Li W.L.S., Drummond A.J., Suchard M.A., Lemey P. 2013. Accurate Model Selection of Relaxed Molecular Clocks in Bayesian Phylogenetics. Molecular Biology and Evolution. 30:239–243.</span>

<a href="https://doi.org/10.1093/molbev/mss243">10.1093/molbev/mss243</a>

</li>
<li><span id="Fan2011">Fan Y., Wu R., Chen M.-H., Kuo L., Lewis P.O. 2011. Choosing among Partition Models in Bayesian Phylogenetics. Molecular Biology and Evolution. 28:523–532.</span>

</li>
<li><span id="Gernhard2008">Gernhard T. 2008. The conditioned reconstructed process. Journal of Theoretical Biology. 253:769–778.</span>

<a href="https://doi.org/10.1016/j.jtbi.2008.04.005">10.1016/j.jtbi.2008.04.005</a>

</li>
<li><span id="Jeffreys1961">Jeffreys H. 1961. The Theory of Probability. Oxford University Press.</span>

<a href="https://doi.org/10.1038/109132a0">10.1038/109132a0</a>

</li>
<li><span id="Kendall1948">Kendall D.G. 1948. On the Generalized "Birth-and-Death" Process. The Annals of Mathematical Statistics. 19:1–15.</span>

<a href="https://doi.org/10.1214/aoms/1177730285">10.1214/aoms/1177730285</a>

</li>
<li><span id="Lartillot2006">Lartillot N. 2006. Conjugate Gibbs Sampling for Bayesian Phylogenetic Models. Journal of Computational Biology. 13:1701–1722.</span>

</li>
<li><span id="Lavine1999">Lavine M., Schervish M.J. 1999. Bayes Factors: What They Are and What They Are Not. The American Statistician. 53:119–122.</span>

<a href="https://doi.org/10.1080/00031305.1999.10474443">10.1080/00031305.1999.10474443</a>

</li>
<li><span id="Nee1994b">Nee S., May R.M., Harvey P.H. 1994. The Reconstructed Evolutionary Process. Philosophical Transactions: Biological Sciences. 344:305–311.</span>

<a href="https://doi.org/10.1098/rstb.1994.0068">10.1098/rstb.1994.0068</a>

</li>
<li><span id="Rambaut2011">Rambaut A., Drummond A.J. 2011. Tracer v1.5. .</span>


<a href="http://tree.bio.ed.ac.uk/software/tracer/">http://tree.bio.ed.ac.uk/software/tracer/</a>
</li>
<li><span id="Suchard2001">Suchard M.A., Weiss R.E., Sinsheimer J.S. 2001. Bayesian Selection of Continuous-Time Markov Chain Evolutionary Models. Molecular Biology and Evolution. 18:1001–1013.</span>

</li>
<li><span id="Xie2011">Xie W., Lewis P.O., Fan Y., Kuo L., Chen M.H. 2011. Improving Marginal Likelihood Estimation for Bayesian Phylogenetic Model Selection. Systematic Biology. 60:150–160.</span>

</li>
<li><span id="Yule1925">Yule G.U. 1925. A mathematical theory of evolution, based on the conclusions of Dr. JC Willis, FRS. Philosophical Transactions of the Royal Society of London. Series B, Containing Papers of a Biological Character. 213:21–87.</span>

</li>
<li><span id="DosReis2012">dos Reis M., Inoue J., Hasegawa M., Asher R.J., Donoghue P.C.J., Yang Z. 2012. Phylogenomic datasets provide both precision and accuracy in estimating the timescale of placental mammal phylogeny. Proceedings of the Royal Society B: Biological Sciences. 279:3491–3500.</span>

<a href="https://doi.org/10.1098/rspb.2012.0683">10.1098/rspb.2012.0683</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
