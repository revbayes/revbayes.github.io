<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Discrete morphology - Multistate Characters</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Discrete morphology - Multistate Characters</h1>
	<h3 class="subtitle">Phylogenetic inference with discrete morphological data</h3>
	<h4 class="authors">April M. Wright</h4>
  <h5>Last modified on January 30, 2026</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
            <strong>Data Files</strong>
            <ul id="data_files" class="file-list">
        

        
        

        
            <li >
                <a href="/tutorials/morph_tree/data/Cinctans.nex">Cinctans.nex</a>
            </li>
        
        </ul>

        

    
        
            <strong>Scripts</strong>
            <ul id="scripts" class="file-list">
        

        
        

        
            <li >
                <a href="/tutorials/morph_tree/scripts/mcmc_mk_tutorial.Rev">mcmc_mk_tutorial.Rev</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/mk_model_gamma.Rev">mk_model_gamma.Rev</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/mk_model_gamma_lognormal.Rev">mk_model_gamma_lognormal.Rev</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/mk_model_tree.Rev">mk_model_tree.Rev</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/mkv_model_gamma.Rev">mkv_model_gamma.Rev</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/mkv_model_gamma_discretized.Rev">mkv_model_gamma_discretized.Rev</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/mkv_model_gamma_discretized_multistate.Rev">mkv_model_gamma_discretized_multistate.Rev</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/plot_convergence.R">plot_convergence.R</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/plot_convergence_all.R">plot_convergence_all.R</a>
            </li>
        
            <li >
                <a href="/tutorials/morph_tree/scripts/plot_trees.R">plot_trees.R</a>
            </li>
        
        </ul>

        

    
</blockquote>




</div>
<h2 class="section" id="introduction">Introduction</h2>
<hr class="section" />

<p>Morphological data is commonly used for estimating phylogenetic trees from fossils. This tutorial will focus on estimating phylogenetic trees from <em>discrete</em> characters, those characters which can be broken into non-overlapping character states. This type of data has been used for estimation of phylogenetic trees for many years. In the past twenty years, Bayesian methods for estimating phylogeny from this type of data have become increasingly common.</p>

<p>This tutorial will give an overview of common models and assumptions when estimating a tree from discrete morphological data. We will use a dataset from <a class="citation" href="#zamora2013">(Zamora et al. 2013)</a>. This dataset contains 27 extinct echinoderm taxa and 60 binary and multistate characters.</p>

<h3 class="subsection" id="overview-of-discrete-morphology-models">Overview of Discrete Morphology Models</h3>
<hr class="subsection" />

<p>As technologies for obtaining low-cost and high-throughput nucleotide sequence data have become available, many scientists have become reliant on molecular data for phylogenetics. However, morphological data remain the only direct observations we have of most extinct organisms, and are an independent data source for understanding phylogeny. Many of the phylogenetic methods we will discuss in this tutorial were invented for use with sequence data. However, these methods are still very useful for discrete morphological data. We will examine some common assumptions for modeling data in a phylogenetic context, then move on to look at relaxing these assumptions.</p>

<p>Modeling discrete morphological data requires an understanding of the underlying properties of the data. When we work with molecular data, we know <em>a priori</em> that certain types of changes are more likely than others. For example, changes within a type of base (purine and pyrimidine) are much more likely than changes between types of bases. This information can be used to add parameters to the phylogenetic model. There are no equivalent and generalizable truths across characters in a morphological data matrix. For example, while <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code> are commonly coded to “presence” and “absence”, this is not always the case, nor are all characters atomized at the same magnitude. For instance, at one character, changing character states may not reflect a large amount of genetic changes. Theca shape (character 2 in the Zamora et al. 2013 dataset), for example appears quite labile. At another, the changes to the character state may reflect a rearrangement of genetic elements, or might have larger ramifications for the organism’s life and behavior. Character 38, the central plate of the lintel, may be one such character, as it changes seldom.</p>

<p>When we work with morphological data in a Bayesian context, we are performing these analyses after a long history of workers performing phylogenetic analysis in a maximum parsimony framework. Under maximum parsimony, trees are proposed. The number of changes in the data implied by the tree are then counted. The tree implying the fewest changes is considered the best. There may be multiple most parsimonious trees in a dataset. Parsimony has been the dominant method for estimating phylogenetic trees from discrete morphological data. Characters that cannot be used to discriminate between tree topologies are not typically collected by workers using parsimony. For example, characters that do not vary are not collected, as they all have the same length (0 steps) on a tree. Likewise, autapomorphies are typically not collected. As we will see later, this has ramifications for how we model the data.</p>

<figure id="Mk_model"><p><img src="figures/tikz/Mk_model.png" width="800" /></p>
<figcaption>Graphical model showing the Mk model (left panel) and corresponding Rev code (right panel).</figcaption>
</figure>

<p>For many years, parsimony was the only way to estimate a phylogenetic tree from morphological data. In 2001, Paul Lewis published the Mk model of morphological evolution. The Mk model <a class="citation" href="#Lewis2001">(Lewis 2001)</a> is a generalization of the Jukes-Cantor model <a class="citation" href="#Jukes1969">(Jukes and Cantor 1969)</a> of nucleotide sequence evolution. This model, while simple, has allowed researchers to access the toolkit of phylogenetic methods available to researchers working with other discretely-valued data, such as nucleotides or amino acids.</p>

<h4 class="subsubsection" id="the-mk-model">The Mk Model</h4>
<hr class="subsubsection" />

<p>As mentioned above, the Mk model is a generalization of the JC model. This model assumes that all transitions between character states are equal, and that all characters in the matrix have the same transition matrix. The transition matrix for a binary trait looks like so:</p>

\[Q = \begin{pmatrix} -\mu_0 &amp; \mu_{01} \\
\mu_{10} &amp; -\mu_1  &amp;\\
\end{pmatrix} \mbox{  ,}\]

<p>In this matrix, $\mu$ represents the transition probability between the two states that follow it. A transition matrix for multistate data simply expands.</p>

\[Q = \begin{pmatrix} -\mu_0 &amp; \mu_{01} &amp; \mu_{02} &amp; \mu_{03} \\
\mu_{10} &amp; -\mu_1  &amp; \mu_{12} &amp; \mu_{13} \\
\mu_{20} &amp; \mu_{21} &amp; -\mu_2  &amp; \mu_{23} \\
\mu_{30} &amp; \mu_{31} &amp; \mu_{32} &amp; -\mu_3
\end{pmatrix} \mbox{  ,}\]

<p>However, the Mk model sets transitions to be equal from any state to any other state. In that sense, our multistate matrix really looks like this:</p>

\[Q = \begin{pmatrix} -(k-1)\mu &amp; \mu &amp; \mu &amp; \mu \\
\mu &amp; -(k-1)\mu  &amp; \mu &amp; \mu \\
\mu &amp; \mu &amp; -(k-1)\mu  &amp; \mu \\
\mu &amp; \mu &amp; \mu &amp; -(k-1)\mu \\
\end{pmatrix} \mbox{  ,}\]

<p>You might notice that these transition rates are not different than what we might expect from an equal-weights parsimony matrix. In practice, the Mk model makes very few assumptions due to the complexity and non-generalizability of morphological data.</p>

<p>This model may strike some readers as too simplistic to be adequate for morphological data. However, Bayesian methods are less likely to be mislead by homoplasy than is parsimony <a class="citation" href="#Felsenstein1983">(Felsenstein 1983)</a>. More recent work has demonstrated that the model outperforms parsimony in many situations, particularly those in which there is high homoplasy <a class="citation" href="#Wright2014">(Wright and Hillis 2014)</a>, with empirical work demonstrating that it fits many datasets reasonably well <a class="citation" href="#Wright2016">(Wright et al. 2016)</a>.</p>

<p>In the first part of this tutorial, we will estimate a tree under the Mk model as proposed by Lewis (2001). We will then relax core parameters of the model.</p>

<h4 class="subsubsection" id="ascertainment-bias">Ascertainment Bias</h4>
<hr class="subsubsection" />

<p>One remaining component of the model we have not yet discussed is ascertainment bias. Because workers using parsimony do not collect invariant characters and seldom collect autapomorphies, our data are <em>biased</em>. Imagine, for a moment, that you were to measure the average height in a room. But first, you asked the 10 shortest people to leave. Your estimate of the average height would be too tall! In effect, this happens in the morphological data, as well. Because the characters with the fewest changes are not collected, we over estimate the amount of evolutionary change on the tree. At the time of publication, Lewis (2001) also included a correction factor for this bias.</p>

<p>These original corrections involved simulating parsimony non-informative characters along each proposed tree. These would be used to normalize the likelihood value. While this procedure is statistically valid, it is a bit slow. There are multiple ways to perform this correction <a class="citation" href="#allman08b">(Allman and Rhodes 2008)</a>. RevBayes uses a dynamic likelihood approach to avoid repeated simulations.</p>

<h2 class="section" id="example-inferring-a-phylogeny-of-extinct-cinctans-using-the-mk-model">Example: Inferring a Phylogeny of Extinct Cinctans Using the Mk Model</h2>
<hr class="section" />

<h3 class="subsection" id="tutorial-format">Tutorial Format</h3>
<hr class="subsection" />

<p>This tutorial follows a specific format for issuing instructions and information.</p>

<blockquote>
  <p>The boxed instructions guide you to complete tasks that are not part of the RevBayes syntax, but rather direct you to create directories or files or similar.</p>
</blockquote>

<p>Information describing the commands and instructions will be written in paragraph-form before or after they are issued.</p>

<p>All command-line text, including all Rev syntax, are given in
<code class="language-plaintext highlighter-rouge">monotype font</code>. Furthermore, blocks of Rev code that are needed to build the model, specify the analysis, or execute the run are given in separate shaded boxes. For example, we will instruct you to create a constant node called <code class="language-plaintext highlighter-rouge">example</code> that is equal to <code class="language-plaintext highlighter-rouge">1.0</code> using the <code class="language-plaintext highlighter-rouge">&lt;-</code> operator like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>example &lt;- 1.0
</code></pre></div></div>

<p>It is important to be aware that some PDF viewers may render some characters given as differently. Thus, if you copy and paste text from this PDF, you may introduce some incorrect characters. Because of this, we recommend that you type the instructions in this tutorial or copy them from the scripts provided.</p>

<h3 class="subsection" id="subsec_data_files">Data and Files</h3>
<hr class="subsection" />

<h4 class="subsubsection" id="getting-started">Getting Started</h4>
<hr class="subsubsection" />

<blockquote>
  <p>First create a directory for this tutorial and name it <strong>RB_MultistateCharacters_Tutorial</strong>, or any name you like. Navigate to this new directory and create subdirectories called <strong>data</strong> and <strong>scripts</strong>.</p>

  <p>Download the data file called <a href="data/Cinctans.nex"><code class="language-plaintext highlighter-rouge">Cinctans.nex</code></a> and save it to your <code class="language-plaintext highlighter-rouge">data</code> directory.</p>
</blockquote>

<h4 class="subsubsection" id="subsec_creating_files">Creating Rev Files</h4>
<hr class="subsubsection" />

<blockquote>
  <p>In this exercise, we advise you to record all your commands via a text editor in a set of files – corresponding to the different modules of the model – that will be easily managed and interchanged. Call them <code class="language-plaintext highlighter-rouge">mcmc_mk_tutorial.Rev</code>, <code class="language-plaintext highlighter-rouge">mk_model_tree.Rev</code>, <code class="language-plaintext highlighter-rouge">mk_model_gamma.Rev</code>, and place them in <code class="language-plaintext highlighter-rouge">scripts</code>.</p>
</blockquote>

<p>When you execute RevBayes in this tutorial, you will do so within the main directory  (<code class="language-plaintext highlighter-rouge">RB_MultistateCharacters_Tutorial</code>), thus, if you are using a Unix-based operating system, we recommend that you add the RevBayes binary to your path. Alternatively make sure that you set the  working directory to the directory you stored the scripts and data in.</p>

<p>In the following sections you will begin the <code class="language-plaintext highlighter-rouge">mcmc_mk_tutorial.Rev</code> file and write the Rev commands for loading in the taxon list and managing the data matrices. Then, starting in <a href="#subsec_Mk_model"></a>, you will move on to specifying each of the Mk model components, in files <code class="language-plaintext highlighter-rouge">mk_model_tree.Rev</code> and <code class="language-plaintext highlighter-rouge">mk_model_gamma.Rev</code>. Once the model specifications are complete, you will complete the MCMC script with the instructions given in <a href="#subsec_complete_MCMC"></a>.</p>

<h3 class="subsection" id="subsec_load_data">Load Data Matrices</h3>
<hr class="subsection" />

<p>RevBayes uses the function <code class="language-plaintext highlighter-rouge">readDiscreteCharacterData()</code> to load a data matrix to the workspace from a formatted file. This function can be used for both molecular sequences and discrete morphological characters. Import the morphological character matrix and assign it the variable <code class="language-plaintext highlighter-rouge">morpho</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>morpho &lt;- readDiscreteCharacterData("data/Cinctans.nex")
</code></pre></div></div>

<h3 class="subsection" id="subsec_var">Create Helper Variables</h3>
<hr class="subsection" />

<p>We will dig into the model momentarily. But first, we will create some variables that are used in our analysis, but are not parameters. We will assign these variables with the constant node assignment operator, <code class="language-plaintext highlighter-rouge">&lt;-</code>. Even though these values are used in our scripts, they are not parameters of the model.</p>

<p>We will first create a constant node called <code class="language-plaintext highlighter-rouge">num_taxa</code> that is equal to the number of species in our analysis (27). We will also create a constant node called <code class="language-plaintext highlighter-rouge">num_branches</code> representing the number of branches in the tree, and one of the taxon names. This list will be used to initialize the tree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taxa &lt;- morpho.names()
    num_taxa &lt;- taxa.size()
    num_branches &lt;- 2 * num_taxa - 2
</code></pre></div></div>

<p>Next, create a workspace variable called <code class="language-plaintext highlighter-rouge">moves</code>, a vector containing all of the MCMC moves used to propose new states for every stochastic node in the model graph.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves    = VectorMoves()
</code></pre></div></div>

<p>One important distinction here is that <code class="language-plaintext highlighter-rouge">moves</code> is part of the RevBayes workspace and not the hierarchical model. Thus, we use the workspace assignment operator <code class="language-plaintext highlighter-rouge">=</code> instead of the constant node assignment <code class="language-plaintext highlighter-rouge">&lt;-</code>.</p>

<p>Provided that you started RevBayes from the correct directory, you can then use the <code class="language-plaintext highlighter-rouge">source()</code>
function to load the model files into RevBayes from your Rev-script files (<code class="language-plaintext highlighter-rouge">mk_model_tree.Rev</code> and <code class="language-plaintext highlighter-rouge">mk_model_gamma.Rev</code> ).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mk_model_tree.Rev")
    source("scripts/mk_model_gamma.Rev")
</code></pre></div></div>

<h3 class="subsection" id="subsec_Mk_model">The Mk Model</h3>
<hr class="subsection" />

<p>In this section you will move on to specifying the Mk model components, starting in file <code class="language-plaintext highlighter-rouge">mk_model_tree.Rev</code>. First, we will create a joint prior on the branch lengths.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>br_len_lambda ~ dnExp(0.2)
    moves.append( mvScale(br_len_lambda, weight=2) )
</code></pre></div></div>

<p>This prior specifies that branch lengths will be drawn from an exponential distribution with parameter 0.2.</p>

<p>Now, we combine the branch lengths with a uniform prior on topology to make a tree. The uniform prior simply means no tree is more likely <em>a priori</em> than any other. This can be easily changed, for example, to use a starting tree. We then specify MCMC moves on the topology, NNI and SPR. These moves propose new topologies. In this way, we propose and evaluate new sets of relationships. We perform these moves frequently because these parameters are really important. We will also move each of the branch lengths each iteration. The scale move scales the current branch length. Finally, we monitor the tree length by adding a deterministic node with the operator <code class="language-plaintext highlighter-rouge">:=</code>. This is a quantity many biologists are interested in.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phylogeny ~ dnUniformTopologyBranchLength(taxa, branchLengthDistribution=dnExponential(br_len_lambda))
    moves.append( mvNNI(phylogeny, weight=num_branches/2.0) )
    moves.append( mvSPR(phylogeny, weight=num_branches/10.0) )
    moves.append( mvBranchLengthScale(phylogeny, weight=num_branches) )


    # compute the tree length from the phylogeny
    tree_length := phylogeny.treeLength()
</code></pre></div></div>

<p>Move on to file <code class="language-plaintext highlighter-rouge">mk_model_gamma.Rev</code>, where we will add Gamma-distributed rate variation and specify moves on the parameter of the Gamma distribution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Set up Gamma-distributed rate variation.
    alpha_morpho ~ dnUniform( 0.0, 1E6 )
    rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )

    # Moves on the parameters to the Gamma distribution.
    moves.append( mvScale(alpha_morpho,lambda=1, weight=2.0) )
</code></pre></div></div>

<p>Next we will create a $Q$-matrix. Recall that the Mk model is simply a generalization of the JC model. Therefore, we will create a $Q$-matrix using <code class="language-plaintext highlighter-rouge">fnJC</code>, which initializes $Q$-matrices with equal transition probabilities between all states. Since we have multistate data, we need to specify different $Q$-matrices for the different number of character states. For example, it would not make sense to model a 5-state character using a model saying there are only two character states.</p>

<p>To do this, we have written a loop in which we break up the data set into partitions according to the number of character states that character has. Then, we specify a $Q$-matrix in the correct dimensions. We do not retain any partitions that do not have any characters. For example, if we tried to partition the characters with 4 states, and there were none, we would not create a $Q$-matrix.</p>

<p>Then, we combine each partition, Gamma-distributed rate heterogeneity, and the tree together into what is called the <code class="language-plaintext highlighter-rouge">phyloCTMC</code>. This is the joint set of model parameters that will be used the model these data. Each partition is then clamped to its model.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_max_states &lt;- 7
    idx = 1
    morpho_bystate[1] &lt;- morpho
    for (i in 2:n_max_states) {
        # make local tmp copy of data
        # only keep character blocks with state space equal to size i

        morpho_bystate[i] &lt;- morpho
        morpho_bystate[i].setNumStatesPartition(i)

        # get number of characters per character size wth i-sized states
        nc = morpho_bystate[i].nchar()

        # for non-empty character blocks
        if (nc &gt; 0) {

            # make i-by-i rate matrix
            q[idx] &lt;- fnJC(i)

            # create model of evolution for the character block
            m_morph[idx] ~ dnPhyloCTMC( tree=phylogeny,
                                        Q=q[idx],
                                        nSites=nc,
                                        siteRates=rates_morpho,
                                        type="Standard")

            # attach the data
            m_morph[idx].clamp(morpho_bystate[i])

            # increment counter
            idx = idx + 1
            idx
        }
    }
</code></pre></div></div>

<p>We see some familiar pieces: tree, $Q$-matrix and <code class="language-plaintext highlighter-rouge">rates_morpho</code>.
We also have two new keywords: data type and coding. The data type argument specifies the type of data - in our case, “Standard”, the specification for morphology.
All of the components of the model are now specified.</p>

<h3 class="subsection" id="subsec_complete_MCMC">Complete MCMC Analysis</h3>
<hr class="subsection" />

<h4 class="subsubsection" id="subsec_Mod_Obj">Create Model Object</h4>
<hr class="subsubsection" />

<p>Back in file <code class="language-plaintext highlighter-rouge">mcmc_mk_tutorial.Rev</code>, we can now create our workspace model variable with our fully specified model DAG. We will do this with the <code class="language-plaintext highlighter-rouge">model()</code> function and provide a single node in the graph (<code class="language-plaintext highlighter-rouge">phylogeny</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(phylogeny)
</code></pre></div></div>

<p>The object <code class="language-plaintext highlighter-rouge">mymodel</code> is a wrapper around the entire model graph and allows us to pass the model to various functions that are specific to our MCMC analysis.</p>

<h4 class="subsubsection" id="subsubsec_Monitors">Specify Monitors and Output Filenames</h4>
<hr class="subsubsection" />

<p>The next important step for our Rev-script is to specify the monitors and output file names. For this, we use the vector called <code class="language-plaintext highlighter-rouge">monitors</code> that will take each sample and record or output our MCMC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors = VectorMonitors()
</code></pre></div></div>

<p>The first monitor we create will monitor every named random variable in our model graph. This will include every stochastic and deterministic node using the <code class="language-plaintext highlighter-rouge">mnModel</code> monitor. The only parameter that is not included in the <code class="language-plaintext highlighter-rouge">mnModel</code> is the tree topology. Therefore, the parameters in the file written by this monitor are all numerical parameters written to a tab-separated text file that can be opened by accessory programs for evaluating such parameters. We will also name the output file for this monitor and indicate that we wish to sample our MCMC every 10 cycles.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/mk_gamma.log", printgen=10) )
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mnFile</code> monitor writes any parameter we specify to file. Thus, if we only cared about the branch lengths and nothing else (this is not a typical or recommended attitude for an analysis this complex) we wouldn’t use the <code class="language-plaintext highlighter-rouge">mnModel</code> monitor above and just use the <code class="language-plaintext highlighter-rouge">mnFile</code> monitor to write a smaller and simpler output file. Since the tree topology is not included in the <code class="language-plaintext highlighter-rouge">mnModel</code> monitor (because it is not numerical), we will use <code class="language-plaintext highlighter-rouge">mnFile</code> to write the tree to file by specifying our <code class="language-plaintext highlighter-rouge">phylogeny</code> variable in the arguments.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnFile(filename="output/mk_gamma.trees", printgen=10, phylogeny) )
</code></pre></div></div>

<p>The third monitor we will add to our analysis will print information to the screen. Like with <code class="language-plaintext highlighter-rouge">mnFile</code> we could tell <code class="language-plaintext highlighter-rouge">mnScreen</code> which parameters we’d like to see updated on the screen.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(printgen=100) )
</code></pre></div></div>

<h4 class="subsubsection" id="set-up-the-mcmc">Set-Up the MCMC</h4>
<hr class="subsubsection" />

<p>Once we have set up our model, moves, and monitors, we can now create the workspace variable that defines our MCMC run. We do this using the <code class="language-plaintext highlighter-rouge">mcmc()</code> function that simply takes the three main analysis components as arguments. Furthermore, we will perform and combine two independent MCMC runs to ensure proper convergence.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves, nruns=2, combine="mixed")
</code></pre></div></div>

<p>The MCMC object that we named <code class="language-plaintext highlighter-rouge">mymcmc</code> has a member method called <code class="language-plaintext highlighter-rouge">.run()</code>. This will execute our analysis and we will set the chain length to <code class="language-plaintext highlighter-rouge">10000</code> cycles using the <code class="language-plaintext highlighter-rouge">generations</code> option.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=50000, tuningInterval=200)
</code></pre></div></div>

<p>Once our Markov chain has terminated, we will want RevBayes to close. Tell the program to quit using the <code class="language-plaintext highlighter-rouge">q()</code> function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q()
</code></pre></div></div>

<blockquote class="instruction">
  <p>You made it! Save all of your files.</p>
</blockquote>

<h3 class="subsection" id="subsec_run_MCMC">Execute the MCMC Analysis</h3>
<hr class="subsection" />

<p>We will now execute an MCMC analysis.</p>

<blockquote>
  <p>Begin by running the RevBayes executable on your MCMC script. In Unix systems, from the <strong>RB_MultistateCharacters_Tutorial</strong> folder directory, type the
following in your terminal (if the RevBayes binary is in your path) :
rb scripts/mcmc_mk_tutorial.Rev</p>
</blockquote>

<p>When the analysis is complete, RevBayes will quit and you will have a new directory called <code class="language-plaintext highlighter-rouge">output</code> that will contain all of the files you specified with the monitors.</p>

<p>We can look at the log files in the software <code class="language-plaintext highlighter-rouge">Tracer</code>. We can also calculate several different types of summary trees:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Read in the tree trace and summarize tree topology #
    trace = readTreeTrace("output/mk_gamma.trees", treetype="non-clock")
    trace.setBurnin(0.25)

    # Summarize tree trace
    # maximum clade credibility tree
    mccTree(trace, file="output/mk_gamma.mcc.tre")
    # maximum a posteriori tree
    mapTree(trace, file="output/mk_gamma.map.tre")
    # majority rule consensus tree
    consensusTree(trace, file="output/mk_gamma.majrule.tre")
</code></pre></div></div>

<p>RevBayes can calculate MCC trees, MAP trees, and consensus trees. Have each person at your table try one, and see how they differ.</p>

<h2 class="section" id="subsubsec_Adventure">Choose Your Own Adventure</h2>
<hr class="section" />

<p>For this next portion of the tutorial, we will choose and edit some pieces of the model. Feel free to add your own innovations. For this, you will create copies of your previous <code class="language-plaintext highlighter-rouge">Rev</code> scripts, and modify them. Make sure to change the file names in the <code class="language-plaintext highlighter-rouge">source()</code> function accordingly before running the MCMC!</p>

<h3 class="subsection" id="subsubsec_lognormal">Lognormally-distributed among-character rate variation</h3>
<hr class="subsection" />

<p>As we discussed, there is reason to believe a lognormal distribution may fit morphological data better than a gamma. RevBayes makes it very natural to discretize <em>any</em> distribution you might like to work with.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rates_morpho := fnDiscretizeDistribution( dnLognormal(ln(alpha_morpho), 0.01), 4 )
</code></pre></div></div>

<p>Can you figure out which line you might replace with this code? Do it, and change your output files to indicate that this is estimation uses a lognormal distribution. Re-run your Rev script.</p>

<h3 class="subsection" id="subsubsec_Ascertainment">Ascertainment Bias</h3>
<hr class="subsection" />

<p>As discussed earlier in the section Ascertainment_Bias, we also need to correct for ascertainment bias.</p>

<blockquote>
  <p>Create a copy of your previous <code class="language-plaintext highlighter-rouge">Rev</code> script, and call it <em>mkv_model_gamma.Rev</em>.
You will need to modify the <code class="language-plaintext highlighter-rouge">Rev</code>
code provided in this section in this file.</p>
</blockquote>

<p>In <code class="language-plaintext highlighter-rouge">RevBayes</code> it is actually very simple to add a correction for ascertainment bias. You only need to set the option <code class="language-plaintext highlighter-rouge">coding="variable"</code> in the <code class="language-plaintext highlighter-rouge">dnPhyloCTMC</code>. Coding specifies
what type of ascertainment bias is expected. We are using the <code class="language-plaintext highlighter-rouge">variable</code> correction, as we have no invariant character in our matrix. If we also lacked parsimony non-informative characters, we would use the coding <code class="language-plaintext highlighter-rouge">informative</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phyMorpho ~ dnPhyloCTMC(tree=phylogeny, siteRates=rates_morpho, Q=Q_morpho, type="Standard", coding="variable")
</code></pre></div></div>

<h3 class="subsection" id="subsubsec_relaxing">Relaxing Character State Symmetry</h3>
<hr class="subsection" />

<p>The Mk model makes a number of assumptions, but one that may strike you
as particularly unrealistic is the assumption that characters are equally likely to change from any one state to any other. That means that a trait is as likely to be gained as lost. While this may hold true for some traits, we expect that it may be untrue for many others.</p>

<p>RevBayes has functionality to allow us to relax this assumption <a class="citation" href="#Nylander2004">(Nylander et al. 2004)</a>. We do
this by specifying a beta prior on state frequencies. Stationary frequencies impact how likely we are to see changes in a character. For example, it may be very likely, in a character, to change from 0 to 1. But if the frequency of 0 is very low, we will still seldom see this change.</p>

<p>We can think of a Q matrix as looking like so:</p>

\[Q = \begin{pmatrix} -\mu_0\pi0 &amp; \mu_{01}\pi0 \\
\mu_{10}\pi1 &amp; -\mu_1\pi1  &amp;\\
\end{pmatrix} \mbox{  ,}\]

<p>In which the probability of changing states depends not solely on the transition probability, but also the frequency of the starting state. For example, if we have a rare character state, we do not expect to see many transitions from the rare state to another. $\pi$ is the value chosen to represent state frequency commonly in phylogenetic models.</p>

<p>We can exploit the relationship between state frequencies and observed
changes to allow for variable Q-matrices across characters. To do this, we generate a beta distribution on state frequencies, and use the state frequencies from that distribution to generate a series of Q-matrices used to evaluate our data <a class="citation" href="#Pagel2004">(Pagel and Meade 2004; Nylander et al. 2004; Wright et al. 2016)</a>.</p>

<p>This type of model is called a <strong>mixture model</strong>. There are assumed to
be subdivisions in the data, which may require different parameters (in
this case, state frequencies). These subdivisions are not defined <em>a
priori</em>. This model has previously been shown to be effective for a
range of empirical and simulated datasets <a class="citation" href="#Wright2016">(Wright et al. 2016)</a>.</p>

<figure id="morpho_graphical_model"><p><img src="figures/tikz/morpho_gm.png" width="400" /></p>
<figcaption>Graphical model demonstrating the
discretized beta distribution for allowing variable state frequencies.</figcaption>
</figure>

<h4 class="subsubsection" id="subsubsec_RevScript">Modifying the Rev-script</h4>
<hr class="subsubsection" />

<blockquote>
  <p>Make a copy of the Rev script you made earlier. Call it
<code class="language-plaintext highlighter-rouge">mkv_model_gamma_discretized.Rev</code>. This new script will
contain the new model parameters and models.</p>
</blockquote>

<p>We will use a discretized beta distribution to place a prior on the state frequencies.
The beta distribution has two parameters, $\alpha$ and $\beta$. These two
parameters specify the shape of the distribution. State frequencies will
be evaluated according to this distribution, in the same way that rate
variation is evaluated according to the gamma distribution. The
discretized distribution is split into multiple classes, each with its
own set of frequencies for the 0 and 1 characters. The number of classes
can vary; we have chosen 4 for tractability. Note that we need to make sure that this discretization results in a symmetric model, therefore we will use only one parameter for the beta distribution: <code class="language-plaintext highlighter-rouge">beta_scale</code> such that $\alpha = \beta$.</p>

<p>To simplify the analysis, and make it tractable within the time period, we will only use the binary characters.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>morpho.setNumStatesPartition(2)
</code></pre></div></div>

<p>Next, we will set up the prior on $\beta$.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num_cats = 4
    beta_scale ~ dnLognormal( 0.0, sd=2*0.587405 )
    moves.append( mvScale(beta_scale, lambda=1, weight=5.0 ) )
</code></pre></div></div>

<p>Above, we initialized the number of categories, the parameters of the
beta distribution, and the moves on these parameters.</p>

<p>Next, we set the categories to each represent a quadrant of the beta
distribution specified by <code class="language-plaintext highlighter-rouge">beta_scale</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cats := fnDiscretizeBeta(beta_scale, beta_scale, num_cats)
</code></pre></div></div>

<p>If you were to print the <code class="language-plaintext highlighter-rouge">cats</code> variable, you would see a list of state
frequencies like so:</p>

<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 0.011, 0.236, 0.764, 0.989 ]
</code></pre></div></div>

<p>Using these state frequencies, we will generate a new vector of Q-matrices. Because we are varying the state frequencies, we must use a Q-matrix generation function that allows for state frequencies to vary as
a parameter. We will, therefore, use the <code class="language-plaintext highlighter-rouge">fnF81</code> function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:cats.size())
    {
        Q[i] := fnF81(simplex(abs(1-cats[i]), cats[i]))
    }
</code></pre></div></div>

<p>Additionally, in RevBayes we need to specify the probabilities that a site evolves according to one
of the Q-matrices. For this model the probabilities must be equal because we need to guarantee that
the model is symmetric. Thus, we use a <code class="language-plaintext highlighter-rouge">simplex</code> function to create a vector that sums to 1.0.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mat_prior &lt;- rep(1,num_cats)
    matrix_probs ~ dnDirichlet(mat_prior)

    moves.append( mvBetaSimplex(matrix_probs, weight=3.0) )
    moves.append( mvDirichletSimplex(matrix_probs, weight=1.5) )
</code></pre></div></div>

<p>Finally, we make the CTMC for the model:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phyMorpho ~ dnPhyloCTMC(tree=phylogeny, siteRates=rates_morpho, Q=Q, type="Standard", coding="variable", siteMatrices=matrix_probs)
    phyMorpho.clamp(morpho)
</code></pre></div></div>

<p>This model can be embedded in the for loop seen in <a href="#subsec_Mk_model"></a> to work with multi-state characters. An example is provided in script <code class="language-plaintext highlighter-rouge">mkv_model_gamma_discretized_multistate.Rev</code>.</p>

<ol class="bibliography"><li><span id="allman08b">Allman E.S., Rhodes J.A. 2008. Identifying evolutionary trees and substitution parameters for the general Markov model with invariable sites. Mathematical Biosciences. 211:18–33.</span>

</li>
<li><span id="Felsenstein1983">Felsenstein J. 1983. Parsimony in Systematics: Biological and Statistical Issues. Annual Review of Ecology and Systematics. 14:313–333.</span>

<a href="https://doi.org/10.1146/annurev.es.14.110183.001525">10.1146/annurev.es.14.110183.001525</a>

</li>
<li><span id="Jukes1969">Jukes T.H., Cantor C.R. 1969. Evolution of Protein Molecules. Mammalian Protein Metabolism. 3:21–132.</span>

<a href="https://doi.org/10.1016/B978-1-4832-3211-9.50009-7">10.1016/B978-1-4832-3211-9.50009-7</a>

</li>
<li><span id="Lewis2001">Lewis P.O. 2001. A Likelihood Approach to Estimating Phylogeny from Discrete Morphological Character Data. Systematic Biology. 50:913–925.</span>

<a href="https://doi.org/10.1080/106351501753462876">10.1080/106351501753462876</a>

</li>
<li><span id="Nylander2004">Nylander J.A.A., Ronquist F., Huelsenbeck J.P., Nieves-Aldrey J. 2004. Bayesian phylogenetic analysis of combined data. Systematic Biology. 53:47–67.</span>

</li>
<li><span id="Pagel2004">Pagel M., Meade A. 2004. A Phylogenetic Mixture Model for Detecting Pattern-Heterogeneity in Gene Sequence or Character-State Data. Systematic Biology. 53:571–581.</span>

<a href="https://doi.org/10.1080/10635150490468675">10.1080/10635150490468675</a>

</li>
<li><span id="Wright2014">Wright A.M., Hillis D.M. 2014. Bayesian analysis using a simple likelihood model outperforms parsimony for estimation of phylogeny from discrete morphological data. PLoS One. 9:e109210.</span>

<a href="https://doi.org/10.1371/journal.pone.0109210">10.1371/journal.pone.0109210</a>

</li>
<li><span id="Wright2016">Wright A.M., Lloyd G.T., Hillis D.M. 2016. Modeling Character Change Heterogeneity in Phylogenetic Analyses of Morphology through the Use of Priors. Systematic Biology. 65:602–611.</span>

<a href="https://doi.org/10.1093/sysbio/syv122">10.1093/sysbio/syv122</a>

</li>
<li><span id="zamora2013">Zamora S., Rahman I.A., Smith A.B. 2013. The ontogeny of cinctans (stem-group Echinodermata) as revealed by a new genus, GraciaCystis, from the middle Cambrian of Spain. Palaeontology. 56:399–410.</span>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://github.com/revbayes/revbayes/discussions">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
