<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Dating with Relative Constraints</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Dating with Relative Constraints</h1>
	<h3 class="subtitle">Constraining the relative order of nodes when dating a phylogeny</h3>
	<h4 class="authors">Dominik Schrempf, Gergely Szöllősi, and Bastien Boussau</h4>
  <h5>Last modified on May 10, 2025</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/relative_time_constraints/data/alignment.fasta">alignment.fasta</a></li>
        
          <li><a href="/tutorials/relative_time_constraints/data/constraints.txt">constraints.txt</a></li>
        
          <li><a href="/tutorials/relative_time_constraints/data/substitution.tree">substitution.tree</a></li>
        
          <li><a href="/tutorials/relative_time_constraints/data/time.tree">time.tree</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/relative_time_constraints/scripts/1a_mcmc_jc.rev">1a_mcmc_jc.rev</a></li>
        
          <li><a href="/tutorials/relative_time_constraints/scripts/1b_summarize_branch_lengths.rev">1b_summarize_branch_lengths.rev</a></li>
        
          <li><a href="/tutorials/relative_time_constraints/scripts/2_mcmc_dating.rev">2_mcmc_dating.rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="introduction">Introduction</h2>

<p>In phylogenetics, the term <strong>dating</strong> denotes the inference of node ages of
phylogenies. For example, dating a species tree involves inference of the times
when the species split. Dating phylogenies is central to understanding the
evolution of life on Earth. However, evolutionary sequences evolve with
different rates, an observation that has been termed <strong>relaxed molecular
clock</strong>. In general, it is difficult to map a phylogeny obtained from a multiple
sequence alignment, and with branch lengths measured in average number of
substitutions per site, to a phylogeny with branch lengths measured in actual
units of time. For this reason, the molecular clocks are calibrated with
information gained from fossils, which can be accurately dated. Incorporating
fossil information enables <strong>calibration</strong> of node ages of a phylogeny. Please
also see the <a href="../fbd/">tutorial on fossil calibrations</a>.</p>

<p>In this tutorial, we explore another possibility to improve on the accuracy of
dating a phylogeny. Namely, horizontal gene transfers and ancient evolutionary
relationships such as symbioses are informative about the order of nodes of a
phylogeny of interest. That is, horizontal gene transfers define <strong>relative node
constraints</strong>. Relative node constraints can be particularly helpful when the
geological record is sparse, for example, for microorganisms, which represent
the vast majority of extant and extinct biodiversity. Combination of node
calibrations with relative node constraints can significantly improve both
accuracy and resolution of molecular clock estimates <a class="citation" href="#Szollosi2021">(Szöllősi et al. 2021)</a>.</p>

<h2 class="section" id="definitions">Definitions</h2>

<p><strong>Alignment</strong>: Multiple sequence alignment.</p>

<p><strong>Timetree</strong>: Phylogeny with branch lengths measured in units of time. If the
leaves have been sampled at the same time, for example, at the present, a
time-tree is ultrametric.</p>

<p><strong>Branch-length tree</strong>: Phylogeny with branch lengths measured in expected
numbers of substitutions. Usually, branch-length trees are obtained from a
phylogenetic analysis of an alignment.</p>

<p><strong>Calibration</strong>: Absolute node calibration; an estimate of the age of a node of
a timetree. This is usually associated with a prior describing the uncertainty
associated to this node age.</p>

<p><strong>Constraint</strong>: Relative node order constraint, which specifies the relative
order in time of two nodes of a tree (e.g. node A is older than node B).</p>

<h2 class="section" id="getting-started">Getting Started</h2>

<p>This tutorial was tested against the development branch,
available at <a href="https://github.com/revbayes/revbayes/commit/06c1cac4b9e62185cd8db45f638f152e30045ab8">commit 06c1cac</a>.
Similar to other RevBayes tutorials, we suggest using the following
directory structure:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
├── data
├── scripts
└── output
</code></pre></div></div>

<p>The following data files are available:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data/
├── alignment.fasta    -- Alignment file simulated with the Jukes-Cantor (JC) model.
├── constraints.txt    -- File containing constraints.
├── substitution.tree  -- Tree with branch length in expected number of substitutions used to simulate the alignment.
└── time.tree          -- Original timetree to be recovered.
</code></pre></div></div>

<p>The following RevBayes script files are available:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scripts/
├── 1a_mcmc_jc.rev                   -- Infer branch-length trees using the JC model.
├── 1b_summarize_branch_lengths.rev  -- Extract posterior means and variances of branch lengths.
└── 2_mcmc_dating.rev                -- Date with calibrations and constraints.
</code></pre></div></div>

<p>Simulated data will be used, so that the inferred timetrees can be tested for
accuracy against the correct timetree stored in the file <code class="language-plaintext highlighter-rouge">time.tree</code>. Inference
will be done twice: (1) using calibrations only, and (2) using calibrations and
constraints. We will not perform inference of the topology of the tree, only of
the age of its nodes. We will therefore work with the correct, fixed tree
topology obtained from the file <code class="language-plaintext highlighter-rouge">substitution.tree</code>. On empirical data, one
could use the maximum-likelihood (ML) or the maximum a posteriori (MAP) topology
obtained from a phylogenetic reconstruction based on the alignment as in e.g.
tutorial <a href="../ctmc/">Phylogenetic inference of nucleotide data using RevBayes</a>.</p>

<h2 class="section" id="statement-of-the-problem">Statement of the Problem</h2>

<p>We are interested in inferring the following timetree using calibrations
and constraints:</p>

<figure id="time-tree"><p><img src="figures/time-tree.png" width="600" /></p>
<figcaption><em>Timetree with 25 leaves (T0 to T24) to be inferred. The tree
was simulated using a birth process (Yule process) with a birth rate of 1.0 per
unit of time. The tree was conditioned on having height 0.3, and 25 leaves.</em></figcaption>
</figure>

<p>However, the only information we get is an alignment simulated along the
following branch-length tree:</p>

<figure id="substitution-tree"><p><img src="figures/substitution-tree.png" width="600" /></p>
<figcaption><em>Branch-length tree obtained from the timetree by multiplying the branch
lengths with randomly chosen rates. The rates are sampled from
two log-normal distributions introducing frequent minor, and sparse major rate
modifications, respectively. The alignment used for inference was simulated
along this tree using the JC model.</em></figcaption>
</figure>

<p>For reasons of computational efficiency, the phylogenetic likelihood is
approximated using a branch-wise composition of normal distributions. For a
detailed description of this two-step procedure please see <a class="citation" href="#Szollosi2021">(Szöllősi et al. 2021)</a>. In the first step, the posterior distributions of branch lengths for a fixed
unrooted topology is inferred using the JC model (<code class="language-plaintext highlighter-rouge">1a_mcmc_jc.rev</code>). Then, the
inferred posterior distributions of branch lengths are summarized into the
posterior means and variances of the branch lengths
(<code class="language-plaintext highlighter-rouge">1b_summarize_branch_lengths.rev</code>). In the second step, these posterior means
and variances of the branch lengths, as well as the calibrations and constraints
are used to date the phylogeny (<code class="language-plaintext highlighter-rouge">2_mcmc_dating.rev</code>).</p>

<p>The approximation of the phylogenetic likelihood using posterior means and
variances is optional but recommended for reasons of computational efficiency.
It is not necessary to use this approximation when dealing with relative time
constraints, but the benefit here is clear: the first step computes
branch-length tree distributions, which is costly and takes a long time. Once
this has been done, in step two, several different dating models can be run
efficiently without the need to rerun the analysis performed in the first step.</p>

<h2 class="section" id="step-1a-inference-of-the-posterior-distributions-of-the-branch-lengths">Step 1a: Inference of the Posterior Distributions of the Branch Lengths</h2>

<p>Please execute the following command to perform Bayesian inference of the
posterior distributions of branch-length trees using a Jukes-Cantor substitution
model on a single alignment with a fixed tree topology. The Markov chain Monte
Carlo (MCMC) algorithm runs for 30000 iterations. It uses the alignment
<code class="language-plaintext highlighter-rouge">data/alignment.fasta</code>, and the branch-length tree <code class="language-plaintext highlighter-rouge">data/substitution.tree</code>. The
output is a file <code class="language-plaintext highlighter-rouge">output/alignment.fasta.trees</code> containing the 30000
branch-length trees from the MCMC chain. It will be used to calculate the
posterior means and variances of the branch lengths.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> rb ./scripts/1a_mcmc_jc.rev
</code></pre></div></div>

<p>For more detailed explanations of the script file, please consult the
<a href="../ctmc/">continuous time Markov chain tutorial</a>.</p>

<h2 class="section" id="step-1b-summarizing-branch-length-distributions-by-means-and-variances">Step 1b: Summarizing Branch Length Distributions by Means and Variances</h2>

<p>In this step, we compute the means and variances of the posterior distributions
of branch lengths using the 30000 trees obtained in step 1a. Please have a look
at the script file <code class="language-plaintext highlighter-rouge">scripts/1b_summarize_branch_lengths.rev</code>.</p>

<p>First, we specify the name of the file containing the trees, and the amount of
thinning we apply (<code class="language-plaintext highlighter-rouge">thinning = 5</code> means that we take every fifth tree):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># File including trees obtained in step 1a.
tree_file="alignment.fasta.trees"
# Only use every nth tree to calculate the posterior means and variances.
thinning = 5
</code></pre></div></div>

<p>Then, the trees are loaded and thinned:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tre = readBranchLengthTrees(outdir+file_trees_only)

print("Number of trees before thinning: ")
print(tre.size())

# Perform thinning.
index = 1
for (i in 1:tre.size()) {
  if (i % thinning == 0) {
    trees[index] = tre[i]
    index = index + 1
  }
}
</code></pre></div></div>

<p>The posterior means and squared means (which will be used to calculate
variances) are then computed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Compute the posterior means and squared means of the branch lengths.")
num_branches = trees[1].nnodes()-1
bl_means &lt;- rep(0.0,num_branches)
bl_squaredmeans &lt;- rep(0.0,num_branches)

# Extract the posterior branch lengths. The index `i` is traversing the trees,
# the index `j` is traversing the branches.
for (i in 1:(trees.size())) {
  for (j in 1:num_branches ) {
    bl_means[j] &lt;- bl_means[j] + trees[i].branchLength(j)
    bl_squaredmeans[j] &lt;- bl_squaredmeans[j] + trees[i].branchLength(j)^2
    }
}

# Compute the posterior means and squared means.
for (j in 1:num_branches ) {
  bl_means[j] &lt;- bl_means[j] / (trees.size())
  bl_squaredmeans[j] &lt;- bl_squaredmeans[j] / (trees.size())
}
</code></pre></div></div>

<p>Finally, the posterior means and variances are stored in two trees having the
same topology as the one used for inference. In this way we ensure that the
posterior means and variances for the specific branches are tracked in a correct
way.</p>

<p>The posterior variances are calculated using the standard formula \(Var(X) =
E(X^2) - E(X)^2.\)</p>

<p>Here we save the posterior means in a separate tree so we can use them later.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Compute the tree with posterior means as branch lengths.")
meanTree = readBranchLengthTrees(outdir+file_trees_only)[1]

print("Original mean tree before changing branch lengths")
print(meanTree)

for (j in 1:num_branches ) {
  meanTree.setBranchLength(j, bl_means[j])
}

print("Tree with posterior means as branch lengths.")
print(meanTree)

writeNexus(outdir+tree_file+"_meanBL.nex", meanTree)
print("The tree with posterior mean branch lengths has been saved.")
</code></pre></div></div>

<p>We also save the posterior varainces in a separate tree so we can use them later.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
print ("Compute tree with posterior variances as branch lengths.")
varTree = readBranchLengthTrees(outdir+file_trees_only)[1]

print("Original variance tree before changing branch lengths")
print(varTree)

# Here, the posterior variances are calculated using the well known formula
# Var(x) =E[X^2] - E[X]^2.
for (j in 1:num_branches ) {
  varTree.setBranchLength(j, abs ( bl_squaredmeans[j] - bl_means[j]^2) )
}

print("Tree with posterior variances as branch lengths.")
print(varTree)

writeNexus(outdir+tree_file+"_varBL.nex", varTree)
print("The tree with posterior variance branch lengths has been saved.")
</code></pre></div></div>

<p>To run the script, please execute</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> rb ./scripts/1b_summarize_branch_lengths.rev
</code></pre></div></div>

<h2 class="section" id="step-2-dating-using-calibrations-and-constraints">Step 2: Dating Using Calibrations and Constraints</h2>

<p>Finally, we date the phylogeny using a relaxed clock model. Please have a look
at the script <code class="language-plaintext highlighter-rouge">2_mcmc_dating.rev</code>. Important parts will be explained in the
following.</p>

<h3 class="subsection" id="options">Options</h3>
<hr class="subsection" />

<p>First, let’s define some file names and options:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time_tree_file="data/time.tree"
constraints_file="data/constraints.txt"
mean_tree_file="output/alignment.fasta.trees_meanBL.nex"
var_tree_file="output/alignment.fasta.trees_varBL.nex"
out_bn="alignment.fasta.approx.dating"

# Show debug output?
debug = true
# Use relative constraints?
constrain = false
# Length of Markov chain.
mcmc_length = 50000
mcmc_burnin = 100
# The posterior branch length distribution of some branches of the first run has
# zero variance. In this case, set the variance to the following value.
var_min = 1e-6
</code></pre></div></div>

<h3 class="subsection" id="root-age">Root Age</h3>
<hr class="subsection" />

<p>Then, the root age is calibrated using an interval around the true root age:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root_age &lt;- tree.rootAge()
root_age_delta &lt;- root_age / 5
root_age_min &lt;- root_age - root_age_delta
root_age_max &lt;- root_age + root_age_delta
root_time_real ~ dnUniform(root_age_min, root_age_max)
root_time_real.setValue(tree.rootAge())
root_time := abs( root_time_real )
</code></pre></div></div>

<p>The correct root age is obtained from the variable <code class="language-plaintext highlighter-rouge">tree</code> which was initialized
to store the correct timetree. By doing this, we are benefiting from the fact
that we know the true timetree.
When analyzing an empirical data set for which the timetree is not known, one
needs to find other ways to come up
with a reasonable prior distribution for the root age. We set a
uniform prior on the age of the root.</p>

<h3 class="subsection" id="setting-up-constraints">Setting up Constraints</h3>
<hr class="subsection" />

<p>If specified, we also load the constraints from the given file <code class="language-plaintext highlighter-rouge">contraints.txt</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (constrain) {
  out_bn = out_bn + "_cons"
  constraints &lt;- readRelativeNodeAgeConstraints(file=constraints_file)
}
</code></pre></div></div>

<p>The file <code class="language-plaintext highlighter-rouge">constraints.txt</code> stores the constraints obtained from 3 hypothetical
gene transfer events.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Contents of file `data/constraints.txt`
T0	T1	T14	T15
T7	T8	T19	T20
T3	T4	T8	T9
</code></pre></div></div>

<p>The first line <code class="language-plaintext highlighter-rouge">T0\tT1\tT14\tT15</code> tells RevBayes that the most recent common
ancestor (MRCA) of <code class="language-plaintext highlighter-rouge">T0</code> and <code class="language-plaintext highlighter-rouge">T1</code> has to be older than the MRCA of <code class="language-plaintext highlighter-rouge">T14</code> and
<code class="language-plaintext highlighter-rouge">T15</code>, and so on for the following lines. You can look for the respective nodes
on the timetree given above, and check that the constraints are actually valid.
In fact, the constraints may be helpful in that they resolve the order of
nodes having similar ages.</p>

<h3 class="subsection" id="yule-tree-model">Yule Tree Model</h3>
<hr class="subsection" />

<p>Next, we use a birth process with an unknown birth rate as a prior for the
timetree <code class="language-plaintext highlighter-rouge">psi</code>, and define some proposals for the MCMC sampler. The
proposals change the root age, scale the branches of <code class="language-plaintext highlighter-rouge">psi</code>, and slide the nodes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>################################################################################
# Tree model.

birth_rate ~ dnExp(1)
moves.append(mvScale(birth_rate, lambda=1.0, tune=true, weight=3.0))

if (!constrain) psi ~ dnBDP(lambda=birth_rate, mu=0.0, rho=1.0, rootAge=root_time, samplingStrategy="uniform", condition="survival", taxa=taxa)
if (constrain) psi ~  dnConstrainedNodeOrder(dnBDP(lambda=birth_rate, mu=0.0, rho=1.0, rootAge=root_time, samplingStrategy="uniform", condition="survival", taxa=taxa), constraints)

psi.setValue(tree)
if (debug == true) {
  print("The original time tree:")
  print(tree)
  print("The tree used in the Markov chain:")
  print(psi)
}

moves.append(mvScale(root_time_real, weight=1.0, lambda=0.1))
moves.append(mvSubtreeScale(psi, weight=1.0*n_branches))
moves.append(mvNodeTimeSlideUniform(psi, weight=1.0*n_branches))
moves.append(mvLayeredScaleProposal(tree=psi, lambda=0.1, tune=true, weight=1.0*n_branches))
</code></pre></div></div>
<h4 class="subsubsection" id="adding-node-calibrations">Adding Node Calibrations</h4>
<hr class="subsubsection" />

<p>Now, two calibrations are added. The MRCAs of <code class="language-plaintext highlighter-rouge">T1</code> and <code class="language-plaintext highlighter-rouge">T2</code>, as well as <code class="language-plaintext highlighter-rouge">T14</code>
and <code class="language-plaintext highlighter-rouge">T15</code> are fixed to be within intervals centered around their true ages
(initially, <code class="language-plaintext highlighter-rouge">psi</code> stores the true tree). The distribution
<code class="language-plaintext highlighter-rouge">dnSoftBoundUniformNormal</code> is uniform between the specified boundaries and
decreases normally out of the boundaries with the given standard deviation
(<code class="language-plaintext highlighter-rouge">sd</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>################################################################################
# Node calibrations provide information about the ages of the MRCA.

# The MRCAs of the following clades are calibrated.
clade_0 = clade("T1","T2")
clade_1 = clade("T14","T15")

# Clade 0.
tmrca_clade_0 := tmrca(psi, clade_0)
age_clade_0_mean &lt;- tmrca(psi, clade_0)
age_clade_0_delta &lt;- age_clade_0_mean / 5
age_clade_0_prior ~ dnSoftBoundUniformNormal(min=age_clade_0_mean-age_clade_0_delta, max=age_clade_0_mean+age_clade_0_delta, sd=2.5, p=0.95)
age_clade_0_prior.clamp(age_clade_0_mean)

# Clade 1.
tmrca_clade_1 := tmrca(psi, clade_1)
age_clade_1_mean &lt;- tmrca(psi, clade_1)
age_clade_1_delta &lt;- age_clade_1_mean / 5
age_clade_1_prior ~ dnSoftBoundUniformNormal(min=age_clade_1_mean-age_clade_1_delta, max=age_clade_1_mean+age_clade_1_delta, sd=2.5, p=0.95)
age_clade_1_prior.clamp(age_clade_1_mean)
</code></pre></div></div>

<h3 class="subsection" id="posterior-means-and-variances">Posterior Means and Variances</h3>
<hr class="subsection" />

<p>Finally, we read in the posterior means and variances of the branch lengths
prepared in the step 1b.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mean_tree &lt;- readTrees(mean_tree_file)[1]
var_tree &lt;- readTrees(var_tree_file)[1]
</code></pre></div></div>

<p>We re-root the timetrees and ensure that they are bifurcating. These steps are
necessary to get the correct mapping between branches, and their posterior means
and variances. Internally, it is ensured that the indices are shared correctly.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Reroot and make bifurcating.
rootId &lt;- tree.getRootIndex()
outgroup &lt;- tree.getDescendantTaxa(rootId)
mean_tree.reroot(outgroup=clade(outgroup), make_bifurcating=TRUE)
var_tree.reroot(outgroup=clade(outgroup), make_bifurcating=TRUE)

# Renumber nodes.
mean_tree.renumberNodes(tree)
var_tree.renumberNodes(tree)
</code></pre></div></div>

<p>Further, this step harbors a complication. During the first step, the reversible
JC model was used to estimate the posterior means and variances of the branch
lengths. Hence, the estimated branch-length tree is unrooted. Now, we estimate a
rooted time tree. It follows that the two branches leading to the root of the
timetree correspond to a single branch of the unrooted tree from the first step.
We have to take this into account when approximating the phylogenetic likelihood.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Get indices of left child and right child of root.
i_left &lt;- tree.child(tree.nnodes(),1)
i_right &lt;- tree.child(tree.nnodes(),2)

# Get posterior means and variances of all branches except the branches leading
# to the root.
for(i in 1:n_branches) {
  if(i != i_left &amp;&amp; i != i_right) {
    posterior_mean_bl[i] &lt;- mean_tree.branchLength(i)
    posterior_var_bl[i] := var_tree.branchLength(i)
    if (posterior_var_bl[i]&lt;var_min) posterior_var_bl[i]:=var_min
  }
}

# Get the index of the root in the time tree.
if (i_left&lt;i_right)  i_root &lt;- i_left
if (i_left&gt;=i_right) i_root &lt;- i_right

# Get the mean and variance of the branch containing the root.
posterior_mean_bl_root &lt;- mean_tree.branchLength(i_root)
posterior_var_bl_root &lt;- var_tree.branchLength(i_root)
if (posterior_var_bl_root&lt;var_min) posterior_var_bl_root:=var_min
</code></pre></div></div>

<p>Please also note that we set a minimum variance. In some extreme cases, the
posterior distribution of a branch length may be so condensed, that the variance is
too low to be used for calculating the approximate phylogenetic likelihood.</p>

<h3 class="subsection" id="relaxed-molecular-clock-model">Relaxed Molecular Clock Model</h3>
<hr class="subsection" />

<p>In the next step, we define the relaxed molecular clock model. Several of them
are available in RevBayes. Here, we decided to use an uncorrelated model. We
separate between a global rate (<code class="language-plaintext highlighter-rouge">global_rate_mean</code>) and the relative branch-wise
rates (<code class="language-plaintext highlighter-rouge">rel_branch_rates</code>). We use an uncorrelated gamma model
(UGAM). In the UGAM model, the relative branch rates are distributed according
to a gamma distribution. We use a hyper parameter <code class="language-plaintext highlighter-rouge">sigma</code> on the shape and scale
parameters of the gamma distribution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mean_tree_root_age := mean_tree.rootAge()
global_rate_mean ~ dnExp(1)
global_rate_mean.setValue(mean_tree_root_age/tree.rootAge());
sigma ~ dnExp(10.0)

first_gamma_param := 1/sigma
second_gamma_param := 1/sigma

moves.append(mvScaleBactrian(global_rate_mean, lambda=0.5, weight=10.0))
moves.append(mvScaleBactrian(sigma, lambda=0.5, weight=10.0))

# Use a Gamma distribution on rates.
for (i in n_branches:1) {
  times[i]=psi.branchLength(i)
  rel_branch_rates[i] ~ dnGamma(first_gamma_param, second_gamma_param)
  # Exclude the branches leading to the root (see above).
  if(i != i_left &amp;&amp; i != i_right) {
    rel_branch_rates[i].setValue(posterior_mean_bl[i]/times[i]/global_rate_mean)
  } else {
    # And set them to half of the branch length in the unrooted tree.
    rel_branch_rates[i].setValue(posterior_mean_bl_root/2/times[i]/global_rate_mean)
  }
  moves.append(mvScale(rel_branch_rates[i], lambda=0.5, weight=1.0,tune=true))
}

for (i in n_branches:1) {
  branch_rates[i] := global_rate_mean * rel_branch_rates[i]
}
</code></pre></div></div>

<h3 class="subsection" id="likelihood">Likelihood</h3>
<hr class="subsection" />

<p>Finally, we calculate the approximate phylogenetic likelihood. In detail, for
each branch, the length measured in substitutions is the product of the length
measured in time, and the evolutionary rate at that branch:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mean_bl[i] := times[i]*branch_rates[i]
</code></pre></div></div>

<p>The branch lengths are then distributed according to normal distributions with
the posterior means and variances obtained in the previous step:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bls[i] ~ dnNormal(mean_bl[i] ,sqrt(posterior_var_bl[i]))
</code></pre></div></div>

<p>Again, the two branches leading to the root are handled in a special way. In
total, the approximate phylogenetic likelihood is calculated like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>times[i_left] := psi.branchLength(i_left)
times[i_right] := psi.branchLength(i_right)

for(i in 1:n_branches) {
  if(i != i_left &amp;&amp; i != i_right) {
    times[i] := psi.branchLength(i)
    mean_bl[i] := times[i]*branch_rates[i]
    bls[i] ~ dnNormal(mean_bl[i] ,sqrt(posterior_var_bl[i]))
    bls[i].clamp(posterior_mean_bl[i])
  }
}

# See above.
mean_bl_root := times[i_left]*branch_rates[i_left] + times[i_right]*branch_rates[i_right]
bls[i_root] ~ dnNormal(mean_bl_root, sqrt(posterior_var_bl_root))
bls[i_root].clamp(posterior_mean_bl_root)
</code></pre></div></div>

<h3 class="subsection" id="monitors-and-mcmc">Monitors and MCMC</h3>
<hr class="subsection" />

<p>The last part of the script defines the monitors, executes the MCMC chain, and
saves the results.</p>

<p>Define the monitors:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(i in 1:n_branches)
{
  ages_psi[i] := psi.nodeAge(i)
  ages_true[i] := tree.nodeAge(i)
}
if (debug == true) {
  print("True node ages:")
  print(ages_true)
  print("Node ages of state of Markov chain:")
  print(ages_psi)
}

trees_base_name = "output/" + out_bn
trees_file_name = trees_base_name + ".trees"
monitors.append(mnModel(filename="output/"+out_bn+".log",printgen=10, separator = TAB))
monitors.append(mnStochasticVariable(filename="output/"+out_bn+"_Stoch.log",printgen=10))
monitors.append(mnExtNewick(filename=trees_file_name, isNodeParameter=FALSE, printgen=10, separator = TAB, tree=psi, branch_rates))

# Add some random age monitors.
monitors.append(mnScreen(printgen=100, root_time, ages_psi[20], ages_psi[25], ages_psi[27]))
</code></pre></div></div>

<p>Use the Metropolis-coupled Markov chain Monte Carlo algorithm:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mymodel = model(branch_rates)
mymodel = model(bls)
mymcmc = mcmcmc(mymodel, monitors, moves, nruns=1, nchains=4, tuneHeat=TRUE)
mymcmc.burnin(generations=mcmc_burnin,tuningInterval=mcmc_burnin/10)
mymcmc.operatorSummary()
mymcmc.run(generations=mcmc_length)
mymcmc.operatorSummary()
</code></pre></div></div>

<p>To perform the dating analysis, please execute twice (once
with <code class="language-plaintext highlighter-rouge">constrain = true</code>, and once with <code class="language-plaintext highlighter-rouge">constrain = false</code>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rb ./scripts/2_mcmc_dating.rev
</code></pre></div></div>

<p>The MAP trees for the analysis with calibrations only, and with calibrations and
constraints are stored in the files <code class="language-plaintext highlighter-rouge">output/alignment.fasta.approx.dating.tree</code>,
and <code class="language-plaintext highlighter-rouge">output/alignment.fasta.approx.dating_cons.tree</code>, respectively.</p>

<h2 class="section" id="analysis-of-results">Analysis of results</h2>

<p>The following figures show the inferred timetrees.</p>

<figure id="time-tree-calibrations-only"><p><img src="figures/time-tree-calibrations-only.png" width="600" /></p>
<figcaption><em>Inferred timetree using calibrations only.</em></figcaption>
</figure>

<figure id="time-tree-calibrations-and-constraints"><p><img src="figures/time-tree-calibrations-and-constraints.png" width="600" /></p>
<figcaption><em>Inferred timetree using calibrations and constraints.</em></figcaption>
</figure>

<p>We see that the constraints help improve the accuracy, as well as reduce the
confidence intervals of the node ages. Further, we can measure the distance
between the inferred timetrees, and the original timetree used for simulating
the alignment. We use the branch score distance</p>

\[d(T_1, T_2) = \sqrt{\sum_{i} \Delta_i^2},\]

<p>where $T_1$ and $T_2$ are two trees, $i$ traverses the branches, and $\Delta_i$
is the difference of the lengths of the branch in $T_1$ and $T_2$. If a branch
is only in one tree, the whole length is chosen (although this is not the case
here). The branch score distances can be calculated with any phylogenetic
software package. Here, we used <a href="https://github.com/dschrempf/elynx">ELynx</a>. The
branch score distances between the original timetree, and the inferred timetrees
are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ tlynx distance -d branch-score -f RevBayes -m data/time.tree output/alignment.fasta.approx.dating.tree output/alignment.fasta.approx.dating_cons.tree
=== tlynx
Compare, examine, and simulate phylogenetic trees.
ELynx Suite version 0.4.0.
Developed by Dominik Schrempf.
Compiled on September 19, 2020, at 13:41 pm, UTC.
Start time: October 9, 2020, at 11:29 am, UTC.
Command line: tlynx distance -d branch-score -f RevBayes -m data/time.tree output/alignment.fasta.approx.dating.tree output/alignment.fasta.approx.dating_cons.tree

Write results to standard output.
Read master tree from file: data/time.tree.
Compute distances between all trees and master tree.
Read trees from files.
Trees are named according to their file names.
Use branch score distance.
Summary statistics of Branch Score Distance:
Mean:     0.151
Median:   0.159
Variance: 0.000

Tree 1                                          Tree 2                                            Branch Score
data/time.tree                                  output/alignment.fasta.approx.dating.tree                0.159
data/time.tree                                  output/alignment.fasta.approx.dating_cons.tree           0.142
No output file given --- skip writing ELynx file for reproducible runs.
=== End time: October 9, 2020, at 11:29 am, UTC.
</code></pre></div></div>

<p>That is, using constraints helped improve the branch score distance by 11
percent.</p>

<h2 class="section" id="concluding-remarks">Concluding remarks</h2>

<p>When analyzing real data a more appropriate substitution model should be used.
Also, when the tree topology is unknown, it has to be inferred. This has to be done
beforehand. Finally, calibrations and constraints have to be obtained manually
either based on the literature or based on original research.</p>

<p>The simulations were done using a custom simulator called <code class="language-plaintext highlighter-rouge">ELynx</code>. If you are
interested, please have a look at the <a href="https://github.com/dschrempf/elynx">source code of
ELynx</a> and the <a href="https://github.com/revbayes/revbayes.github.io/tree/source/tutorials/relative_time_constraints/internal/simulate">simulation scripts for this
tutorial</a>.</p>

<ol class="bibliography"><li><span id="Szollosi2021">Szöllősi G.J., Höhna S., Williams T.A., Schrempf D., Daubin V., Boussau B. 2021. Relative time constraints improve molecular dating. Manuscript in preparation.</span>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
