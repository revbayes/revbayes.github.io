########################################################
#
# RevBayes Example: Bayesian Island Biogeography
#
# authors: Isabel Sanmartin and Sebastian Hoehna
#
########################################################

# Processes all datasets jointly.
# We assume each group has its own molecular model, but shares the biogeographic model.

# We assume that all the molecular and the biogeographic data are in
# a single file for each genus. The molecular data need to be in the
# first data matrix in each file, and the biogeographic data in the
# second data matrix. The biogeographic
# states need to be the same across groups.

# Read in all molecular data matrices into the vector D
# Read in all biogeographic matrices into the vector B
# Also set age calibrations for each group

filenames <- [  "Bystropogon",
                "Calathus",
                "Dolichoiulus",
                "Micromeria",
                "Lotus",
                "Pimelia",
                "Psyllids"
              ]



for ( i in 1:filenames.size() ) {
    X <- readDiscreteCharacterData( "data/BIB/" + filenames[i] + ".nex" )

    D[i] <- X[1]
    B[i] <- X[2]
}




# Create some vector for the moves and monitors of this analysis
moves    = VectorMoves()
monitors = VectorMonitors()


for ( i in 1:D.size() ) {

    # Define priors for elements of rate matrix
    pi_M[i] ~ dnDirichlet( v(1,1,1,1) )
    r_M[i]  ~ dnDirichlet( v(1,1,1,1,1,1) )

    # Define rate matrix
    Q_M[i] := fnGTR( r_M[i], pi_M[i] )

    # Clock rate: We use an exponential prior with expectation 1/1000=0.001
    # because the dataset is made up of chloroplast markers, which are typically between  10E-4 and 10E-3.

#    clockRate_M[i] ~ dnExponential( 1000.0 )
    clockRate_M[i] ~ dnLognormal( ln(0.001), sd=0.587405 )

    # Set tree prior parameters
    # Set bd model priors

    # Diversification prior
    # The mean of the diversification prior corresponds to an expectation
    # of 20 lineages in 3.0 Myr, i.e. exp(rT) = 20 when T = 3 and r = 1

    speciation[i] ~ dnUniform(0.0,10.0)
    extinction[i] ~ dnUniform(0.0,10.0)

    # Set the root age: anywhere from 0 to 20 Myr old
    # Age of Canary Islands goes from 0.1 (El Hierro) to 20 Ma (Fuerteventura)

    rootAge[i] ~ dnUniform( 0.000001, 20.0 )

    # We define the complete tree model

    tau[i] ~ dnBirthDeath(  lambda = speciation[i],
                            mu = extinction[i],
                            rootAge = rootAge[i],
                            rho = 1.0,
                            samplingStrategy = "uniform",
                            condition = "survival",
                            taxa = D[i].taxa()
                        )

    alpha_M[i] ~ dnUniform(0.0,1E8)
    alpha_M[i].setValue( 1.0 )

    siteRates_M[i] := fnDiscretizeGamma( alpha_M[i], alpha_M[i], 4 )

    seq_M[i] ~ dnPhyloCTMC( tree        = tau[i],
                            Q           = Q_M[i],
                            branchRates = clockRate_M[i],
                            siteRates   = siteRates_M[i],
                            type        = "DNA"
                          )

    seq_M[i].clamp( D[i] )

    # add moves
    moves.append( mvScale(clockRate_M[i],lambda=1,tune=true,weight=1) )
    moves.append( mvScale(rootAge[i],lambda=1,tune=true,weight=1) )
    moves.append( mvScale(speciation[i],lambda=1,tune=true,weight=1) )
    moves.append( mvScale(extinction[i],lambda=1,tune=true,weight=1) )
    moves.append( mvNarrow(tau[i], weight=10.0) )
    moves.append( mvNNI(tau[i], weight=10.0) )
    moves.append( mvFNPR(tau[i], weight=10.0) )
    moves.append( mvSubtreeScale(tau[i], weight=5.0) )
    moves.append( mvNodeTimeSlideUniform(tau[i], weight=10.0) )
    moves.append( mvScale(alpha_M[i], lambda=1, tune=true, weight=1.0) )

    up_down_scale[i] = mvUpDownScale(weight=2)
    up_down_scale[i].addVariable(tau[i], up=TRUE)
    up_down_scale[i].addVariable(rootAge[i], up=TRUE)
    up_down_scale[i].addVariable(clockRate_M[i], up=FALSE)
    moves.append( up_down_scale[i] )

    monitors.append( mnFile( tau[i], filename = "output_BIB/" + filenames[i] + ".trees", printgen = 10 ) )

}


# Setting the BIB biogeographic model shared by all clades

# We assume following state codes (0-offset in Nexus file, 1-offset here)
# 0 1 Eastern Islands (Fuerteventura, Lanzarote)
# 1 2 Central Islands (Tenerife, Gran Canaria, Gomera)
# 2 3 Western Islands (El Hierro, La Palma)
# 3 4 Mainland

# Define the island carrying capacities and biotic exchange intensities
pi_bio ~ dnDirichlet( v(1,1,1,1) )
r_bio  ~ dnDirichlet( v(1,1,1,1,1,1) )

moves.append( mvBetaSimplex(pi_bio, alpha=10.0, tune=true, weight=4.0) )
moves.append( mvBetaSimplex(r_bio, alpha=10.0, tune=true, weight=6.0) )


# Define thes biogeographic rate matrix
Q_bio := fnGTR( r_bio, pi_bio )


# Migration rate is defined in units of time; prior is derived
# assuming an expected rate of 1.0 island switches/Myr. We want
# a fairly vague prior because the uncertainty is considerable.
# Here we use a gamma(1,1)=exp(1) prior. It has 50 % credible
# set (0.29,1.39) and 95 % set (0.025,3.69).

for ( i in 1:B.size() ) {

  migrationRates[i] ~ dnGamma( 1.0, 1.0 )

  # Biogeography model, assuming that tau is in time units
  bio[i] ~ dnPhyloCTMC(   tree            = tau[i],
                          Q               = Q_bio,
                          rootFrequencies = pi_bio,
                          branchRates     = migrationRates[i],
                          nSites          = 1,
                          type            = "Standard"
                      )

  bio[i].clamp( B[i] )


  # Add moves for the biogeography part of the model
  # assuming that the molecular evolution moves are already
  # in the vector moves
  moves.append( mvScale(migrationRates[i],lambda=1,tune=true,weight=1) )

}

mymodel = model(Q_bio)


# Screen and model monitors
monitors.append( mnModel(filename = "output_BIB/all_params.log", printgen = 10) )
monitors.append( mnScreen(printgen = 10, pi_bio) )

mymcmc = mcmc( mymodel, monitors, moves, nruns=2, combine="mixed" )
mymcmc.run( generations=50000, tuningInterval=200 )


q()
