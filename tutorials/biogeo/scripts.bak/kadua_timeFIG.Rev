
####################################################
# IMPORTANT: set `tensorphylo_fp` to the directory #
# containing your `libTensorPhylo.a/dylib` library #
####################################################


###########################
# LOAD TENSORPHYLO PLUGIN #
###########################

tensorphylo_fp = "/Users/mlandis/.local/lib/tensorphylo"
if (!exists("tensorphylo_fp")) {
  tensorphylo_fp = "~/.plugins/"
}
loadPlugin("TensorPhylo", tensorphylo_fp)

#######################
# INITIALIZE SETTINGS # 
#######################

# RNG seed
if (!exists("my_seed"))           my_seed = 1
seed(my_seed)

# Toggle a default settings with `!`, e.g. `!true` is `false`
# The analysis filename will indicate non-default settings
if (!exists("init_parameters"))   init_parameters  = true

if (!exists("use_features"))      use_features     = true
if (!exists("use_paleogeo"))      use_paleogeo     = true
if (!exists("under_prior"))       under_prior      = false

if (!exists("use_rj"))            use_rj           = true
if (!exists("move_schedule"))     move_schedule    = v("random","single")[1]

# benchmarking
if (!exists("rel_tol"))           rel_tol = 1e-7
if (!exists("abs_tol"))           abs_tol = 1e-7

# param init
if (!exists("rho_d_init"))        rho_d_init   = 0.1
if (!exists("rho_e_init"))        rho_e_init   = 0.1
if (!exists("rho_w_init"))        rho_w_init   = 0.1
if (!exists("rho_b_init"))        rho_b_init   = 0.1
if (!exists("phi_d_init"))        phi_d_init   = 0.0
if (!exists("phi_e_init"))        phi_e_init   = 0.0
if (!exists("phi_w_init"))        phi_w_init   = 0.0
if (!exists("phi_b_init"))        phi_b_init   = 0.0
if (!exists("sigma_d_init"))      sigma_d_init = 0.0
if (!exists("sigma_b_init"))      sigma_b_init = 0.0
if (!exists("sigma_e_init"))      sigma_e_init = 0.0
if (!exists("sigma_w_init"))      sigma_w_init = 0.0

# dataset constraints
if (!exists("max_subrange_split_size")) max_subrange_split_size = 7
if (!exists("max_range_size"))    max_range_size = 4

# analysis string name
analysis                                    = "timeFIG_model"
if (!use_features)                analysis += "_noFeatures"
if (!use_paleogeo)                analysis += "_noPaleogeo"
if (under_prior)                  analysis += "_underPrior"
if (!use_rj)                      analysis += "_noRjmcmc"
analysis += "_seed" + my_seed

print("Analysis name: ", analysis)

# analysis settings
n_proc          = 6
n_iter          = 10000
print_gen       = 1
stoch_print_gen = 20

# filesystem
clade_name    = "kadua"
fp            = "./"
dat_fp        = fp + "data/clade/"
geo_fp        = fp + "data/geo/"
code_fp       = fp + "scripts/timefig_model/"
feature_fn    = geo_fp + "feature_summary.csv"
phy_fn        = dat_fp + clade_name + ".tre"
bg_fn         = dat_fp + clade_name + "_range.nex"
label_fn      = dat_fp + clade_name + "_range_label.csv"

# model source code
geo_code_fn   = code_fp + "geo_timeFIG.Rev"
phylo_code_fn = code_fp + "phylo_timeFIG.Rev"

# get phylogenetic data
phy          <- readTrees(phy_fn)[1]
phy.rescale( 5./phy.rootAge() )
tree_height  <- phy.rootAge()
taxa         = phy.taxa()
num_taxa     = taxa.size()
num_branches = 2 * num_taxa - 2

# get biogeographic data
dat_01       = readDiscreteCharacterData(bg_fn)
num_regions  = dat_01.nchar()
num_ranges   = 0
for (k in 1:max_range_size) {
    num_ranges += choose(num_regions, k)
}
dat_nn       = formatDiscreteCharacterData(dat_01, format="GeoSSE", numStates=num_ranges)
desc         = dat_nn.getStateDescriptions()

write("index,range\n", filename=label_fn)
for (i in 1:desc.size()) {
    write((i-1) + "," + desc[i] + "\n", filename=label_fn, append=true)
}

# load geography model script
source( geo_code_fn )

# load phylogeny model script
source( phylo_code_fn )

# associate phylo/biogeo data with model
timetree.setValue(phy)
timetree.clampCharData(dat_nn)

print("Creating moves...")

# create moves
moves = VectorMoves()

# base rates
moves.append( mvScale(rho_d, weight=5) )
moves.append( mvScale(rho_e, weight=5) )
moves.append( mvScale(rho_w, weight=5) )
moves.append( mvScale(rho_b, weight=5) )

if (use_features) {
    for (i in 1:sigma_e.size()) {
        moves.append( mvScale(sigma_e[i], weight=2) )
        moves.append( mvScale(sigma_w[i], weight=2) )
        moves.append( mvSlide(sigma_e[i], weight=2) )
        moves.append( mvSlide(sigma_w[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(sigma_e[i], weight=3) )
            moves.append( mvRJSwitch(sigma_w[i], weight=3) )
            use_sigma_e[i] := ifelse(sigma_e[i] == 0.0, 0, 1)
            use_sigma_w[i] := ifelse(sigma_w[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:sigma_d.size()) {
        moves.append( mvScale(sigma_d[i], weight=2) )
        moves.append( mvScale(sigma_b[i], weight=2) )
        moves.append( mvSlide(sigma_d[i], weight=2) )
        moves.append( mvSlide(sigma_b[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(sigma_d[i], weight=3) )
            moves.append( mvRJSwitch(sigma_b[i], weight=3) )
            use_sigma_d[i] := ifelse(sigma_d[i] == 0.0, 0, 1)
            use_sigma_b[i] := ifelse(sigma_b[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:phi_e.size()) {
        moves.append( mvScale(phi_e[i], weight=2) )
        moves.append( mvScale(phi_w[i], weight=2) )
        moves.append( mvSlide(phi_e[i], weight=2) )
        moves.append( mvSlide(phi_w[i], weight=2) )
        if (use_rj) {
            moves.append( mvRJSwitch(phi_e[i], weight=3) )
            moves.append( mvRJSwitch(phi_w[i], weight=3) )
            use_phi_e[i] := ifelse(phi_e[i] == 0.0, 0, 1)
            use_phi_w[i] := ifelse(phi_w[i] == 0.0, 0, 1)
        }
    }
    for (i in 1:phi_d.size()) {
        moves.append( mvScale(phi_d[i], weight=2) )
        moves.append( mvScale(phi_b[i], weight=2) )
        moves.append( mvSlide(phi_d[i], weight=2) )
        moves.append( mvSlide(phi_b[i], weight=2) )   
     if (use_rj) {
            moves.append( mvRJSwitch(phi_d[i], weight=3) )
            moves.append( mvRJSwitch(phi_b[i], weight=3) )
            use_phi_d[i] := ifelse(phi_d[i] == 0.0, 0, 1)
            use_phi_b[i] := ifelse(phi_b[i] == 0.0, 0, 1)
        }
    }
} else {
    # set all feature effect parameters to zero;
    # do not add moves to update during MCMC
    for (i in 1:sigma_e.size()) {
        sigma_e[i].setValue(0.0)
        sigma_w[i].setValue(0.0)
    }
    for (i in 1:sigma_d.size()) {
        sigma_d[i].setValue(0.0)
        sigma_b[i].setValue(0.0)
    }
    for (i in 1:phi_e.size()) {
        phi_e[i].setValue(0.0)
        phi_w[i].setValue(0.0)
    }
    for (i in 1:phi_d.size()) {
        phi_d[i].setValue(0.0)
        phi_b[i].setValue(0.0)
    }
}

############
# Monitors #
############

print("Creating monitors...")
# create monitor vector
monitors = VectorMonitors()
# screen monitor, so you don't get bored
monitors.append( mnScreen(root_age, printgen=print_gen) )
# file monitor for all simple model variables
monitors.append( mnModel(printgen=print_gen, file="output/" + analysis + ".model.txt") )
# file monitor for biogeographic model
for (k in 1:num_times) {
    bg_mon_filename = "output/" + analysis + ".time" + k + ".bg.txt"
    monitors.append( mnFile(filename = bg_mon_filename,printgen=print_gen,rho_e, rho_w, rho_d, rho_b, r_e[k], r_w[k], r_d[k][1], r_d[k][2], r_d[k][3], r_d[k][4], r_d[k][5], r_d[k][6], r_b[k][1], r_b[k][2], r_b[k][3], r_b[k][4], r_b[k][5], r_b[k][6], m_e[k][1], m_w[k][1], m_d[k][1], m_d[k][2], m_d[k][3], m_d[k][4], m_d[k][5], m_d[k][6], m_b[k][1], m_b[k][2], m_b[k][3], m_b[k][4], m_b[k][5], m_b[k][6]))
}
monitors.append( mnFile(filename="output/"+analysis+".param.json", printgen=print_gen, format="json",
                        rho_e, rho_w, rho_d, rho_b, r_e, r_w, r_d, r_b, m_e, m_w, m_d, m_b) )

# ancestral estimates
monitors.append( mnJointConditionalAncestralState(tree=timetree, glhbdsp=timetree, printgen=print_gen*stoch_print_gen, filename="output/" + analysis + ".states.txt", withTips=true, withStartStates=true, type="NaturalNumbers") ) 

# create model object
print("Creating model...")
mymodel = model(timetree)

# create MCMC object
print("Creating MCMC...")
mymcmc = mcmc(mymodel, moves, monitors, moveschedule=move_schedule)
mymcmc.operatorSummary()

# run MCMC
print("Running MCMC...")
mymcmc.run(n_iter, underPrior=under_prior)

# done!
quit()
