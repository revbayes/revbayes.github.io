<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Nucleotide substitution models</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Nucleotide substitution models</h1>
	<h3 class="subtitle">Phylogenetic inference of nucleotide data using RevBayes</h3>
	<h4 class="authors">Sebastian Höhna, Michael Landis, Brian Moore and Tracy Heath</h4>
  <h5>Last modified on June  5, 2025</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/ctmc/data/primates_and_galeopterus_cytb.nex">primates_and_galeopterus_cytb.nex</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/ctmc/scripts/asides.Rev">asides.Rev</a></li>
        
          <li><a href="/tutorials/ctmc/scripts/mcmc_GTR.Rev">mcmc_GTR.Rev</a></li>
        
          <li><a href="/tutorials/ctmc/scripts/mcmc_GTR_Gamma_Inv.Rev">mcmc_GTR_Gamma_Inv.Rev</a></li>
        
          <li><a href="/tutorials/ctmc/scripts/mcmc_HKY.Rev">mcmc_HKY.Rev</a></li>
        
          <li><a href="/tutorials/ctmc/scripts/mcmc_JC.Rev">mcmc_JC.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<p>This tutorial comes with a recorded video walkthrough. The video corresponding to each section of the exercise is linked next to the section title. The full playlist is available here: <a href="https://www.youtube.com/playlist?list=PLztACvN0g42t9pLJpeUel-ynfuNdWOsa4"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough playlist" height="36" width="36" /></a></p>

<h2 class="section" id="overview">Overview</h2>
<hr class="section" />

<p><a href="https://youtu.be/x4ADIyqbYGM"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>This tutorial covers the first protocol from <a class="citation" href="#Hoehna2017a">Höhna et al. (2017)</a>,
which demonstrates how to set up and perform analyses
using common nucleotide substitution models. The substitution models
used in molecular evolution are continuous time Markov models, which are
fully characterized by their instantaneous-rate matrix:</p>

\[Q = \begin{pmatrix}
-\mu_A &amp; \mu_{AC} &amp; \mu_{AG} &amp; \mu_{AT} \\
\mu_{CA} &amp; -\mu_C  &amp; \mu_{CG} &amp; \mu_{CT} \\
\mu_{GA} &amp; \mu_{GC} &amp; -\mu_C  &amp; \mu_{GT} \\
\mu_{TA} &amp; \mu_{TC} &amp; \mu_{TG} &amp; -\mu_T
\end{pmatrix} \mbox{  ,}\]

<p>where $\mu_{ij}$ represents the instantaneous rate of substitution from
state $i$ to state $j$. The diagonal elements $\mu_i$ are the rates of
<em>not</em> changing out of state $i$, equal to the sum of the elements in the
corresponding row. Given the instantaneous-rate matrix, $Q$, we can
compute the corresponding transition probabilities for a branch of
length $t$, $P(t)$, by exponentiating the rate matrix:</p>

\[P(t) = \begin{pmatrix}
p_{AA}(t) &amp; p_{AC}(t) &amp; p_{AG}(t) &amp; p_{AT}(t) \\
p_{CA}(t) &amp; p_{CC}(t) &amp; p_{CG}(t) &amp; p_{CT}(t) \\
p_{GA}(t) &amp; p_{GC}(t) &amp; p_{GG}(t) &amp; p_{GT}(t) \\
p_{TA}(t) &amp; p_{TC}(t) &amp; p_{TG}(t) &amp; p_{TT}(t)
\end{pmatrix} = e^{Qt} = \sum_{j=0}^\infty\frac{(Qt)^j}{j!} \mbox{  .}\]

<p>Each of the named substitution models (e.g., HKY or GTR) has a uniquely defined
instantaneous-rate matrix, $Q$.</p>

<p>In this tutorial you will perform phylogeny inference under common
models of DNA sequence evolution: JC, F81, HKY85, GTR, GTR+Gamma and
GTR+Gamma+I. For all of these substitution models, you will perform a
Markov chain Monte Carlo (MCMC) analysis to estimate phylogeny and other model parameters. The
estimated trees will be unrooted trees with independent branch-length
parameters. We will provide comments on how to modify the tutorial if
you wish to estimate rooted, clock-like trees. All the assumptions will
be covered in more detail later in this tutorial.</p>

<figure id="tab_subst_models" class="table"><figcaption class="table">Specific functions for substitution models available in RevBayes.</figcaption>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>Model</strong></th>
      <th style="text-align: center"><strong>Reference</strong></th>
      <th style="text-align: center"><strong>Function</strong></th>
      <th style="text-align: center"><strong>Parameters</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Jukes-Cantor</td>
      <td style="text-align: center"><a class="citation" href="#Jukes1969">(Jukes and Cantor 1969)</a></td>
      <td style="text-align: center">fnJC</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: center">K80 (a.k.a. K2P)</td>
      <td style="text-align: center"><a class="citation" href="#Kimura1980">(Kimura 1980)</a></td>
      <td style="text-align: center">fnK80</td>
      <td style="text-align: center">$\kappa$</td>
    </tr>
    <tr>
      <td style="text-align: center">Felsenstein-81</td>
      <td style="text-align: center"><a class="citation" href="#Felsenstein1981">(Felsenstein 1981)</a></td>
      <td style="text-align: center">fnF81</td>
      <td style="text-align: center">$\pi$</td>
    </tr>
    <tr>
      <td style="text-align: center">T92</td>
      <td style="text-align: center"><a class="citation" href="#Tamura1992">(Tamura 1992)</a></td>
      <td style="text-align: center">fnT92</td>
      <td style="text-align: center">$\pi_{GC}$, $\kappa$</td>
    </tr>
    <tr>
      <td style="text-align: center">HKY</td>
      <td style="text-align: center"><a class="citation" href="#Hasegawa1985">(Hasegawa et al. 1985)</a></td>
      <td style="text-align: center">fnHKY</td>
      <td style="text-align: center">$\pi$, $\kappa$</td>
    </tr>
    <tr>
      <td style="text-align: center">GTR</td>
      <td style="text-align: center"><a class="citation" href="#Tavare1986">(Tavaré 1986)</a></td>
      <td style="text-align: center">fnGTR</td>
      <td style="text-align: center">$\pi$, $\epsilon$</td>
    </tr>
  </tbody>
</table>
</figure>

<h2 class="section" id="example-character-evolution-under-the-jukes-cantor-substitution-model">Example: Character Evolution under the Jukes-Cantor Substitution Model</h2>
<hr class="section" />

<p><a href="https://youtu.be/z-94P0d10us"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>
<h3 class="subsection" id="getting-started">Getting Started</h3>
<hr class="subsection" />

<p>The first section of this exercise involves:</p>
<ol>
  <li>setting up a Jukes-Cantor (JC) substitution model for an alignment of the cytochrome b subunit;</li>
  <li>approximating the posterior probability of the tree topology and node ages (and all other parameters) using MCMC, and;</li>
  <li>summarizing the MCMC output by computing the maximum <em>a posteriori</em> tree.</li>
</ol>

<figure id="jc_graphical_model"><p><img src="figures/jc_graphical_model.png" /></p>
<figcaption>Graphical model representation of a simple phylogenetic model. The graphical model shows the dependencies among parameters <a class="citation" href="#Hoehna2014b">(Höhna et al. 2014)</a>. Here, the rate matrix $Q$ is a constant variable because it is fixed and does not depend on any parameter. The only free parameters of this model, the Jukes-Cantor model, are the tree $\Psi$ including the branch lengths.</figcaption>
</figure>

<p>We first consider the simplest substitution model described by
<a class="citation" href="#Jukes1969">Jukes and Cantor (1969)</a>. The instantaneous-rate matrix for the JC substitution
model is defined as</p>

\[Q_{JC69} = \begin{pmatrix}
{*} &amp; \frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{3} \\
\frac{1}{3} &amp; {*} &amp; \frac{1}{3} &amp; \frac{1}{3} \\
\frac{1}{3} &amp; \frac{1}{3} &amp; {*} &amp; \frac{1}{3} \\
\frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{3} &amp; {*}
\end{pmatrix} \mbox{  ,}\]

<p>which has the advantage that the transition probability matrix can be
computed analytically</p>

\[P_{JC69} = \begin{pmatrix} {\frac{1}{4} + \frac{3}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} + \frac{3}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} + \frac{3}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-rt}} &amp; {\frac{1}{4} + \frac{3}{4}e^{-rt}}
\end{pmatrix} \mbox{  ,}\]

<p>where $t$ is the branch length in units of time, and $r$ is the rate (clock) for the process. In the later exercises you will be asked to specify more complex substitution models. <strong>Don’t worry, you won’t have to calculate all of the transition probabilities, because RevBayes will take care of all the computations for you.</strong> Here we only provide some of the equations for the models in case you might be interested in the details. You will be able to complete the exercises without understanding the underlying math.</p>

<p>The files for this example analysis are provided for you (<a href="scripts/mcmc_JC.Rev"><code class="language-plaintext highlighter-rouge">mcmc_JC.Rev</code></a>).
If you download this file and place it in a directory called <code class="language-plaintext highlighter-rouge">scripts</code> inside your main tutorial directory,
you can
easily execute this analysis using the <code class="language-plaintext highlighter-rouge">source()</code> function in the RevBayes console:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mcmc_JC.Rev")
</code></pre></div></div>

<p>If everything loaded properly, then you should see the program initiate
the Markov chain Monte Carlo analysis that estimates the posterior
distribution. If you continue to let this run, then you will see it
output the states of the Markov chain once the MCMC analysis begins.</p>

<p>Ultimately, this is how you will execute most analyses in RevBayes, with the full specification of the model and analyses contained in the sourced files. You could easily run this entire analysis on your own data by substituting your data file name for that in the model-specification file. However, it is important to understand the components of the model to be able to take full advantage of the flexibility and richness of RevBayes. Furthermore, without inspecting the Rev scripts sourced in <code class="language-plaintext highlighter-rouge">mcmc_JC.Rev</code>, you may end up inadvertently performing inappropriate analyses on your dataset, which would be a waste of your time and CPU cycles. The next steps will walk you through the full specification of the model and MCMC analyses.</p>

<h3 class="subsection" id="loading-the-data">Loading the Data</h3>
<hr class="subsection" />

<p><a href="https://youtu.be/kU-6WEv0mRQ"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<blockquote class="instruction">
  <p>First create a directory for this tutorial and name it <code class="language-plaintext highlighter-rouge">RB_CTMC_Tutorial</code>, or any name
you like.</p>

  <p>Navigate to this new directory and create a new folder called <code class="language-plaintext highlighter-rouge">data</code> inside of it.</p>

  <p>Download the data file called <a href="data/primates_and_galeopterus_cytb.nex"><code class="language-plaintext highlighter-rouge">primates_and_galeopterus_cytb.nex</code></a>
and save it to the <code class="language-plaintext highlighter-rouge">data</code> directory.</p>

  <p>Now start RevBayes from your working directory (<code class="language-plaintext highlighter-rouge">RB_CTMC_Tutorial</code>).</p>
</blockquote>

<blockquote class="aside"><h2>Checking and Changing Your Working Directory</h2><p>For this tutorial and much of the work you will do in RevBayes, you will need to access files.
It is important that you are aware of your current working directory if you use relative file paths
in your Rev scripts or in the RevBayes console.</p>

<p>To check your current working directory, use the function <code class="language-plaintext highlighter-rouge">getwd()</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getwd()
</code></pre></div></div>
<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/Users/tombayes/Work
</code></pre></div></div>

<p>If you want to change the directory, enter the path to your directory in the arguments of the function <code class="language-plaintext highlighter-rouge">setwd()</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setwd("Tutorials/RB_CTMC_Tutorial")
</code></pre></div></div>

<p>Now check your directory again to make sure you are where you want to be:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getwd()
</code></pre></div></div>
<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/Users/tombayes/Work/Tutorials/RB_CTMC_Tutorial
</code></pre></div></div>
</blockquote>

<p>First load in the sequences using the <code class="language-plaintext highlighter-rouge">readDiscreteCharacterData()</code>
function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data = readDiscreteCharacterData("data/primates_and_galeopterus_cytb.nex")
</code></pre></div></div>

<p>Executing these lines initializes the data matrix as the respective
Rev variables. To report the current value of any variable, simply
type the variable name and press enter. For the <code class="language-plaintext highlighter-rouge">data</code> matrix, this
provides information about the alignment:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data
</code></pre></div></div>
<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   DNA character matrix with 23 taxa and 1102 characters
   =====================================================
   Origination:                   "primates_and_galeopterus_cytb.nex"
   Number of taxa:                23
   Number of included taxa:       23
   Number of characters:          1102
   Number of included characters: 1102
   Datatype:                      DNA
</code></pre></div></div>

<p>Next we will specify some useful variables based on our dataset. The variable <code class="language-plaintext highlighter-rouge">data</code> has <em>member functions</em>
that we can use to retrieve information about the dataset. These include, for example,
the number of species and the taxa.</p>

<p>To check all available <em>member functions</em>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data.methods()
</code></pre></div></div>

<p>We will need taxon information for setting up different parts of our model.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num_taxa &lt;- data.ntaxa()
num_branches &lt;- 2 * num_taxa - 3
taxa &lt;- data.taxa()
</code></pre></div></div>

<p>Additionally, we set up a (vector) variable that holds all the moves for our analysis.
Recall that moves are algorithms used to propose new parameter values during the MCMC simulation.
Similarly, we set up a variable for the monitors.
Monitors print the values of model parameters to the screen and/or log files during the MCMC analysis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves    = VectorMoves()
monitors = VectorMonitors()
</code></pre></div></div>

<p>You may have noticed that we used the <code class="language-plaintext highlighter-rouge">=</code> operator to create the move index.
This simply means that the variable is not part of the model.
You will later see that we use this operator more often, e.g., when we create moves and monitors.</p>

<p>With the data loaded, we can now proceed to specify our specifying the model.</p>

<h3 class="subsection" id="setting-up-the-graphical-model-and-mcmc">Setting up the Graphical Model and MCMC</h3>
<hr class="subsection" />

<p>Estimating an unrooted tree under the JC model requires specification of two main components:
(1) the <a href="#subsub-JCMod"></a> and (2) the <a href="#subsub-TreeBlMod"></a>.</p>

<h4 class="subsubsection" id="subsub-JCMod">Jukes-Cantor Substitution Model</h4>
<hr class="subsubsection" />

<p><a href="https://youtu.be/S1XTkUOWTLo"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>A given substitution model is defined by its corresponding
instantaneous-rate matrix, $Q$. The Jukes-Cantor substitution model does
not have any free parameters (as the substitution rates are all assumed
to be equal, and there is a separate parameter that scales their overall
magnitude), so we can define it as a constant variable. The function
<code class="language-plaintext highlighter-rouge">fnJC(n)</code> will create an instantaneous-rate matrix for a character with
$n$ states. Since we use DNA data here, we create a 4x4
instantaneous-rate matrix:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q &lt;- fnJC(4)
</code></pre></div></div>

<p>You can see the rates of the $Q$ matrix by typing</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q
</code></pre></div></div>
<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   [ [ -1.0000, 0.3333, 0.3333, 0.3333 ] ,
     [ 0.3333, -1.0000, 0.3333, 0.3333 ] ,
     [ 0.3333, 0.3333, -1.0000, 0.3333 ] ,
     [ 0.3333, 0.3333, 0.3333, -1.0000 ] ]
</code></pre></div></div>

<p>As you can see, all substitution rates are equal.</p>

<h4 class="subsubsection" id="subsub-TreeBlMod">Tree Topology and Branch Lengths</h4>
<hr class="subsubsection" />

<p>The tree topology and branch lengths are stochastic nodes in our phylogenetic model.
In <a href="#jc_graphical_model"></a>, the tree topology is denoted $\Psi$ and the
length of the branch leading to node $i$ is $bl_i$.</p>

<p>We will assume that all possible labeled, unrooted tree topologies have equal probability.
This is the <code class="language-plaintext highlighter-rouge">dnUniformTopology()</code> distribution in RevBayes.
Note that in RevBayes it is advisable to specify the outgroup for your study system
if you use an unrooted tree prior, whereas other software, <em>e.g.</em>,
MrBayes uses the first taxon in the data matrix file as the outgroup.
Providing RevBayes with an outgroup clade will enable the monitor writing the trees
to file to orient the topologies with the outgroup clade at the base,
thus making the trees easier to visualize.
Specify the <code class="language-plaintext highlighter-rouge">topology</code> stochastic node by passing in the list of <code class="language-plaintext highlighter-rouge">taxa</code>
to the <code class="language-plaintext highlighter-rouge">dnUniformTopology()</code> distribution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>out_group = clade("Galeopterus_variegatus")
topology ~ dnUniformTopology(taxa, outgroup=out_group)
</code></pre></div></div>

<p>Some types of stochastic nodes can be updated by a number of alternative moves.
Different moves may explore parameter space in different ways,
and it is possible to use multiple different moves for a given parameter to improve mixing
(the efficiency of the MCMC simulation).
In the case of our unrooted tree topology, for example, we can use both a nearest-neighbor interchange move (<code class="language-plaintext highlighter-rouge">mvNNI</code>) and a subtree-prune and regrafting move (<code class="language-plaintext highlighter-rouge">mvSPR</code>). These moves do not have tuning parameters associated with them, thus you only need to pass in the <code class="language-plaintext highlighter-rouge">topology</code> node and proposal <code class="language-plaintext highlighter-rouge">weight</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvNNI(topology, weight=num_taxa) )
moves.append( mvSPR(topology, weight=num_taxa/10) )
</code></pre></div></div>

<p>The weight specifies how often the move will be applied either on average per iteration or relative to all other moves. Have a look at the MCMC Diagnosis tutorial for more details about moves and MCMC strategies (found in <a href="/tutorials/">Tutorials</a>).</p>

<p>Next we have to create a stochastic node representing the length of each of the $2N - 3$ branches in our tree (where $N=$ <code class="language-plaintext highlighter-rouge">n_species</code>). We can do this using a <code class="language-plaintext highlighter-rouge">for</code> loop — this is a plate in our graphical model. In this loop, we can create each of the branch-length nodes and assign each move. Copy this entire block of Rev code into the console:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:num_branches) {
    bl[i] ~ dnExponential(10.0)
    moves.append( mvScale(bl[i]) )
}
</code></pre></div></div>

<p>It is convenient for monitoring purposes to add the tree length as deterministic variable. The tree length is simply the sum of all branch lengths. Accordingly, the tree length can be computed using the <code class="language-plaintext highlighter-rouge">sum()</code> function, which calculates the sum of any vector of values.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TL := sum(bl)
</code></pre></div></div>

<p>Finally, we can create a <em>phylogram</em> (a phylogeny in which the branch lengths are proportional to the expected number of substitutions/site) by combining the tree topology and branch lengths. We do this using the <code class="language-plaintext highlighter-rouge">treeAssembly()</code> function, which applies the value of the $i^{th}$ member of the <code class="language-plaintext highlighter-rouge">br_lens</code> vector to the branch leading to the $i^{th}$ node in <code class="language-plaintext highlighter-rouge">topology</code>. Thus, the <code class="language-plaintext highlighter-rouge">psi</code> variable is a deterministic node:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi := treeAssembly(topology, bl)
</code></pre></div></div>

<blockquote class="aside"><h2>Alternative tree priors</h2><p>For large phylogenetic trees, i.e., with more than 200 taxa, it might be easier to specify a combined topology and branch length prior distribution.
We can achieve this by simple using the distribution <code class="language-plaintext highlighter-rouge">dnUniformTopologyBranchLength()</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>br_len_lambda &lt;- 10.0

psi ~ dnUniformTopologyBranchLength(taxa, branchLengthDistribution=dnExponential(br_len_lambda))

moves.append( mvNNI(psi, weight=num_taxa) )
moves.append( mvSPR(psi, weight=num_taxa/10.0) )
moves.append( mvBranchLengthScale(psi, weight=num_branches) )
</code></pre></div></div>

<p>You might think that this approach is in fact simpler than the <code class="language-plaintext highlighter-rouge">for</code> loop that we explained above.
We still think that it is pedagogical to specify the prior on each branch length separately in this tutorial to emphasize all components of the model.</p>
</blockquote>

<blockquote class="aside"><h2>Alternative branch-length priors</h2><p>Some studies, <em>e.g.</em> <a class="citation" href="#Brown2010">Brown et al. (2010), Rannala et al. (2012)</a>,
have criticized the exponential prior distribution for branch lengths
because it induces a gamma-distributed tree-length and the mean of this gamma distribution
grows with the number of taxa. As an alternative, we can instead use a specific gamma prior distribution
(or any other distribution defined on a positive real variable) for the tree length,
and then use a Dirichlet prior distribution to break the tree length into
the corresponding branch lengths <a class="citation" href="#Zhang2012">(Zhang et al. 2012)</a>.</p>

<p>First, specify a prior distribution on the tree length with your desired mean.
For example, we use a gamma distribution as our prior on the tree length.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TL ~ dnGamma(2,4)
moves.append( mvScale(TL) )
</code></pre></div></div>

<p>Now we create a random variable for the relative branch lengths.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rel_branch_lengths ~ dnDirichlet( rep(1.0,num_branches) )
moves.append( mvBetaSimplex(rel_branch_lengths, weight=num_branches) )
moves.append( mvDirichletSimplex(rel_branch_lengths, weight=num_branches/10.0) )
</code></pre></div></div>

<p>Finally, transform the relative branch lengths into actual branch lengths</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>br_lens := rel_branch_lengths * TL
</code></pre></div></div>
</blockquote>

<blockquote class="aside"><h2>Alternative Prior on Time-Trees: Tree Topology and Node Ages</h2><p>Alternatively, you may want to specify a prior on time-trees.
Here we will briefly indicate how to specify such an prior which will lead to inference of time trees.</p>

<p>The tree (the topology and node ages) is a stochastic node in our phylogenetic model.
For simplicity, we will assume a uniform prior on both topologies and node ages.
The distribution in RevBayes is <code class="language-plaintext highlighter-rouge">dnUniformTimeTree()</code>.</p>

<p>Fore more information on tree priors, such as birth-death processes, please read the <a href="/tutorials/clocks/">Relaxed Clocks &amp; Time Trees</a>.</p>

<p>First, we need to specify the age of the tree:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root_age &lt;- 10.0
</code></pre></div></div>

<p>Here we simply assumed that the tree is 10.0 time units old. We could also specify a prior on the root age if we have fossil calibrations (see <a href="/tutorials/clocks/">Relaxed Clocks &amp; Time Trees</a>). Next, we specify the <code class="language-plaintext highlighter-rouge">tree</code> stochastic variable by passing in the taxon information <code class="language-plaintext highlighter-rouge">taxa</code> to the <code class="language-plaintext highlighter-rouge">dnUniformTimeTree()</code> distribution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi ~ dnUniformTimeTree(rootAge=root_age, taxa=taxa)
</code></pre></div></div>

<p>Some types of stochastic nodes can be updated by a number of alternative moves.
Different moves may explore parameter space in different ways,and it is possible to use
multiple different moves for a given parameter to improve mixing
(the efficiency of the MCMC simulation). In the case of our rooted tree,
for example, we can use both a nearest-neighbor interchange move without and with changing
the node ages (<code class="language-plaintext highlighter-rouge">mvNarrow</code> and <code class="language-plaintext highlighter-rouge">mvNNI</code>) and a fixed-node-height subtree-prune and regrafting
move (<code class="language-plaintext highlighter-rouge">mvFNPR</code>) and its Metropolized-Gibbs variant (<code class="language-plaintext highlighter-rouge">mvGPR</code>) <a class="citation" href="#Hoehna2008">(Höhna et al. 2008; Höhna and Drummond 2012)</a>.
We also need moves that change the ages of the internal nodes, for example, <code class="language-plaintext highlighter-rouge">mvSubtreeScale</code>
and <code class="language-plaintext highlighter-rouge">mvNodeTimeSlideUniform</code>. These moves do not have tuning parameters associated with
them, thus you only need to pass in the <code class="language-plaintext highlighter-rouge">psi</code> node and proposal <code class="language-plaintext highlighter-rouge">weight</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvNarrow(psi, weight=num_taxa) )
moves.append( mvNNI(psi, weight=num_taxa/5.0) )
moves.append( mvFNPR(psi, weight=num_taxa/5.0) )
moves.append( mvGPR(psi, weight=num_taxa/30.0) )
moves.append( mvSubtreeScale(psi, weight=num_taxa/3.0) )
moves.append( mvNodeTimeSlideUniform(psi, weight=num_taxa) )
</code></pre></div></div>

<p>The weight specifies how often the move will be applied either on average per iteration or relative to all other moves. Have a look at the <a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a> for more details about moves and MCMC strategies.</p>

<h4 class="subsubsection" id="molecular-clock">Molecular Clock</h4>
<hr class="subsubsection" />

<p>Additionally, in the case of time-calibrated trees, we need to add a molecular clock rate parameter. For example, we know from empirical estimates that the molecular clock rate is about 0.01 (=1%) per million years per site. Nevertheless, we can estimate it here because we fixed the root age. We use a uniform prior on the log-transform clock rate. This specifies our lack of prior knowledge on the magnitude of the clock rate.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log_clock_rate ~ dnUniform(-6,1)

moves.append( mvSlide(log_clock_rate, weight=2.0) )

clock_rate := 10^log_clock_rate
</code></pre></div></div>

<p>Instead, you could also fix the clock rate and estimate the root age.
For more information on molecular clocks please read the <a href="/tutorials/clocks/">Relaxed Clocks &amp; Time Trees</a> tutorial.</p>
</blockquote>

<h4 class="subsubsection" id="putting-it-all-together">Putting it All Together</h4>
<hr class="subsubsection" />

<p><a href="https://youtu.be/XaXJ26rD16c"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>We have fully specified all of the parameters of our phylogenetic
model—the tree topology with branch lengths, and the substitution model
that describes how the sequence data evolved over the tree with branch
lengths. Collectively, these parameters comprise a distribution called
the <em>phylogenetic continuous-time Markov chain</em>, and we use the
<code class="language-plaintext highlighter-rouge">dnPhyloCTMC</code> constructor function to create this node. This
distribution requires several input arguments:</p>
<ol>
  <li>the <code class="language-plaintext highlighter-rouge">tree</code> with branch lengths;</li>
  <li>the instantaneous-rate matrix <code class="language-plaintext highlighter-rouge">Q</code>;</li>
  <li>the <code class="language-plaintext highlighter-rouge">type</code> of character data.</li>
</ol>

<p>Build the random variable for the character data (sequence alignment).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC(tree=psi, Q=Q, type="DNA")
</code></pre></div></div>

<p>Once the <code class="language-plaintext highlighter-rouge">PhyloCTMC</code> model has been created, we can attach our sequence
data to the tip nodes in the tree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq.clamp(data)
</code></pre></div></div>

<p>Note that although we assume that our sequence data are random
variables—they are realizations of our phylogenetic model—for the
purposes of inference, we assume that the sequence data are “clamped” to their observed values.
When this function is called, RevBayes sets each of the stochastic
nodes representing the tips of the tree to the corresponding nucleotide
sequence in the alignment. This essentially tells the program that we
have observed data for the sequences at the tips.</p>

<p>Finally, we wrap the entire model in a single object to provide convenient access to the
DAG. To do this, we only need to give the <code class="language-plaintext highlighter-rouge">model()</code> function a single
node. With this node, the <code class="language-plaintext highlighter-rouge">model()</code> function can find all of the other
nodes by following the arrows in the graphical model:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(Q)
</code></pre></div></div>

<p>Now we have specified a simple phylogenetic analysis—each parameter of
the model will be estimated from every site in our alignment. If we
inspect the contents of <code class="language-plaintext highlighter-rouge">mymodel</code> we can review all of the nodes in the
DAG:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel
</code></pre></div></div>

<!--
<h4 class="subsubsection" id="performing-an-mcmc-analysis-under-the-jukes-cantor-model">Performing an MCMC Analysis Under the Jukes-Cantor Model</h4><hr class="subsubsection">

In this section, we will describe how to set up the MCMC sampler and
summarize the resulting posterior distribution of trees.
 -->

<h4 class="subsubsection" id="specifying-monitors-and-output-files">Specifying Monitors and Output Files</h4>
<hr class="subsubsection" />

<p>For our MCMC analysis, we need to set up a vector of <em>monitors</em> to
record the states of our Markov chain. The monitor functions are all
called <code class="language-plaintext highlighter-rouge">mn\*</code>, where <code class="language-plaintext highlighter-rouge">\*</code> is the wild-card representing the monitor type.
First, we will initialize the model monitor using the <code class="language-plaintext highlighter-rouge">mnModel</code>
function. This creates a new monitor variable that will output the
states for all model parameters when passed into a MCMC function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/primates_cytb_JC.log", printgen=10) )
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mnFile</code> monitor will record the states for only the parameters
passed in as arguments. We use this monitor to specify the output for
our sampled trees and branch lengths.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnFile(filename="output/primates_cytb_JC.trees", printgen=10, psi) )
</code></pre></div></div>

<p>Finally, create a screen monitor that will report the states of
specified variables to the screen with <code class="language-plaintext highlighter-rouge">mnScreen</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(printgen=100, TL) )
</code></pre></div></div>

<p>This monitor mostly helps us to see the progress of the MCMC run.</p>

<h4 class="subsubsection" id="initializing-and-running-the-mcmc-simulation">Initializing and Running the MCMC Simulation</h4>
<hr class="subsubsection" />

<p>With a fully specified model, a set of monitors, and a set of moves, we
can now set up the MCMC algorithm that will sample parameter values in
proportion to their posterior probability. The <code class="language-plaintext highlighter-rouge">mcmc()</code> function will
create our MCMC object:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, moves, monitors)
</code></pre></div></div>

<p>Now, run the MCMC:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=20000)
</code></pre></div></div>

<p>When the analysis is complete, you will have the monitored files in your output directory.</p>

<blockquote class="aside"><h2>Saving and restarting analyses</h2><p>MCMC analyses can take a long time to converge, and it is usually difficult to predict how many generations will be needed to obtain results. In addition, many analyses are run on computer clusters with time limits, and so may be stopped by the cluster partway through. For all of these reasons, it is useful to save the state of the chain regularly through the analysis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=100000000, checkpointInterval=100, checkpointFile="output/primates_cytb_JC.state")
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">checkpointInterval</code> and <code class="language-plaintext highlighter-rouge">checkpointFile</code> inputs specify respectively how often, and to which file, the chain should be saved. Three different files will be used for storing the state, with no extension and with extensions <code class="language-plaintext highlighter-rouge">_mcmc</code> and <code class="language-plaintext highlighter-rouge">_moves</code>.
When multiple independent runs are specified, they will automatically be saved in separate files (with extensions <code class="language-plaintext highlighter-rouge">_run_1</code>, <code class="language-plaintext highlighter-rouge">_run_2</code>, etc.).</p>

<p>Restarting the chain from a previous run is done by adding this line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.initializeFromCheckpoint("output/primates_cytb_JC.state")
</code></pre></div></div>

<p>before calling the function <code class="language-plaintext highlighter-rouge">mcmc.run()</code>. The file name should match what was given as <code class="language-plaintext highlighter-rouge">checkpointFile</code> when running the previous analysis. <strong>NB:</strong> Note that this line will create an error if the state file does not exist yet, and so should be commented out in the first run.</p>

<p>The full MCMC block thus becomes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves)
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.initializeFromCheckpoint("output/primates_cytb_JC.state")

mymcmc.run(generations=100000000, checkpointInterval=100, checkpointFile="output/primates_cytb_JC.state")
</code></pre></div></div>
</blockquote>

<h4 class="subsubsection" id="summarizing-mcmc-samples">Summarizing MCMC Samples</h4>
<hr class="subsubsection" />

<p><a href="https://youtu.be/ZJhj8wR9YNs"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>Methods for visualizing the marginal densities of parameter values are not currently available in RevBayes itself.
Thus, it is important to use programs like <a href="http://tree.bio.ed.ac.uk/software/tracer/">Tracer</a> <a class="citation" href="#Rambaut2011">(Rambaut and Drummond 2011)</a> to evaluate mixing and non-convergence.</p>

<p>Look at the file called <code class="language-plaintext highlighter-rouge">output/primates_cytb_JC.log</code> in Tracer.
There you see the posterior distribution of the continuous parameters, <em>e.g.</em>, the tree length variable <code class="language-plaintext highlighter-rouge">TL</code>.</p>

<figure id="jc_trace_tl"><p><img src="figures/primates_cytb_JC_TL_Trace.png" width="500" /> <img src="figures/primates_cytb_JC_TL_Distribution.png" width="500" /></p>
<figcaption><strong>Left:</strong> Trace of tree-length samples for one MCMC run. The caterpillar-like look is a good sign.You will also see that the effective sample size is comparably large, i.e., much larger than 200. <strong>Right:</strong> Posterior distribution of the tree length of the primate phylogeny under a Jukes-Cantor substitution model.</figcaption>
</figure>

<p>It is always important to carefully assess the MCMC samples for the various parameters in your analysis.
You can read more about MCMC tuning and
evaluating and improving mixing in the tutorials <a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a>.</p>

<h3 class="subsection" id="exercise-1">Exercise 1</h3>
<hr class="subsection" />

<p>We are interested in the phylogenetic relationship of the Tarsiers.
Therefore, we need to summarize the trees sampled from the posterior
distribution. RevBayes can summarize the sampled trees by reading in
the tree-trace file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>treetrace = readTreeTrace("output/primates_cytb_JC.trees", treetype="non-clock")
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mapTree()</code> function will summarize the tree samples and write the
maximum <em>a posteriori</em> tree to file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>map_tree = mapTree(treetrace,"output/primates_cytb_JC_MAP.tree")
</code></pre></div></div>

<figure id="jc_tree"><p><img src="figures/primates_cytb_JC_tree.png" width="800" /></p>
<figcaption>Maximum a posteriori estimate of the primate phylogeny under a Jukes-Cantor substitution model. The numbers at the nodes show the posterior probabilities for the clades. We have rooted the tree at the outgroup <em>Galeopterus_variegatus</em></figcaption>
</figure>

<p>Look at the file called <code class="language-plaintext highlighter-rouge">output/primates_cytb_JC_MAP.tree</code> in
<code class="language-plaintext highlighter-rouge">FigTree</code>. We show it in <a href="#jc_tree"></a>.</p>

<p>Fill in the following table as you go through the tutorial.</p>

<figure id="tab_primates_posterior" class="table"><figcaption class="table">Posterior probabilities under different analyses</figcaption>

<table>
  <thead>
    <tr>
      <th style="text-align: right"><strong>Model</strong></th>
      <th style="text-align: center"><strong>Lemuroidea</strong></th>
      <th style="text-align: center"><strong>Lorisoidea</strong></th>
      <th style="text-align: center"><strong>Platyrrhini</strong></th>
      <th style="text-align: center"><strong>Catarrhini</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">Jukes-Cantor</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right">HKY85</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right">F81</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right">GTR</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right">GTR+Gamma</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right">GTR+Gamma+I</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>
</figure>

<p>Note, you can query the posterior probability of a clade being
monophyletic using the following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lemuroidea &lt;- clade("Cheirogaleus_major",
                    "Daubentonia_madagascariensis",
                    "Lemur_catta",
                    "Lepilemur_hubbardorum",
                    "Microcebus_murinus",
                    "Propithecus_coquereli",
                    "Varecia_variegata_variegata")

treetrace.cladeProbability( Lemuroidea )
</code></pre></div></div>

<figure id="tab_primates" class="table"><figcaption class="table">Primate and species relationships.</figcaption>

<table>
  <thead>
    <tr>
      <th><strong>Species</strong></th>
      <th style="text-align: center"><strong>Family</strong></th>
      <th style="text-align: center"><strong>Parvorder</strong></th>
      <th style="text-align: center"><strong>Suborder</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Aotus trivirgatus</td>
      <td style="text-align: center">Aotidae</td>
      <td style="text-align: center">Platyrrhini (NWM)</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Callicebus donacophilus</td>
      <td style="text-align: center">Pitheciidae</td>
      <td style="text-align: center">Platyrrhini (NWM)</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Cebus albifrons</td>
      <td style="text-align: center">Cebidae</td>
      <td style="text-align: center">Platyrrhini (NWM)</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Cheirogaleus major</td>
      <td style="text-align: center">Cheirogaleidae</td>
      <td style="text-align: center">Lemuroidea</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Chlorocebus aethiops</td>
      <td style="text-align: center">Cercopithecoidea</td>
      <td style="text-align: center">Catarrhini</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Colobus guereza</td>
      <td style="text-align: center">Cercopithecoidea</td>
      <td style="text-align: center">Catarrhini</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Daubentonia madagascariensis</td>
      <td style="text-align: center">Daubentoniidae</td>
      <td style="text-align: center">Lemuroidea</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Galago senegalensis</td>
      <td style="text-align: center">Galagidae</td>
      <td style="text-align: center">Lorisidae</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Hylobates lar</td>
      <td style="text-align: center">Hylobatidea</td>
      <td style="text-align: center">Catarrhini</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Lemur catta</td>
      <td style="text-align: center">Lemuridae</td>
      <td style="text-align: center">Lemuroidea</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Lepilemur hubbardorum</td>
      <td style="text-align: center">Lepilemuridae</td>
      <td style="text-align: center">Lemuroidea</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Loris tardigradus</td>
      <td style="text-align: center">Lorisidae</td>
      <td style="text-align: center">Lorisidae</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Macaca mulatta</td>
      <td style="text-align: center">Cercopithecoidea</td>
      <td style="text-align: center">Catarrhini</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Microcebus murinus</td>
      <td style="text-align: center">Cheirogaleidae</td>
      <td style="text-align: center">Lemuroidea</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Nycticebus coucang</td>
      <td style="text-align: center">Lorisidae</td>
      <td style="text-align: center">Lorisidae</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Otolemur crassicaudatus</td>
      <td style="text-align: center">Galagidae</td>
      <td style="text-align: center">Lorisidae</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Pan paniscus</td>
      <td style="text-align: center">Hominoidea</td>
      <td style="text-align: center">Catarrhini</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Perodicticus potto</td>
      <td style="text-align: center">Lorisidae</td>
      <td style="text-align: center">Lorisidae</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Propithecus coquereli</td>
      <td style="text-align: center">Indriidae</td>
      <td style="text-align: center">Lemuroidea</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
    <tr>
      <td>Saimiri sciureus</td>
      <td style="text-align: center">Cebidae</td>
      <td style="text-align: center">Platyrrhini (NWM)</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Tarsius syrichta</td>
      <td style="text-align: center">Tarsiidae</td>
      <td style="text-align: center">Tarsiiformes</td>
      <td style="text-align: center">Haplorrhini</td>
    </tr>
    <tr>
      <td>Varecia variegata variegata</td>
      <td style="text-align: center">Lemuridae</td>
      <td style="text-align: center">Lemuroidea</td>
      <td style="text-align: center">Strepsirrhini</td>
    </tr>
  </tbody>
</table>
</figure>

<blockquote class="aside"><h2>Setting up the Kimura 1980 (K80 or K2P) substitution model</h2><p>The K80 model (AKA the K2P model) allows the rates of transition and transversion substitutions to be unequal <a class="citation" href="#Kimura1980">(Kimura 1980)</a>.
The parameter $\kappa$ describes the relative rate of transition to transversion substitutions (if $\kappa &gt; 1$, transitions occur at a higher rate than transversions). The instantaneous-rate matrix for the K80 model is defined as:</p>

\[Q_{K80} = \begin{pmatrix}
                  -                 &amp; \frac{1}{4} &amp; \frac{\kappa}{4} &amp; \frac{1}{4} \\
                  \frac{1}{4} &amp; -               &amp; \frac{1}{4} &amp; \frac{\kappa}{4} \\
                  \frac{\kappa}{4} &amp; \frac{1}{4} &amp; -                &amp; \frac{1}{4} \\
                  \frac{1}{4} &amp; \frac{\kappa}{4}	&amp; \frac{1}{4} &amp; -
\end{pmatrix} \mbox{  .}\]

<p>Now, add the parameter $\kappa$ to the substitution model, and create a K80 rate matrix:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kappa ~ dnExp(1)
moves.append( mvScale(kappa, weight=1.0) )

Q := fnK80(kappa)
</code></pre></div></div>
</blockquote>

<h2 class="section" id="the-hasegawa-kishino-yano-hky-1985-substitution-model">The Hasegawa-Kishino-Yano (HKY) 1985 Substitution Model</h2>
<hr class="section" />

<p><a href="https://youtu.be/cqeyZyjIcuw"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>The Jukes-Cantor model assumes that all substitution rates are equal,
which also implies that the stationary frequencies of the four
nucleotide bases are equal. These assumptions are not very biologically
reasonable, so we might wish to consider a more realistic substitution
model that relaxes some of these assumptions. For example, we might
allow stationary frequencies, $\pi$, to be unequal, and allow rates of
transition and transversion substitutions to differ, $\kappa$. This
corresponds to the substitution model proposed by <a class="citation" href="#Hasegawa1985">Hasegawa et al. (1985)</a>,
which is specified with the following instantaneous-rate matrix:</p>

\[Q_{HKY} = \begin{pmatrix}
{\cdot}             &amp; {\pi_C}           &amp; {\kappa\pi_G}     &amp; {\pi_T} \\
{\pi_A}             &amp; {\cdot}           &amp; {\pi_G}           &amp; {\kappa\pi_T} \\
{\kappa\pi_A}       &amp; {\pi_C}           &amp; {\cdot}           &amp; {\pi_T} \\
{\pi_A}             &amp; {\kappa\pi_C}     &amp; {\pi_G}           &amp; {\cdot}
\end{pmatrix} \mbox{  ,}\]

<p>where the diagonal ${\cdot}$ entries are equal to the negative sum of the
elements in the corresponding row.</p>

<p>Use the file <code class="language-plaintext highlighter-rouge">mcmc_JC.Rev</code> as a starting point for the HKY analysis.</p>

<p>Note that we are adding two new variables to our model. We can define a
variable <code class="language-plaintext highlighter-rouge">pi</code> for the stationary frequencies that are drawn from a flat
Dirichlet distribution by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi ~ dnDirichlet(pi_prior)
</code></pre></div></div>

<p>Since <code class="language-plaintext highlighter-rouge">pi</code> is a stochastic variable, we need to specify a move to
propose updates to it. A good move on variables drawn from a Dirichlet
distribution is the <code class="language-plaintext highlighter-rouge">mvBetaSimplex</code>. This move randomly takes an element
from the simplex, proposes a new value for it drawn from a Beta
distribution, and then rescales all values of the simplex to sum to 1
again.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvBetaSimplex(pi, weight=2) )
moves.append( mvDirichletSimplex(pi, weight=1) )
</code></pre></div></div>

<p>The second new variable is $\kappa$, which specifies the ratio of
transition-transversion rates. The $\kappa$ parameter must be a
positive-real number and a natural choice as the prior distribution is
the lognormal distribution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kappa ~ dnLognormal(0.0, 1.0)
</code></pre></div></div>

<p>Again, we need to specify a move for this new stochastic variable. A
simple scaling move should do the job.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale(kappa) )
</code></pre></div></div>

<p>Finally, we need to create the HKY instantaneous-rate matrix using the
<code class="language-plaintext highlighter-rouge">fnHKY</code> function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnHKY(kappa,pi)
</code></pre></div></div>

<p>This should be all for the HKY model. Don’t forget to change the output file names, otherwise your old analyses files will be overwritten.</p>

<h3 class="subsection" id="exercise-2">Exercise 2</h3>
<hr class="subsection" />

<ul>
  <li>
    <p>With <a href="#jc_graphical_model"></a> as your guide, draw the probabilistic
graphical model of the HKY model.</p>
  </li>
  <li>
    <p>Download the file called <a href="scripts/mcmc_JC.Rev"><code class="language-plaintext highlighter-rouge">mcmc_JC.Rev</code></a> and rename it
<code class="language-plaintext highlighter-rouge">mcmc_HKY.Rev</code>. Save this file in a directory called <code class="language-plaintext highlighter-rouge">scripts</code> located in the same
directory as your <code class="language-plaintext highlighter-rouge">data</code> folder.</p>
  </li>
  <li>
    <p>Modify <code class="language-plaintext highlighter-rouge">mcmc_HKY.Rev</code> by including the
necessary parameters to specify the HKY substitution model. <em>Be sure to change the output file names given to the monitors.</em></p>
  </li>
  <li>
    <p>Run a MCMC analysis to estimate the posterior distribution under
the HKY substitution model.</p>
  </li>
  <li>
    <p>Are the resulting estimates of the base frequencies equal? If not,
how much do they differ? Are the estimated base frequencies similar
to the empirical base frequencies? The empirical base frequencies
are the frequencies of the characters in the alignment, which can be
computed with RevBayes by <code class="language-plaintext highlighter-rouge">data.getEmpiricalBaseFrequencies()</code>.</p>
  </li>
  <li>
    <p>Is the inferred rate of transition substitutions higher than the
rate of transversion substitutions? If so, by how much?</p>
  </li>
  <li>
    <p>Like the HKY model, the Felsenstein 1981 (F81) substitution model
has unequal stationary frequencies, but it assumes equal
transition-transversion rates <a class="citation" href="#Felsenstein1981">(Felsenstein 1981)</a>.
Can you set up the F81 model and run an analysis?</p>
  </li>
  <li>
    <p>Complete the <a href="#tab_primates_posterior"></a> by reporting the posterior
probabilities of phylogenetic relationships.</p>
  </li>
</ul>

<h2 class="section" id="the-general-time-reversible-gtr-substitution-model">The General Time-Reversible (GTR) Substitution Model</h2>
<hr class="section" />

<p><a href="https://youtu.be/mqLv0INyit4"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>The HKY substitution model can accommodate unequal base frequencies and
different rates of transition and transversion substitutions. Despite
these extensions, the HKY model may still be too simplistic for many
real datasets. Here, we extend the HKY model to specify the general time
reversible (GTR) substitution model <a class="citation" href="#Tavare1986">(Tavaré 1986)</a>, which allows all six
exchangeability rates to differ (<a href="#gtr_graphical_model"></a>).</p>

<p>The instantaneous-rate matrix for the GTR substitution model is:</p>

\[Q_{GTR} = \begin{pmatrix}
{\cdot}	   &amp; {r_{AC}\pi_C} &amp; {r_{AG}\pi_G} &amp; {r_{AT}\pi_T} \\
{r_{AC}\pi_A} &amp; {\cdot}       &amp; {r_{CG}\pi_G} &amp; {r_{CT}\pi_T} \\
{r_{AG}\pi_A} &amp; {r_{CG}\pi_C} &amp; {\cdot}       &amp; {r_{GT}\pi_T} \\
{r_{AT}\pi_A} &amp; {r_{CT}\pi_C} &amp; {r_{GT}\pi_G} &amp; {\cdot}       \\
\end{pmatrix} \mbox{  ,}\]

<p>where the six exchangeability parameters, $r_{ij}$, specify the relative
rates of change between states $i$ and $j$.</p>

<figure id="gtr_graphical_model"><p><img src="figures/gtr_graphical_model.png" /></p>
<figcaption>Graphical model representation of the general-time reversible (GTR) phylogenetic model.</figcaption>
</figure>

<p>The GTR model requires that we define and specify a prior on the six
exchangeability rates, which we will describe using a flat Dirichlet
distribution. As we did previously for the Dirichlet prior on base
frequencies, we first define a constant node specifying the vector of
concentration-parameter values using the <code class="language-plaintext highlighter-rouge">v()</code> function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>er_prior &lt;- v(1,1,1,1,1,1)
</code></pre></div></div>

<p>This node defines the concentration-parameter values of the Dirichlet
prior distribution on the exchangeability rates. Now, we can create a
stochastic node for the exchangeability rates using the <code class="language-plaintext highlighter-rouge">dnDirichlet()</code>
function, which takes the vector of concentration-parameter values as an
argument and the <code class="language-plaintext highlighter-rouge">~</code> operator. Together, these create a stochastic node
named <code class="language-plaintext highlighter-rouge">er</code> ($\theta$ in <a href="#gtr_graphical_model"></a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>er ~ dnDirichlet(er_prior)
</code></pre></div></div>

<p>The Dirichlet distribution assigns probability densities to a group of parameters: <em>e.g.</em>,  those that measure proportions and must sum to 1. Here, we have specified a six-parameter Dirichlet prior, where each value describes one of the six relative rates of the GTR model: (1) $A\leftrightarrows C$; (2) $A\leftrightarrows G$; (3) $A\leftrightarrows T$; (4) $C\leftrightarrows G$; (5) $C\leftrightarrows T$; (6) $G\leftrightarrows T$. The input parameters of a Dirichlet distribution are called shape (or concentration) parameters. The expectation and variance for each variable are related to the sum of the shape parameters. The prior we specified above is a ‘flat’ or symmetric Dirichlet distribution; all of the shape parameters are equal (1,1,1,1,1,1). This describes a model that allows for equal rates of change between nucleotides, such that the expected rate for each is equal to $\frac{1}{6}$ (<a href="#dirichletFig"></a>a).</p>

<p>We might also parameterize the Dirichlet distribution such that all of the shape parameters were equal to 100, which would also specify a prior with an expectation of equal exchangeability rates (<a href="#dirichletFig"></a>b). However, by increasing the values of the shape parameters, <code class="language-plaintext highlighter-rouge">er_prior &lt;- v(100,100,100,100,100,100)</code>, the Dirichlet distribution will more strongly favor equal exchangeability rates; (<em>i.e.</em>, a relatively informative prior).</p>

<p>Alternatively, we might consider an asymmetric Dirichlet parameterization that could reflect a strong prior belief that transition and transversion substitutions occur at different rates. For example, we might specify the prior density <code class="language-plaintext highlighter-rouge">er_prior &lt;- v(4,8,4,4,8,4)</code>. Under this model, the expected rate for transversions would be $\frac{4}{32}$ and that for transitions would be $\frac{8}{32}$, and there would be greater prior probability on sets of GTR rates that matched this configuration (<a href="#dirichletFig"></a>c).</p>

<p>Yet another asymmetric prior could specify that each of the six GTR rates had a different value conforming to a Dirichlet(2,4,6,8,10,12). This would lead to a different prior probability density for each rate parameter (<a href="#dirichletFig"></a>d). Without strong prior knowledge about the pattern of relative rates, however, we can better reflect our uncertainty by using a vague prior on the GTR rates. Notably, all patterns of relative rates have the same probability density under <code class="language-plaintext highlighter-rouge">er_prior &lt;- v(1,1,1,1,1,1)</code>.</p>

<figure id="dirichletFig"><p><img src="figures/dirichlet_rates.png" width="600" /></p>
<figcaption>Four different examples of Dirichlet priors on exchangeability rates.</figcaption>
</figure>

<p>For each stochastic node in our model, we must also specify a proposal mechanism if we wish to estimate that parameter. The Dirichlet prior on our parameter <code class="language-plaintext highlighter-rouge">er</code> creates a <a href="http://en.wikipedia.org/wiki/Simplex"><em>simplex</em></a> of values that sum to 1.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvBetaSimplex(er, weight=3) )
moves.append( mvDirichletSimplex(er, weight=1) )
</code></pre></div></div>

<p>We can use the same type of distribution as a prior on the 4 stationary
frequencies ($\pi_A, \pi_C, \pi_G, \pi_T$) since these parameters also
represent proportions. Specify a flat Dirichlet prior density on the
base frequencies:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi_prior &lt;- v(1,1,1,1) 
pi ~ dnDirichlet(pi_prior)
</code></pre></div></div>

<p>The node <code class="language-plaintext highlighter-rouge">pi</code> represents the $\pi$ node in <a href="#gtr_graphical_model"></a>. Now add the simplex scale move on the stationary frequencies to the moves vector:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvBetaSimplex(pi, weight=2) )
moves.append( mvDirichletSimplex(pi, weight=1) )
</code></pre></div></div>

<p>We can finish setting up this part of the model by creating a deterministic node for the GTR instantaneous-rate matrix <code class="language-plaintext highlighter-rouge">Q</code>. The <code class="language-plaintext highlighter-rouge">fnGTR()</code> function takes a set of exchangeability rates and a set of base frequencies to compute the instantaneous-rate matrix used when calculating the likelihood of our model.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnGTR(er,pi) 
</code></pre></div></div>

<h3 class="subsection" id="exercise-3">Exercise 3</h3>
<hr class="subsection" />

<ul>
  <li>
    <p>Use one of your previous analysis files—either the <code class="language-plaintext highlighter-rouge">mcmc_JC.Rev</code> or
<code class="language-plaintext highlighter-rouge">mcmc_HKY.Rev</code>—to specify a GTR analysis in a new file called
<code class="language-plaintext highlighter-rouge">mcmc_GTR.Rev</code>. Adapt the old analysis to be performed under the
GTR substitution model.</p>
  </li>
  <li>
    <p>Run an MCMC analysis to estimate the posterior distribution.</p>
  </li>
  <li>
    <p>Complete the table of the phylogenetic relationship of primates.</p>
  </li>
</ul>

<h2 class="section" id="the-discrete-gamma-model-of-among-site-rate-variation">The Discrete Gamma Model of Among Site Rate Variation</h2>
<hr class="section" />

<p><a href="https://youtu.be/JN1nOT7iSOE"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>Members of the GTR family of substitution models assume that rates are homogeneous across sites, an assumption that is often violated by real data. We can accommodate variation in substitution rate among sites (ASRV) by adopting the discrete-gamma model <a class="citation" href="#Yang1994a">(Yang 1994)</a>. This model assumes that the substitution rate at each site is a random variable that is described by a discretized gamma distribution, which has two parameters: the shape parameter, $\alpha$, and the rate parameter, $\beta$. In order that we can interpret the branch lengths as the expected number of substitutions per site, this model assumes that the mean site rate is equal to 1. The mean of the gamma is equal to $\alpha/\beta$, so a mean-one gamma is specified by setting the two parameters to be equal, $\alpha=\beta$. This means that we can fully describe the gamma distribution with the single shape parameter, $\alpha$. The degree of among-site substitution rate variation is inversely proportional to the value of the $\alpha$-shape parameter. As the value of the $\alpha$-shape increases, the gamma distribution increasingly resembles a normal distribution with decreasing variance, which therefore corresponds to decreasing levels of ASRV (<a href="#asrhGammaFig"></a>). By contrast, when the value of the $\alpha$-shape parameter is $&lt; 1$, the gamma distribution assumes a concave distribution that concentrates most of the prior density on low rates, but retains some prior mass on sites with very high rates, which therefore corresponds to high levels of ASRV (<a href="#asrhGammaFig"></a>). Note that, when $\alpha = 1$, the gamma distribution collapses to an exponential distribution with a rate parameter equal to $\beta$.</p>

<figure id="asrhGammaFig"><p><img src="figures/asrh_gamma.png" width="600" /></p>
<figcaption>The probability density of mean-one gamma-distributed rates for different values of the $\alpha$-shape parameter.</figcaption>
</figure>

<p>We typically lack prior knowledge regarding the degree of ASRV for a given alignment.
Accordingly, rather than specifying a precise value of $\alpha$, we can instead estimate the value of the $\alpha$-shape parameter from the data. This requires that we specify a diffuse (relatively <a href="http://andrewgelman.com/2013/11/21/hidden-dangers-noninformative-priors/">‘uninformative’</a>) prior on the $\alpha$-shape parameter. For this analysis, we will use a uniform distribution between 0 and 10.</p>

<p>This approach for accommodating ASRV is another example of a hierarchical model (<a href="#fig_gtrg"></a>).
That is, variation in substitution rates across sites is addressed by applying a site-specific rate multiplier to each of the $j$ sites, $r_j$.
These rate-multipliers are drawn from a discrete, mean-one gamma distribution; the shape of this prior distribution (and the corresponding degree of ASRV) is governed by the $\alpha$-shape parameter. The $\alpha$-shape parameter, in turn, is treated as a lognormal distributed random variable. Finally, the shape of the lognormal prior is governed by the mean and standard deviation parameters, which are set to fixed values.</p>

<figure id="fig_gtrg"><p><img src="figures/gtrg_graphical_model.png" alt="" /></p>
<figcaption>Graphical model representation of the General Time Reversible (GTR) + Gamma phylogenetic model with invariable sites.</figcaption>
</figure>

<h4 class="subsubsection" id="setting-up-the-gamma-model-in-revbayes">Setting up the Gamma Model in RevBayes</h4>
<hr class="subsubsection" />

<p>Then create a stochastic node called <code class="language-plaintext highlighter-rouge">alpha</code> with a uniform prior distribution between 0.0 and $10$
(this represents the stochastic node for the $\alpha$-shape parameter in
<a href="#fig_gtrg"></a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha ~ dnUniform( 0.0, 10 )
</code></pre></div></div>

<p>The way the ASRV model is implemented involves discretizing the mean-one gamma distribution into a set number of rate categories, $k$. Thus, we can analytically marginalize over the uncertainty in the rate at each site. The likelihood of each site is averaged over the $k$ rate categories, where the rate multiplier is the mean (or median) of each of the discrete $k$ categories. To specify this, we need a deterministic node that is a vector that will hold the set of $k$ rates drawn from the gamma distribution with $k$ rate categories. The <code class="language-plaintext highlighter-rouge">fnDiscretizeGamma()</code> function returns this deterministic node and takes three arguments: the shape and rate of the gamma distribution and the number of categories. Since we want to discretize a mean-one gamma distribution, we can pass in <code class="language-plaintext highlighter-rouge">alpha</code> for both the shape and rate.</p>

<p>Initialize the <code class="language-plaintext highlighter-rouge">sr</code> deterministic node vector using the <code class="language-plaintext highlighter-rouge">fnDiscretizeGamma()</code> function with <code class="language-plaintext highlighter-rouge">4</code> bins:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sr := fnDiscretizeGamma( alpha, alpha, 4 )
</code></pre></div></div>

<p>Note that here, by convention, we set $k = 4$. The random variable that controls the rate variation is the stochastic node <code class="language-plaintext highlighter-rouge">alpha</code>. We will apply a simple scale move to this parameter.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale(alpha, weight=2.0) )
</code></pre></div></div>

<p>Remember that you need to call the <code class="language-plaintext highlighter-rouge">PhyloCTMC</code> constructor to include the new site-rate parameter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC(tree=psi, Q=Q, siteRates=sr, type = "DNA")
</code></pre></div></div>

<h3 class="subsection" id="exercise-4">Exercise 4</h3>
<hr class="subsection" />

<ul>
  <li>
    <p>Modify the previous GTR analysis to specify the GTR+Gamma model.
Run an MCMC simulation to estimate the posterior distribution.</p>
  </li>
  <li>
    <p>Is there an impact on the estimated phylogeny compared with the
previous analyses? Look at the MAP tree and the posterior
probabilities of the clades.</p>
  </li>
  <li>
    <p>Complete the table of the phylogenetic relationship of primates.</p>
  </li>
</ul>

<h2 class="section" id="modeling-invariable-sites">Modeling Invariable Sites</h2>
<hr class="section" />

<p><a href="https://youtu.be/0P4yLk0jxps"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>All of the substitution models described so far assume that the sequence data are potentially variable. That is, we assume that the sequence data are random variables; specifically, we assume that they are realizations of the specified <code class="language-plaintext highlighter-rouge">PhyloCTMC</code> distribution. However, some sites may not be free to vary—when the substitution rate of a site is zero, it is said to be <em>invariable</em>. Invariable sites are often confused with <em>invariant</em> sites—when each species exhibits the same state, it is said to be invariant. The concepts are related but distinct. If a site is truly invariable, it will necessarily give rise to an invariant site pattern, as such sites will always have a zero substitution rate. However, an invariant site pattern may be achieved via multiple substitutions that happen to end in the same state for every species.</p>

<p>Here we describe an extension to our phylogenetic model to accommodate invariable sites. Under the invariable-sites model <a class="citation" href="#Hasegawa1985">(Hasegawa et al. 1985)</a>, each site is invariable with probability <code class="language-plaintext highlighter-rouge">p_inv</code>, and variable with probability $1-$<code class="language-plaintext highlighter-rouge">p_inv</code>.</p>

<p>First, let’s have a look at the data and see how many invariant sites we have:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data.getNumInvariantSites()
</code></pre></div></div>

<p>There seem to be a substantial number of invariant sites.</p>

<p>Now let’s specify the invariable-sites model in RevBayes. We need to specify the prior probability that a site is invariable. A Beta distribution is a common choice for parameters representing probabilities.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p_inv ~ dnBeta(1,1)
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Beta(1,1)</code> distribution is a flat prior distribution that specifies equal probability for all values between 0 and 1.</p>

<p>Then, as usual, we add a move to change this stochastic variable; we’ll use a simple sliding window move.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvSlide(p_inv) )
</code></pre></div></div>

<p>Finally, you need to call the <code class="language-plaintext highlighter-rouge">PhyloCTMC</code> constructor to include the
new <code class="language-plaintext highlighter-rouge">p_inv</code> parameter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC(tree=psi, Q=Q, siteRates=sr, pInv=p_inv, type="DNA")
</code></pre></div></div>

<h3 class="subsection" id="exercise-5">Exercise 5</h3>
<hr class="subsection" />

<ul>
  <li>
    <p>Extend the GTR model to account for invariable sites and run
an analysis.</p>
  </li>
  <li>
    <p>What is the estimated probability of invariable sites and how does
it relate to the ratio of invariant sites to the total number of
sites?</p>
  </li>
  <li>
    <p>Extend the GTR+$\Gamma$ model to account for invariable sites and
run an analysis.</p>
  </li>
  <li>
    <p>What is the estimated probability of invariable sites now?</p>
  </li>
  <li>
    <p>Complete the table of the phylogenetic relationship of primates.</p>
  </li>
</ul>

<ol class="bibliography"><li><span id="Brown2010">Brown J.M., Hedtke S.M., Lemmon A.R., Lemmon E.M. 2010. When Trees Grow Too Long: Investigating the Causes of Highly Inaccurate Bayesian Branch-Length Estimates. Systematic Biology. 59:145–161.</span>

<a href="https://doi.org/10.1093/sysbio/syp081">10.1093/sysbio/syp081</a>

</li>
<li><span id="Felsenstein1981">Felsenstein J. 1981. Evolutionary Trees from DNA Sequences: a Maximum Likelihood Approach. Journal of Molecular Evolution. 17:368–376.</span>

<a href="https://doi.org/10.1007/BF01734359">10.1007/BF01734359</a>

</li>
<li><span id="Hasegawa1985">Hasegawa M., Kishino H., Yano T. 1985. Dating of the Human-Ape Splitting by a molecular Clock of Mitochondrial DNA. Journal of Molecular Evolution. 22:160–174.</span>

<a href="https://doi.org/10.1007/BF02101694">10.1007/BF02101694</a>

</li>
<li><span id="Hoehna2008">Höhna S., Defoin-Platel M., Drummond A.J. 2008. Clock-Constrained Tree Proposal Operators in Bayesian Phylogenetic Inference. 8th IEEE International Conference on BioInformatics and BioEngineering, 2008. BIBE 2008.:1–7.</span>

</li>
<li><span id="Hoehna2012">Höhna S., Drummond A.J. 2012. Guided Tree Topology Proposals for Bayesian Phylogenetic Inference. Systematic Biology. 61:1–11.</span>

</li>
<li><span id="Hoehna2014b">Höhna S., Heath T.A., Boussau B., Landis M.J., Ronquist F., Huelsenbeck J.P. 2014. Probabilistic Graphical Model Representation in Phylogenetics. Systematic Biology. 63:753–771.</span>

<a href="https://doi.org/10.1093/sysbio/syu039">10.1093/sysbio/syu039</a>

</li>
<li><span id="Hoehna2017a">Höhna S., Landis M.J., Heath T.A. 2017. Phylogenetic Inference using RevBayes. Current Protocols in Bioinformatics.</span>

<a href="https://doi.org/10.1002/cpbi.22">10.1002/cpbi.22</a>

</li>
<li><span id="Jukes1969">Jukes T.H., Cantor C.R. 1969. Evolution of Protein Molecules. Mammalian Protein Metabolism. 3:21–132.</span>

<a href="https://doi.org/10.1016/B978-1-4832-3211-9.50009-7">10.1016/B978-1-4832-3211-9.50009-7</a>

</li>
<li><span id="Kimura1980">Kimura M. 1980. A simple method for estimating evolutionary rates of base substitutions through comparative studies of nucleotide sequences. Journal of Molecular Evolution. 16:111–120.</span>

</li>
<li><span id="Rambaut2011">Rambaut A., Drummond A.J. 2011. Tracer v1.5. .</span>


<a href="http://tree.bio.ed.ac.uk/software/tracer/">http://tree.bio.ed.ac.uk/software/tracer/</a>
</li>
<li><span id="Rannala2012">Rannala B., Zhu T., Yang Z. 2012. Tail Paradox, Partial Identifiability, and Influential Priors in Bayesian Branch Length Inference. Molecular Biology and Evolution. 29:325–335.</span>

</li>
<li><span id="Tamura1992">Tamura K. 1992. Estimation of the number of nucleotide substitutions when there are strong transition-transversion and G+ C-content biases. Molecular Biology and Evolution. 9:678–687.</span>

</li>
<li><span id="Tavare1986">Tavaré S. 1986. Some Probabilistic and Statistical Problems in the Analysis of DNA Sequences. Some Mathematical Questions in Biology: DNA Sequence Analysis. 17:57–86.</span>

</li>
<li><span id="Yang1994a">Yang Z. 1994. Maximum Likelihood Phylogenetic Estimation from DNA Sequences with Variable Rates Over Sites: Approximate Methods. Journal of Molecular Evolution. 39:306–314.</span>

<a href="https://doi.org/10.1007/BF00160154">10.1007/BF00160154</a>

</li>
<li><span id="Zhang2012">Zhang C., Rannala B., Yang Z. 2012. Robustness of Compound Dirichlet Priors for Bayesian Inference of Branch Lengths. Systematic Biology. 61:779–784.</span>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
