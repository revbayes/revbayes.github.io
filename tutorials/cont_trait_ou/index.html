<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Phylogenetic Inference using RevBayes</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="https://revbayes.github.io/revscripter/">RevScripter</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Phylogenetic Inference using RevBayes</h1>
	<h3 class="subtitle">Continuous trait evolution with Ornstein-Uhlenbeck models</h3>
	<h4 class="authors">Sebastian Höhna</h4>
  <h5>Last modified on April 18, 2018</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Rev Language Syntax</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





</div>
<p><strong>This tutorial is currently under construction/revision.</strong></p>

<h1 id="introduction">Introduction</h1>

<p>Throughout this tutorial, we have exclusively considered undirected
Brownian models. However, many other models could be used, and this,
both for quantitative traits and for substitution rates or substitution
parameters. Right now, there are at least two other models available in
‘RevBayes‘: the Brownian model with systematic trend and the
Ornstein-Uhlenbeck process.</p>

<h1 id="data-and-files">Data and files</h1>

<p>We provide several data files which we will use in this tutorial. You
may want to use your own data instead. In the ‘data‘ folder, you will
find the following files</p>

<ul>
  <li>
    <p>‘primates_cytb.nex‘: Alignment of the <em>cytochrome b</em> subunit from
23 primates representing 14 of the 16 families (<em>Indriidae</em> and
<em>Callitrichidae</em> are missing).</p>
  </li>
  <li>
    <p>‘primates_lhtlog.nex‘: 2 life-history traits (endocranial volume
(ECV), body mass; each for males and females separately) for 23
primate species [taken from the Anage database, @DeMagalhaes2009].
The traits have been log-transformed.</p>
  </li>
  <li>
    <p>‘primates.tree‘: A time calibrated phylogeny of the same
23 primates.</p>
  </li>
</ul>

<h1 id="ornstein-uhlenbeck-process">Ornstein-Uhlenbeck process</h1>

<p>First, load the trait data:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>contData &lt;- readContinuousCharacterData("data/primates_lhtlog.nex")
</code></pre></div></div>

<p>If you type you will see that the continuous character data matrix
contains several characters (columns).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>contData
</code></pre></div></div>

<div class="rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
       Continuous character matrix with 23 taxa and 11 characters
       ==========================================================
       Origination:                   primates_lhtlog.nex
       Number of taxa:                23
       Number of included taxa:       23
       Number of characters:          11
       Number of included characters: 11
       Datatype:                      Continuous
</code></pre></div></div>

<p>Since we only want the body mass (of females) we exclude all but the
third character</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>contData.excludeAll()
contData.includeCharacter(3) 
</code></pre></div></div>

<p>Next, load the time-tree from file. Remember that we use in this first
simple example a fixed tree that we assume is known without uncertainty.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>treeArray &lt;- readTrees("data/primates.tree")
psi &lt;- treeArray[1]
</code></pre></div></div>

<p>\
You may want to look at this tree before by loading the ‘primates.tree‘
in FigTree or any other tree visualization software.</p>

<p>As usual, we start be initializing some useful helper variables. For
example, we set up a counter variable for the number of moves that we
already added to our analysis. This will make it much easier if we
extend the model or analysis to include additional moves or to remove
some moves.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvi = 0 
</code></pre></div></div>

<p>Then, we define the overall rate parameter $\sigma$ which we assign a
(truncated) log-uniform prior. Note that it is more efficient in
Bayesian inference to specify a uniform prior and then to transform the
parameter which we will use here:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logAlpha ~ dnUniform(-10,10)
alpha := 10^logAlpha

logSigma ~ dnUniform(-5,5)
sigma := 10^logSigma
</code></pre></div></div>

<p>Using this approach we have specified a prior probability distribution
on ‘sigma‘ between $10^{-5}$ to $10^5$ which should be broad enough to
include all reasonable values. Since the rate of trait evolution
‘logSigma‘ is a stochastic variable and we want to estimate it, we need
to add a sliding move on it. Remember that the sliding move proposes new
values drawn from a window with width ‘delta‘ and is centered around the
current values; thus it slides through the parameter space together with
the current parameter value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[++mvi] = mvSlide(logAlpha,delta=10,tune=true,weight=2)
moves[++mvi] = mvSlide(logSigma, delta=1.0, tune=true, weight=2.0)
</code></pre></div></div>

<p>In order to create the random variables for the internal states we need
to know the number of nodes and the number of tips. We will store these
as some helper variables.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>numNodes = psi.nnodes()
numTips = psi.ntips()
</code></pre></div></div>

<p>We will use a uniform prior distribution on the logarithm of the root
mass optimal value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logOptim ~ dnUniform(-10,10)
</code></pre></div></div>

<p>Again, we’ll specify a sliding move that proposes new values for the
‘rootlogmass‘ randomly drawn from a window centered around the current
value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[++mvi] = mvSlide(logOptim,delta=10,tune=true,weight=2)
</code></pre></div></div>

<p>Now we are ready to specify the Brownian motion model for each branch.
That is, we simply specify a new normal distributed random variable for
each node with mean being equal to the value of the parent variable and
the standard deviation being equal to the product of the square root of
the branch length and our rate parameter ‘sigma‘. We store all the
variables in the vector ‘logmass‘. Then we are able to access the value
at the parent node using the index of the parent node, which we can
obtain from the tree using the function ‘psi.parent(i)‘. Similarly,
since the variance depends on the branch length we retrieve the branch
length of node with index ‘i‘ using the function ‘psi.branchLength(i)‘.</p>

<p>First we need to copy (create a reference to) the ‘rootlogmass‘</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logmass[numNodes] := logOptim
</code></pre></div></div>

<p>Let us start by creating the random variables for the internal nodes.
Remember that the variance is equal to ‘sigma‘-squared times the branch
length, and we need to compute the square root of it to obtain the
standard deviation.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># univariate Ornstein-Uhlenbeck process along the tree
for (i in (numNodes-1):(numTips+1) ) {
  logmass[i] ~ dnOrnsteinUhlenbeck( x0=logmass, theta=logOptim, alpha=alpha, sigma=sigma, time=psi.branchLength(i) )
  # moves on the Ornstein-Uhlenbeck process
  moves[++mvi] = mvSlide( logmass[i], delta=10, tune=true ,weight=2) 
}
</code></pre></div></div>

<p>You may have noticed that we specified in the loop a move for each
internal ‘logmass‘. This is because we want to use the MCMC algorithm to
integrate over the uncertainty in the states.</p>

<p>Next, we repeat the same loop but now for the tip nodes. Instead of
applying a move to each tip node we will clamp the nodes. The nodes will
be clamped with the data that we read in before.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in numTips:1 ) {
  logmass[i] ~ dnOrnsteinUhlenbeck( x0=logmass, theta=logOptim, alpha=alpha, sigma=sigma, time=psi.branchLength(i) )

  # condition OU model on quantitative trait data (second column of the dataset)
  logmass[i].clamp(contData.getTaxon(psi.nodeName(i))[1])
}
</code></pre></div></div>

<p>The model is now entirely specified and we can create a model object
containing the entire model graph by providing it with only one of our
model variables, <em>e.g.,</em>‘sigma‘.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(sigma)
</code></pre></div></div>

<p>To see what it happing during the MCMC let us make a screen monitor that
tracks the rate ‘sigma‘.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[1] = mnScreen(printgen=10, sigma, alpha, logOptim)
</code></pre></div></div>

<p>Since we have several additional parameters —the states at the internal
nodes— we will use a model monitor to write to file instead.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[2] = mnModel(filename="output/primates_mass_OU.log", printgen=10, separator = TAB)
monitors[3] = mnExtNewick(filename="output/primates_mass_OU_ext.trees", isNodeParameter=TRUE, printgen=10, separator = TAB, tree=psi, logmass)
</code></pre></div></div>

<p>We can finally create a mcmc, and run it for a good 100 000 cycles after
we did a burnin phase of 10 000 iterations:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves)
mymcmc.burnin(generations=10000,tuningInterval=500)
mymcmc.run(100000)
</code></pre></div></div>

<p>To get the annotate tree we use the map tree function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>treetrace = readTreeTrace("output/primates_mass_OU_ext.trees", treetype="clock")
map_tree = mapTree(treetrace,"output/primates_mass_OU_ext_MAP.tree")
</code></pre></div></div>

<h2 id="exercises-exercises-unnumbered">Exercises {#exercises .unnumbered}</h2>

<ul>
  <li>
    <p>Run the analysis.</p>
  </li>
  <li>
    <p>Using ‘Tracer‘, visualize the posterior distribution on the rate
parameter ‘sigma‘ and the ‘rootlogmass‘ and the internal states.</p>
  </li>
  <li>
    <p>How does the posterior distribution of ‘logOptim‘ looks compared
with the first and second analysis?</p>
  </li>
  <li>
    <p>Calculate the 95% credible interval for the rate of evolution of the
log of body mass ($\sigma$) and the ‘rootlogmass‘. Have they
changed?</p>
  </li>
</ul>

<h1 id="branch-rate-jump-process">Branch-rate jump process</h1>

<p>We start with specifying a probability for a jump to occur at a given
branch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rho &lt;- 0.01
</code></pre></div></div>

<p>Next, we specify the prior distribution on the root value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logRootOptim ~ dnUniform(-10,10)
moves[++mvi] = mvSlide(logRootOptim,delta=10,tune=true,weight=2)
</code></pre></div></div>

<p>Now, we use a loop over all branches to specify the per branch optimal
value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in numBranches:1) {
   optimChangeProbability[i] := Probability(1-rho)      # + (1-exp(-lambda*psi.branchLength(i)))
   optimMultiplier[i] ~ dnReversibleJumpMixture(1, dnGamma(2,2), optimChangeProbability[i] )
   if ( psi.isRoot( psi.parent(i) ) ) {
      nodeOptim[i] := logRootOptim * optimMultiplier[i]
   } else {
      nodeOptim[i] := nodeOptim[psi.parent(i)] * optimMultiplier[i]
   }
   optimChange[i] := ifelse( optimMultiplier[i] == 1, 0, 1 )
   moves[++mvi] = mvRJSwitch(optimMultiplier[i], weight=1)
   moves[++mvi] = mvScale(optimMultiplier[i], lambda=0.1, tune=true, weight=1)
}
</code></pre></div></div>

<p>Only for monitoring purposes we add a variable that counts the current
number of jumps.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>numOptimChanges := sum( optimChange )
</code></pre></div></div>

<p>You may want to monitor and then visualize the branch-specific jumps</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[4] = mnExtNewick(filename="output/primates_mass_OU_rate_jumps.trees", isNodeParameter=FALSE, printgen=10, separator = TAB, tree=psi, nodeOptim, optimChange)
</code></pre></div></div>


<ol class="bibliography"></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>

<script src="/assets/js/base.js"></script>

<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

  </body>
</html>
