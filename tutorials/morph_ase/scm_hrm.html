<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Discrete morphology - Stochastic Character Mapping and Hidden Rates</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Discrete morphology - Stochastic Character Mapping and Hidden Rates</h1>
	<h3 class="subtitle">Mapping Character Transitions and Testing for Rate Variation</h3>
	<h4 class="authors">Sebastian Höhna</h4>
  <h5>Last modified on November 29, 2022</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
            <li><a href="/tutorials/morph_tree/">Discrete morphology - Tree Inference</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/morph_ase/data/primates_activity_period.nex">primates_activity_period.nex</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_diet.nex">primates_diet.nex</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_habitat.nex">primates_habitat.nex</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_males.nex">primates_males.nex</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_mating_system.nex">primates_mating_system.nex</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_morph.nex">primates_morph.nex</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_morph_description.txt">primates_morph_description.txt</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_solitariness.nex">primates_solitariness.nex</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_terrestrially.nex">primates_terrestrially.nex</a></li>
        
          <li><a href="/tutorials/morph_ase/data/primates_tree.nex">primates_tree.nex</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/morph_ase/scripts/mcmc_scm_hrm.Rev">mcmc_scm_hrm.Rev</a></li>
        
          <li><a href="/tutorials/morph_ase/scripts/plot_anc_states_hrm.R">plot_anc_states_hrm.R</a></li>
        
          <li><a href="/tutorials/morph_ase/scripts/plot_hrm.R">plot_hrm.R</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="sec_hrm_overview">Overview</h2>
<hr class="section" />

<p>In this tutorial we focus on two new elements.
First, we will focus on how to model rate variation among lineages using hidden rate models.
Second, we will apply stochastic character mapping to estimate the location of character transitions.
Previously, we primarily estimated the ancestral states, which indirectly also show the transitions.
Ancestral state estimates are more powerful in their summary in that they show uncertainties of the estimated states.
Stochastic character maps are more powerful in showing a specific sequence of changes, especially for somewhat ordered models, such as the hidden rate models.
Stochastic character maps could be used to build ancestral state estimates as well, but this is not the purpose here.</p>

<h2 class="section" id="sec_hrm">Hidden rates to test for rate variation</h2>
<hr class="section" />

<p>Rates of morphological evolution, e.g., rates of gains and losses, might not have been constant over time and/or among different lineages.
For example, phylogenetically local clusters of plant lineages appear to transition between herbaceous and woody habits at relatively high rates, so one might want to quantify where these bursts occur <a class="citation" href="#Beaulieu2013">(Beaulieu et al. 2013)</a>.
There are two approaches how to include this rate variation.
First, we could employ <em>relaxed clock</em> models (see <a href="/tutorials/clocks/">Relaxed Clocks &amp; Time Trees</a> Tutorial) which are very powerful and flexible.
Second, we can use hidden rates models (HRMs).
HRMs do not observe the hidden state that induce the mode-shifts.
Instead, HRMs expand the character’s state space by a factor of $K$, and observe the character once for each of the $K$ categories.
For example, take a binary character modeled with $K=2$ hidden state classes.
The model would treat a character that is observed as being in state 0 as possibly being in either of the $K=2$ classes (0,1) and (0,2).
In practice, this is done by setting the likelihood of observing those $0k$ states to equal 1, thus, similar as ambiguous characters.</p>

<p>Remember the rate matrix for our independent rates model,
\(Q = \begin{smallmatrix}
 &amp; \begin{smallmatrix}0 &amp; 1\end{smallmatrix} \\
\begin{smallmatrix}0\\1\end{smallmatrix} &amp;
  \left(\begin{smallmatrix}- &amp; \mu_1\\\mu_2 &amp; -\end{smallmatrix}\right)\\
\end{smallmatrix}\)
where we can say that $\mu_1$ is the rate of gain and $\mu_2$ is the rate of loss.
Now if we say that there are two rate classes, one where characters evolve fast and the other where characters evolve slow, then we have a 4x4 rate matrix which is
\(Q = \begin{smallmatrix}
 &amp; \begin{smallmatrix}0S &amp; 1S &amp; 0F &amp; 1F\end{smallmatrix} \\
\begin{smallmatrix}0S\\1S\\0F\\1F\end{smallmatrix} &amp;
  \left(\begin{smallmatrix}- &amp; \mu_{1,s} &amp; \alpha &amp; 0 \\ \mu_{2,s} &amp; - &amp; 0 &amp; \alpha\\ \beta &amp; 0 &amp; - &amp; \mu_{1,f} \\ 0 &amp; \beta &amp; \mu_{2,f} &amp; -  \end{smallmatrix}\right)\\
\end{smallmatrix}\)
As you can see, we have now 6 parameters.
These parameters are:</p>
<ul>
  <li>$\mu_{1,s}$ the slow rate of gain</li>
  <li>$\mu_{1,f}$ the fast rate of gain</li>
  <li>$\mu_{2,s}$ the slow rate of loss</li>
  <li>$\mu_{2,f}$ the fast rate of loss</li>
  <li>$\alpha$ the rate of switching from the slow to the fast category</li>
  <li>$\beta$ the rate of switching from the fast to the slow category</li>
</ul>

<p>In principle, one can add arbitrarily many more rate categories, for example, using three rate categories (slow, intermediate and fast) or four rate categories (very slow, slow, fast, very fast).
In this tutorial, we show you the basic steps how to set up this hidden rates model with a slow and a fast class.</p>

<blockquote class="instruction">
  <p>Let us start with a fresh Rev script.
Create an empty text file and call it `mcmc_scm_hrm.Rev.</p>
</blockquote>

<h4 class="subsubsection" id="subsubsec_load_data">Load Data Matrices</h4>
<hr class="subsubsection" />

<p>As before, use the function <code class="language-plaintext highlighter-rouge">readDiscreteCharacterData()</code> to load a data matrix to the workspace from a formatted file.
Import the morphological character matrix and assign it to the variable <code class="language-plaintext highlighter-rouge">morpho</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>morpho &lt;- readDiscreteCharacterData("data/primates_solitariness.nex")
</code></pre></div></div>
<p>However, now we also need to <em>expand</em> the state space to include the 2 categories.
In RevBayes, the character data matrix has a member function <code class="language-plaintext highlighter-rouge">.expandCharacters()</code> which will create these additional categories.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>morpho_exp = morpho.expandCharacters( 2 )
</code></pre></div></div>
<p>To understand better what has happened, let us look at the character data matrices in RevBayes.
First, we look at the original character data matrix.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>morpho
</code></pre></div></div>
<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Standard character matrix with 233 taxa and 1 characters
   ========================================================
   Origination:                   primates_solitariness.nex
   Number of taxa:                233
   Number of included taxa:       233
   Number of characters:          1
   Number of included characters: 1
   Datatype:                      Standard
</code></pre></div></div>
<p>Notice that the <em>Datatype</em> for this character data matrix is <em>Standard</em>.
Now look at the expanded character data matrix.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; morpho_exp
</code></pre></div></div>
<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   NaturalNumbers character matrix with 233 taxa and 1 characters
   ==============================================================
   Origination:                   
   Number of taxa:                233
   Number of included taxa:       233
   Number of characters:          1
   Number of included characters: 1
   Datatype:                      NaturalNumbers
</code></pre></div></div>
<p>Notice that the <em>Datatype</em> here is <em>NaturalNumbers</em>.</p>

<p>Let us now also look at how the states are <em>expanded</em>.
Again, we look first at the original character data matrix.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; morpho.show()
</code></pre></div></div>
<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Allenopithecus_nigroviridis
   0
   Allocebus_trichotis
   1
   Alouatta_belzebul
   0
   Alouatta_caraya
   0
   Alouatta_coibensis
   0
   Alouatta_fusca
   0
   Alouatta_palliata
   0
   Alouatta_pigra
   0
   Alouatta_sara
   ?
...
</code></pre></div></div>
<p>And next for the expanded character data matrix.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; morpho_exp.show()
</code></pre></div></div>
<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Allenopithecus_nigroviridis
   (0 2)
   Allocebus_trichotis
   (1 3)
   Alouatta_belzebul
   (0 2)
   Alouatta_caraya
   (0 2)
   Alouatta_coibensis
   (0 2)
   Alouatta_fusca
   (0 2)
   Alouatta_palliata
   (0 2)
   Alouatta_pigra
   (0 2)
   Alouatta_sara
   ?
...
</code></pre></div></div>
<p>We see that state 0 (e.g., for <em>Allenopithecus nigroviridis</em>) was expanded to state (0 2) and that state 1 (e.g., <em>Allocebus trichotis</em>) was expanded to (1 3).
The state (0 2) means that the species is either in state 0 or state 2, we don’t know which.
This is exactly how ambiguous data is coded.
It also means that our previous state 0 now corresponds to 0 = No-Slow and 2 = No-Fast.
It is important to remember how the state space was expanded to set the rates up correctly.</p>

<h4 class="subsubsection" id="subsubsec_var">Create Helper Variables</h4>
<hr class="subsubsection" />

<p>As before, we need to instantiate a couple “helper variables” that will be used by downstream parts of our model specification files.
Create vectors of moves and monitors</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves = VectorMoves()
monitors = VectorMonitors()
</code></pre></div></div>

<h3 class="subsection" id="subsec_phylogeny">The Phylogeny</h3>
<hr class="subsection" />

<p>As usual for morphological analysis, we assume the phylogeny to be know.
Thus, we read in the tree as a constant variable:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phylogeny &lt;- readTrees("data/primates_tree.nex")[1]
</code></pre></div></div>

<h3 class="subsection" id="subsec_HRM_Model">The Hidden Rates Model (HRM)</h3>
<hr class="subsection" />

<p>Now we need to specify the hidden rates model.
Have a look again above at the rate matrix that we need to specify.
In the current example, we assume a binary morphological character and two rate categories.
This gives 4 states in total and therefore a 4x4 rate matrix.</p>

<p>Start with creating a matrix called <code class="language-plaintext highlighter-rouge">rates</code> where all elements are 0.0.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># we will fill the non-zero elements below
for (i in 1:4) {
  for (j in 1:4) {
    rates[i][j] &lt;- 0.0
  }
}
</code></pre></div></div>
<p>Next, we need to specify some priors for our rates.
It is probably quite challenging to have a good idea of a reasonable rate for the <em>hidden</em> category changes, i.e., the rate of changing between the slow and the fast rate categories.
We simply assume the same prior as before, that is, we assume on average 10 changes along the given phylogeny.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_pr := phylogeny.treeLength() / 10
</code></pre></div></div>
<p>Next, we need to assume some model how the fast and the slow rates are specified.
If we simply use free parameters for $\mu_{1,s}$ and $\mu_{1,f}$, we could easily estimate that $\mu_{1,s} &gt; \mu_{1,f}$ or the other way around.
So this model is clearly non-identifiable and we need to restrict that $\mu_{1,s} &lt; \mu_{1,f}$.
One option is to say that $\mu_{1,f} = \gamma * \mu_{1,s}$ where $\gamma \leq 1.0$.
In words, $\gamma$ is the factor how much the fast rate of gain is faster than the slow rate of gain.
An alternative solution is to specify that $\mu_{1}$ comes from a distribution, for example, a lognormal or gamma distribution, and $\mu_{1,i}$ corresponds to the median of the i-th quantile.
This approach is analogous in idea to the well known $+\Gamma$ model of among site rate variation for nulceotide evolution <a class="citation" href="#Yang1994a">(Yang 1994)</a>.</p>

<p>We will use the second approach but give some thoughts below on how to specify the first approach.
First, we need to specify the prior distribution on the standard deviation of the lognormal distribution.
Let us assume an exponential that on standard deviation with mean of $0.587405$, which means that the 95% probability interval of the lognormal distribution spans 1 order of magnitude.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>H &lt;- 0.587405
SD_PRIOR &lt;- 1/H
</code></pre></div></div>
<p>Now that we have the hyper-prior parameters, we can start with the prior distribution.
Let us start with the rate of gain.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_gain_median ~ dnExponential( rate_pr )
rate_gain_sd ~ dnExponential( SD_PRIOR )
</code></pre></div></div>
<p>Since these are positive real variable, we apply scaling moves on them.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale( rate_gain_median, weight=2 ) )
moves.append( mvScale( rate_gain_sd, weight=2 ) )
</code></pre></div></div>
<p>Next, we use the prior median and prior standard deviation to construct the median quantiles of the lognormal distribution.
We will use the function <code class="language-plaintext highlighter-rouge">fnDiscretizeDistribution</code>, which takes as arguments the distribution and the number of quantiles, which is 2 in our case for 2 rate categories (slow vs fast).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_gain := fnDiscretizeDistribution( dnLognormal( ln(rate_gain_median), rate_gain_sd ), 2 )
</code></pre></div></div>
<p>Now repeat exactly the same for the loss rate.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_loss_median ~ dnExponential( rate_pr )
rate_loss_sd ~ dnExponential( SD_PRIOR )

moves.append( mvScale( rate_loss_median, weight=2 ) )
moves.append( mvScale( rate_loss_sd, weight=2 ) )

rate_loss := fnDiscretizeDistribution( dnLognormal( ln(rate_loss_median), rate_loss_sd ), NUM_HIDDEN_STATES )
</code></pre></div></div>
<p>Finally, we create the two rate variables for the switching rates between the fast and slow rate categories.
As mentioned before, we will simply assume an exponential prior distribution with a mean of 10 events along the phylogeny.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch_slow_fast ~ dnExponential( rate_pr )
switch_fast_slow ~ dnExponential( rate_pr )
</code></pre></div></div>
<p>We also should not forget the moves on the switching rates.
We will use as usual the scaling move since these are rate variables (positive real numbers).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale( switch_slow_fast, weight=2 ) )
moves.append( mvScale( switch_fast_slow, weight=2 ) )
</code></pre></div></div>
<p>Now we have created all the rate variables.
We need to connect them to our rate matrix.
As a help, look again at the rate matrix described in the introduction.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rates[1][2] := rate_gain[1]     # 0S-&gt;1S
rates[1][3] := switch_slow_fast # 0S-&gt;0F
rates[2][1] := rate_loss[1]     # 1S-&gt;0S
rates[2][4] := switch_slow_fast # 1S-&gt;1F
rates[3][1] := switch_fast_slow # 0F-&gt;0S
rates[3][4] := rate_gain[2]     # 0F-&gt;1F
rates[4][2] := switch_fast_slow # 1F-&gt;1S
rates[4][3] := rate_loss[2]     # 1F-&gt;2F
</code></pre></div></div>
<p>Finally, we can create our transition rate matrix <code class="language-plaintext highlighter-rouge">Q</code> using the rate matrix function <code class="language-plaintext highlighter-rouge">fnFreeK</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_morpho := fnFreeK(rates, rescaled=FALSE)
</code></pre></div></div>

<p>For this model, we also want to specify parameters for the root frequencies $\pi$, and thus also their prior distributions.
We assume a flat Dirichlet distribution, which assigns each combination of root frequencies the exact same prior probability.
Remember that we 2 states for the observed characters and 2 states for the rate categories.
Thus we need a vector of 2*2 filled with ones.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rf_prior &lt;- rep(1,2*2)
</code></pre></div></div>
<p>We use this for our Dirichlet distribution.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rf ~ dnDirichlet( rf_prior )
</code></pre></div></div>
<p>We apply two different moves to the root frequencies, a <code class="language-plaintext highlighter-rouge">mvBetaSimplex</code> that changes a single frequencies and rescales the other frequencies, and a <code class="language-plaintext highlighter-rouge">mvDirichletSimplex</code> that redraws all root frequencies together.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvBetaSimplex( rf, weight=2 ) )
moves.append( mvDirichletSimplex( rf, weight=2 ) )
</code></pre></div></div>

<p>Lastly, we set up the CTMC.
Not that this time we need to specify the <code class="language-plaintext highlighter-rouge">type=NaturalNumbers</code>, as we saw this is used in the <em>expanded</em> data matrix.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phyMorpho ~ dnPhyloCTMC(tree=phylogeny, Q=Q_morpho, rootFrequencies=rf, type="NaturalNumbers")
</code></pre></div></div>
<p>We conclude the model specification by attaching the <em>expanded</em> data matrix to the CTMC object.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phyMorpho.clamp(morpho_exp)
</code></pre></div></div>

<h3 class="subsection" id="subsec_complete_MCMC">Complete MCMC Analysis</h3>
<hr class="subsection" />

<h4 class="subsubsection" id="subsubsec_Mod_Obj">Create Model Object</h4>
<hr class="subsubsection" />

<p>We can now create our workspace model variable with our fully specified model DAG.
We will do this with the <code class="language-plaintext highlighter-rouge">model()</code> function and provide a single node in the graph (<code class="language-plaintext highlighter-rouge">phylogeny</code>).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(phylogeny)
</code></pre></div></div>

<p>The object <code class="language-plaintext highlighter-rouge">mymodel</code> is a wrapper around the entire model graph and allows us to pass the model to various functions that are specific to our MCMC analysis.</p>

<h4 class="subsubsection" id="subsubsec_Monitors">Specify Monitors and Output Filenames</h4>
<hr class="subsubsection" />

<p>In this exercise we wanted to explore stochastic character mapping.
Stochastic character mapping, similar to ancestral state estimation, is achieved in RevBayes using the help of monitors, specifically the <code class="language-plaintext highlighter-rouge">mnStochasticCharacterMap</code> monitor.</p>

<p>We will specify the same model monitor (<code class="language-plaintext highlighter-rouge">mnModel</code>), screen monitor (<code class="language-plaintext highlighter-rouge">mnScreen</code>) and ancestral state monitor (<code class="language-plaintext highlighter-rouge">mnJointConditionalAncestralState</code>) as before (<a href="/tutorials/morph_ase/ase.html">Discrete morphology - Ancestral State Estimation</a>).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 1. for the full model #
monitors.append( mnModel(filename="output/solitariness_hrm.log", printgen=1) )
# 2. and a few select parameters to be printed to the screen #
monitors.append( mnScreen(printgen=10) )
# 3. add an ancestral state monitor
monitors.append( mnJointConditionalAncestralState(tree=phylogeny,
                                                  ctmc=phyMorpho,
                                                  filename="output/solitariness_hrm.states.txt",
                                                  type="NaturalNumbers",
                                                  printgen=1,
                                                  withTips=true,
                                                  withStartStates=false) )
</code></pre></div></div>
<p>Now add the new stochastic character mapping monitor, <code class="language-plaintext highlighter-rouge">mnStochasticCharacterMap</code>.
This monitor also requires that you specify the <code class="language-plaintext highlighter-rouge">CTMC</code> object, which is <code class="language-plaintext highlighter-rouge">phyMorpho</code> in our example, and output filename, the frequency how often you want to generate stochastic character maps, e.g., once every iteration or every 10 generations, and whether we want to include the simmap states (yes, very important).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 4. add an stochastic character map monitor
monitors.append( mnStochasticCharacterMap(ctmc=phyMorpho,
                                          filename="output/solitariness_hrm_stoch_char_map.log",
                                          printgen=1,
                                          include_simmap=true) )
</code></pre></div></div>
<p>This monitor will create the <code class="language-plaintext highlighter-rouge">output/solitariness_hrm_stoch_char_map.log</code> file.
Just like the other log files, each row in this file represents a different sample from the MCMC.
Each column in the file, though, is the character history for a different node in the phylogeny.</p>

<h4 class="subsubsection" id="set-up-the-mcmc">Set-Up the MCMC</h4>
<hr class="subsubsection" />

<p>Setup the MCMC analysis as before (<a href="/tutorials/morph_ase/ase.html">Discrete morphology - Ancestral State Estimation</a>).
This will run 2 replicated MCMC runs with 5,000 iterations and auto-tuning the moves every 200 iterations.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves, nruns=2, combine="mixed")
mymcmc.run(generations=5000, tuningInterval=200)
</code></pre></div></div>

<h4 class="subsubsection" id="summarizing-the-mcmc-output">Summarizing the MCMC output</h4>
<hr class="subsubsection" />

<p>After the MCMC simulation, we can calculate the maximum a posteriori
<em>marginal</em>, <em>joint</em>, or <em>conditional</em> character history.
As before (<a href="/tutorials/morph_ase/ase.html">Discrete morphology - Ancestral State Estimation</a>), we will compute the ancestral state estimates.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Read in the tree trace and construct the ancestral states (ASE) #
anc_states = readAncestralStateTrace("output/solitariness_hrm.states.txt")
anc_tree = ancestralStateTree(tree=phylogeny, ancestral_state_trace_vector=anc_states, include_start_states=false, file="output/solitariness_ase_hrm.tree", burnin=0.25, summary_statistic="MAP", site=1, nStates=2*2)
</code></pre></div></div>
<p>In a very similar way, we summarize the output of the stochastic character mapping.
First, we load in the ancestral state trace (sampled character histories)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>anc_states_stoch_map = readAncestralStateTrace("output/solitariness_hrm_stoch_char_map.log")
</code></pre></div></div>
<p>Then we use the <code class="language-plaintext highlighter-rouge">characterMapTree</code> function.
This generates two <strong>SIMMAP</strong> <a class="citation" href="#Bollback2006">(Bollback 2006)</a>
formatted files:
1) the maximum a posteriori character history,
and 2) the posterior probabilities of the entire character history.
These can be plotted using the <strong>phytools</strong> R package <a class="citation" href="#Revell2012">(Revell 2012)</a>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char_map_tree = characterMapTree(tree=phylogeny,
                 ancestral_state_trace_vector=anc_states_stoch_map,
                 character_file="output/solitariness_hrm_marginal_character.tree",
                 posterior_file="output/solitariness_hrm_marginal_posterior.tree",
                 burnin=0.25,
                 num_time_slices=500)
</code></pre></div></div>

<p>This is all you need for this analysis.
Don’t forget to quit RevBayes at the end of the script.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Quit RevBayes #
q()
</code></pre></div></div>

<blockquote class="instruction">
  <p>This is all that you need to do for the rate variation analysis with hidden rate categories and stochastic character mapping. Save your script and give it a try!</p>
</blockquote>

<h2 class="section" id="sec_ase_results">Evaluate and Summarize Your Results</h2>
<hr class="section" />

<h3 class="subsection" id="subsec_ase_plots">Visualizing Ancestral State Estimates</h3>
<hr class="subsection" />

<p>We have previously plotted the ancestral states, both the <em>maximum a posterior</em> (MAP) states as well as the posterior probabilities of all states shown as pie chart <a href="/tutorials/morph_ase/ase.html">Discrete morphology - Ancestral State Estimation</a>.
You should repeat plotting the ancestral states now also for the hidden rates model (<code class="language-plaintext highlighter-rouge">hrm</code>) analyses.
My output is shown in <a href="#fig_anc_states_hrm"></a>.</p>

<p>Finally, we also want to plot the stochastic character mapping.
Unfortunately, this cannot be done yet in RevGadgets and instead we are going to use <strong>phytools</strong> <a class="citation" href="#Revell2012">(Revell 2012)</a>.
Here is a slightly simplified version of the script whithout changing the color scheme.</p>
<pre><code class="language-{R}">library(plotrix)
library(phytools)

character_file = "output/solitariness_hrm_marginal_character.tree"

sim2 = read.simmap(file=character_file, format="phylip")

colors = vector()
for (i in 1:length( sim2$maps ) ) {
    colors = c(colors, names(sim2$maps[[i]]) )
}
colors = sort(as.numeric(unique(colors)))
col_idx = colors + 1
cols = setNames( rainbow(length(colors), start=0.0, end=0.9), colors)
cols = cols[col_idx]

pdf( "Primates_solitariness_HRM_simmap.pdf" )

plotSimmap(sim2, cols, fsize=0.5, lwd=1, split.vertical=TRUE, ftype="i")

# add legend
x = 0
y = 225

leg = c("no - slow", "yes - slow", "no - fast", "yes - fast")
leg = leg[col_idx]
colors = cols
y = y - (0:(length(leg) - 1))*10
x = rep(x, length(y))
text(x + 0.005, y, leg, pos=4, cex=1.15)

mapply(draw.circle, x=x, y=y, col=colors, MoreArgs = list(nv=200, radius=1, border="white"))

dev.off()
</code></pre>

<figure id="fig_anc_states_hrm"><p><img src="figures/Primates_solitariness_HRM_simmap.png" height="300" />
<img src="figures/Primates_solitariness_ASE_HRM_MAP.png" height="300" />
<img src="figures/Primates_solitariness_ASE_HRM_Pie.png" height="300" /></p>
<figcaption>Stochastic character map (left) and ancestral state estimates (middle and right) of solitariness under the hidden rates model. You might notice that there is a switch from the fast to the slow rate category for the <strong>no</strong> state, but we never visited the slow rate category for the <strong>yes</strong> state.</figcaption>
</figure>

<blockquote class="instruction">
  <p>How can you explain the observed allocation of clades to the slow and fast rate categories?
Do ancestral state estimates match with the stochastic character maps?
How certain are we in the ancestral state estimates?</p>
</blockquote>

<blockquote class="instruction">
  <p>Click below to begin the next exercise!</p>
</blockquote>

<ul>
  <li><a href="/tutorials/morph_ase/corr">Testing for Correlation between Characters</a></li>
</ul>

<ol class="bibliography"><li><span id="Beaulieu2013">Beaulieu J.M., O’Meara B.C., Donoghue M.J. 2013. Identifying hidden rate changes in the evolution of a binary morphological character: the evolution of plant habit in campanulid angiosperms. Systematic Biology. 62:725–737.</span>

<a href="https://doi.org/10.1093/sysbio/syt034">10.1093/sysbio/syt034</a>

</li>
<li><span id="Bollback2006">Bollback J.P. 2006. SIMMAP: stochastic character mapping of discrete traits on phylogenies. BMC bioinformatics. 7:88.</span>

</li>
<li><span id="Revell2012">Revell L.J. 2012. phytools: an R package for phylogenetic comparative biology (and other things). Methods in Ecology and Evolution.:217–223.</span>

</li>
<li><span id="Yang1994a">Yang Z. 1994. Maximum Likelihood Phylogenetic Estimation from DNA Sequences with Variable Rates Over Sites: Approximate Methods. Journal of Molecular Evolution. 39:306–314.</span>

<a href="https://doi.org/10.1007/BF00160154">10.1007/BF00160154</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
