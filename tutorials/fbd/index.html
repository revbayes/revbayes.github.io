<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <link rel="canonical" href="https://revbayes.github.io/tutorials/fbd/fbd_specimen.html"> <!--Point search engines away until debugged-->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Combined-Evidence Analysis and the Fossilized Birth-Death Process for Stratigraphic Range Data</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Combined-Evidence Analysis and the Fossilized Birth-Death Process for Stratigraphic Range Data</h1>
	<h3 class="subtitle">Joint inference of divergence times and phylogenetic relationships of fossil and extant taxa</h3>
	<h4 class="authors">Tracy A. Heath, April M. Wright, and June Walker</h4>
  <h5>Last modified on March 17, 2025</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/fbd/data/bears_cytb.nex">bears_cytb.nex</a></li>
        
          <li><a href="/tutorials/fbd/data/bears_morphology.nex">bears_morphology.nex</a></li>
        
          <li><a href="/tutorials/fbd/data/bears_taxa.tsv">bears_taxa.tsv</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/fbd/scripts/mcmc_CEFBDRP_Ranges.Rev">mcmc_CEFBDRP_Ranges.Rev</a></li>
        
          <li><a href="/tutorials/fbd/scripts/model_FBDRP.Rev">model_FBDRP.Rev</a></li>
        
          <li><a href="/tutorials/fbd/scripts/model_GTRG.Rev">model_GTRG.Rev</a></li>
        
          <li><a href="/tutorials/fbd/scripts/model_Morph.Rev">model_Morph.Rev</a></li>
        
          <li><a href="/tutorials/fbd/scripts/model_UExp.Rev">model_UExp.Rev</a></li>
        
          <li><a href="/tutorials/fbd/scripts/summarize_CEFBD.Rev">summarize_CEFBD.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="overview">Overview</h2>
<hr class="section" />

<p>This tutorial demonstrates how to specify the models used in a Bayesian
“combined-evidence” phylogenetic analysis of extant and fossil species,
combining morphological and molecular data as well as stratigraphic
range data from the fossil record [<em>e.g.,</em> 
<a class="citation" href="#Ronquist2012a">(Ronquist et al. 2012; Zhang et al. 2016; Gavryushkina et al. 2017)</a>]. 
We begin with a concise
introduction to the models used in this analysis in the <a href="#introduction"></a> section, 
followed by a detailed example analysis in 
<a href="#Exercise"></a> demonstrating how to apply these models in
RevBayes <a class="citation" href="#Hoehna2017a">(Höhna et al. 2017)</a> and use Markov chain Monte Carlo (MCMC) to
estimate the posterior distribution of dated phylogenies for data
collected from living and fossil bears (family Ursidae).</p>

<h2 class="section" id="introduction">Introduction</h2>
<hr class="section" />

<p>The “combined-evidence” analysis described in this tutorial uses a
probabilistic graphical model <a class="citation" href="#Hoehna2014b">(Höhna et al. 2014)</a> integrating three separate
likelihood components or data partitions (<a href="#fig_module_gm"></a>): one
for molecular data (<a href="#Intro-GTR"></a>), one for
morphological data (<a href="#Intro-Morpho"></a>), and one for
fossil stratigraphic range data (<a href="#Intro-FBD"></a>).
In addition, all likelihood components are conditioned on a tree
topology with divergence times which is modeled according to a separate
prior component (defined in <a href="#Intro-FBD"></a>).</p>

<figure id="fig_module_gm"><p><img src="figures/tikz/full_model_modular.png" width="700" /></p>
<figcaption>Modular components of the graphical model used in the “combined-evidence” 
analysis described in this tutorial.</figcaption>
</figure>

<p>In <a href="#fig_example_tree"></a> we provide an example of a type of tree
estimated from a combined-evidence analysis. This example shows the
complete tree (<a href="#fig_example_tree"></a>A) and the “reconstructed tree”
(<a href="#fig_example_tree"></a>B).
We will describe the distinction between these two trees in 
the section on <a href="#Intro-FBD"></a>.</p>

<figure id="fig_example_tree"><p><img src="figures/complete_tree.png" width="400" />
<img src="figures/reconstructed_tree.png" width="400" /></p>
<figcaption>One possible
realization of the specimen-level fossilized birth-death (described in section
<a href="#Intro-FBD"></a>) (A) The complete tree shows all lineages both sampled (solid
lines) and unsampled (dotted lines).
(B) The reconstructed tree shows only the sampled specimens, both fossil and extant.</figcaption>
</figure>

<h3 class="subsection" id="Intro-FBD">Lineage Diversification and Sampling</h3>
<hr class="subsection" />

<p>The joint prior distribution on tree topologies and divergence times of
living and extinct species used in this tutorial is described by the
<em>fossilized birth-death</em> (FBD) process <a class="citation" href="#Stadler2010">(Stadler 2010; Heath et al. 2014; Stadler et al. 2018)</a>. This
model simply treats the fossil observations as part of the process
governing the tree topology and branch times (the ‘Time Tree Model’ node in
<a href="#fig_module_gm"></a>). The fossilized birth-death process provides a
model for the distribution of speciation and sampling events <em>i.e.</em> tree topology, 
speciation times, number of sampled living taxa, and
lineage samples before the present
(<em>e.g.</em> non-contemporaneous samples like
fossils or viruses). This type of tree is shown in <a href="#fig_example_tree"></a>. 
Importantly, this model can be used <em>with or
without</em> character data for the historical samples. Thus, it provides a
reasonable prior distribution for analyses combining morphological or
DNA data for both extant and fossil
taxa—<em>i.e.</em> the so-called “combined-evidence” or “total evidence”
approaches described by <a class="citation" href="#Ronquist2012a">Ronquist et al. (2012)</a> and extended by <a class="citation" href="#Zhang2016">Zhang et al. (2016)</a> and
<a class="citation" href="#Gavryushkina2016">Gavryushkina et al. (2017)</a>. When matrices of discrete morphological characters
for both living and fossil species are unavailable, the fossilized
birth-death model imposes a time structure on the tree by
<a href="https://en.wikipedia.org/wiki/Marginal_distribution"><em>marginalizing</em></a>
over all possible attachment points for the fossils on the extant tree
<a class="citation" href="#Heath2014">(Heath et al. 2014)</a>, therefore, some prior knowledge of phylogenetic
relationships is important.</p>

<p>The FBD model (<a href="#fig_fbd_gm"></a>) describes the probability of the
tree and fossils conditional on the birth-death parameters:
$f[\mathcal{T} \mid \lambda, \mu, \rho, \psi, \phi]$, where
$\mathcal{T}$ denotes the tree topology, divergence times fossil
occurrence times and the times at which the fossils attach to the tree.
The birth-death parameters $\lambda$ and $\mu$ denote the speciation and
extinction rates, respectively. The ‘fossil
recovery rate’ is denoted $\psi$ and describes the rate at which fossils
are sampled along lineages of the complete tree. The sampling
probability parameter $\rho$ represents the <em>probability</em> that an extant
species is sampled, and $\phi$ represents the time at which the process
originated (called the ‘origin time’).</p>

<figure id="fig_fbd_gm"><p><img src="figures/tikz/fbd_gm.png" width="500" /></p>
<figcaption>A graphical model of the fossilized birth-death model describing the 
generation of the time tree (in
<a href="#fig_module_gm"></a>) used in this tutorial. The parameters of the
fossilized birth-death process are labeled in orange. The speciation,
extinction and fossilization rates are stochastic nodes (circles) drawn
from exponential distributions, while the origin time is uniformly
distributed. The sampling probability is constant node (square) and
equal to one for the tree in <a href="#fig_example_tree"></a> 
and for the analysis in the exercise given in this tutorial. 
This model represents the phylogenetic continuous-time Markov
chain that links the tree model to the other model components and the
observed sequence data. For more information on probabilistic graphical
models and their notation, please see <a class="citation" href="#Hoehna2014b">(Höhna et al. 2014)</a>.</figcaption>
</figure>

<p>In the example FBD tree shown in <a href="#fig_example_tree"></a>, the
diversification process originates at time $\phi$, giving rise to $n=10$
species in the present, with both sampled fossils and
extant species. All of the lineages represented in <a href="#fig_example_tree"></a>A 
(both solid and dotted lines) show the
<em>complete tree</em>. This is the tree of all extant <em>and</em> extinct lineages
generated by the process.
The complete tree is distinct from the
<em>reconstructed tree</em> (<a href="#fig_example_tree"></a>B) which is the tree
representing only the lineages sampled as extant taxa or fossils. Fossil
observations (non-extant red circles in <a href="#fig_example_tree"></a>) are recovered
over the lifetime of the process along the lineages of the complete
tree. If a lineage does not have any descendants sampled in the present 
(or at the moment it goes extinct),
it is lost and cannot be observed, these are the dotted lines in 
<a href="#fig_example_tree"></a>A. The probability must be conditioned on the origin
time of the process $\phi$. The origin ($\phi$) of a birth-death process
is the starting time of the <em>stem</em> lineage, thus this conditions on a
single lineage giving rise to the tree.</p>

<p>An important characteristic of the FBD model is that it accounts for the
probability of sampled ancestor-descendant pairs <a class="citation" href="#foote1996">(Foote 1996)</a>. Given
that fossils are sampled from lineages in the diversification process,
the probability of sampling fossils that are ancestors to taxa sampled
at a later date is correlated with the turnover rate ($r=\mu/\lambda$),
the fossil recovery rate ($\psi$), and the probability of sampling an extant taxon ($\rho$). 
This feature is important,
particularly for datasets with many sampled fossils. In the example
(<a href="#fig_example_tree"></a>), several of the fossils have sampled
descendants. These fossils have solid black lines leading to the
present.</p>

<h3 class="subsection" id="Intro-Taxonomy">Assignment of fossil specimens to taxonomic species</h3>
<hr class="subsection" />

<p>The most basic version of the FBD treats individual fossil specimens as separate taxonomic entities. This is the standard specimen-level “Fossilized Birth Death Process” (implemented as <code class="language-plaintext highlighter-rouge">FBDP</code> in RevBayes).
However, in most cases taxonomic species are represented in the fossil record by multiple fossil specimens sampled at
different stratigraphic ages. 
These <em>stratigraphic ranges</em> are the first and last occurrences observed for a single morpho-species in the fossil
record (for extant species, the last occurrence is the present day).
In order to compute the density of the FBD while accounting for this stratigraphic species range data, we need to assume some model of speciation that will allow us to assign fossil specimens to species. <a class="citation" href="#Stadler2018">Stadler et al. (2018)</a> describe an extension to the FBD which assigns lineages to taxonomic species through a process of asymmetric or “budding” speciation. This model assumes that at each asymmetric speciation event, one descendant species represents a new species, while the other descendant represents the continuation of the parent species. In this way, each lineage (and therefore all the fossil specimens sampled along that lineage) can be mapped to a unique species. An example realization of such a speciation process is shown in <a href="#fig_budding"></a>.</p>

<figure id="fig_budding"><p><img src="figures/budding1.png" width="400" />
\(\implies\)
<img src="figures/budding2.png" width="400" /></p>
<figcaption>One possible realization of asymmetric speciation (light blue) along one lineage of the fossilized birth 
death tree from <a href="#fig_example_tree"></a>.
(A) The highlighted lineage originates through an asymmetric speciation event by branching upward,
and then continues past additional speciation events by downward branching.
Fossil specimens lying along this path are assigned to the same taxonomic species.
(B) The same lineage is highlighted in the oriented tree with lineages representing the same species collapsed into straight lines.</figcaption>
</figure>

<p><a class="citation" href="#Stadler2018">Stadler et al. (2018)</a> show how to compute the density of the “sampled tree”, which is obtained by pruning all unsampled lineages after asymmetric species identities have been assigned in the complete tree (<a href="#fig_sampled"></a>). This gives rise to the “Fossilized Birth Death Range Process” (implemented as <code class="language-plaintext highlighter-rouge">FBDRP</code> in RevBayes). This is the model we will be using in this tutorial. It is important to note that the tips in the sampled tree represent the age of the youngest sample for each species.</p>

<figure id="fig_sampled"><p><img src="figures/sampled_tree.png" width="400" /></p>
<figcaption>The “sampled tree” is produced by pruning unsampled lineages from the oriented tree in <a href="#fig_budding"></a>B and collapsing intermediate fossil samples other than the first and last occurrences into stratigraphic ranges.</figcaption>
</figure>

<h3 class="subsection" id="Intro-GTR">Nucleotide Sequence Evolution</h3>
<hr class="subsection" />

<p>The model component for the molecular data uses a general
time-reversible model of nucleotide evolution and gamma-distributed rate
heterogeneity across sites (the <em>Substitution Model</em> and <em>Sites Model</em> in <a href="#fig_module_gm"></a>). This
model of sequence evolution is covered thoroughly in the
<a href="/tutorials/ctmc/">Nucleotide substitution models</a>
tutorial.</p>

<h4 class="subsubsection" id="Intro-GTR-UExp">Lineage-Specific Rates of Sequence Evolution</h4>
<hr class="subsubsection" />

<p>Rates of nucleotide sequence evolution can vary widely among lineages,
and so models that account for this variation by relaxing the assumption
of a strict molecular clock <a class="citation" href="#Zuckerkandl1962">(Zuckerkandl and Pauling 1962)</a> can allow for more
accurate estimates of substitution rates and divergence times
<a class="citation" href="#Drummond2006">(Drummond et al. 2006)</a>. The simplest type of relaxed clock model assumes that
lineage-specific substitution rates are independent or “uncorrelated”.
One example of such an uncorrelated relaxed model is the uncorrelated
<em>exponential</em> relaxed clock, in which the substitution rate for each
lineage is assumed to be independent and identically distributed
according to an exponential density (<a href="#fig_uexp_gm"></a>). This is <em>Branch Rates Model</em> 
for the <em>Molecular Data</em> (<a href="#fig_module_gm"></a>) that we will use in this tutorial. 
Another possible uncorrelated relaxed
clock model is the uncorrelated lognormal model, described in the
<a href="/tutorials/clocks/">Relaxed Clocks &amp; Time Trees</a>
tutorial [also see <a class="citation" href="#Thorne2002">Thorne and Kishino (2002)</a>].</p>

<figure id="fig_uexp_gm"><p><img src="figures/tikz/uexp_gm.png" width="400" /></p>
<figcaption>A graphical model of the
uncorrelated exponential relaxed clock model. In this model, the clock
rate on each branch is independent and identically distributed according
to an exponential density with mean drawn from an exponential hyperprior
distribution.</figcaption>
</figure>

<h3 class="subsection" id="Intro-Morpho">Morphological Character Evolution</h3>
<hr class="subsection" />

<p>For the vast majority of extinct species, fossil morphology is the
primary source of phylogenetically informative characters. Therefore, an
appropriate model of morphological character evolution is needed to
reliably infer the positions of these species in a phylogenetic
analysis. The Mk model <a class="citation" href="#Lewis2001">(Lewis 2001)</a> uses a generalized Jukes-Cantor
matrix to allow for the incorporation of morphology into likelihood and
Bayesian analyses. In its simplest form, this model assumes that
characters change states symmetrically—that a given character is as
likely to transition from a one state to another as it is to reverse. In
this tutorial we will consider only binary morphological characters,
<em>i.e.</em> characters that are observed in one of
two states, 0 or 1. For example, the assumption of the single-rate Mk
model applied to our binary character would mean that a change from a 0
state to a 1 state is as likely as a change from a 1 state to a 0 state.
This assumption is equivalent to assuming that the stationary
probability of being in a 1 state is equal to $1/2$.</p>

<p>In this tutorial, we will apply a single-rate Mk model as a prior on
binary morphological character change. If you are interested extensions
of the Mk model that relax the assumptions of symmetric state change,
please see <a href="/tutorials/morph_tree/">Discrete morphology - Tree Inference</a>.</p>

<p>Because of the way morphological data are collected, we need to exercise
caution in how we model the data. Traditionally, phylogenetic trees were
built from morphological data using parsimony. Therefore, only parsimony
informative characters were collected—that is, characters that are
useful for discriminating between phylogenetic hypotheses under the
maximum parsimony criterion. This means that many morphological datasets
do not contain invariant characters or
<a href="https://en.wikipedia.org/wiki/Autapomorphy">autapomorphies</a>, as these
are not parsimony informative. However, by excluding these slow-evolving
characters, estimates of the branch lengths can be inflated
<a class="citation" href="#Felsenstein1992">(Felsenstein 1992; Lewis 2001)</a>. Therefore, it is important to use models
that can condition on this data-acquisition bias. RevBayes has two
ways of doing this: one is used for datasets in which only parsimony
informative characters are observed; the other is for datasets in which
parsimony informative characters and parsimony uninformative variable
characters (such as autapomorphies) are observed.</p>

<h4 class="subsubsection" id="Intro-MorphClock">The Morphological Clock</h4>
<hr class="subsubsection" />

<p>Just like with the molecular data <a href="#Intro-GTR-UExp"></a>,
our observations of discrete morphological characters are conditional on
the rate of change along each branch in the tree. This model component
defines the of the in the generalized graphical model shown in 
<a href="#fig_module_gm"></a>. The relaxed clock model we described for the
molecular data in <a href="#Intro-GTR-UExp"></a> it allows the
substitution rate to vary through time and among lineages. For the
morphological data, we will instead use a “strict clock” model
<a class="citation" href="#Zuckerkandl1962">(Zuckerkandl and Pauling 1962)</a>, in which the rate of discrete character change is
assumed to be constant throughout the tree. The strict clock is the
simplest morphological branch rate model we can construct (graphical
model shown in <a href="#fig_morph_clock_gm"></a>).</p>

<figure id="fig_morph_clock_gm"><p><img src="figures/tikz/morph_clock_gm.png" width="300" /></p>
<figcaption>The graphical-model
representation of the branch-rate model governing the evolution of
morphological characters. This model is consistent with a strict
morphological clock, where every branch has the same rate of change
($c$) and that rate is drawn from an exponential distribution with a
rate parameter of $\delta_c$.</figcaption>
</figure>

<h2 class="section" id="Exercise">Example: Estimating the Phylogeny and Divergence Times of Fossil and Extant Bears</h2>
<hr class="section" />

<p>In this exercise, we will combine different types of data from 22
species of extant and extinct bears to estimate a posterior distribution
of calibrated time trees for this group. We have molecular sequence data
for ten species, which represent all of the eight living bears and two
extinct species sequenced from sub-fossil specimens (<em>Arctodus simus,
Ursus spelaeus</em>). The sequence alignment provided is a 1,000 bp fragment
of the cytochrome-b mitochondrial gene <a class="citation" href="#krause2008">(Krause et al. 2008)</a>. The morphological
character matrix unites 18 taxa (both fossil and extant) with 62 binary
(states 0 or 1) characters <a class="citation" href="#abella12">(Abella et al. 2012)</a>. For the fossil species,
occurrence times are obtained from the literature or fossil databases
like the <a href="http://fossilworks.org/">Fossilworks PaleoDB</a> or the <a href="http://fossilcalibrations.org/">Fossil
Calibration Database</a>, or from your own
paleontological expertise. The 14 fossil species used in this analysis
are listed in <a href="#tab_bear_fossils"></a> along with the age range for the
species and relevant citation. Finally, there are two fossil species
(<em>Parictis montanus, Ursus abstrusus</em>) for which we do not have
morphological character data (or molecular data) and we must use prior
information about their phylogenetic relationships to incorporate these
taxa in our analysis. This information will be applied using clade
constraints.</p>

<h3 class="subsection" id="Exercise-DataFiles">Data and Files</h3>
<hr class="subsection" />

<p>On your own computer or your remote machine, create a directory for this tutorial.</p>

<p>In this directory, create another directory called <code class="language-plaintext highlighter-rouge">data</code>, and download the data
files which you can find at the top of this page.</p>

<p>In the <code class="language-plaintext highlighter-rouge">data</code> folder, you will find the following files:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">bears_taxa.tsv</code>: a tab-separated table listing every bear species
(both fossil and extant) and their occurrence age ranges. For extant
taxa, the minimum age is 0.0
(<em>i.e.</em> the present).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">bears_cytb.nex</code>: an alignment in NEXUS format of 1,000 bp of
cytochrome b sequences for 10 bear species. This alignment includes
8 living bears and 2 extinct sub-fossil bears.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">bears_morphology.nex</code>: a matrix of 62 discrete, binary (coded <code class="language-plaintext highlighter-rouge">0</code>
or <code class="language-plaintext highlighter-rouge">1</code>) morphological characters for 18 species of fossil and
extant bears.</p>
  </li>
</ul>

<figure id="tab_bear_fossils" class="table"><figcaption class="table">Age range data for fossil and extant bear species.</figcaption>

<table>
  <thead>
    <tr>
      <th><strong>Fossil Species</strong></th>
      <th style="text-align: center"><strong>Age</strong></th>
      <th style="text-align: right"><strong>Reference</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><em>Ailuropoda melanoleuca</em></td>
      <td style="text-align: center">0.0-1.24</td>
      <td style="text-align: right"><a class="citation" href="#abella12">(Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Helarctos malayanus</em></td>
      <td style="text-align: center">0.0-1.78</td>
      <td style="text-align: right"><a class="citation" href="#abella12">(Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Melursus ursinus</em></td>
      <td style="text-align: center">0.0-1.8</td>
      <td style="text-align: right"><a class="citation" href="#abella12">(Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Tremarctos ornatus</em></td>
      <td style="text-align: center">0.0-0.0</td>
      <td style="text-align: right"><a class="citation" href="#abella12">(Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Ursus americanus</em></td>
      <td style="text-align: center">0.0-1.84</td>
      <td style="text-align: right"><a class="citation" href="#abella12">(Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Ursus arctos</em></td>
      <td style="text-align: center">0.0-1.71</td>
      <td style="text-align: right"><a class="citation" href="#abella12">(Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Ursus maritimus</em></td>
      <td style="text-align: center">0.0-0.65</td>
      <td style="text-align: right"><a class="citation" href="#abella12">(Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Ursus thibetanus</em></td>
      <td style="text-align: center">0.0-1.18</td>
      <td style="text-align: right"><a class="citation" href="#abella12">(Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Agriarctos spp.</em></td>
      <td style="text-align: center">4.9–7.75</td>
      <td style="text-align: right"><a class="citation" href="#abella2011">(Abella et al. 2011; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Ailurarctos lufengensis</em></td>
      <td style="text-align: center">5.8–8.2</td>
      <td style="text-align: right"><a class="citation" href="#jin2007">(Jin et al. 2007; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Arctodus simus</em></td>
      <td style="text-align: center">0.012–2.588</td>
      <td style="text-align: right"><a class="citation" href="#churcher1993">(Churcher et al. 1993; Krause et al. 2008)</a></td>
    </tr>
    <tr>
      <td><em>Ballusia elmensis</em></td>
      <td style="text-align: center">13.7–16</td>
      <td style="text-align: right"><a class="citation" href="#ginsburg1998">(Ginsburg and Morales 1998; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Indarctos vireti</em></td>
      <td style="text-align: center">7.75–8.7</td>
      <td style="text-align: right"><a class="citation" href="#montoya2001">(Montoya et al. 2001; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Indarctos arctoides</em></td>
      <td style="text-align: center">8.7–9.7</td>
      <td style="text-align: right"><a class="citation" href="#geraads2005">(Geraads et al. 2005; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Indarctos punjabiensis</em></td>
      <td style="text-align: center">4.9–9.7</td>
      <td style="text-align: right"><a class="citation" href="#baryshnikov2002">(Baryshnikov 2002; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Kretzoiarctos beatrix</em></td>
      <td style="text-align: center">11.2–11.8</td>
      <td style="text-align: right"><a class="citation" href="#abella2011">(Abella et al. 2011; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Parictis montanus</em></td>
      <td style="text-align: center">33.9–37.2</td>
      <td style="text-align: right"><a class="citation" href="#clark1972">(Clark and Guensburg 1972; Krause et al. 2008)</a></td>
    </tr>
    <tr>
      <td><em>Ursavus primaevus</em></td>
      <td style="text-align: center">13.65–15.97</td>
      <td style="text-align: right"><a class="citation" href="#andrews1977">(Andrews and Tobien 1977; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Ursavus brevihinus</em></td>
      <td style="text-align: center">15.97–16.9</td>
      <td style="text-align: right"><a class="citation" href="#heizmann1980">(Heizmann et al. 1980; Abella et al. 2012)</a></td>
    </tr>
    <tr>
      <td><em>Ursus abstrusus</em></td>
      <td style="text-align: center">1.8–5.3</td>
      <td style="text-align: right"><a class="citation" href="#bjork1970">(Bjork 1970; Krause et al. 2008)</a></td>
    </tr>
    <tr>
      <td><em>Ursus spelaeus</em></td>
      <td style="text-align: center">0.027–0.25</td>
      <td style="text-align: right"><a class="citation" href="#loreille2001">(Loreille et al. 2001; Krause et al. 2008)</a></td>
    </tr>
    <tr>
      <td><em>Zaragocyon daamsi</em></td>
      <td style="text-align: center">20–22.8</td>
      <td style="text-align: right"><a class="citation" href="#ginsburg1995">(Ginsburg and Morales 1995; Abella et al. 2012)</a></td>
    </tr>
  </tbody>
</table>
</figure>

<h3 class="subsection" id="Exercise-GetStart">Getting Started</h3>
<hr class="subsection" />

<p>Create a new directory called <code class="language-plaintext highlighter-rouge">scripts</code>.</p>

<p>When you execute RevBayes in this exercise, you will do so within the
main directory you created. 
Thus, if you are using a Unix-based operating system, we recommend that
you add the RevBayes binary to your path.</p>

<h3 class="subsection" id="Exercise-CreatingFiles">Creating Rev Files</h3>
<hr class="subsection" />

<p>For complex models and analyses, it is best to create Rev script files
that will contain all of the model parameters, moves, and functions. In
this exercise, you will work primarily in your text editor and
create a set of modular files that will be easily managed and
interchanged. You will write the following files from scratch and save
them in the <code class="language-plaintext highlighter-rouge">scripts</code> directory:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">mcmc_CEFBDRP_Ranges.Rev</code>: the master Rev file that loads the data, the
separate model files and specifies the monitors and MCMC sampler.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">model_FBDRP.Rev</code>: specifies the model parameters and moves
required for the fossilized birth-death range process prior on the tree topology,
divergence times, fossil occurrence ranges, and
diversification dynamics.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">model_UExp.Rev</code>: specifies the components of the
uncorrelated exponential model of lineage-specific substitution
rate variation.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">model_GTRG.Rev</code>: specifies the parameters and moves for the
general time-reversible model of sequence evolution with
gamma-distributed rates across sites (GTR+$\Gamma$).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">model_Morph.Rev</code>: specifies the model describing discrete
morphological character change (binary characters) under a strict
morphological clock.</p>
  </li>
</ul>

<p>All of the files that you will create are also provided in the
RevBayes tutorial at the top of the page to download. 
Please refer to these files to
verify or troubleshoot your own scripts.</p>

<h3 class="subsection" id="Exercise-StartMasterRev">Start the Master Rev File and Import Data</h3>
<hr class="subsection" />

<p>In this section you will begin the master file that you will load into
RevBayes when you’ve completed all of the components of the analysis.</p>

<blockquote class="instruction">
  <p>Open your text editor and create the master Rev
file called <code class="language-plaintext highlighter-rouge">mcmc_CEFBDRP_Ranges.Rev</code> in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>

  <p>Enter the Rev code provided in this section in the new model file.</p>
</blockquote>

<p>In this file you will write the Rev commands for
loading in the taxon list and managing the data matrices. Then, starting
in section <a href="#Exercise-ModelFBD"></a>, you will move on to writing
module files for each of the model components. Once the model files are
complete, you will return to editing <code class="language-plaintext highlighter-rouge">mcmc_CEFBDRP_Ranges.Rev</code> and complete the
Rev script with the instructions given in section, 
you will move on to writing the <a href="#Exercise-CompleteMCMC"></a>.</p>

<h4 class="subsubsection" id="Exercise-TaxList">Load Taxon List</h4>
<hr class="subsubsection" />

<p>Begin the Rev script by loading in the list of taxon names from the
<code class="language-plaintext highlighter-rouge">bears_taxa.tsv</code> file using the <code class="language-plaintext highlighter-rouge">readTaxonData</code> function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taxa &lt;- readTaxonData("data/bears_taxa.tsv")
</code></pre></div></div>

<p>This function reads a tab-delimited file and creates a variable called
<code class="language-plaintext highlighter-rouge">taxa</code> that is a list of all of the taxon names relevant to this
analysis. This list includes all of the fossil and extant bear species
names in the first columns and minimum/maximum ages in the second/third columns.</p>

<h4 class="subsubsection" id="Exercise-LoadData">Load Data Matrices</h4>
<hr class="subsubsection" />

<p>RevBayes uses the function <code class="language-plaintext highlighter-rouge">readDiscreteCharacterData</code> to load a
data matrix to the workspace from a formatted file. This function can be
used for both molecular sequences and discrete morphological characters.</p>

<p>Load the cytochrome-b sequences from file and assign the data matrix to
a variable called <code class="language-plaintext highlighter-rouge">cytb</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cytb &lt;- readDiscreteCharacterData("data/bears_cytb.nex")
</code></pre></div></div>

<p>Next, import the morphological character matrix and assign it to the
variable <code class="language-plaintext highlighter-rouge">morpho</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>morpho &lt;- readDiscreteCharacterData("data/bears_morphology.nex")
</code></pre></div></div>

<h4 class="subsubsection" id="Exercise-AddMissing">Add Missing Taxa</h4>
<hr class="subsubsection" />

<p>In the descriptions of the files in section
<a href="#Exercise-DataFiles"></a>, we mentioned that the two data matrices
have different numbers of taxa. Thus, we must add any taxa that are not
found in the molecular (<code class="language-plaintext highlighter-rouge">cytb</code>) partition
(<em>i.e.</em> are only found in the fossil data) to
that data matrix as missing data (with <code class="language-plaintext highlighter-rouge">?</code> in place of all characters),
and do the same with the morphological data partition (<code class="language-plaintext highlighter-rouge">morpho</code>). In
order for all the taxa to appear on the same tree, they all need to be
part of the same dataset, as opposed to present in separate datasets.
This ensures that there is a unified taxon set that contains all of our
tips.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cytb.addMissingTaxa( taxa )
morpho.addMissingTaxa( taxa )
</code></pre></div></div>

<h4 class="subsubsection" id="Exercise-mviVar">Create Helper Variables</h4>
<hr class="subsubsection" />

<p>Before we begin writing the Rev scripts for each of the model
components, we need to instantiate a couple “helper variables” that will
be used by downstream parts of our model specification files. These
variables will be used in more than one of the module files so it’s best
to initialize them in the master file.</p>

<p>Create a new constant node called <code class="language-plaintext highlighter-rouge">n_taxa</code> that is equal to the number
of species in our analysis (22).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_taxa &lt;- taxa.size()
</code></pre></div></div>

<p>Next, create a workspace variable called <code class="language-plaintext highlighter-rouge">moves</code>. This variable is a vector that will 
contain all of the MCMC moves used
to propose new states for every stochastic node in the model graph. Each
time a new stochastic node is created in the model, we can append the move to this vector.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves = VectorMoves()
</code></pre></div></div>

<p>One important distinction here is that <code class="language-plaintext highlighter-rouge">moves</code> is part of the RevBayes
workspace and not the hierarchical model. Thus, we use the workspace
assignment operator <code class="language-plaintext highlighter-rouge">=</code> instead of the constant node assignment <code class="language-plaintext highlighter-rouge">&lt;-</code>.</p>

<blockquote class="instruction">
  <p>Save your current working version of <code class="language-plaintext highlighter-rouge">mcmc_CEFBDRP_Ranges.Rev</code> in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>
</blockquote>

<p>We will now move on to the next Rev file and will complete
<code class="language-plaintext highlighter-rouge">mcmc_CEFBDRP_Ranges.Rev</code> in section <a href="#Exercise-CompleteMCMC"></a>.</p>

<h3 class="subsection" id="Exercise-ModelFBD">The Fossilized Birth-Death Process</h3>
<hr class="subsection" />

<p>In this section we will define the models described in section
<a href="#Intro-FBD"></a> above. If
necessary, please review the graphical models depicted for the
fossilized birth-death process (<a href="#fig_fbd_gm"></a>).</p>

<blockquote class="instruction">
  <p>Open your text editor and create the fossilized birth-death model file
called <code class="language-plaintext highlighter-rouge">model_FBDRP.Rev</code> in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>
</blockquote>

<h4 class="subsubsection" id="Exercise-FBD-SpeciationExtinction">Speciation and Extinction Rates</h4>
<hr class="subsubsection" />

<p>Two key parameters of the FBD process are the speciation rate (the rate
at which lineages are added to the tree, denoted by $\lambda$ in
<a href="#fig_fbd_gm"></a>) and the extinction rate (the rate at which
lineages are removed from the tree, $\mu$ in <a href="#fig_fbd_gm"></a>).
We’ll place exponential priors on both of these values. Each parameter
is assumed to be drawn independently from a different exponential
distribution with rates $\delta_{\lambda}$ and $\delta_{\mu}$
respectively (see <a href="#fig_fbd_gm"></a>). Here, we will assume that
$\delta_{\lambda} = \delta_{\mu} = 10$. Note that an exponential
distribution with $\delta = 10$ has an expected value (mean) of $1/10$.</p>

<p>Create the exponentially distributed stochastic nodes for the
<code class="language-plaintext highlighter-rouge">speciation_rate</code> and <code class="language-plaintext highlighter-rouge">extinction_rate</code> using the <code class="language-plaintext highlighter-rouge">~</code> operator.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>speciation_rate ~ dnExponential(10)
extinction_rate ~ dnExponential(10)
</code></pre></div></div>

<p>For every stochastic node we declare, we must also specify proposal
algorithms (called <em>moves</em>) to sample the value of the parameter in
proportion to its posterior probability. If a move is not specified for
a stochastic node, then it will not be estimated, but fixed to its
initial value.</p>

<p>The rate parameters for extinction and speciation are both positive,
real numbers (<em>i.e.</em> non-negative floating
point variables). For both of these nodes, we will use a scaling move
(<code class="language-plaintext highlighter-rouge">mvScale</code>), which proposes multiplicative changes to a parameter.
Many moves also require us to set a <em>tuning value</em>, called <code class="language-plaintext highlighter-rouge">lambda</code> for
<code class="language-plaintext highlighter-rouge">mvScale</code>, which determine the size of the proposed change. Here, we
will use three scale moves for each parameter with different values of
lambda. By using multiple moves for a single parameter, we will improve
the mixing of the Markov chain.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale(speciation_rate, lambda=0.01, weight=1) )
moves.append( mvScale(speciation_rate, lambda=0.1,  weight=1) )
moves.append( mvScale(speciation_rate, lambda=1.0,  weight=1) )

moves.append( mvScale(extinction_rate, lambda=0.01, weight=1) )
moves.append( mvScale(extinction_rate, lambda=0.1,  weight=1) )
moves.append( mvScale(extinction_rate, lambda=1,    weight=1) )
</code></pre></div></div>

<p>You will also notice that each move has a specified <code class="language-plaintext highlighter-rouge">weight</code>. This
option allows you to indicate how many times you would like a given move
to be performed at each MCMC cycle. The way that we will run our MCMC
for this tutorial will be to execute a <em>schedule</em> of moves at each step
in our chain instead of just one move per step, as is done in
MrBayes <a class="citation" href="#Ronquist2003">(Ronquist and Huelsenbeck 2003)</a> or BEAST
<a class="citation" href="#Drummond2012">(Drummond et al. 2012; Bouckaert et al. 2014)</a>. Here, if we were to run our MCMC with
our current vector of 6 moves, then our move schedule would perform 6
moves at each cycle. Within a cycle, an individual move is chosen from
the move list in proportion to its weight. Therefore, with all six moves
assigned <code class="language-plaintext highlighter-rouge">weight=1</code>, each has an equal probability of being executed and
will be performed on average one time per MCMC cycle. For more
information on moves and how they are performed in RevBayes, please
refer to the <a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a> and <a href="/tutorials/ctmc/">Nucleotide substitution models</a> tutorials.</p>

<p>In addition to the speciation ($\lambda$) and extinction ($\mu$) rates,
we may also be interested in inferring diversification ($\lambda - \mu$)
and turnover ($\mu/\lambda$). Since these parameters can be expressed as
a deterministic transformation of the speciation and extinction rates,
we can monitor (that is, track the values of these parameters, and print
them to a file) their values by creating two deterministic nodes using
the <code class="language-plaintext highlighter-rouge">:=</code> operator.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diversification := speciation_rate - extinction_rate
turnover := extinction_rate/speciation_rate
</code></pre></div></div>

<h4 class="subsubsection" id="Exercise-FBD-Rho">Probability of Sampling Extant Taxa</h4>
<hr class="subsubsection" />

<p>All extant bears are represented in this dataset. Therefore, we will fix
the probability of sampling an extant lineage ($\rho$ in
<a href="#fig_fbd_gm"></a>) to 1. The parameter <code class="language-plaintext highlighter-rouge">rho</code> will be specified as a
constant node using the <code class="language-plaintext highlighter-rouge">&lt;-</code> operator.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rho &lt;- 1.0
</code></pre></div></div>

<p>Because $\rho$ is a constant node, we do not have to assign a move to
this parameter.</p>

<h4 class="subsubsection" id="Exercise-FBD-Psi">The Fossil Sampling Rate</h4>
<hr class="subsubsection" />

<p>Since our data set includes serially sampled lineages, we must also
account for the rate of sampling back in time. This is the fossil
sampling (or recovery) rate ($\psi$ in <a href="#fig_fbd_gm"></a>), which we
will instantiate as a stochastic node (named <code class="language-plaintext highlighter-rouge">psi</code>). As with the
speciation and extinction rates
(see <a href="#Exercise-FBD-SpeciationExtinction"></a>), we will use an
exponential prior on this parameter and use scale moves to sample values
from the posterior distribution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi ~ dnExponential(10) 

moves.append( mvScale(psi, lambda=0.01, weight=1) )
moves.append( mvScale(psi, lambda=0.1,  weight=1) )
moves.append( mvScale(psi, lambda=1,    weight=1) )
</code></pre></div></div>

<h4 class="subsubsection" id="Exercise-FBD-Origin">The Origin Time</h4>
<hr class="subsubsection" />

<p>We will condition the FBD process on the origin time ($\phi$ in
<a href="#fig_fbd_gm"></a>) of bears, and we will specify a uniform
distribution on the origin age. For this parameter, we will use a
sliding window move (<code class="language-plaintext highlighter-rouge">mvSlide</code>). A sliding window samples a parameter
uniformly within an interval (defined by the half-width <code class="language-plaintext highlighter-rouge">delta</code>).
Sliding window moves can be tricky for small values, as the window may
overlap zero. However, for parameters such as the origin age, there is
little risk of this being an issue.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>origin_time ~ dnUnif(37.0, 55.0)

moves.append( mvSlide(origin_time, delta=0.01, weight=5.0) )
moves.append( mvSlide(origin_time, delta=0.1,  weight=5.0) )
moves.append( mvSlide(origin_time, delta=1,    weight=5.0) )
</code></pre></div></div>

<p>Note that we specified a higher move <code class="language-plaintext highlighter-rouge">weight</code> for each of the proposals
operating on <code class="language-plaintext highlighter-rouge">origin_time</code> than we did for the three previous
stochastic nodes. This means that our move schedule will propose five
times as many updates to <code class="language-plaintext highlighter-rouge">origin_time</code> than it will to
<code class="language-plaintext highlighter-rouge">speciation_rate</code>, <code class="language-plaintext highlighter-rouge">extinction_rate</code>, or <code class="language-plaintext highlighter-rouge">psi</code>.</p>

<h4 class="subsubsection" id="Exercise-FBD-dnFBD">The FBD Distribution Object</h4>
<hr class="subsubsection" />

<p>All the parameters of the FBD process have now been specified. The next
step is to use these parameters to define the FBD tree prior
distribution, which we will call <code class="language-plaintext highlighter-rouge">fbd_dist</code>. Note that, because we are
using stratigraphic range data to represent our sampled species,
we use the <code class="language-plaintext highlighter-rouge">FBDRP</code> distribution function
(as opposed to the specimen-level distribution function <code class="language-plaintext highlighter-rouge">FBDP</code>; see <a href="#Intro-Taxonomy"></a>)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fbd_dist = dnFBDRP(origin=origin_time, lambda=speciation_rate, mu=extinction_rate, psi=psi, rho=rho, taxa=taxa)
</code></pre></div></div>

<h4 class="subsubsection" id="Exercise-FBD-Constraints">Clade Constraints</h4>
<hr class="subsubsection" />

<p>Note that we created the distribution as a workspace variable using the
workspace assignment operator <code class="language-plaintext highlighter-rouge">=</code>. This is because we still need to
include a topology constraint in our final specification of the tree
prior. Specifically, we do not have any morphological or molecular data
for the fossil species <em>Ursus abstrusus</em>. Therefore, in order to use the
age of this fossil as an observation, we need to specify to which clade
it belongs. In this case, <em>Ursus abstrusus</em> belongs to the subfamily
Ursinae, so we define a clade for the total group Ursinae including
<em>Ursus abstrusus</em>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clade_ursinae = clade("Melursus_ursinus", "Ursus_arctos", "Ursus_maritimus", 
                      "Helarctos_malayanus", "Ursus_americanus", "Ursus_thibetanus", 
                      "Ursus_abstrusus", "Ursus_spelaeus")
constraints = v(clade_ursinae)
</code></pre></div></div>

<p>Then we can specify the final constrained tree prior distribution by
creating a vector of constraints, and providing it along with the
workspace FBD distribution to the constrained topology distribution.
Here we use the stochastic assignment operator <code class="language-plaintext highlighter-rouge">~</code> to create a
stochastic node for our constrained FBD tree variable (called
<code class="language-plaintext highlighter-rouge">fbd_tree</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fbd_tree ~ dnConstrainedTopology(fbd_dist, constraints=constraints)
</code></pre></div></div>

<p>It is important to recognize that we do not know if <em>Ursus abstrusus</em> is
a <em>crown</em> or <em>stem</em> Ursinae. Because of this, we defined this clade
constraint so that it constrained the <em>total group</em> Ursinae and this
uncertainty is taken into account. As a result, our MCMC will
marginalize over both stem and crown positions of <em>U. abstrusus</em> and
sample the phylogeny in proportion to its posterior probability,
conditional on our model and data.</p>

<p>Additionally, we do not have morphological data for the fossil species
<em>Parictis montanus</em>. However, we will not create a clade constraint for
this taxon because it is a very old, stem-fossil bear. Thus, the MCMC
may propose to place this taxon anywhere in the tree (except within the
clade constraint we made above). This allows us to account for the
maximum amount of uncertainty in the placement of <em>P. montanus</em>.</p>

<h4 class="subsubsection" id="Exercise-FBD-TreeMoves">Moves on the Tree Topology and Node Ages</h4>
<hr class="subsubsection" />

<p>Next, in order to sample from the posterior distribution of trees, we
need to specify moves that propose changes to the topology (<code class="language-plaintext highlighter-rouge">mvFNPR</code>)
and node times (<code class="language-plaintext highlighter-rouge">mvNodeTimeSlideUniform</code>). Included with these moves is
a proposal that will collapse or expand a fossil branch
(<code class="language-plaintext highlighter-rouge">mvCollapseExpandFossilBranch</code>). This will change a fossil that is a
sampled ancestor (see <a href="#fig_example_tree"></a> and
Sect. <a href="#Intro-FBD"></a>) so that it is on its own branch and vice
versa. In addition, when conditioning on the origin time, we also need
to explicitly sample the root age (<code class="language-plaintext highlighter-rouge">mvRootTimeSlideUniform</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvFNPR(fbd_tree, weight=15.0) )
moves.append( mvCollapseExpandFossilBranch(fbd_tree, origin_time, weight=6.0) )

moves.append( mvNodeTimeSlideUniform(fbd_tree, weight=40.0) )
moves.append( mvRootTimeSlideUniform(fbd_tree, origin_time, weight=5.0) )
</code></pre></div></div>

<blockquote class="aside" id="specimen-level"><h2>Incorporating Specimen-Level Fossil Age Uncertainty</h2><p>If we are using the specimen-level <code class="language-plaintext highlighter-rouge">FBDP</code> distribution (see <a href="#Intro-Taxonomy"></a>),
in order to account for uncertainty in the ages of fossil specimens,
we can incorporate intervals on the fossil ages.
These intervals can represent, for example, stratigraphic ranges or measurement error.
We do this by assuming each fossil can occur with
uniform probability anywhere within its observed interval. This is
somewhat different from the typical approach to node calibration. Here,
instead of treating the calibration density as an additional prior
distribution on the tree, we treat it as the <em>likelihood</em> of our fossil
data given the tree parameter. Specifically, we assume the likelihood of
a particular fossil observation $\mathcal{F}_i$ is equal to one if the
fossil’s inferred age on the tree $t_i$ falls within its observed time
interval $(a_i,b_i)$, and zero otherwise:</p>

<blockquote>

\[f[\mathcal{F}_i \mid a_i, b_i, t_i] = \begin{cases}
1 &amp; \text{if } a_i &lt; t_i &lt; b_i\\
0 &amp; \text{otherwise}
\end{cases}\]
</blockquote>

<p>In other words, we assume the likelihood is equal to one
if the inferred age is consistent with the observed data. We can
represent this likelihood in RevBayes using a distribution that is
proportional to the likelihood,
<em>i.e.</em> non-zero when the likelihood is equal
to one. This model component represents
the observed in the modular graphical model shown in <a href="#fig_module_gm"></a>.</p>

<figure id="fig_tipsampling_gm"><p><img src="figures/tikz/tipsampling_gm.png" width="400" /></p>
<figcaption>A graphical model of the
fossil age likelihood model used in this tutorial. The likelihood of
fossil observation $\mathcal{F}_i$ is uniform and non-zero when the
inferred fossil age $t_i$ falls within the observed time interval
$(a_i,b_i)$.</figcaption>
</figure>

<h4 id="sampling-fossil-specimen-ages">Sampling Fossil Specimen Ages</h4>
<p>When using the specimen-level FBD distribution <code class="language-plaintext highlighter-rouge">FBDP</code>, 
we can account for uncertainty in the age estimates of our
fossils specimens using the observed minimum and maximum stratigraphic ages.
First, we loop over the the list of taxa. For each fossil observation, we create a
uniform random variable representing the likelihood. Remember, we can
represent the fossil likelihood using any uniform distribution that is
non-zero when the likelihood is equal to one.</p>

<p>For example, if $t_i$ is the inferred fossil age and $(a_i,b_i)$ is the
observed stratigraphic interval, we know the likelihood is equal to one
when $a_i &lt; t_i &lt; b_i$, or equivalently $t_i - b_i &lt; 0 &lt; t_i - a_i$. So
let’s represent the likelihood using a uniform random variable uniformly
distributed in $(t_i - b_i, t_i - a_i)$ and clamped at zero.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fossils = fbd_tree.getFossils()
for(i in 1:fossils.size())
{
    t[i] := tmrca(fbd_tree, clade(fossils[i]))

    a_i = fossils[i].getMinAge()
    b_i = fossils[i].getMaxAge()

    F[i] ~ dnUniform(t[i] - b_i, t[i] - a_i)
    F[i].clamp( 0 )
}
</code></pre></div></div>

<p>Finally, we add a move that samples the ages of the fossil nodes on the
tree.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvFossilTimeSlideUniform(fbd_tree, origin_time, weight=5.0) )
</code></pre></div></div>
</blockquote>

<h4 class="subsubsection" id="Exercise-FBD-DetNodes">Monitoring Parameters of Interest using Deterministic Nodes</h4>
<hr class="subsubsection" />

<p>There are additional parameters that may be of particular interest to us
that are not directly inferred as part of this graphical model. As with
the diversification and turnover nodes specified in
<a href="#Exercise-FBD-SpeciationExtinction"></a>, we can create
deterministic nodes to sample the posterior distributions of these
parameters. Create a deterministic node called <code class="language-plaintext highlighter-rouge">num_samp_anc</code> that
will compute the number of sampled ancestors in our <code class="language-plaintext highlighter-rouge">fbd_tree</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num_samp_anc := fbd_tree.numSampledAncestors();
</code></pre></div></div>

<p>We are also interested in the age of the most-recent-common ancestor
(MRCA) of all living bears. To monitor the age of this node in our MCMC
sample, we must use the <code class="language-plaintext highlighter-rouge">clade</code> function to identify the node.
Importantly, since we did not include this clade in our constraints that
defined <code class="language-plaintext highlighter-rouge">fbd_tree</code>, this clade will not be constrained to be
monophyletic. Once this clade is defined we can instantiate a
deterministic node called <code class="language-plaintext highlighter-rouge">age_extant</code> with the <code class="language-plaintext highlighter-rouge">tmrca</code> function that
will record the age of the MRCA of all living bears.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clade_extant = clade("Ailuropoda_melanoleuca","Tremarctos_ornatus","Melursus_ursinus",
                    "Ursus_arctos","Ursus_maritimus","Helarctos_malayanus",
                    "Ursus_americanus","Ursus_thibetanus")
age_extant := tmrca(fbd_tree, clade_extant)
</code></pre></div></div>

<p>Finally, we will monitor the tree after removing taxa for which we did
not have any molecular or morphological data. The phylogenetic placement
of these taxa is based only on their occurrence times and any clade
constraints we applied (see <a href="#Exercise-FBD-Constraints"></a>).
Because no data are available to resolve their relationships to other
lineages, we will treat their placement as <a href="https://en.wikipedia.org/wiki/Nuisance_parameter"><em>nuisance
parameters</em></a> and
remove them from the output.</p>

<p>We will remove two fossil taxa, <em>Parictis montanus</em> and <em>Ursus
abstrusus</em>, from every tree in the trace file before summarizing the
samples. Use the <code class="language-plaintext highlighter-rouge">fnPruneTree</code> function to create a deterministic tree
variable <code class="language-plaintext highlighter-rouge">pruned_tree</code> from which these taxa have been pruned. We will
monitor this tree instead of <code class="language-plaintext highlighter-rouge">fbd_tree</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pruned_tree := fnPruneTree(fbd_tree, prune=v(taxa[17],taxa[20]))
</code></pre></div></div>

<blockquote class="instruction">
  <p>You have completed the FBD model file. Save <code class="language-plaintext highlighter-rouge">model_FBDRP.Rev</code> in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>
</blockquote>

<h3 class="subsection" id="Exercise-ModelUExp">The Uncorrelated Exponential Relaxed Clock Model</h3>
<hr class="subsection" />

<p>We will now define the molecular relaxed clock model.</p>

<blockquote class="instruction">
  <p>Open your text editor and create the lineage-specific branch-rate model
file called <code class="language-plaintext highlighter-rouge">model_UExp.Rev</code> in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>

  <p>Enter the Rev code provided in this section in the new model file.</p>
</blockquote>

<p>For our hierarchical, uncorrelated exponential relaxed clock model
(described in section <a href="#Intro-GTR-UExp"></a> and shown in
<a href="#fig_uexp_gm"></a>), we first define the mean branch rate as an
exponential random variable. Then, we specify scale proposal moves on
the mean rate parameter.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>branch_rates_mean ~ dnExponential(10.0)

moves.append( mvScale(branch_rates_mean, lambda=0.01, weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=0.1,  weight=1.0) )
moves.append( mvScale(branch_rates_mean, lambda=1.0,  weight=1.0) )
</code></pre></div></div>

<p>Before creating a rate parameter for each branch, we need to get the
number of branches in the tree. For rooted trees with $n$ taxa, the
number of branches is $2n-2$.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_branches &lt;- 2 * n_taxa - 2
</code></pre></div></div>

<p>Then, use a for loop to define a rate for each branch. The branch rates
are independent and identically exponentially distributed with mean
equal to the mean branch rate parameter we specified above. For each
rate parameter we also create scale proposal moves.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(i in 1:n_branches){
    branch_rates[i] ~ dnExp(1/branch_rates_mean)
    moves.append( mvScale(branch_rates[i], lambda=1.0,  weight=1.0) )
    moves.append( mvScale(branch_rates[i], lambda=0.1,  weight=1.0) )
    moves.append( mvScale(branch_rates[i], lambda=0.01, weight=1.0) )
}
</code></pre></div></div>

<p>Lastly, we use a vector scale move to propose changes to all branch
rates simultaneously. This way we can sample the total branch rate
independently of each individual rate, which can improve mixing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvVectorScale(branch_rates, lambda=0.01, weight=4.0) )
moves.append( mvVectorScale(branch_rates, lambda=0.1,  weight=4.0) )
moves.append( mvVectorScale(branch_rates, lambda=1.0,  weight=4.0) )
</code></pre></div></div>

<p>You have completed the molecular relaxed clock model file. Save <code class="language-plaintext highlighter-rouge">model_UExp.Rev</code> in
the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>

<h3 class="subsection" id="Exercise-ModelGTRG">The General Time-Reversible + Gamma Model of Nucleotide Sequence Evolution</h3>
<hr class="subsection" />

<p>In this section we will define our nucleotide sequence evolution model.</p>

<blockquote class="instruction">
  <p>Open your text editor and create the molecular substitution model file
called <code class="language-plaintext highlighter-rouge">model_GTRG.Rev</code> in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>

  <p>Enter the Rev code provided in this section in the new model file.</p>
</blockquote>

<p>For our nucleotide sequence evolution model, we need to define a general
time-reversible (GTR) instantaneous-rate matrix
(<em>i.e.</em> $Q$-matrix). A nucleotide GTR matrix
is defined by a set of 4 stationary frequencies, and 6 exchangeability
rates. We create stochastic nodes for these variables, each drawn from a
uniform Dirichlet prior distribution.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sf_hp &lt;- v(1,1,1,1)
sf ~ dnDirichlet(sf_hp)

er_hp &lt;- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_hp)
</code></pre></div></div>

<p>We need special moves to propose changes to a Dirichlet random variable,
also known as a simplex (a vector constrained sum to one). Here, we use
a <code class="language-plaintext highlighter-rouge">mvSimplexElementScale</code> move, which scales a single element of a
simplex and then renormalizes the vector to sum to one. The tuning
parameter <code class="language-plaintext highlighter-rouge">alpha</code> specifies how conservative the proposal should be,
with larger values of <code class="language-plaintext highlighter-rouge">alpha</code> leading to proposals closer to the current
value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvSimplexElementScale(er, alpha=10.0, weight=5.0) )
moves.append( mvSimplexElementScale(sf, alpha=10.0, weight=5.0) )
</code></pre></div></div>

<p>Then we can define a deterministic node for our GTR $Q$-matrix using the
special GTR matrix function (<code class="language-plaintext highlighter-rouge">fnGTR</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_cytb := fnGTR(er,sf)
</code></pre></div></div>

<p>Next, in order to model gamma-distributed rates across, we create an
exponential parameter $\alpha$ for the shape of the gamma distribution,
along with scale proposals.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha_cytb ~ dnExponential( 1.0 )

moves.append( mvScale(alpha_cytb, lambda=0.01, weight=1.0) )
moves.append( mvScale(alpha_cytb, lambda=0.1,  weight=1.0) )
moves.append( mvScale(alpha_cytb, lambda=1,    weight=1.0) )
</code></pre></div></div>

<p>Then we create a Gamma$(\alpha,\alpha)$ distribution, discretized into 4
rate categories using the <code class="language-plaintext highlighter-rouge">fnDiscretizeGamma</code> function. Here,
<code class="language-plaintext highlighter-rouge">rates_cytb</code> is a deterministic vector of rates computed as the mean of
each category.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rates_cytb := fnDiscretizeGamma( alpha_cytb, alpha_cytb, 4 )
</code></pre></div></div>

<p>Finally, we can create the phylogenetic continuous time Markov chain
(PhyloCTMC) distribution for our sequence data, including the
gamma-distributed site rate categories, as well as the branch rates
defined as part of our exponential relaxed clock. We set the value of
this distribution equal to our observed data and identify it as a static
part of the likelihood using the <code class="language-plaintext highlighter-rouge">clamp</code> method.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phySeq ~ dnPhyloCTMC(tree=fbd_tree, Q=Q_cytb, siteRates=rates_cytb, branchRates=branch_rates, type="DNA")
phySeq.clamp(cytb)
</code></pre></div></div>

<blockquote class="instruction">
  <p>You have completed the GTR model file. Save <code class="language-plaintext highlighter-rouge">model_GTRG.Rev</code> in
the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>
</blockquote>

<p>We will now move on to the next model file.</p>

<h3 class="subsection" id="Exercise-ModelMorph">Modeling the Evolution of Binary Morphological Characters</h3>
<hr class="subsection" />

<p>In this section we will define the model of morphological character evolution.</p>

<blockquote class="instruction">
  <p>Open your text editor and create the morphological character model file
called <code class="language-plaintext highlighter-rouge">model_Morph.Rev</code> in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>
</blockquote>

<p>As stated in the introduction (<a href="#Intro-Morpho"></a>) we will
use Mk to model our data. Because the Mk model is a generalization of
the Jukes-Cantor model, we will initialize our Q matrix from a Jukes-Cantor
matrix.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_morpho := fnJC(2)
</code></pre></div></div>

<p>As in the molecular data partition, we will allow gamma-distributed rate
heterogeneity among sites.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha_morpho ~ dnExponential( 1.0 )
rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )

moves.append( mvScale(alpha_morpho, lambda=0.01, weight=5.0) )
moves.append( mvScale(alpha_morpho, lambda=0.1,  weight=3.0) )
moves.append( mvScale(alpha_morpho, lambda=1,    weight=1.0) )
</code></pre></div></div>

<p>The phylogenetic model also assumes that each branch has a rate of
morphological character change. For simplicity, we will assume a strict
exponential clock—meaning that every branch has the same rate drawn from
an exponential distribution (see <a href="#Intro-MorphClock"></a>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clock_morpho ~ dnExponential(1.0)

moves.append( mvScale(clock_morpho, lambda=0.01, weight=4.0) )
moves.append( mvScale(clock_morpho, lambda=0.1,  weight=4.0) )
moves.append( mvScale(clock_morpho, lambda=1,    weight=4.0) )
</code></pre></div></div>

<p>As in our molecular data partition, we now combine our data and our
model in the phylogenetic CTMC distribution. There are some unique
aspects to doing this for morphology.</p>

<p>You will notice that we have an option called <code class="language-plaintext highlighter-rouge">coding</code>. This option
allows us to condition on biases in the way the morphological data were
collected (ascertainment bias). The option <code class="language-plaintext highlighter-rouge">coding=variable</code> specifies
that we should correct for coding only variable characters (discussed in
<a href="#Intro-Morpho"></a>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phyMorpho ~ dnPhyloCTMC(tree=fbd_tree, siteRates=rates_morpho, branchRates=clock_morpho, Q=Q_morpho, type="Standard", coding="variable")
phyMorpho.clamp(morpho)
</code></pre></div></div>

<p>You have completed the morphology model file. Save <code class="language-plaintext highlighter-rouge">model_Morph.Rev</code> in
the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>

<p>We will now move on to the next model file.</p>

<h3 class="subsection" id="Exercise-CompleteMCMC">Complete Master Rev File</h3>
<hr class="subsection" />

<blockquote class="instruction">
  <p>Return to the master Rev file you created in section
<a href="#Exercise-StartMasterRev"></a> called <code class="language-plaintext highlighter-rouge">mcmc_CEFBDRP_Ranges.Rev</code> in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>
</blockquote>

<h4 class="subsubsection" id="Exercise-SourceMods">Source Model Scripts</h4>
<hr class="subsubsection" />

<p>RevBayes uses the <code class="language-plaintext highlighter-rouge">source</code> function to load commands from Rev
files into the workspace. Use this function to load in the model scripts
we have written in the text editor and saved in the <code class="language-plaintext highlighter-rouge">scripts</code> directory.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/model_FBDRP.Rev") # FBD tree prior

source("scripts/model_UExp.Rev") # UExp relaxed clock

source("scripts/model_GTRG.Rev") # Molecular substitution model (GTR+G)

source("scripts/model_Morph.Rev") # Morphological character change model
</code></pre></div></div>

<h4 class="subsubsection" id="Exercise-ModObj">Create Model Object</h4>
<hr class="subsubsection" />

<p>We can now create our workspace model variable with our fully specified
model DAG. We will do this with the <code class="language-plaintext highlighter-rouge">model</code> function and provide a
single node in the graph (<code class="language-plaintext highlighter-rouge">sf</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(sf)
</code></pre></div></div>

<p>The object <code class="language-plaintext highlighter-rouge">mymodel</code> is a wrapper around the entire model graph and
allows us to pass the model to various functions that are specific to
our MCMC analysis.</p>

<h4 class="subsubsection" id="Exercise-Monitors">Specify Monitors and Output Filenames</h4>
<hr class="subsubsection" />

<p>The next important step for our master Rev file is to specify the
monitors and output file names. For this, we create a vector called
<code class="language-plaintext highlighter-rouge">monitors</code> that will each sample and record or output our MCMC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors = VectorMonitors()
</code></pre></div></div>

<p>The first monitor we will create will monitor every named random
variable in our model graph. This will include every stochastic and
deterministic node using the <code class="language-plaintext highlighter-rouge">mnModel</code> monitor. The only parameter that
is not included in the <code class="language-plaintext highlighter-rouge">mnModel</code> is the tree topology. Therefore, the
parameters in the file written by this monitor are all numerical
parameters written to a tab-separated text file that can be opened by
accessory programs for evaluating such parameters. We will also name the
output file for this monitor and indicate that we wish to sample our
MCMC every 10 cycles.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/bears.log", printgen=10) )
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mnFile</code> monitor writes any parameter we specify to file. Thus, if
we only cared about the speciation rate and nothing else (this is not a
typical or recommended attitude for an analysis this complex) we
wouldn’t use the <code class="language-plaintext highlighter-rouge">mnModel</code> monitor above and just use the <code class="language-plaintext highlighter-rouge">mnFile</code>
monitor to write a smaller and simpler output file. Since the tree
topology is not included in the <code class="language-plaintext highlighter-rouge">mnModel</code> monitor (because it is not
numerical), we will use <code class="language-plaintext highlighter-rouge">mnFile</code> to write the tree to file by specifying
our <code class="language-plaintext highlighter-rouge">pruned_tree</code> variable in the arguments. Remember, we are
monitoring the tree with nuisance taxa pruned out (see
<a href="#Exercise-FBD-DetNodes"></a>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnFile(filename="output/bears.trees", printgen=10, pruned_tree) )
</code></pre></div></div>

<p>The last monitor we will add to our analysis will print information to
the screen. Like with <code class="language-plaintext highlighter-rouge">mnFile</code> we must tell <code class="language-plaintext highlighter-rouge">mnScreen</code> which parameters
we’d like to see updated on the screen. We will choose the age of the
MCRCA of living bears (<code class="language-plaintext highlighter-rouge">age_extant</code>), the number of sampled ancestors
(<code class="language-plaintext highlighter-rouge">num_samp_anc</code>), and the origin time (<code class="language-plaintext highlighter-rouge">origin_time</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(printgen=10, age_extant, num_samp_anc, origin_time) )
</code></pre></div></div>

<h4 class="subsubsection" id="set-up-the-mcmc">Set-Up the MCMC</h4>
<hr class="subsubsection" />

<p>Once we have set up our model, moves, and monitors, we can now create
the workspace variable that defines our MCMC run. We do this using the
<code class="language-plaintext highlighter-rouge">mcmc</code> function that simply takes the three main analysis components
as arguments.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves)
</code></pre></div></div>

<p>The MCMC object that we named <code class="language-plaintext highlighter-rouge">mymcmc</code> has a member method called
<code class="language-plaintext highlighter-rouge">run</code>. This will execute our analysis and we will set the chain
length to <code class="language-plaintext highlighter-rouge">10000</code> cycles using the <code class="language-plaintext highlighter-rouge">generations</code> option.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=10000)
</code></pre></div></div>

<p>Once our Markov chain has terminated, we will want RevBayes to close.
Tell the program to quit using the <code class="language-plaintext highlighter-rouge">q()</code> function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q()
</code></pre></div></div>

<blockquote class="instruction">
  <p>You made it! Save all of your files.</p>
</blockquote>

<h3 class="subsection" id="Exercise-RunMCMC">Execute the MCMC Analysis</h3>
<hr class="subsection" />

<p>With all the parameters specified and all analysis components in place,
you are now ready to run your analysis. The Rev scripts you just
created will all be used by RevBayes and loaded in the appropriate
order.</p>

<p>Begin by running the RevBayes executable. In Unix systems, type the
following in your terminal (if the RevBayes binary is in your path):</p>

<p>Provided that you started RevBayes from the correct directory, you can then use the
<code class="language-plaintext highlighter-rouge">source</code> function to feed RevBayes your master script file
(<code class="language-plaintext highlighter-rouge">mcmc_CEFBDRP_Ranges.Rev</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mcmc_CEFBDRP_Ranges.Rev")
</code></pre></div></div>

<p>This will execute the analysis and you should see the various parameters you included when you created <code class="language-plaintext highlighter-rouge">mnScreen</code> printed to the screen every 10 generations.</p>

<p>When the analysis is complete, RevBayes will quit and you will have a
new directory called <code class="language-plaintext highlighter-rouge">output</code> that will contain all of the files you
specified with the monitors (see <a href="#Exercise-Monitors"></a>).</p>

<h3 class="subsection" id="Exercise-SummarizeResults">Evaluate and Summarize Your Results</h3>
<hr class="subsection" />

<p>In this section, we will evaluate the <em>mixing</em> and <em>convergence</em> of our
MCMC simulation using the program Tracer. We can also
summarize the marginal distributions for particular parameters we’re
interested in. <a href="http://tree.bio.ed.ac.uk/software/tracer/">Tracer</a>
<a class="citation" href="#Rambaut2011">(Rambaut and Drummond 2011)</a> is a tool for visualizing parameters sampled by MCMC.
This program is limited to numerical parameters, however, and cannot be
used to summarize or analyze MCMC samples of the tree topology (this
will be discussed further in <a href="#Exercise-SummarizeTree"></a>).</p>

<figure id="fig_tracer"><p><img src="figures/tracer_load_file.png" width="900" /></p>
<figcaption>The Tracer
window. To add data, click on the “+” sign, highlighted in red above</figcaption>
</figure>

<p>Open Tracer and import the <code class="language-plaintext highlighter-rouge">bears.log</code> file in the
<strong><em>File &gt; Import New Trace Files</em></strong>. Or click the button on the
left-hand side of the screen to add your log file (see <a href="#fig_tracer"></a>).</p>

<figure id="tracer_post_ests"><p><img src="figures/tracer_fig_posterior_short.png" width="900" /></p>
<figcaption>The <strong>Estimates</strong> window in Tracer showing the
histogram of the <strong>Posterior</strong></figcaption>
</figure>

<p>Immediately upon loading your file (see <a href="#tracer_post_ests"></a>),
you will see the list of <strong>Trace Files</strong> on the left-hand
side (you can load multiple files). The bottom left section, called
<strong>Traces</strong>, provides a list of every parameter in the log
file, along with the mean and the effective sample size (ESS) for the
posterior sample of that parameter. The ESS statistic provides a measure
of the number of independent draws in our sample for a given parameter.
This quantity will typically be much smaller than the number of
generations of the chain. In Tracer, poor to fair values
for the ESS will be colored red and yellow. You will likely see a lot of
red and yellow numbers because the MCMC runs in this exercise are too
short to effectively sample the posterior distributions of most
parameters. A much longer analysis is provided in the <code class="language-plaintext highlighter-rouge">output</code>
directory.</p>

<p>The inspection window for your selected parameter is the
<strong>Estimates</strong> window, which shows a histogram and summary
statistics of the values sampled by the Markov chain. <a href="#tracer_post_ests"></a> shows the marginal distribution of the
<strong>Posterior</strong> statistic for the <code class="language-plaintext highlighter-rouge">bears.log</code> file in the
<code class="language-plaintext highlighter-rouge">output</code> directory.</p>

<blockquote class="instruction">
  <p>Look through the various parameters and statistics in the list of
<strong>Traces</strong>.</p>

  <p>Are there any parameters that have really low ESS? Why do you think that might be?</p>
</blockquote>

<p>Next, we can click over to the <strong>Trace</strong> window. This
window shows us the samples for a given parameter at each iteration of
the MCMC. The left side of the chain has a shaded portion that has been
excluded as “burn-in”. Samples taken near the beginning of chain are
often discarded or “burned” because the MCMC may not immediately begin
sampling from the target posterior distribution, particularly if the
starting condition of the chain is far from the region of highest
posterior density. <a href="#tracer_extinction_rate_trace_short"></a> shows the
trace for the extinction rate.</p>

<figure id="tracer_extinction_rate_trace_short"><p><img src="figures/tracer_extinction_rate_trace_short.png" width="900" /></p>
<figcaption>The <strong><em>Trace</em></strong> window in Tracer. This window
shows a line plot of every sampled value for the extinction rate that
was saved to file. The lighter shaded portion is the set of samples
discarded as “burn-in” and are not used to compute the summary
statistics found in the <strong><em>Estimates</em></strong> window.</figcaption>
</figure>

<p>The <strong><em>Trace</em></strong> window allows us to evaluate how well our
chain is sampling the target distribution. For a fairly short analysis,
the output in <a href="#tracer_extinction_rate_trace_short"></a> shows reasonable
<em>mixing</em>—there is no consistent pattern or trend in the samples, nor are
there long intervals where the statistic does not change. The presence
of a trend or large leaps in a parameter value might indicate that your
MCMC is not mixing well. You can read more about MCMC tuning and
improving mixing in the tutorials <a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a>.</p>

<blockquote class="instruction">
  <p>Look through the traces for your parameters.</p>

  <p>Are there any parameters in your log files that show trends or large leaps? 
What steps might you take to solve these issues?</p>
</blockquote>

<p>In Tracer you can view the marginal probability
distributions of your parameters in the 
<strong>Marginal Prob Distribution</strong> window. Using this tool, you can compare the
distributions of several different parameters (by selecting them both).</p>

<blockquote class="instruction">
  <p>Go to the <code class="language-plaintext highlighter-rouge">diversification</code> parameter in the 
<strong>Marginal Prob Distribution</strong> window.</p>

  <p>⇨ What is the mean value estimated
for the net diversification rate ($d$)?</p>

  <p>⇨ What does the marginal
distribution tell you about the net diversification? (Hint:
$d = \lambda - \mu$)</p>
</blockquote>

<p>While specifying the model, remember that we created several
deterministic nodes that represent parameters that we would like to
estimate, including the net diversification rate. Tracer
allows us to view the summaries of these parameters since they appear in
our log files.</p>

<p>Go to the <code class="language-plaintext highlighter-rouge">age_extant</code> parameter in the <strong>Estimates</strong>
window.</p>

<p>⇨ What is the mean and 95% highest posterior density of the age of the MRCA for all living bears?</p>

<p>Since you have evaluated several of the parameters by viewing the trace
files and the ESS values, you may be aware that the MCMC analysis you
conducted for this tutorial did not sufficiently sample the joint
posterior distribution of phylogenetic parameters. More explicitly,
<em>your run has not converged</em>. It is not advisable to base your
conclusions on such a run and it will be critical to perform multiple,
independent runs for many more MCMC cycles. For further discussion of
recommended MCMC practices in RevBayes, please see the 
<a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a> tutorials.</p>

<h4 class="subsubsection" id="Exercise-SummarizeTree">Summarize Tree</h4>
<hr class="subsubsection" />

<p>In addition to evaluating the performance and sampling of an MCMC run
using numerical parameters, it is also important to inspect the sampled
topology and tree parameters. This is a difficult endeavor, however. One
tool for evaluating convergence and mixing of the tree samples is
<a href="https://github.com/danlwarren/RWTY">RWTY</a> <a class="citation" href="#Warren2016">(Warren et al. 2016)</a>. In this
tutorial, we will only summarize the sampled trees, but we encourage you
to consider approaches for assessing the performance of the MCMC with
respect to the tree topology.</p>

<p>Ultimately, we are interested in summarizing the sampled trees and
branch times given that our MCMC has sampled all of the important
parameters in proportion to their posterior probabilities. RevBayes
includes some functions for summarizing the tree topology and other tree
parameters.</p>

<p>We will complete this part of the tutorial using RevBayes
interactively.</p>

<blockquote class="instruction">
  <p>Begin by running the RevBayes executable. You should do
this from within the tutorial directory.</p>
</blockquote>

<p>Read in the MCMC sample of trees from file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trace = readTreeTrace("output/bears.trees")
</code></pre></div></div>

<p>By default, a burn-in of 25% is used when creating the tree trace (250
trees in our case). You can specify a different burn-in fraction, say
50%, by typing the command <code class="language-plaintext highlighter-rouge">trace.setBurnin(500)</code>.</p>

<p>Now we will use the <code class="language-plaintext highlighter-rouge">mccTree</code> function to return a maximum clade
credibility (MCC) tree. The MCC tree is the tree with the maximum
product of the posterior clade probabilities. When considering trees
with sampled ancestors, we refer to the maximum sampled ancestor clade
credibility (MSACC) tree <a class="citation" href="#Gavryushkina2016">(Gavryushkina et al. 2017)</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mccTree(trace, file="output/bears.mcc.tre" )
</code></pre></div></div>

<p>When there are sampled ancestors present in the tree, visualizing the
tree can be fairly difficult in traditional tree viewers. We will make
use of a browser-based tree viewer called
<a href="http://tgvaughan.github.io/icytree/">IcyTree</a>, created by <a href="https://github.com/tgvaughan">Tim
Vaughan</a>. IcyTree has many
unique options for visualizing phylogenetic trees and can produce
publication-quality vector image files
(<em>i.e.</em> SVG). Additionally, it correctly
represents sampled ancestors on the tree as nodes, each with only one
descendant (<a href="#summary_tree"></a>).</p>

<figure id="summary_tree"><p><img src="figures/summary_tree.png" width="900" /></p>
<figcaption>Maximum sampled ancestor clade
credibility (MSACC) tree of bear species used in this tutorial. Numbers
above fossil nodes indicate the posterior probability of being a sampled
ancestor</figcaption>
</figure>

<p>Navigate to <a href="https://icytree.org/">https://icytree.org/</a> and open the file
<code class="language-plaintext highlighter-rouge">output/bears.mcc.tre</code> in IcyTree.</p>

<blockquote class="instruction">
  <p>Try to replicate the tree in <a href="#summary_tree"></a> (Hint: <strong><em>Style &gt; Mark
Singletons</em></strong>) Why might a node with a sampled ancestor be
referred to as a singleton?</p>
</blockquote>

<blockquote class="instruction">
  <p>How can you see the names of the fossils that are putative sampled ancestors?</p>
</blockquote>

<blockquote class="instruction">
  <p>Try mousing over different
branches (see <a href="#highlight"></a>. What are the fields
telling you?  What is the
posterior probability that <em>Zaragocyon daamsi</em> is a sampled ancestor?</p>
</blockquote>

<p>Another newly available web-based tree viewer is
<a href="http://phylogeny.io/">Phylogeny.IO</a> <a class="citation" href="#Jovanovic2016">(Jovanovic and Mikheyev 2016)</a>. Try this site for
a different way to view the tree.</p>

<figure id="highlight"><p><img src="figures/branch_highlight.png" width="600" /></p>
</figure>

<ol class="bibliography"><li><span id="abella2011">Abella J., Montoya P., Morales J. 2011. Una nueva especie de <i>Agriarctos</i> (Ailuropodinae, Ursidae, Carnivora) en la localidad de Nombrevilla 2 (Zaragoza, España). Estudios Geológicos. 67:187–191.</span>

</li>
<li><span id="abella12">Abella J., Alba D.M., Robles J.M., Valenciano A., Rotgers C., Carmona R., Montoya P., Morales J. 2012. <i>Kretzoiarctos</i> gen. nov., the Oldest Member of the Giant Panda Clade. PLoS One. 17:e48985.</span>

</li>
<li><span id="andrews1977">Andrews P., Tobien H. 1977. New Miocene locality in Turkey with evidence on the origin of <i>Ramapithecus</i> and <i>Sivapithecus</i>. Nature. 268:699.</span>

</li>
<li><span id="baryshnikov2002">Baryshnikov G.F. 2002. Late Miocene <i>Indarctos punjabiensis atticus</i> (Carnivora, Ursidae) in Ukraine with survey of <i>Indarctos</i> records from the former USSR. Russian J. Theriol. 1:83–89.</span>

</li>
<li><span id="bjork1970">Bjork P.R. 1970. The Carnivora of the Hagerman local fauna (late Pliocene) of Southwestern Idaho. Transactions of the American Philosophical Society. 60:3–54.</span>

</li>
<li><span id="Bouckaert2014">Bouckaert R., Heled J., Kühnert D., Vaughan T., Wu C.-H., Xie D., Suchard M.A., Rambaut A., Drummond A.J. 2014. BEAST 2: a software platform for Bayesian evolutionary analysis. PLoS Computational Biology. 10:e1003537.</span>

<a href="https://doi.org/10.1371/journal.pcbi.1003537">10.1371/journal.pcbi.1003537</a>

</li>
<li><span id="churcher1993">Churcher C.S., Morgan A.V., Carter L.D. 1993. <i>Arctodus simus</i> from the Alaskan Arctic slope. Canadian Journal of Earth Sciences. 30:1007–1013.</span>

</li>
<li><span id="clark1972">Clark J., Guensburg T.E. 1972. Arctoid Genetic Characters as Related to the Genus <i>Parictis</i>. Chicago, Ill.: Field Museum of Natural History.</span>

</li>
<li><span id="Drummond2012">Drummond A.J., Suchard M.A., Xie D., Rambaut A. 2012. Bayesian phylogenetics with BEAUti and the BEAST 1.7. Molecular Biology and Evolution. 29:1969–1973.</span>

<a href="https://doi.org/10.1093/molbev/mss075">10.1093/molbev/mss075</a>

</li>
<li><span id="Drummond2006">Drummond A.J., Ho S.Y.W., Phillips M.J., Rambaut A. 2006. Relaxed Phylogenetics and Dating with Confidence. PLoS Biology. 4:e88.</span>

<a href="https://doi.org/10.1371/journal.pbio.0040088">10.1371/journal.pbio.0040088</a>

</li>
<li><span id="Felsenstein1992">Felsenstein J. 1992. Phylogenies from Restriction Sites: A Maximum-Likelihood Approach. Evolution. 46:159–173.</span>

<a href="https://doi.org/10.1111/j.1558-5646.1992.tb01991.x">10.1111/j.1558-5646.1992.tb01991.x</a>

</li>
<li><span id="foote1996">Foote M. 1996. On the probability of ancestors in the fossil record. Paleobiology. 22:141–151.</span>

<a href="https://doi.org/10.1017/S0094837300016146">10.1017/S0094837300016146</a>

</li>
<li><span id="Gavryushkina2016">Gavryushkina A., Heath T.A., Ksepka D.T., Stadler T., Welch D., Drummond A.J. 2017. Bayesian Total-Evidence Dating Reveals the Recent Crown Radiation of Penguins. Systematic Biology. 66:57–73.</span>

<a href="https://doi.org/10.1093/sysbio/syw060">10.1093/sysbio/syw060</a>

</li>
<li><span id="geraads2005">Geraads D., Kaya T., Mayda S., others. 2005. Late Miocene large mammals from Yulafli, Thrace region, Turkey, and their biogeographic implications. Acta Palaeontologica Polonica. 50:523–544.</span>

</li>
<li><span id="ginsburg1995">Ginsburg L., Morales J. 1995. <i>Zaragocyon daamsi n. gen. sp. nov.</i>, Ursidae primitif du Miocène inférieur d’Espagne. Comptes Rendus de l’Académie des Sciences. Série 2. Sciences de la Terre et des Planètes. 321:811–815.</span>

</li>
<li><span id="ginsburg1998">Ginsburg L., Morales J. 1998. Les Hemicyoninae (Ursidae, Carnivora, Mammalia) et les formes apparentées du Miocène inférieur et moyen d’Europe occidentale. Annales de Paléontologie. 84:71–123.</span>

</li>
<li><span id="Heath2014">Heath T.A., Huelsenbeck J.P., Stadler T. 2014. The fossilized birth-death process for coherent calibration of divergence-time estimates. Proceedings of the National Academy of Sciences. 111:E2957–E2966.</span>

<a href="https://doi.org/10.1073/pnas.1319091111">10.1073/pnas.1319091111</a>

</li>
<li><span id="heizmann1980">Heizmann E., Ginsburg L., Bulot C. 1980. <i>Prosansanosmilus peregrinus</i>, ein neuer machairodontider Felidae aus dem Miozän Deutschlands und Frankreichs. Stuttgarter Beitr. Naturk. B. 58:1–27.</span>

</li>
<li><span id="Hoehna2014b">Höhna S., Heath T.A., Boussau B., Landis M.J., Ronquist F., Huelsenbeck J.P. 2014. Probabilistic Graphical Model Representation in Phylogenetics. Systematic Biology. 63:753–771.</span>

<a href="https://doi.org/10.1093/sysbio/syu039">10.1093/sysbio/syu039</a>

</li>
<li><span id="Hoehna2017a">Höhna S., Landis M.J., Heath T.A. 2017. Phylogenetic Inference using RevBayes. Current Protocols in Bioinformatics.</span>

<a href="https://doi.org/10.1002/cpbi.22">10.1002/cpbi.22</a>

</li>
<li><span id="jin2007">Jin C., Ciochon R.L., Dong W., Hunt R.M., Liu J., Jaeger M., Zhu Q. 2007. The first skull of the earliest giant panda. Proceedings of the National Academy of Sciences. 104:10932–10937.</span>

<a href="https://doi.org/10.1073/pnas.0704198104">10.1073/pnas.0704198104</a>

</li>
<li><span id="Jovanovic2016">Jovanovic N., Mikheyev A.S. 2016. Interactive web-based visualization of phylogenetic trees using Phylogeny. IO. PeerJ Preprints. 4:e2579v1.</span>

</li>
<li><span id="krause2008">Krause J., Unger T., Noçon A., Malaspinas A.-S., Kolokotronis S.-O., Stiller M., Soibelzon L., Spriggs H., Dear P.H., Briggs A.W., others. 2008. Mitochondrial genomes reveal an explosive radiation of extinct and extant bears near the Miocene-Pliocene boundary. BMC Evolutionary Biology. 8:220.</span>

</li>
<li><span id="Lewis2001">Lewis P.O. 2001. A Likelihood Approach to Estimating Phylogeny from Discrete Morphological Character Data. Systematic Biology. 50:913–925.</span>

<a href="https://doi.org/10.1080/106351501753462876">10.1080/106351501753462876</a>

</li>
<li><span id="loreille2001">Loreille O., Orlando L., Patou-Mathis M., Philippe M., Taberlet P., Hänni C. 2001. Ancient DNA analysis reveals divergence of the cave bear, <i>Ursus spelaeus</i>, and brown bear, <i>Ursus arctos</i>, lineages. Current Biology. 11:200–203.</span>

</li>
<li><span id="montoya2001">Montoya P., Alcalá L., Morales J. 2001. <i>Indarctos</i> (Ursidae, Mammalia) from the Spanish Turolian (Upper Miocene). Scripta Geologica. 122:123–151.</span>

</li>
<li><span id="Rambaut2011">Rambaut A., Drummond A.J. 2011. Tracer v1.5. .</span>


<a href="http://tree.bio.ed.ac.uk/software/tracer/">http://tree.bio.ed.ac.uk/software/tracer/</a>
</li>
<li><span id="Ronquist2003">Ronquist F., Huelsenbeck J.P. 2003. MrBayes 3: Bayesian phylogenetic inference under mixed models. Bioinformatics. 19:1572–1574.</span>

<a href="https://doi.org/10.1093/bioinformatics/btg180">10.1093/bioinformatics/btg180</a>

</li>
<li><span id="Ronquist2012a">Ronquist F., Klopfstein S., Vilhelmsen L., Schulmeister S., Murray D.L., Rasnitsyn A.P. 2012. A total-evidence approach to dating with fossils, applied to the early radiation of the Hymenoptera. Systematic Biology. 61:973–999.</span>

</li>
<li><span id="Stadler2010">Stadler T. 2010. Sampling-through-time in birth-death trees. Journal of Theoretical Biology. 267:396–404.</span>

<a href="https://doi.org/10.1016/j.jtbi.2010.09.010">10.1016/j.jtbi.2010.09.010</a>

</li>
<li><span id="Stadler2018">Stadler T., Gavryushkina A., Warnock R.C.M., Drummond A.J., Heath T.A. 2018. The fossilized birth-death model for the analysis of stratigraphic range data under different speciation modes. Journal of Theoretical Biology. 447:41–55.</span>

</li>
<li><span id="Thorne2002">Thorne J.L., Kishino H. 2002. Divergence time and evolutionary rate estimation with multilocus data. Systematic Biology. 51:689–702.</span>

<a href="https://doi.org/10.1080/10635150290102456">10.1080/10635150290102456</a>

</li>
<li><span id="Warren2016">Warren D.L., Geneva A., Swofford D.L., Lanfear R. 2016. rwty: R We There Yet. A package for visualizing MCMC convergence in phylogenetics.</span>

</li>
<li><span id="Zhang2016">Zhang C., Stadler T., Klopfstein S., Heath T.A., Ronquist F. 2016. Total-Evidence Dating under the Fossilized Birth-Death Process. Systematic Biology. 65:228–249.</span>

<a href="https://doi.org/10.1093/sysbio/syv080">10.1093/sysbio/syv080</a>

</li>
<li><span id="Zuckerkandl1962">Zuckerkandl E., Pauling L. 1962. Molecular disease, evolution, and genetic heterogeneity. Horizons in Biochemistry.:189–225.</span>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://github.com/revbayes/revbayes/discussions">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
