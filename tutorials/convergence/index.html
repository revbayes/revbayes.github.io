<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Convergence assessment</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Convergence assessment</h1>
	<h3 class="subtitle">Phylogenetic convergence assessment using the R package Convenience</h3>
	<h4 class="authors">Luiza Fabreti and Sebastian Höhna</h4>
  <h5>Last modified on May 17, 2021</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
            <li><a href="/tutorials/fbd/">Combined-Evidence Analysis and the Fossilized Birth-Death Process for Stratigraphic Range Data</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Example output</strong>
        <ul id="example_output">
        
        
        
          <li><a href="/tutorials/convergence/example_output/bears_cytb_GTR_run_1.log">bears_cytb_GTR_run_1.log</a></li>
        
          <li><a href="/tutorials/convergence/example_output/bears_cytb_GTR_run_1.trees">bears_cytb_GTR_run_1.trees</a></li>
        
          <li><a href="/tutorials/convergence/example_output/bears_cytb_GTR_run_2.log">bears_cytb_GTR_run_2.log</a></li>
        
          <li><a href="/tutorials/convergence/example_output/bears_cytb_GTR_run_2.trees">bears_cytb_GTR_run_2.trees</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="overview">Overview</h2>
<hr class="section" />

<p>This tutorial covers convergence assessment of a Bayesian phylogenetic analysis using the R package Convenience.</p>

<p>Convergence of an MCMC analysis is crucial to assure that the chain has sampled from the stationary distribution and that we have sufficiently many samples to approximate the posterior distribution. That is, the MCMC has explored the parameter space long enough to reach the true posterior distribution of the parameters and the values we are sampling belong to that distribution. Theory says that a chain that runs through an infinite time, will reach convergence. For our practical problem, we need to make a decision of when we have sampled enough to take a good estimate of the desired parameters. Here we will show how to test if we have enough samples or not.</p>

<p>An ideal solution would be to analytically calculate the number of steps needed to reach convergence. This, however, has turned out to be unfeasible because the number of samples depends on the specific model, the specific moves applied within the MCMC simulation, and the given dataset.</p>

<p>Since we lack a theoretical convergence assessment, what is broadly done in the MCMC field is analyze the output from the MCMC for lack of convergence.
To do so, we have to keep in mind two aspects of an analysis that has reached convergence: <strong>precision</strong> and <strong>reproducibility</strong>. Precision means that if we run the chain longer, we do not change the estimates (e.g., the posterior mean estimate). While reproducibility means that if we run another independent chain, we get the same estimates.
Precision can be evaluated by checking that we have sufficiently many samples because more samples lead to less variance in the estimates (e.g., the standard error of the mean). Reproducibility, on the other hand, can be evaluated by comparing independent chains run under the same model. Therefore, it’s recommended to run at least two or better four replicates when performing MCMC analyses.</p>

<p>Another best practice is to remove the initial samples from the chain. Those initial iterations are called <em>burn-in</em>. By that we try to get rid of the samples that are not taken from the stationary distribution.</p>

<p>One last concept we need to keep in mind is the <em>Effective Sample Size</em> (ESS), i.e., the number of independent samples generated by our MCMC sampler. The ESS takes into account the correlation between samples within a chain. Low ESS values represent high autocorrelation in the chain. If the autocorrelation is higher, then the uncertainty in our estimates is also higher.</p>

<h2 class="section" id="criteria-for-convergence-using-in-convenience">Criteria for Convergence using in Convenience</h2>
<hr class="section" />

<p>Now that we learned about convergence, let’s take a look into the criteria in the Convenience package:</p>

<p>The output of a phylogenetic analysis most commonly consists of two types of parameters:</p>

<ul>
  <li>Continuous parameters: the evolutionary model parameters, the tree length, clock rates, etc.;</li>
  <li>Discrete parameters: the phylogenetic tree.</li>
</ul>

<p>To assess convergence for these parameters, the Convenience package evaluates:</p>

<ul>
  <li>The Effective Sample Size (ESS);</li>
  <li>Comparison between windows of the same run;</li>
  <li>Comparison between different runs.</li>
</ul>

<p>The comparison between windows of the same run works by dividing the full length of the run into 5 windows (subsets) and comparing the third and fifth window.
This comparison is used to determine the size of the burn-in. A sufficient burn-in will lead to windows that sampled values from the same distribution. 
Finding the appropriate burn-in size is done automatically in the Convenience package. The package tests burn-in of 0, 10%, 20%, 30%, 40% and 50%. If the required burn-in is higher than 50% of the length of the MCMC, we recommend re-running the MCMC.<br />
In Figure <a href="#windows"></a> we can see a trace plot for the tree length from the example provided in this tutorial. The trace plot shows the sampled values over the iterations of the MCMC. The highlighted areas of the figure show the third and fifth window of the run.</p>

<figure id="windows"><p><img src="figures/windows.png" /></p>
<figcaption>Trace plot of the tree length for our example analysis. The shaded areas show the third and fifth windows of the run.</figcaption>
</figure>

<h3 class="subsection" id="how-do-we-compare-windows-and-runs">How do we compare windows and runs?</h3>
<hr class="subsection" />

<p>For the continuous parameters, the comparison is made with the two-sample Kolmogorov-Smirnov (KS) test, a non-parametric statistical test for equality of probability distributions. Two samples will be equal when the KS value is below a given threshold. The KS value (D) is calculated:</p>

\[{D}_{m,n} = \max_{x} |{F_{1,m}(x) - G_{2,n}(x)}|\]

<p><em>F(x)</em> and <em>G(x)</em> are the empirical distribution functions for the samples with size <em>m</em> and <em>n</em>, respectively.
The two samples will be drawn from different distributions, at level $\alpha$, when:</p>

\[{D}_{m,n} &gt; c(\alpha) \sqrt{\frac{m + n}{m\times n}}\]

<p>with</p>

\[c(\alpha) = \sqrt{-\ln({\frac{\alpha}{2})\times \frac{1}{2}}}\]

<p>The phylogenetic tree is evaluated regarding the bipartitions or splits. Therefore, the comparisons are made using the frequency of a given split between intervals of the same run or between different runs.</p>

<figure id="splits.png"><p><img src="figures/splits.png" /></p>
<figcaption>Two example trees with tips A, B, C, D and the splits seen at each tree.</figcaption>
</figure>

<h3 class="subsection" id="thresholds">Thresholds</h3>
<hr class="subsection" />

<p>The current state of convergence assessment in Bayesian phylogenetics relies mainly on visual tools (e.g., Tracer) and ESS thresholds that have no clear theory to support them <a class="citation" href="#Rambaut2018">(Rambaut et al. 2018)</a>. The motivation for the Convenience package is to provide an easy-to-use framework with clear thresholds for each convergence criterion.</p>

<p>We derive a minimum value for the ESS based on a normal distribution and the standard error of the mean (SEM).
How much error in our estimate of the posterior mean should we find acceptable? Clearly, the mean estimate for a distribution with a large variance does not need to be as precise as the mean estimate for a distribution with a small variance. However, relative to the variance/spread of the distribution, what percentage is acceptable? We suggest to use a SEM smaller of 1% of the 95% probability interval of the distribution, which is equivalent to say that the allowed error of the mean is four times the standard deviation of the distribution. (Note that you can derive a different ESS value for any other threshold that you like.) From this SEM, we can derive the ESS with:</p>

\[SEM = \frac{\sigma}{\sqrt{ESS}}\]

\[\frac{\sigma}{\sqrt{ESS}} &lt; 1\% \times 4 \times \sigma\]

\[ESS &gt; \frac{1}{0.04^2}\]

\[ESS &gt; 625\]

<p>An ESS of 625 is therefore the default value for the convenience package.</p>

<p>For the KS test, the threshold is the critical value for $\alpha$ = 0.01 and the sample size is the calculated threshold for the ESS, 625.
With these values, the threshold for the KS test is ${D}_{crit}$ = 0.0921.</p>

<h4 class="subsubsection" id="split-frequencies">Split Frequencies</h4>
<hr class="subsubsection" />

<p>To date, the most often test to assess convergence of split frequencies is the <em>average standard deviation of split frequencies</em> (ASDSF) <a class="citation" href="#Nylander2008">(Nylander et al. 2008)</a>. The frequency of each split is computed for two separate MCMC runs and the difference between the two split frequency estimates is used. The ASDSF is problematic for two reasons: (1) for large trees with many splits that have posterior probabilities close to 0.0 or 1.0 will overwhelm the ASDSF and hence even a single split that is present in all samples in run 1 (thus a posterior probability of 1.0) and is never present in any sample in run 2 (thus a posterior probability of 0.0) might not be detected, and (2) the expected difference in split frequency depends on the true split frequency (see Figure <a href="#difference_split_frequencies"></a>).</p>

<figure id="difference_split_frequencies"><p><img src="figures/difference_split_frequencies.png" width="500" /></p>
<figcaption>The expected difference in split frequencies for ESS of 100, 200 and 625. The x-axis is the true value of the split frequency. The y-axis is the expected difference in split frequencies. The effect of increasing the ESS is the decrease of differences in frequency of sampled splits.</figcaption>
</figure>

<p>Instead of the ASDSF we use the ESS of each split.
We transform each split into a chain of absence and presence values; if the split was present in the i-th tree then we score the i-th value of the chain as a 1 and 0 otherwise. This sequence of absence and presence observations (0s and 1s) allows us to apply standard methods to compute ESS values and thus we can use the same ESS threshold of 625 as for our continuous parameters.</p>

<p>With the ESS threshold for the splits, we can estimate the expected difference in splits frequencies (EDSF) and use the 95% quantile as a threshold for the split differencies. The expected difference ($ {E}[\Delta^{sf}_{p}] $) between two samples is calculated as the <a href="https://en.wikipedia.org/wiki/Mean_absolute_difference">‘mean absolute difference’</a>, with N as the ESS:</p>

\[{E}[\Delta^{sf}_{p}] = \sum\limits_{i=0}^N \sum\limits_{j=0}^N \left(|\frac{i}{N} - \frac{j}{N}| \times P_{binom}(i|N,p) \times P_{binom}(j|N,p) \right)\]

<h3 class="subsection" id="summary">Summary</h3>
<hr class="subsection" />

<p><a href="#convergence_summary"></a> provides an overview of the convergence assessment described before and implemented in the package Convenience.</p>

<figure id="convergence_summary"><p><img src="figures/convergence_summary.png" width="600" /></p>
<figcaption>Overview of the workflow in the convergence assessment.</figcaption>
</figure>

<h2 class="section" id="convenience">Convenience</h2>
<hr class="section" />

<h3 class="subsection" id="install">Install</h3>
<hr class="subsection" />

<p>To install Convenience, we need first to install the package devtools.
In R, type the commands:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">install.packages("devtools")</code> <br />
<code class="language-plaintext highlighter-rouge">library(devtools)</code> <br />
<code class="language-plaintext highlighter-rouge">install_github("lfabreti/convenience")</code> <br />
<code class="language-plaintext highlighter-rouge">library(convenience)</code> <br /></p>
</blockquote>

<h3 class="subsection" id="functions">Functions</h3>
<hr class="subsection" />

<p>Here is a list of the functions the package uses to assess convergence:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">checkConvergence</code>: takes the output from a phylogenetic analysis and works through the convergence assessment pipeline. This function can take either a directory with all the output files from a single analysis or a list of files. The function has 3 arguments:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">path</code>: for when a path to a directory is provided</li>
      <li><code class="language-plaintext highlighter-rouge">list_files</code>: for when a list of files is provided</li>
      <li><code class="language-plaintext highlighter-rouge">format</code>: the software used for the phylogenetic analysis, current accepted formats are “revbayes”, “mb” for MrBayes, “beast”, “*beast”</li>
      <li><code class="language-plaintext highlighter-rouge">control</code>: calls the <code class="language-plaintext highlighter-rouge">makeControl</code> function</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">essContParam</code>: calculates the ESS for the continuous parameters</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">essSplitFreq</code>: calculates the ESS for the splits from the trees</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ksTestContParam</code>: calculates the KS test for the continuous parameters, for both the comparison between windows or runs</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">loadFiles</code>: gets the MCMC output from a directory path or a list of files. This function uses the package RWTY <a class="citation" href="#Warren2016">(Warren et al. 2016)</a> and returns a list of type rwty.chain</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">loadMulti</code>: this function was modified from RWTY to include the option to pass a list of files to the function <code class="language-plaintext highlighter-rouge">loadFiles</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">makeControl</code>: a function to set the burnin size, the precision of the standard error of the mean and the continuous parameters to exclude from the assessment. Default values are burnin = 0, precision = 1%, namesToExclude = “br_lens, bl, Iteration, Likelihood, Posterior, Prior”</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">meanContParam</code>: calculates the means of the continuous parameters</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">plotDiffSplits</code>: plots the calculated difference in splits frequency</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">plotEssContinuous</code>: plots the histogram of the ESS values for the continuous parameters</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">plotEssSplits</code>: plots the histogram of the ESS values for the splits</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">plotKS</code>: plots the histogram of the KS values for the combination of all runs. The MCMC must have at least 2 runs</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">plotKSPooled</code>: plots the histogram of the KS values for the one-on-one comparison of runs. The MCMC must have at least 3 runs</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">printConvergenceDiag</code>: a S3 method to print the class <code class="language-plaintext highlighter-rouge">convenience.diag</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">printConvergenceTable</code>: a S3 method to print the class <code class="language-plaintext highlighter-rouge">convenience.table</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">printListFails</code>: a S3 method to print the class <code class="language-plaintext highlighter-rouge">list.fails</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">printTableContinuous</code>: prints the means and the ESS of the continuous parameters, you can save the table to a csv file by passing a file name to the function</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">printTableSplits</code>: prints the frequencies and ESS of the splits, you can save the table to a csv file by passing a file name to the function</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">readTrace</code>: this function was modified from <a href="https://github.com/revbayes/RevGadgets">‘RevGadgets’</a> to include the option to read only files with the continuous parameters, when the user has no tree files to assess convergence</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">removeBurnin</code>: remove the initial statates from the MCMC output</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">splitFreq</code>: calculates the difference in splits for the trees, for both the comparison between windows or runs</p>
  </li>
</ul>

<h2 class="section" id="example">Example</h2>
<hr class="section" />

<p>First, download the files listed as example output files on the top left of this page. Save them in a folder called output.
These files are the output from a phylogenetic analysis performed with a dataset from bears. The nucleotide substitution model was GTR+$\Gamma$+I and the MCMC was set to run 2 independent runs.
The package also works if your analysis has only one run of the MCMC. But the part to compare runs will not be evaluated. Therefore, it is not possible to say that your MCMC result is reproducible. We strongly advise on running more than 1 run.</p>

<p>Let’s run the <code class="language-plaintext highlighter-rouge">checkConvergence</code> function with our example output in a directory (this step may take a few minutes):</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">check_bears &lt;- checkConvergence("output/")</code> <br /></p>
</blockquote>

<p>We can also list the names of the files:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">check_bears &lt;- checkConvergence( list_files = c("bears_cytb_GTR_run_1.log", "bears_cytb_GTR_run_1.trees", "bears_cytb_GTR_run_2.log", "bears_cytb_GTR_run_2.trees") )</code> <br /></p>
</blockquote>

<p>To better understand what <code class="language-plaintext highlighter-rouge">checkConvergence</code> is doing, take a look at <a href="#checkConvergence_summary"></a>. The first step consists of the user setting up the precision in the standard error of the mean for our estimates. The thresholds for ESS, KS test and difference in split frequencies will be calculated based on the precision. Then the function reads in the MCMC output, from the files provided by the user, and computes the quantities used in the criteria for convergence. Afterwards, the function checks if the computed quantities are within the calculated thresholds. Finally, the function reports wheter the MCMC has converged or not, the computed quantities and, in case of non convergence, the parameters that failed to achieve the desired thresholds.</p>

<figure id="checkConvergence_summary"><p><img src="figures/checkConvergence_summary_modified.png" width="500" /></p>
<figcaption>Summary of the process in the <code class="language-plaintext highlighter-rouge">checkConvergence</code> function. SF is the abbreviation for split frequencies.</figcaption>
</figure>

<p>Now, let’s see the output from <code class="language-plaintext highlighter-rouge">checkConvergence</code> by typing <code class="language-plaintext highlighter-rouge">check_bears</code>.
The output message includes:</p>

<ul>
  <li>
    <p>A message if convergence was achieved or not</p>
  </li>
  <li>
    <p>The calculated burn-in</p>
  </li>
  <li>
    <p>Lowest ESS for the splits and continuous parameters</p>
  </li>
  <li>
    <p>Instructions to check further the output:</p>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">To check the calculated parameters for the continuous parameters type:</code> <br />
   <code class="language-plaintext highlighter-rouge">Means: output$continuous_parameters$means</code> <br />
   <code class="language-plaintext highlighter-rouge">ESS: output$continuous_parameters$ess</code> <br />
   <code class="language-plaintext highlighter-rouge">KS score: output$continuous_parameters$compare_runs</code> <br /></p>
</blockquote>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">To check the calculated parameters for the splits type:</code> <br />
   <code class="language-plaintext highlighter-rouge">Frequencies of splits: output$tree_parameters$frequencies</code> <br />
   <code class="language-plaintext highlighter-rouge">ESS: output$tree_parameters$ess</code> <br />
   <code class="language-plaintext highlighter-rouge">Difference in frequencies: output$tree_parameters$compare_runs</code> <br /></p>
</blockquote>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">To check the full summary message with splits and parameters excluded from the analysis type:</code> <br />
   <code class="language-plaintext highlighter-rouge">output$message_complete</code> <br /></p>
</blockquote>

<p>We can see that <code class="language-plaintext highlighter-rouge">check_bears</code> has 4 elements: <code class="language-plaintext highlighter-rouge">message</code>, <code class="language-plaintext highlighter-rouge">message_complete</code>, <code class="language-plaintext highlighter-rouge">converged</code>, <code class="language-plaintext highlighter-rouge">continuous_parameters</code> and <code class="language-plaintext highlighter-rouge">tree_parameters</code>.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">message</code>: a summary of the convergence assessment;</li>
  <li><code class="language-plaintext highlighter-rouge">message_complete</code>: the summary from message plus: (1) the splits excluded from the assessment for having frequency above 0.975 or below 0.025 (when applicable), (2) the continuous parameters excluded from the assessment for having no variation during the MCMC (when applicable);</li>
  <li><code class="language-plaintext highlighter-rouge">converged</code>: a boolean that has TRUE if the analysis converged and FALSE if it did not converge;</li>
  <li><code class="language-plaintext highlighter-rouge">continuous_parameters</code>: a list with means, ESS and KS-scores between runs;</li>
  <li><code class="language-plaintext highlighter-rouge">tree_parameters</code>: a list with frequencies, ESS and split frequencies between runs.</li>
</ol>

<p>In case the analysis has failed to converge, another element will be on the output list: <code class="language-plaintext highlighter-rouge">failed</code> with the parameters that failed the criteria for convergence.</p>

<p>We can generate tables with general information for the continuous parameters the splits with the commands:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">printTableContinuous(check_bears)</code> <br /></p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">means</th>
      <th style="text-align: center">ESS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">alpha</td>
      <td style="text-align: center">1.603954589</td>
      <td style="text-align: center">8921.945</td>
    </tr>
    <tr>
      <td style="text-align: center">er.1.</td>
      <td style="text-align: center">0.015576521</td>
      <td style="text-align: center">10705.048</td>
    </tr>
    <tr>
      <td style="text-align: center">er.2.</td>
      <td style="text-align: center">0.505904352</td>
      <td style="text-align: center">11570.794</td>
    </tr>
    <tr>
      <td style="text-align: center">er.3.</td>
      <td style="text-align: center">0.006423004</td>
      <td style="text-align: center">5683.824</td>
    </tr>
    <tr>
      <td style="text-align: center">er.4.</td>
      <td style="text-align: center">0.009572443</td>
      <td style="text-align: center">18078.730</td>
    </tr>
    <tr>
      <td style="text-align: center">er.5.</td>
      <td style="text-align: center">0.454927376</td>
      <td style="text-align: center">15992.299</td>
    </tr>
    <tr>
      <td style="text-align: center">er.6.</td>
      <td style="text-align: center">0.007596305</td>
      <td style="text-align: center">4368.023</td>
    </tr>
    <tr>
      <td style="text-align: center">p_inv</td>
      <td style="text-align: center">0.532339279</td>
      <td style="text-align: center">3306.411</td>
    </tr>
    <tr>
      <td style="text-align: center">pi.1.</td>
      <td style="text-align: center">0.293497210</td>
      <td style="text-align: center">10057.477</td>
    </tr>
    <tr>
      <td style="text-align: center">pi.2.</td>
      <td style="text-align: center">0.301726522</td>
      <td style="text-align: center">11016.263</td>
    </tr>
    <tr>
      <td style="text-align: center">pi.3.</td>
      <td style="text-align: center">0.135420687</td>
      <td style="text-align: center">9775.079</td>
    </tr>
    <tr>
      <td style="text-align: center">pi.4.</td>
      <td style="text-align: center">0.269355587</td>
      <td style="text-align: center">9885.677</td>
    </tr>
    <tr>
      <td style="text-align: center">sr.1.</td>
      <td style="text-align: center">0.216077996</td>
      <td style="text-align: center">10275.761</td>
    </tr>
    <tr>
      <td style="text-align: center">sr.2.</td>
      <td style="text-align: center">0.550663747</td>
      <td style="text-align: center">16053.336</td>
    </tr>
    <tr>
      <td style="text-align: center">sr.3.</td>
      <td style="text-align: center">1.015625752</td>
      <td style="text-align: center">11775.210</td>
    </tr>
    <tr>
      <td style="text-align: center">sr.4.</td>
      <td style="text-align: center">2.217632528</td>
      <td style="text-align: center">3842.496</td>
    </tr>
    <tr>
      <td style="text-align: center">TL</td>
      <td style="text-align: center">1.112491969</td>
      <td style="text-align: center">7677.455</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">printTableSplits(check_bears)</code> <br /></p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: center">frequencies</th>
      <th style="text-align: center">ESS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Helarctos_malayanus Ursus_americanus</td>
      <td style="text-align: center">0.09</td>
      <td style="text-align: center">17127.93</td>
    </tr>
    <tr>
      <td style="text-align: left">Melursus_ursinus Ursus_arctos Ursus_maritimus</td>
      <td style="text-align: center">0.18</td>
      <td style="text-align: center">18074.54</td>
    </tr>
    <tr>
      <td style="text-align: left">Helarctos_malayanus Melursus_ursinus Ursus_americanus Ursus_thibetanus</td>
      <td style="text-align: center">0.32</td>
      <td style="text-align: center">15526.14</td>
    </tr>
    <tr>
      <td style="text-align: left">Helarctos_malayanus Ursus_americanus Ursus_arctos Ursus_maritimus Ursus_thibetanus</td>
      <td style="text-align: center">0.50</td>
      <td style="text-align: center">15731.22</td>
    </tr>
    <tr>
      <td style="text-align: left">Ursus_americanus Ursus_thibetanus</td>
      <td style="text-align: center">0.89</td>
      <td style="text-align: center">15269.03</td>
    </tr>
  </tbody>
</table>

<p>Convenience also provides plot functions to facilitate showing that convergence has been achieved.
The functions <code class="language-plaintext highlighter-rouge">plotEssContinuous</code> and <code class="language-plaintext highlighter-rouge">plotEssSplits</code> plot the histogram of the ESS values for the continuous parameters and  the splits, respectively.
The function <code class="language-plaintext highlighter-rouge">plotKS</code> plots a histogram of the KS values for the continuous parameters.
And the function <code class="language-plaintext highlighter-rouge">plotDiffSplits</code> yields a plot for the calculated difference in splits frequency.</p>

<figure id="plotESS"><p><img src="figures/results_plots.png" width="800" /></p>
<figcaption>The plots generated with Convenience for summarizing and visualizing the results from the convergence assessment. The top-left figure shows the histogram of calculated ESS values for the model parameters (continuous parameters). The bottom-left figure shows the histogram of calculated ESS for the splits. In both histograms the grey dotted lines represents the threshold of 625. The bottom-right plot is the histogram of the Kolmogorov-Smirnov (KS) for the model parameters, the dotted grey line represents the threshold for the KS test. The bottom-left figure shows the observed difference is split frequencies in the green dots and the expected difference between split frequencies (EDSF) in the grey curve. For all plots, the grey area shows where the parameters should be for convergence to be achieved.</figcaption>
</figure>

<p>We can see that, for all figures, all continuous parameters and splits have an ESS above the threshold. This is what we would have expected for a MCMC that has converged. 
The KS histogram shows that all KS values calculated for the continuous parameters are below the threshold. This means that the parameters are drawn from the same distribution for both runs of our analysis. Therefore, if convergence is achieved for a given analysis, the histogram for the KS values should be similiar to this plot.
The calculated differences in split frequencies fall below the threshold curve in grey. When convergence is not achieved, some dots would be above the threshold curve.</p>

<p>It is also possible to plot the histogram of the KS values for the comparisons one-on-one when the MCMC analysis have more than 2 runs.
The function for this plot is <code class="language-plaintext highlighter-rouge">plotKS.pooled</code>. 
The following figure is an example of this plot.</p>

<figure id="checkConvergence_summary"><p><img src="figures/plotKS_pooled.png" width="500" /></p>
<figcaption>Histogram of the calculated KS values for the one-on-one comparison between runs. Each color represents a different comparison of runs, as shown in the legend. The x-axis is the KS values and the y-axis is the frequency. The red dotted line represents the threshold for the KS score.</figcaption>
</figure>

<p>In this example, we observe again that all KS values are below the threshold. Which means that, for this criterion, convergence has been achieved.
Now that we learned how to use the package and how to interpret the results, let’s practice with some exercises.</p>

<h3 class="subsection" id="exercise-1">Exercise 1</h3>
<hr class="subsection" />

<p>Check for convergence in the output generated in the <a href="/tutorials/ctmc/">Nucleotide Substitution Models</a> tutorial.</p>

<p>Which analysis have converged?</p>

<h3 class="subsection" id="convergence-failure">Convergence failure</h3>
<hr class="subsection" />

<p>You can see that the output is different when we have a failure in convergence. We have more information in the text output and 2 extra elements <code class="language-plaintext highlighter-rouge">failed</code> and <code class="language-plaintext highlighter-rouge">failed_names</code>.
The element <code class="language-plaintext highlighter-rouge">failed</code> has a summary text of what failed in our analysis.
The element <code class="language-plaintext highlighter-rouge">failed_names</code> has the specifics about the parameters that failed, like the name of the parameter or the split and if it failed in checking for the ESS, the comparison between windows or between runs.</p>

<p><a href="#failed"></a> shows the <code class="language-plaintext highlighter-rouge">failed</code> message for the convergence assessment on the analysis from Exercise 1 with the GTR+$\Gamma$+I nucleotide substitution model.</p>

<figure id="failed"><p><img src="figures/failed.png" /></p>
<figcaption>The output from the command <code class="language-plaintext highlighter-rouge">check_primates$failed</code> showing a summary of the number of parameters that have failed a certain criterion.</figcaption>
</figure>

<h3 class="subsection" id="exercise-2">Exercise 2</h3>
<hr class="subsection" />

<ul>
  <li>
    <p>Rerun the MCMC with the GTR+$\Gamma$+I model from <a href="/tutorials/ctmc/">Nucleotide Substitution Models</a>, but increase the number of iterations to 50000.</p>
  </li>
  <li>
    <p>Check the new results for convergence.</p>
  </li>
</ul>

<h3 class="subsection" id="exercise-3">Exercise 3</h3>
<hr class="subsection" />

<ul>
  <li>Check convergence for the output from the <a href="/tutorials/fbd_simple/">Estimating a Time-Calibrated Phylogeny of Fossil and Extant Taxa using Morphological Data</a> tutorial.</li>
</ul>

<p>In this case we should check only the continuous parameters (log files). Because the trees sampled throughout the MCMC have different number of tips due to the fossil record.</p>

<h3 class="subsection" id="what-to-do">What to do</h3>
<hr class="subsection" />

<p>When we face a convergence failure, there are a few options of what to do in our MCMC to overcome this problem. The suggestions here come from experience, rather than theoretical proofs.
We can divide our MCMC that lack convergence by the number of parameters that failed:</p>

<ul>
  <li>
    <p>Several parameters failing</p>
  </li>
  <li>
    <p>One or few parameters failing</p>
  </li>
</ul>

<p>For the first case, we should adjust the MCMC to be more efficient. This can be done by increasing the weights on the moves of the parameters that failed, using other MCMC algorithms (such as adaptive MCMC or Metropolis-Coupled MCMC), increasing the number of iterations, etc. 
In the second case, we should increase the weights on the moves or even add more moves for the specific parameters that failed.</p>


<ol class="bibliography"><li><span id="Nylander2008">Nylander J.A.A., Wilgenbusch J.C., Warren D.L., Swofford D.L. 2008. AWTY (are we there yet?): a system for graphical exploration of MCMC convergence in Bayesian phylogenetics. Bioinformatics. 24:581.</span>

</li>
<li><span id="Rambaut2018">Rambaut A., Drummond A.J., Xie D., Baele G., Suchard M.A. 2018. Posterior Summarization in Bayesian Phylogenetics Using Tracer 1.7. Systematic Biology. 67:901–904.</span>

<a href="https://doi.org/10.1093/sysbio/syy032">10.1093/sysbio/syy032</a>

</li>
<li><span id="Warren2016">Warren D.L., Geneva A., Swofford D.L., Lanfear R. 2016. rwty: R We There Yet. A package for visualizing MCMC convergence in phylogenetics.</span>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
