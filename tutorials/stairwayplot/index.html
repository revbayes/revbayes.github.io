<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: StairwayPlot Analyses</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">StairwayPlot Analyses</h1>
	<h3 class="subtitle">Estimating Demographic Histories from SNP data with Bayesian StairwayPlot Approach</h3>
	<h4 class="authors">Sebastian Höhna</h4>
  <h5>Last modified on December  6, 2024</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
            <li><a href="/tutorials/mcmc/moves.html">Overview of Moves in MCMC</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





</div>
<blockquote class="info">
  <h2 id="for-your-info">For your info</h2>
  <p>This tutorial and the included exercises are currently under construction.
If you want to run the analyses, please compile <code class="language-plaintext highlighter-rouge">RevBayes</code> from the <a href="https://github.com/revbayes/revbayes/tree/dev_stairwayplot">dev_stairwayplot</a> branch as described <a href="https://revbayes.github.io/compile-linux">here</a> (for the development branch). The code should hopefully be available in the next release (RevBayes v1.2.6).</p>
</blockquote>

<h2 class="section" id="overview">Overview</h2>
<hr class="section" />

<p>This tutorial describes how to run a demographic analysis using the <code class="language-plaintext highlighter-rouge">StairwayPlot</code> approach <a class="citation" href="#Liu2015">(Liu and Fu 2015; Liu and Fu 2015)</a> in <code class="language-plaintext highlighter-rouge">RevBayes</code> <a class="citation" href="#Hoehna2016b">(Höhna et al. 2016)</a>.
The <code class="language-plaintext highlighter-rouge">StairwayPlot</code> approach assumes an underlying coalescent for a single panmictic population and an infinite sites model.
Population sizes are allowed to vary between coalescent events but assumed to be constant in between, thus producing the characteristic stairway shape.
As data, the <code class="language-plaintext highlighter-rouge">StairwayPlot</code> approach uses the site frequency spectrum (SFS), or allele frequency spectrum, and assumes that SNPs are unlinked, i.e., have their own coalescent history.
<br />
For a detailed description we refer the reader to <a class="citation" href="#Hoehna2024b">Höhna and Catalán (2024)</a>.
The data for these analyses are taken from (missing reference).
More specifically, the data consists of a folded site frequency spectrum of the Munich population from the big European firefly <em>Lampyris noctiluca</em>.</p>

<p><br />
<br />
<br /></p>

<h2 class="section" id="preparation">Preparation</h2>
<hr class="section" />

<blockquote class="instruction">
  <p>In order to perform the different analyses in this tutorial, you will need to create a directory on your computer for this tutorial and download a few files.</p>
</blockquote>

<h3 class="subsection" id="the-scripts">The Scripts</h3>
<hr class="subsection" />

<p>It is useful to create <code class="language-plaintext highlighter-rouge">.Rev</code> scripts for the different analyses.
We will also provide a full script in every tutorial that you can easily run for the whole analysis.</p>

<blockquote class="instruction">
  <p>Please create a “scripts” directory in the tutorial directory.</p>
</blockquote>

<h3 class="subsection" id="the-data">The Data</h3>
<hr class="subsection" />

<p>The data for a <code class="language-plaintext highlighter-rouge">StairwayPlot</code> analysis are the site frequency spectrum.
For this tutorial, we assume that the site frequency spectrum was already computed.
We also refer to our own tutorial (currently in preparation) for obtaining an SFS from a VCF file.
In general, it is best to compute first the SFS so that it can be used efficiently in several analyses without extracting it each time from the VCF.</p>

<p>The SFS is simply specified as a vector of counts:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>obs_sfs = [ 405017549, 1393598, 922300, 682542, 530181, 421015, 360546, 303107, 257549, 218569, 197952, 172446, 161453, 145816, 136546, 123085, 121036, 114119, 116561, 113349, 65829 ]
</code></pre></div></div>
<p>We obtained the data of the Munich population from the big European firefly <em>Lampyris noctiluca</em> from (missing reference), and you can see it plotted in <a href="#fig_SFS"></a>.
Here we use the folded site frequency spectrum from 20 diploid individuals, thus the size of the folded site frequency spectrum is 21 and the first entry represents the fixed sites.</p>

<figure id="fig_SFS"><p><img src="figures/SFS_Munich.png" width="50%" height="50%" /></p>
<figcaption>Unfolded and folded site frequency spectrum of the big European firefly, <em>Lampyris noctiluca</em>. These represent 20 sampled diploid individuals. Data are obtained from (missing reference).</figcaption>
</figure>

<p>We will also use some variables from the data, the number of haploid individuals <code class="language-plaintext highlighter-rouge">N_IND</code> and the total sequence length <code class="language-plaintext highlighter-rouge">N_SITES</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N_IND   = 2*abs(obs_sfs.size()-1)
N_SITES = round(sum(obs_sfs))
</code></pre></div></div>

<blockquote class="aside"><h2>Folding the SFS</h2><p>If you have a full SFS but need to fold it, you can also easily do this in <code class="language-plaintext highlighter-rouge">RevBayes</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tmp_sfs[1] &lt;- obs_sfs[1] + obs_sfs[N_IND+1]
for (i in 1:ceil(N_IND/2)) {
  if ( i != N_IND/2 ) {
    tmp_sfs[i+1] &lt;- obs_sfs[i+1] + obs_sfs[N_IND-i+1]
  } else {
    tmp_sfs[i+1] &lt;- obs_sfs[i+1]
  }
}
obs_sfs &lt;- tmp_sfs
</code></pre></div></div>
</blockquote>

<h2 class="section" id="a-bayesian-stairwayplot-analysis">A Bayesian StairwayPlot Analysis</h2>
<hr class="section" />

<h3 class="subsection" id="initializing-global-variables">Initializing Global Variables</h3>
<hr class="subsection" />

<p>In our <code class="language-plaintext highlighter-rouge">RevBayes</code> scripts we need to use some global variables, specifically a vector for ‘moves’ and ‘monitors’.
Remember that <em>moves</em> are the operators/algorithms that propose and change the stochastic variables in a model based on the Metropolis-Hastings algorithm <a class="citation" href="#Metropolis1953">(Metropolis et al. 1953; Hastings 1970)</a>.
<em>Monitors</em> are used to either store samples of variables in files or print them to the screen.
The monitors give you the flexibility which variables to store into which file for specific post-processing.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves    = VectorMoves()
monitors = VectorMonitors()
</code></pre></div></div>

<h3 class="subsection" id="demographic-model-prior-on-population-sizes">Demographic Model (Prior on Population Sizes)</h3>
<hr class="subsection" />

<p>The different priors on the population sizes are the main feature of the Bayesian StairwayPlot compared with the Maximum Likelihood implementation <a class="citation" href="#Liu2020">(Liu and Fu 2020; Höhna and Catalán 2024)</a>.
The StairwayPlot approach allows to specify one population size parameter for each interval between coalescent events, that is, for a dataset with <em>n</em> individuals (more specifically bins in the unfolded SFS, thus assuming haploid individuals) you can specify <em>n-1</em> population size parameters.
There are various different ways how to specify priors on population size parameters, and we will primarily focus here on the independent and identically distributed (iid) prior.
Other options, such as the Gaussian Markov Random Field (GMRF) and the Horseshoe Markov Random Field (HSMRF) are provided as additional extensions.</p>

<p>The very first step is to initialize a multivariate-normal move <a class="citation" href="#Baele2017">(Baele et al. 2017)</a>.
This move proposes new population sizes for the entire vector (all instead of a single parameter) based on a multivariate normal distribution.
Since posterior samples of the population size parameters are likely to be correlated, either positively or negatively, this multivariate normal distribution learns first the correlation matrix in an initial learning phase by taking samples from the current MCMC.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>avmvn = mvAVMVN(weight=50)
</code></pre></div></div>

<p>Next, we will specify each independent population size parameter.
Remember that the StairwayPlot approach actually uses the parameters $\theta_{k} = 4\times N_{k}\times \mu$.
Thus, we need to specify prior distributions on $\theta_{k}$ instead of $N_{k}$, and we will transform the $\theta$ later into effective population sizes $N$.
In the simplest model, we will assume that each $\theta_k$ has a uniform prior distribution, $\theta_k \sim \text{Unif}(0,0.1)$, but any other prior that is defined for positive real numbers, such as the <em>Exponential</em>, <em>Lognormal</em>, and <em>Gamma</em> distribution.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># now specify a different theta per interval
for (k in 1:(N_IND-1)) {

  # draw theta from a uniform prior distribution
  theta[k] ~ dnUnif( 0.0, 0.1 )

  # set a scaling move for this variable
  moves.append( mvScale(theta[k], weight=5) )
  avmvn.addVariable(theta[k])

}
</code></pre></div></div>
<p>In this <code class="language-plaintext highlighter-rouge">for</code> loop you saw how we specified the iid-uniform prior.
In some cases, it also might be helpful to specify starting values, for example with <code class="language-plaintext highlighter-rouge">theta[i].setValue( 0.05 )</code>.
You also should have noticed that we applied a scaling move (<code class="language-plaintext highlighter-rouge">mvScale</code>) for each $\theta_k$ parameter with a weight of 3, thus proposing on average 3-times a new value per MCMC iteration/cycle.
We also added each $\theta_k$ to our multivariate normal move, which we finally add to our vector of moves.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( avmvn )
</code></pre></div></div>

<p>As alternative prior distributions on the population size parameters, we provide several examples here.
You can simply replace the part above with alternative priors.</p>

<blockquote class="aside"><h2>Gaussian Markov Random Field (GMRF, first and second order)</h2><p>The Gaussian Markov Random Field (GMRF) priors specify normal distributions as shrinkage priors on the population size parameters.
The population size of the next interval is drawn from a normal distribution with mean being equal to the population size in the previous interval.
Note that the variation depends on a global standard deviation parameter.</p>

<p>The entire code block including moves is given by:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>avmvn = mvAVMVN(weight=100)

log_theta_at_present ~ dnUniform(-20,2)
log_theta_at_present.setValue( ln( 0.001 ) )

moves.append( mvSlideBactrian(log_theta_at_present,weight=5) )
avmvn.addVariable(log_theta_at_present)


## Global shrinkage parameter
global_scale_hyperprior     &lt;- 0.021

# Global-scaled variances for hierarchical horseshoe
global_scale ~ dnHalfCauchy(0,1)

# Make sure values initialize to something reasonable
global_scale.setValue(runif(1,0.005,0.1)[1])

# moves on the global scale
moves.append( mvScaleBactrian(global_scale,weight=5.0) )

# now specify a different theta per interval
for (i in 1:(N_IND-2)) {

  # non-centralized parameterization of horseshoe
  delta[i] ~ dnNormal( mean=0, sd=global_scale*global_scale_hyperprior )

  # Make sure values initialize to something reasonable
  delta[i].setValue(runif(1,-0.1,0.1)[1])

  # set a sliding move for this variable
  moves.append( mvSlideBactrian(delta[i], weight=5) )
  avmvn.addVariable(delta[i])

  if ( i &gt; 1 ) {
    move_up_down_delta[i-1] = mvUpDownSlide(weight=3)
    move_up_down_delta[i-1].addVariable( delta[i], up=TRUE )
    move_up_down_delta[i-1].addVariable( delta[i-1], up=FALSE )
    moves.append( move_up_down_delta[i-1] )
  }

}

# Assemble first-order differences and speciation_rate at present into the random field
theta := fnassembleContinuousMRF(log_theta_at_present, delta, initialValueIsLogScale=TRUE, order=1)

# joint sliding moves of all vector elements
moves.append( mvVectorSlide(delta, weight=10) )
moves.append( avmvn )
</code></pre></div></div>
<p>Note that you can switch between first and second order GMRF simply by specifying <code class="language-plaintext highlighter-rouge">order=1</code> or <code class="language-plaintext highlighter-rouge">order=2</code> in <code class="language-plaintext highlighter-rouge">fnassembleContinuousMRF(log_theta_at_present, delta, initialValueIsLogScale=TRUE, order=1)</code></p>
</blockquote>

<blockquote class="aside"><h2>Horseshoe Markov Random Field (HSMRF, first and second order)</h2><p>The Horseshoe Markov Random Field (HSMRF) priors specify normal distributions as shrinkage priors on the population size parameters similar to the GMRF.
However, instead of using a global standard deviation parameter, each interval receives its own standard deviation parameter.
The entire code block including moves is given by:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>avmvn = mvAVMVN(weight=100)

log_theta_at_present ~ dnUniform(-20,2)
log_theta_at_present.setValue( ln( 0.001 ) )

moves.append( mvSlideBactrian(log_theta_at_present,weight=5) )
avmvn.addVariable(log_theta_at_present)


## Global shrinkage parameter
global_scale_hyperprior     &lt;- 0.021

# Global-scaled variances for hierarchical horseshoe
global_scale ~ dnHalfCauchy(0,1)

# Make sure values initialize to something reasonable
global_scale.setValue(runif(1,0.005,0.1)[1])

# moves on the global scale
moves.append( mvScaleBactrian(global_scale,weight=5.0) )

# now specify a different theta per interval
for (i in 1:(N_IND-2)) {

  # non-centralized parameterization of horseshoe
  delta[i] ~ dnNormal( mean=0, sd=global_scale*global_scale_hyperprior )

  # Make sure values initialize to something reasonable
  delta[i].setValue(runif(1,-0.1,0.1)[1])

  # set a sliding move for this variable
  moves.append( mvSlideBactrian(delta[i], weight=5) )
  avmvn.addVariable(delta[i])

  if ( i &gt; 1 ) {
    move_up_down_delta[i-1] = mvUpDownSlide(weight=3)
    move_up_down_delta[i-1].addVariable( delta[i], up=TRUE )
    move_up_down_delta[i-1].addVariable( delta[i-1], up=FALSE )
    moves.append( move_up_down_delta[i-1] )
  }

}

# Assemble first-order differences and speciation_rate at present into the random field
theta := fnassembleContinuousMRF(log_theta_at_present, delta, initialValueIsLogScale=TRUE, order=1)

# joint sliding moves of all vector elements
moves.append( mvVectorSlide(delta, weight=10) )
moves.append( avmvn )
</code></pre></div></div>
<p>Note that you can switch between first and second order HSMRF simply by specifying <code class="language-plaintext highlighter-rouge">order=1</code> or <code class="language-plaintext highlighter-rouge">order=2</code> in <code class="language-plaintext highlighter-rouge">fnassembleContinuousMRF(log_theta_at_present, delta, initialValueIsLogScale=TRUE, order=1)</code></p>
</blockquote>

<h3 class="subsection" id="stairwayplot-distribution">StairwayPlot Distribution</h3>
<hr class="subsection" />

<p>Now comes the main component of the Bayesian StairwayPlot analysis: the StairwayPlot distribution.
We implemented this distribution in simple but flexible way <a class="citation" href="#Hoehna2024b">(Höhna and Catalán 2024)</a> (note that we refer here to the likelihood in <a class="citation" href="#Hoehna2024b">Höhna and Catalán (2024)</a> to match exactly our implementation although the likelihood is, except for conditioning, the same as in <a class="citation" href="#Liu2015">Liu and Fu (2015)</a>).
Our StairwayPlot distribution (<code class="language-plaintext highlighter-rouge">dnStairwayPlot</code>), which specifies the StairwayPlot likelihood <a class="citation" href="#Hoehna2024b">(Höhna and Catalán 2024)</a>, comes with the following parameters:</p>

<ul>
  <li><strong>theta</strong>: The vector of $\theta$ parameters. This must be a vector of length <em>n-1</em>.</li>
  <li><strong>numSites</strong>: The total sequence length, which should be the sum of the SFS. This is used for simulation/initialization and to compute the normalizing constant of the likelihood <a class="citation" href="#Hoehna2024b">(Höhna and Catalán 2024)</a>.</li>
  <li><strong>numIndividuals</strong>: The number of haploid individuals $n$. This again is used primarily for simulation/initialization and needs to match the size of the observed data.</li>
  <li><strong>folded</strong>: Whether the data are folded or not (<code class="language-plaintext highlighter-rouge">TRUE</code> or <code class="language-plaintext highlighter-rouge">FALSE</code>).</li>
  <li><strong>monomorphicProbability</strong>: Whether to compute the probability of monomorphic sites based on the rest of the probability (<code class="language-plaintext highlighter-rouge">rest</code>) or on the tree length (<code class="language-plaintext highlighter-rouge">treelength</code>)?</li>
  <li><strong>coding</strong>: Whether we condition on have <code class="language-plaintext highlighter-rouge">all</code> sites observed, or if we didn’t observe monomorphic sites (<code class="language-plaintext highlighter-rouge">no-monomorphic</code>), or if we also excluded singletons (<code class="language-plaintext highlighter-rouge">no-singletons</code>), i.e., singletons are merged together with monomorphic sites.</li>
</ul>

<p>Several of these parameters have default values.
You can see some information using <code class="language-plaintext highlighter-rouge">?dnStairwayPlot</code>.</p>

<p>Let us specify a variable <code class="language-plaintext highlighter-rouge">sfs</code> drawn from the <code class="language-plaintext highlighter-rouge">dnStairwayPlot</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sfs ~ dnStairwayPlot( theta, numSites=N_SITES, numIndividuals=N_IND, folded=TRUE, coding="all" )
</code></pre></div></div>
<p>and attach/clamp our observed data to this variable</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sfs.clamp( obs_sfs )
</code></pre></div></div>

<p>For post-processing and plotting purposes, we need some additional variables, for example the times when the population sizes changed and the effective population size.
We obtain the changepoint times as the expected coalescent times from our <code class="language-plaintext highlighter-rouge">StairwayPlot</code> distribution, thus using a member function of our variable <code class="language-plaintext highlighter-rouge">sfs</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>times := sfs.getTimes()
</code></pre></div></div>
<p>Note that this variable is a deterministic variable and not a stochastic variable.</p>

<p>Next, we transform these times into actual times and actual effective population sizes.
Therefore, we need to assume some mutation rate $\mu$ and some generation time.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mu        = 2.8e-09
GEN_TIME  = 2
</code></pre></div></div>
<p>Here we assume a mutation rate of $2.8e-09$ (taken from Heliconius melpomene <a class="citation" href="#Keightley2015">(Keightley et al. 2015)</a>) and a generation time of 2 years (missing reference).
Now we can transform the theta</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ordered_Ne    := rev(theta) / 4.0 / mu
ordered_times := rev(times) / mu * GEN_TIME
</code></pre></div></div>
<p>We also want to store the expected site frequency from our model, to compute later the leave-one-out cross-validation score <a class="citation" href="#Lewis2014">(Lewis et al. 2014; Lartillot 2023)</a></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>esfs := sfs.getExpectedAlleleFrequencies()
</code></pre></div></div>

<h3 class="subsection" id="putting-it-all-together">Putting it All Together</h3>
<hr class="subsection" />

<p>We have fully specified all of the parameters of our Bayesian StairwayPlot analysis.
Finally, we wrap the entire model in a single object to provide convenient access to the DAG.
To do this, we only need to give the <code class="language-plaintext highlighter-rouge">model()</code> function a single node.
With this node, the <code class="language-plaintext highlighter-rouge">model()</code> function can find all of the other nodes by following the arrows in the graphical model:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_model = model(sfs)
</code></pre></div></div>

<h3 class="subsection" id="specifying-monitors-and-output-files">Specifying Monitors and Output Files</h3>
<hr class="subsection" />

<p>The next step for our RevBayes analysis is to specify which variables to monitor and to which files to write them.
We want the following monitors:</p>
<ol>
  <li>One monitor that stores all variables of the model into a log-file (<code class="language-plaintext highlighter-rouge">mnModel</code>).</li>
  <li>One monitor that stores the vector of effective population sizes into a file (<code class="language-plaintext highlighter-rouge">mnFile</code>).</li>
  <li>One monitor that stores the change points of population sizes into a file (<code class="language-plaintext highlighter-rouge">mnFile</code>).</li>
  <li>One monitor that stores the expected SFS into a file (<code class="language-plaintext highlighter-rouge">mnFile</code>).</li>
  <li>One monitor that keeps us informed about the progress on the screen (<code class="language-plaintext highlighter-rouge">mnScreen</code>).
Overall, we specify that our monitors that write into our files will sample every 10 iterations, thus thinning the MCMC.
We could also instead increase the weights of our moves.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/StairwayPlot_iid.log", printgen=10) )
monitors.append( mnFile(ordered_Ne, filename="output/StairwayPlot_iid_ordered_Ne.log", printgen=10) )
monitors.append( mnFile(ordered_times, filename="output/StairwayPlot_iid_ordered_times.log", printgen=10) )
monitors.append( mnFile(esfs, filename="output/StairwayPlot_iid_esfs.log", printgen=10) )
monitors.append( mnScreen(printgen=1000) )
</code></pre></div>    </div>
  </li>
</ol>

<h3 class="subsection" id="initializing-and-running-the-mcmc-simulation">Initializing and Running the MCMC Simulation</h3>
<hr class="subsection" />

<p>Now we are ready to run our MCMC simulation.
The first step is to create the MCMC object.
There, we need our <code class="language-plaintext highlighter-rouge">model</code> object, our <code class="language-plaintext highlighter-rouge">moves</code> vector and our <code class="language-plaintext highlighter-rouge">monitors</code> vector.
Additionally, we need to specify how many MCMC replicates we perform.
Here we perform 4 replicates to check for convergence and reproducibility.
We also need to specify whether and how to combine the log-files of the separate replicates.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_mcmc = mcmc(my_model, monitors, moves, nruns=4, combine="mixed")
</code></pre></div></div>
<p>Next, we will run both a pre-burnin phase of 10,000 MCMC iterations, and the actual MCMC simulation with 100,000 iterations.
During the pre-burnin, our monitors will not sample value to the files.
This is mostly done to tune the moves (we tune them here automatically every 100 iterations) and to move from random or fixed starting values to (hopefully) random samples from the stationary posterior distribution.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_mcmc.burnin( generations=10000, tuningInterval=100 )
my_mcmc.run( generations=100000, tuningInterval=200 )
</code></pre></div></div>
<p>After the MCMC is finished, we can check the acceptance rates of our moves to inspect the MCMC performance.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_mcmc.operatorSummary()
</code></pre></div></div>

<h3 class="subsection" id="model-testing-leave-one-out-cross-validation">Model Testing: Leave-one-out cross-validation</h3>
<hr class="subsection" />

<p>The next step of our analysis is to compute the leave-one-out cross-validation score <a class="citation" href="#Lartillot2023">(Lartillot 2023)</a>.
The LOO-CV gives the probability of observing the data under the model after the parameters have been trained to the data.
That is, the LOO-CV gives a prediction of the overall model fit to the data and is more powerful than conventional Bayes factors <a class="citation" href="#Lartillot2023">(Lartillot 2023)</a>.
We compute the LOO-CV from the conditional posterior ordinates <a class="citation" href="#Lewis2014">(Lewis et al. 2014; Lartillot 2023)</a>.
Thus, we create a <code class="language-plaintext highlighter-rouge">ConditionalPosteriorOrdinate</code> object with the expected SFS read from our log files for each of the 4 MCMC replicates.
Then, we compute the LOO-CV given the actual observed SFS.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:4) {
   cpo = ConditionalPosteriorOrdinate( filename="output/StairwayPlot_iid_esfs_run_"+i+".log" )
   pred_prob = cpo.predictiveProbability( obs_sfs, log=FALSE )

   "predictive probability"
   pred_prob
}
</code></pre></div></div>

<blockquote class="instruction">
  <p>Finish your RevBayes script and run this Bayesian StairwayPlot analysis with the iid prior on population sizes.</p>
</blockquote>

<h3 class="subsection" id="the-figures">The Figures</h3>
<hr class="subsection" />

<p>The <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">RevGadgets</code> provides functionality for plotting <code class="language-plaintext highlighter-rouge">RevBayes</code> results.
In each exercise, you can plot the population size trajectories resulting from the different analyses.</p>

<blockquote class="instruction">
  <p>If you want to plot the results from the exercises, please create a “figures” directory in the tutorial directory and install the <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">RevGadgets</code>.</p>
</blockquote>

<p>Here is a code example how to plot the demographic history for each replicate separately.
Since <code class="language-plaintext highlighter-rouge">RevGadgets</code> returns <code class="language-plaintext highlighter-rouge">ggplot2</code> objects, you can easily modify the output to your liking.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(RevGadgets)
library(ggplot2)

burnin = 0.1
probs = c(0.025, 0.975)
summary = "median"

x.lim &lt;- c(1E2,1E7)
y.lim &lt;- c(1E3,1E7)

num_grid_points = 500

for (run in 1:4) {

  population_size_log = paste0("output/StairwayPlot_iid_ordered_Ne_run_",run,".log")
  interval_change_points_log = paste0("output/StairwayPlot_iid_ordered_times_run_",run,".log")

  df &lt;- processPopSizes(population_size_log, interval_change_points_log, burnin = burnin, probs = probs, summary = summary, num_grid_points = num_grid_points)

  p &lt;- plotPopSizes(df) +
       ggtitle( paste0("Demography of Lampyris noctiluca (Munich) - Rep ", run ) + theme(plot.title = element_text(hjust = 0.5, size=10, face="bold.italic")) +
       xlab("Time before present (in years)") + theme(axis.title.x = element_text(size=10, face="bold")) +
       scale_x_continuous(trans='log10', limits = x.lim, breaks=c(1E2,1E3,1E4,1E5,1E6,1E7), labels=c("1E2","1E3","1E4","1E5","1E6","1E7")) +
       ylab("Effective Population Size") + theme(axis.title.y = element_text(size=10, face="bold")) +
       scale_y_continuous(trans='log10', limits = y.lim, breaks=c(1E2,1E3,1E4,1E5,1E6,1E7), labels=c("1E2","1E3","1E4","1E5","1E6","1E7"))

  ggplot2::ggsave(filename=paste0("figures/StairwayPlot_iid_",run,".pdf"), plot=p, width=4, height=4)
}
</code></pre></div></div>

<figure id="fig_demography"><p><img src="figures/StairwayPlot_iid_1.png" width="48%" height="48%" />
<img src="figures/StairwayPlot_iid_2.png" width="48%" height="48%" />
<img src="figures/StairwayPlot_iid_3.png" width="48%" height="48%" />
<img src="figures/StairwayPlot_iid_4.png" width="48%" height="48%" /></p>
<figcaption>Deomgraphy of the big European firefly, <em>Lampyris noctiluca</em> (missing reference).
Here we show 4 MCMC replicates to demonstrate the MCMC convergence.
The prior on population sizes was the iid-uniform distribution.</figcaption>
</figure>

<h2 class="section" id="exercises">Exercises</h2>
<hr class="section" />

<blockquote class="instruction">
  <p>As an exercise, try different models, such as the GMRF, GMRF2, HSMRF and HSMRF2.</p>
</blockquote>

<ol class="bibliography"><li><span id="Baele2017">Baele G., Lemey P., Rambaut A., Suchard M.A. 2017. Adaptive MCMC in Bayesian phylogenetics: an application to analyzing partitioned data in BEAST. Bioinformatics. 33:1798–1805.</span>

</li>
<li><span id="Hoehna2016b">Höhna S., Landis M.J., Heath T.A., Boussau B., Lartillot N., Moore B.R., Huelsenbeck J.P., Ronquist F. 2016. RevBayes: Bayesian Phylogenetic Inference Using Graphical Models and an Interactive Model-Specification Language. Systematic Biology. 65:726–736.</span>

<a href="https://doi.org/10.1093/sysbio/syw021">10.1093/sysbio/syw021</a>

</li>
<li><span id="Hastings1970">Hastings W.K. 1970. Monte Carlo Sampling Methods Using Markov Chains and Their Applications. Biometrika. 57:97–109.</span>

</li>
<li><span id="Hoehna2024b">Höhna S., Catalán A. 2024. The Bayesian StairwayPlot for Inferring Single Population Demographic Histories from Site Frequency Spectra. in review.</span>

</li>
<li><span id="Keightley2015">Keightley P.D., Pinharanda A., Ness R.W., Simpson F., Dasmahapatra K.K., Mallet J., Davey J.W., Jiggins C.D. 2015. Estimation of the spontaneous mutation rate in Heliconius melpomene. Molecular biology and evolution. 32:239–243.</span>

</li>
<li><span id="Lartillot2023">Lartillot N. 2023. Identifying the best approximating model in Bayesian phylogenetics: Bayes factors, cross-validation or wAIC? Systematic Biology. 72:616–638.</span>

</li>
<li><span id="Lewis2014">Lewis P.O., Xie W., Chen M.-H., Fan Y., Kuo L. 2014. Posterior predictive Bayesian phylogenetic model selection. Systematic biology. 63:309–321.</span>

</li>
<li><span id="Liu2015">Liu X., Fu Y.-X. 2015. Exploring population size changes using SNP frequency spectra. Nature genetics. 47:555–559.</span>

</li>
<li><span id="Liu2020">Liu X., Fu Y.-X. 2020. Stairway Plot 2: demographic history inference with folded SNP frequency spectra. Genome biology. 21:280.</span>

</li>
<li><span id="Metropolis1953">Metropolis N., Rosenbluth A.W., Rosenbluth M.N., Teller A.H., Teller E. 1953. Equation of State Calculations by Fast Computing Machines. Journal of Chemical Physics. 21:1087–1092.</span>

<a href="https://doi.org/10.1063/1.1699114">10.1063/1.1699114</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
