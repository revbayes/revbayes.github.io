<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Total-evidence dating, model sensitivity, and model comparison</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Total-evidence dating, model sensitivity, and model comparison</h1>
	<h3 class="subtitle">An example analysis workflow for total-evidence dating analyses</h3>
	<h4 class="authors">Michael R. May</h4>
  <h5>Last modified on March 29, 2022</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
            <li><a href="/tutorials/model_selection_bayes_factors/bf_intro.html">General Introduction to Model selection</a></li>
          
            <li><a href="/tutorials/model_testing_pps/pps_data.html">Assessing Phylogenetic Reliability Using RevBayes and $P^{3}$</a></li>
          
            <li><a href="/tutorials/dating/">Dating trees</a></li>
          
            <li><a href="/tutorials/fbd/fbd_specimen.html">Combined-Evidence Analysis and the Fossilized Birth-Death Process for Analysis of Extant Taxa and Fossil Specimens</a></li>
          
            <li><a href="/tutorials/morph_tree/">Discrete morphology - Tree Inference</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





</div>
<h2 class="section" id="overview">Overview</h2>
<hr class="section" />

<p>Total-evidence (or combined-evidence) dating allows us to estimate time-calibrated phylogenies for extinct and extant species in one coherent statistical framework.
In this framework, fossils are treated as tips in the phylogeny, and their phylogenetic position and branch lengths are inferred directly from morphological data rather than specified a priori.
While this relieves us from the difficult (sometimes impossible) task of deriving reliable fossil-calibration densities for use in node-dating, it requires us to specify a model that (in addition to the standard components of a phylogenetic model) describes how morphological characters evolve, and how lineages diversify and produce fossils over time.</p>

<p>As with all phylogenetic analyses (and divergence-time estimation in particular), inferences using total-evidence dating may be sensitive to the models we use.
Therefore, when applying total-evidence dating, it’s a good idea to use different models to assess whether they affect your inferences, and if they do, to assess the relative and absolute performance of the different models.
The purpose of this tutorial is to help you manage the task of using a potentially large number of total-evidence dating models and assessing their performance, similar to the workflow we use for our own work <a class="citation" href="#May2021">(May et al. 2021)</a>.
It is intended to be adapted to new datasets, and to allow you to add or modify models as appropriate for your own analyses.</p>

<p>This tutorial is structured as follows.
In the first section (<a href="#intro"></a>), we discuss the general structure of the total-evidence-dating model, and the organizational scheme of the analysis scripts we provide.
In the second section (<a href="#MCMC"></a>), we show how to estimate the posterior distribution under a given model using Markov-chain Monte Carlo.
In the third section (<a href="#sensitivity"></a>), we present some tools for assessing how much different modeling assumptions affect tree topologies and divergence-time estimates.
In the fourth section (<a href="#bayes_factors"></a>), we show how to compare the relative fit of competing models using Bayes factors, which can be useful if posterior estimates are sensitive to different models.
In the final section (<a href="#posterior_prediction"></a>), we show how to use posterior-predictive simulation to assess whether our models provide a good absolute (rather than relative) description of morphological evolution.</p>

<p>⚠ <strong><em>This tutorial involves running many analyses and comparing many models. Be aware that it can take several hours to complete! We will also presume some familiarity with many aspects of phylogenetic modeling; be sure to refer to the prerequisites if you are not already familiar with the models we are using.</em></strong></p>

<h4 class="subsubsection" id="a-note-about-r-dependencies">A note about <code class="language-plaintext highlighter-rouge">R</code> dependencies</h4>
<hr class="subsubsection" />

<p>Many of the post-processing steps in this tutorial require you to use <code class="language-plaintext highlighter-rouge">R</code>, especially the package <code class="language-plaintext highlighter-rouge">RevGadgets</code>.
Before you begin, you should make sure you have the following <code class="language-plaintext highlighter-rouge">R</code> package dependencies installed:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">RevGadgets</code></li>
  <li><code class="language-plaintext highlighter-rouge">ggplot2</code></li>
  <li><code class="language-plaintext highlighter-rouge">ape</code></li>
  <li><code class="language-plaintext highlighter-rouge">phytools</code></li>
  <li><code class="language-plaintext highlighter-rouge">phangorn</code></li>
  <li><code class="language-plaintext highlighter-rouge">smacof</code></li>
  <li><code class="language-plaintext highlighter-rouge">gtools</code></li>
  <li><code class="language-plaintext highlighter-rouge">gridExtra</code></li>
</ul>

<p>You can install these packages in <code class="language-plaintext highlighter-rouge">R</code> using <code class="language-plaintext highlighter-rouge">install.packages(library name)</code>.
Consider doing the <a href="/tutorials/intro/revgadgets.html">RevGadgets tutorial</a> if you’re not comfortable working in <code class="language-plaintext highlighter-rouge">R</code>.</p>

<!-- <h3 class="subsection" id="some-comments-on-terminology">Some comments on terminology</h3><hr class="subsection">

**Node dating**: This refers to calibrating trees using calibration densities assigned to particular nodes in the phylogeny. The calibration densities are often based on fossils that the researcher presumes belong to the clade in question, and the researcher must specify their belief about how long the clade could have existed before the appearance of the fossil.

**Tip dating**: Compared to node dating, tip dating involves treating fossils as tips in a phylogeny. The position of the fossils may either be constrained based on a researcher's belief about where the fossil belongs (see e.g. <a class="citation" href="#Heath2014">Heath et al. (2014)</a>), or inferred from data (typically morphological characters).

**Total-evidence (or combined-evidence) dating**: Total-evidence dating refers to tip dating, where the phylogenetic position and branch lengths for fossils are inferred from morphological data (see e.g. <a class="citation" href="#Ronquist2012a">Ronquist et al. (2012)</a>).

**Fossilized birth-death process**: This is a stochastic process that models how lineages diversify (speciate and go extinct) and produce fossils over time. It is often used as part of a tip-dating analysis. <a class="citation" href="#Heath2014">Heath et al. (2014)</a> introduced the fossilized birth-death process as a better way to specify to include temporal information for molecular (not total-evidence) divergence-time estimation. In contrast, <a class="citation" href="#Zhang2016">Zhang et al. (2016)</a> and <a class="citation" href="#Gavryushkina2016">Gavryushkina et al. (2017)</a> used the fossilized birth-death process as a tree model for total-evidence dating. -->

<h2 class="section" id="intro">Introduction</h2>
<hr class="section" />

<h3 class="subsection" id="the-total-evidence-dating-model">The Total-Evidence Dating Model</h3>
<hr class="subsection" />

<p>The total-evidence dating analysis has five model components:</p>
<ol>
  <li>A <em>tree model</em> that describes how lineages are distributed over time.</li>
  <li>A <em>molecular clock model</em> that describes how rates of molecular evolution vary over the branches of the phylogeny (if at all).</li>
  <li>A <em>molecular substitution model</em> that describes the process of evolution between different nucleotide states.</li>
  <li>A <em>morphological clock model</em> that describes how rates of morphological evolution vary over the branches of the phylogeny (if at all).</li>
  <li>A <em>morphological transition model</em> that describes the process of evolution between different morphological character states (e.g., between states 0 and 1 for a binary character).</li>
</ol>

<p>For any one of these model components, we must choose one of several possible models.
For example, we may choose to use a uniform tree distribution or a fossilized birth-death process for the tree model.
If we choose to use a fossilized birth-death process, we have to decide whether rates of diversification and/or fossilization vary over time (or even among clades).
Because these assumptions can have strong effects on our ultimate inferences, we may wish to perform analyses under various different models and compare the relative and absolute fit of these models to our data.
To learn more about these different model components, see the <a href="/tutorials/ctmc/">CTMC</a>, <a href="/tutorials/dating/">molecular dating</a>, <a href="/tutorials/fbd_simple/">FBD</a>, and <a href="/tutorials/morph_tree/">morphological phylogenetics</a> tutorials.</p>

<h3 class="subsection" id="data-and-script-files">Data and Script Files</h3>
<hr class="subsection" />

<p>The data and scripts for this tutorial have a special structure.
To download all the files in the appropriate structure, click <a href="/tutorials/ted_workflow/files/TED_workflow.tar.gz">HERE</a>, and then unpack the archive.
You will want to run all of the scripts from this tutorial in the top-level directory of <code class="language-plaintext highlighter-rouge">TED_workflow</code>.</p>

<p>The example dataset is a pruned down version of the marattialean fern dataset analyzed in <a class="citation" href="#May2021">May et al. (2021)</a>.
We also provide scripts for most of the models we used for that study.
However, the workflow is intended to be adapted to other datasets, and you can even add new models or variants of the existing models for your own studies.
The archive also includes a <code class="language-plaintext highlighter-rouge">headers</code> directory, a <code class="language-plaintext highlighter-rouge">modules</code> directory, and a <code class="language-plaintext highlighter-rouge">posterior_summary</code> directory, all of which we explain below.</p>

<h3 class="subsection" id="script-organization">Script Organization</h3>
<hr class="subsection" />

<p>When we run a single analysis, it is often most convenient to write a single script that specifies every part of our model.
However, when we run a potentially large number of analyses under different models, it can be helpful to adopt a different approach.
While there are many conceivable approaches, one that we find useful is to create <em>headers</em>, which define the models to be used for a particular analysis, a <em>template</em>, which stitches together the models provided by the header file, and <em>module</em> files which implement the individual models (<a href="#organization"></a>).</p>

<figure id="organization"><p><img src="files/figures/organization.png" width="100%" height="100%" /></p>
<figcaption><strong>Structure of the analyses.</strong> The <em>header</em> file (left) defines which models a particular analysis will use. The header file sources the template file. The <em>template</em> file (middle) uses the variables defined in the header file to find and source the appropriate module files. The <em>module</em> files (right column) specify specific model components, for example the <em>Mk</em> model or the constant-rate fossilized birth-death model.</figcaption>
</figure>

<p>This tutorial focuses on the structure of a total-evidence dating analysis, and on assessing different models, rather than on the specific details of any one model.
One thing to keep in mind is that it’s critical that different modules for a given model component define a common set of variables, so that we can swap different modules in without having to change other parts of the code.
For example, all diversification models will have to define parameters $\lambda$ and $\mu$, to be used by the fossilized birth-death process.
The details of how the different diversification models fill in $\lambda$ and $\mu$ will, of course, depend on the model.
We’ll hide details of particular models in folds, like so (in case you want to dig in):</p>

<blockquote class="aside"><h2>Module: An example model module</h2><p>Here’s a Jukes-Cantor model of sequence evolution, partitioned by alignment:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the partitioned JC substitution model</span><span class="w">
</span><span class="c1"># REQUIRED: mole_Q (one per partition), mole_site_rates (one per partition), and mole_relative_rates (one per partition)</span><span class="w">

</span><span class="c1"># define the Q matrix and site rates per partition</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">naln</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># the Q matrices</span><span class="w">
  </span><span class="n">mole_Q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fnJC</span><span class="p">(</span><span class="m">4</span><span class="p">)</span><span class="w">

  </span><span class="c1"># the site rates</span><span class="w">
  </span><span class="c1"># NOTE: this model doesn't have ASRV, but we have to define it anyway</span><span class="w">
  </span><span class="n">mole_site_rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="m">1.0</span><span class="p">]</span><span class="w">

</span><span class="p">}</span><span class="w">


</span><span class="c1"># relative-rate multipliers among partitions</span><span class="w">
</span><span class="n">mole_proportional_rates</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnDirichlet</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">naln</span><span class="p">))</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvBetaSimplex</span><span class="p">(</span><span class="n">mole_proportional_rates</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">naln</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="c1"># rescale the rates so the mean is 1</span><span class="w">
</span><span class="n">mole_relative_rates</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="n">mole_proportional_rates</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">naln</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Note that the comments at the top of the module file list what variables <em>have</em> to be defined in this module.
These are variables that will ultimately be used by other parts of the model, so all modules for a given model component must define those variables.
For example, all substitution models must define one $Q$ matrix per data partition, a set of site rates to accommodate site-rate variation within partitions, and a set of relative rates among partitions.</p>
</blockquote>

<h3 class="subsection" id="a-simple-header-file">A Simple Header File</h3>
<hr class="subsection" />

<p>We’ll see how this works by starting with the header file for an MCMC analysis under a simple total-evidence model (located in <code class="language-plaintext highlighter-rouge">headers/MCMC/strict_Mk.Rev</code>).</p>

<p>The first thing we’re going to do is specify which tree model to use.
In this tutorial, we’ll assume we’re always using a variant of the fossilized birth-death process as our tree model.
However, there are variants of the fossilized birth-death process that assume that rates are constant over time, or that they vary over time.
We create a variable, <code class="language-plaintext highlighter-rouge">diversification_model</code>, whose value is a string that refers to a specific diversification model (which defines speciation and extinction rates).
We create an analogous variable that defines which fossilization model to use, <code class="language-plaintext highlighter-rouge">fossilization_model</code>.
In this case, we’ll assume that both all of the parameters are constant over time.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># tree model</span><span class="w">
</span><span class="n">diversification_model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"constant"</span><span class="w">
</span><span class="n">fossilization_model</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="s2">"constant"</span><span class="w">
</span></code></pre></div></div>

<p>Next, we say which molecular model we want to use.
In this case, we are using a strict molecular clock model and an HKY substitition model.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># molecular model</span><span class="w">
</span><span class="n">mole_clock_model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"strict"</span><span class="w">
</span><span class="n">substn_model</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="s2">"HKY"</span><span class="w">
</span></code></pre></div></div>

<p>Likewise, we’ll use a strict morphological clock model, and a simple model of morphological evolution, the Mk model.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># morphological model</span><span class="w">
</span><span class="n">morph_clock_model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"linked"</span><span class="w">
</span><span class="n">morph_model</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="s2">"Mk"</span><span class="w">
</span></code></pre></div></div>

<p>Next, we’ll specify what type of analysis we want to do.
In this example, we’re going to start with a standard MCMC analysis; later, we’ll also do “power posterior” and “posterior-predictive simulation” analyses.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the type of analysis</span><span class="w">
</span><span class="n">analysis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"MCMC"</span><span class="w">
</span></code></pre></div></div>

<p>There’s nothing more frustrating than running two (or more) analyses but forgetting to change the output files, so all your outputs get overwritten!
To prevent this from happening, we’ll create some variable in the header file that define where the output should be stored, and also build the name of the output directory based on the variables defined above (so that different analyses will end up with different output filenames).
To achieve this, we start by defining the overall output directory:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the output directory</span><span class="w">
</span><span class="n">output_dir</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="s2">"output_MCMC"</span><span class="w">
</span></code></pre></div></div>
<p>We then create another variable, <code class="language-plaintext highlighter-rouge">output_extra</code> that you can use to append any additional information to the output file name.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">output_extra</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="s2">"_run_01"</span><span class="w">
</span></code></pre></div></div>
<p>(We’re using <code class="language-plaintext highlighter-rouge">output_extra</code> to specify a given run of the same analyses.
This lets us quickly do multiple runs by duplicating the header and changing the run number.
However, in principle, you could use this variable to keep track of any additional information you want.)</p>

<p>Next, we use string concatenation (<code class="language-plaintext highlighter-rouge">+</code>) to programmatically create the output filename based on the <code class="language-plaintext highlighter-rouge">output_dir</code> and the analysis-specific variables.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">output_filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_dir</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"/div_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diversification_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"_foss_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fossilization_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"_moleclock_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mole_clock_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"_moleQ_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">substn_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"_morphclock_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">morph_clock_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"_morphQ_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">morph_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">analysis</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">output_extra</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"/"</span><span class="w">
</span></code></pre></div></div>

<p>Finally, the header file sources the <code class="language-plaintext highlighter-rouge">template.Rev</code> file.
You can think of this as the header file handing all of the relevant information we’ve just defined to the template file, which then puts together all the corresponding models into one analysis.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># source the template file</span><span class="w">
</span><span class="n">source</span><span class="p">(</span><span class="s2">"modules/template.Rev"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h3 class="subsection" id="the-template-file-reading-the-data">The Template File: Reading the Data</h3>
<hr class="subsection" />

<p>The job of the template file is to take the values specified in the header to put together an analysis.
The template file is located in <code class="language-plaintext highlighter-rouge">modules/template.Rev</code>.
Let’s look at it line-by-line.</p>

<p>Like most <code class="language-plaintext highlighter-rouge">Rev</code> scripts, the first thing we’ll do in the template is create a container for moves:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># moves container</span><span class="w">
</span><span class="n">moves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VectorMoves</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>as well as some useful constants (in this case, <code class="language-plaintext highlighter-rouge">H</code> is the standard deviation for a lognormal distribution that spans one order of magnitude, which we use for some prior distributions):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># convenient constants</span><span class="w">
</span><span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ln</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">qnorm</span><span class="p">(</span><span class="m">0.975</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">qnorm</span><span class="p">(</span><span class="m">0.025</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Again like a normal <code class="language-plaintext highlighter-rouge">Rev</code> script, we’ll load our data.
For your own datasets, you’ll want to substitute your own data files for these variables.
We’ll begin by reading in our molecular dataset:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the sequence data</span><span class="w">
</span><span class="n">moledata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readDiscreteCharacterData</span><span class="p">(</span><span class="s2">"data/rbcL.nex"</span><span class="p">,</span><span class="w"> </span><span class="n">alwaysReturnAsVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">naln</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">moledata.size</span><span class="p">()</span><span class="w"> </span><span class="c1"># the number of alignments</span><span class="w">
</span></code></pre></div></div>
<p>The argument <code class="language-plaintext highlighter-rouge">alwaysReturnAsVector = TRUE</code> enforces that the molecular data is always assumed to be a vector.
Whether you are reading in a nexus file with a single alignment or many alignments, the result will always be a vector of alignments.
If we read one alignment, we’d just end up with a vector of length one.
This means that <code class="language-plaintext highlighter-rouge">moledata.size()</code> returns the number of alignments in the vector, not the number of sites in the alignment.
(Also note that our example molecular data file contains three alignments, one per codon position.)</p>

<p>Next, we read our morphological data:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the morphological data</span><span class="w">
</span><span class="n">morphdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readDiscreteCharacterData</span><span class="p">(</span><span class="s2">"data/morpho.nex"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now, we read in the taxon data (including the ages associated with each taxon, as described <a href="/tutorials/fbd_simple/">here</a>):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the taxon data</span><span class="w">
</span><span class="n">taxa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTaxonData</span><span class="p">(</span><span class="s2">"data/taxa.tsv"</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span><span class="o">=</span><span class="n">TAB</span><span class="p">)</span><span class="w">
</span><span class="n">ntax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taxa.size</span><span class="p">()</span><span class="w">
</span><span class="n">nbranch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ntax</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">2</span><span class="w">
</span></code></pre></div></div>

<p>It will be handy to know the number of fossils in our dataset.
To do this, we count the number of taxa in our <code class="language-plaintext highlighter-rouge">taxa.tsv</code> file that aren’t sampled at time 0:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># count the number of fossils</span><span class="w">
</span><span class="n">num_fossils</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">taxa.size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">taxa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="n">.getMinAge</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">num_fossils</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_fossils</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>We also need to make sure all of our character data objects have the same species in them.
We add missing data to each data object for any species that aren’t sampled for that dataset.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># add missing taxa to the sequence data</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">naln</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moledata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">
  </span><span class="n">x.addMissingTaxa</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span><span class="w">
  </span><span class="n">moledata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># add missing taxa to the morphological data</span><span class="w">
</span><span class="n">morphdata.addMissingTaxa</span><span class="p">(</span><span class="n">taxa</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Finally, some of our fossilized birth-death models will allow diversification and/or fossilization rates to vary among geological epochs.
We’ll read in a file that encodes these epochs, <code class="language-plaintext highlighter-rouge">epoch_timescale.csv</code>, and define our breakpoints accordingly.
You may wish for rates to vary over ages, periods, or some other arbitrary way; this code should work for any arbitrary piecewise timescale, as long as it is formatted the same as <code class="language-plaintext highlighter-rouge">epoch_timescale.csv</code>.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read in the timescale</span><span class="w">
</span><span class="n">timescale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readDataDelimitedFile</span><span class="p">(</span><span class="s2">"data/epoch_timescale.csv"</span><span class="p">,</span><span class="w"> </span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">true</span><span class="p">,</span><span class="w"> </span><span class="n">delimiter</span><span class="o">=</span><span class="s2">","</span><span class="p">)</span><span class="w">
</span><span class="n">num_bins</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">timescale.size</span><span class="p">()</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">num_bins</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">breakpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">timescale</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="m">2</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 class="subsection" id="the-template-file-specifying-the-models">The Template File: Specifying the Models</h3>
<hr class="subsection" />

<p>Here is where the rubber meets the road!
We’ll start using the variables defined in the header file to create our model.</p>

<h4 class="subsubsection" id="the-tree-model">The Tree Model</h4>
<hr class="subsubsection" />

<p>The first object we will create is the tree.
We first need to define some dataset-specific variables, for example the number of extant taxa in the tree, and the total number of extant taxa (these values will be used to compute the sampling fraction):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#############################</span><span class="w">
</span><span class="c1"># specifying the tree model #</span><span class="w">
</span><span class="c1">#############################</span><span class="w">

</span><span class="c1"># first we specify some dataset-specific parameters</span><span class="w">
</span><span class="n">extant_taxa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="w">    </span><span class="c1"># total number of extant taxa in the tree</span><span class="w">
</span><span class="n">total_taxa</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="m">111</span><span class="w">   </span><span class="c1"># total number of extant taxa in the group</span><span class="w">
</span></code></pre></div></div>
<p>We also need to specify the minimum and maximum age of the group (the age of the lineage ancestral to the root of the tree):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">origin_min</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="m">419.2</span><span class="w"> </span><span class="c1"># latest origin is the beginning of the Devonian</span><span class="w">
</span><span class="n">origin_max</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="m">485.4</span><span class="w"> </span><span class="c1"># earliest origin is the beginning of the Ordovician</span><span class="w">
</span></code></pre></div></div>

<p>We assume the ancestral lineage is uniformly distributed between this minimum and maximum age.
We therefore draw it from a uniform prior distribution and place MCMC proposals on it:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># draw the origin time</span><span class="w">
</span><span class="n">origin_time</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnUniform</span><span class="p">(</span><span class="n">origin_min</span><span class="p">,</span><span class="w"> </span><span class="n">origin_max</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvSlide</span><span class="p">(</span><span class="n">origin_time</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now we create the diversification model (that defines speciation and extinction rates) using the variables defined in the header.
Once again, we use string concatenation to look up the appropriate file:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># specify the diversification model</span><span class="w">
</span><span class="n">source</span><span class="p">(</span><span class="s2">"modules/diversification_models/"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diversification_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".Rev"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>In this case, the above code will evaluate to <code class="language-plaintext highlighter-rouge">source("modules/diversification_models/constant.Rev")</code>, because we defined <code class="language-plaintext highlighter-rouge">diversification_model = "constant"</code> in our header file!</p>

<blockquote class="aside"><h2>Module: The Constant-Rate Diversification Model</h2><p>In this model, (<code class="language-plaintext highlighter-rouge">modules/diversification_models/constant.Rev</code>) we assume speciation ($\lambda$) and extinction ($\mu$) rates are constant over time.
We parameterize the model using the net-diversification rate ($\lambda - \mu$) and the relative extinction rate ($\mu \div \lambda$).
We use an empirical prior on the diversification rate such that the prior mean diversification rate gives rise to the known number of taxa at the present (see below for details):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the constant-rate diversification model</span><span class="w">
</span><span class="c1"># REQUIRED: lambda, mu (both one per time interval)</span><span class="w">

</span><span class="c1"># empirical prior on the diversification rate</span><span class="w">
</span><span class="n">diversification_prior_mean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ln</span><span class="p">(</span><span class="n">total_taxa</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">origin_time</span><span class="w">
</span><span class="n">diversification_prior_sd</span><span class="w">   </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">H</span><span class="w">

</span><span class="c1"># the diversification rate</span><span class="w">
</span><span class="n">diversification</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnLognormal</span><span class="p">(</span><span class="w"> </span><span class="n">ln</span><span class="p">(</span><span class="n">diversification_prior_mean</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">diversification_prior_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">diversification_prior_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">diversification_prior_sd</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvScale</span><span class="p">(</span><span class="n">diversification</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>The standard deviation of this distribution is <code class="language-plaintext highlighter-rouge">H</code>, which implies that the true diversification rate is within one order of magnitude of the prior mean.</p>

<p>We draw the relative-extinction rate from a uniform prior between 0 and 1 (if the relative extinction rate was greater than one, the process almost certainly would have died before reaching the present):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the relative extinction rate</span><span class="w">
</span><span class="n">relext</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnUniform</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvSlide</span><span class="p">(</span><span class="n">relext</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Finally, we transform the net-diversification and relative-extinction rates into the speciation and extinction rates:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># transform to real parameters</span><span class="w">
</span><span class="n">lambda</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="nf">abs</span><span class="p">(</span><span class="n">diversification</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="m">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">relext</span><span class="p">)),</span><span class="w"> </span><span class="n">num_bins</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">mu</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="n">lambda</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">relext</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Note that we replicate <code class="language-plaintext highlighter-rouge">lambda</code> one time per time interval (<code class="language-plaintext highlighter-rouge">num_bins + 1</code>).
We are doing this because some diversification models will actually let <code class="language-plaintext highlighter-rouge">lambda</code> vary among time intervals, and other parts of the code (for example, the FBD distribution) will not know whether we are using a constant or epochal model.
Replicating <code class="language-plaintext highlighter-rouge">lambda</code> lets us use downstream code that will work the same for constant or epochal models.
The <code class="language-plaintext highlighter-rouge">abs()</code> functions just guarantee that both of these rates are positive numbers.</p>

<p>Here’s how the empirical prior works.
For simplicity, we imagine the process begins with at time 0 and diversifies forward in time, $t$, under a deterministic growth model with growth rate (diversification rate) $\lambda - mu$.
The number of species at time $t$ is then:</p>

\[\begin{equation*}
N(t) = N(0) \exp^{(\lambda - \mu)t}
\end{equation*}\]

<p>We can turn this into an empirical prior on the mean by plugging in the number of extant species into $N(t)$, the number of initial species (one) into $N(0)$ and solving for $\lambda - \mu$:</p>

\[\begin{equation*}
\lambda - \mu = \frac{ln[N(t)/N(0)]}{t} = \frac{ln[N(t)]}{t}
\end{equation*}\]

<p>which is reflected in the prior mean code:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">diversification_prior_mean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ln</span><span class="p">(</span><span class="n">total_taxa</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">origin_time</span><span class="w">
</span></code></pre></div></div>
</blockquote>

<p>Next, we source the fossilization model:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># specify the fossilization model</span><span class="w">
</span><span class="n">source</span><span class="p">(</span><span class="s2">"modules/fossilization_models/"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fossilization_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".Rev"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<blockquote class="aside"><h2>Module: The Constant-Rate Fossilization Model</h2><p>This model is defined in <code class="language-plaintext highlighter-rouge">modules/fossilization_models/constant.Rev</code>.
As with the constant-rate diversification model, this model assumes that the fossilization rate is constant over time.
Here, we use an empirical prior that centers the fossilization rate such that, on average, we expect to see the number of fossils we observe in the empirical dataset (see below for details):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the constant-rate fossilization model</span><span class="w">
</span><span class="c1"># REQUIRED: psi (one per time interval)</span><span class="w">

</span><span class="c1"># empirical prior on the fossilization rate</span><span class="w">
</span><span class="n">fossilization_prior_mean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">num_fossils</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">diversification_prior_mean</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nf">exp</span><span class="p">(</span><span class="n">diversification_prior_mean</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">origin_time</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">fossilization_prior_sd</span><span class="w">   </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">H</span><span class="w">
</span></code></pre></div></div>

<p>We then draw the fossilization rate from the corresponding Lognormal prior:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the fossilization rate</span><span class="w">
</span><span class="n">psi_global</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnLognormal</span><span class="p">(</span><span class="w"> </span><span class="n">ln</span><span class="p">(</span><span class="n">fossilization_prior_mean</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fossilization_prior_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fossilization_prior_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">fossilization_prior_sd</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvScale</span><span class="p">(</span><span class="n">psi_global</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>As with the constant diversification model, we replicate the global fossilization rate so there is one per time interval:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># define the timelines</span><span class="w">
</span><span class="n">psi</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="n">psi_global</span><span class="p">,</span><span class="w"> </span><span class="n">num_bins</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Like the diversification parameter, we’ve used an empirical prior on the fossilization rate, $\psi$.
If there are $N(t)$ species at time $t$, each of which leaves a fossil with rate $\psi$, then the rate at which fossils are produced by the entire population at time $t$ is $\psi \times N(t)$.
Assuming deterministic population growth at rate $\lambda - \mu$, we can compute the total number of fossils produced by the population up to time $t$, $F(t)$, by integrating time up to $t$:</p>

\[\begin{equation*}
F(t) = \int_0^t \psi N(s) ds = \frac{\psi (\exp^{(\lambda - \mu)t} - 1)}{\lambda - \mu}
\end{equation*}\]

<p>(assuming we began with a single lineage at time $t = 0$).
To derive an empirical prior mean for the fossilization rate, we plug the observed number of fossils in our dataset into $F(t)$ and solve for $\psi$, which leads to:</p>

\[\begin{equation}
\psi = \frac{F(t) (\lambda  - \mu) }{ \exp^{(\lambda - \mu)t} - 1 }
\end{equation}\]

<p>which is reflected in the code as:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fossilization_prior_mean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">num_fossils</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">diversification_prior_mean</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nf">exp</span><span class="p">(</span><span class="n">diversification_prior_mean</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">origin_time</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
</blockquote>

<p>Now that we have defined our <code class="language-plaintext highlighter-rouge">origin_time</code> and the diversification and fossilization models, we can draw the tree from a fossilized birth-death distribution:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make the FBD tree</span><span class="w">
</span><span class="n">timetree</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnFBDP</span><span class="p">(</span><span class="n">originAge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin_time</span><span class="p">,</span><span class="w">
                  </span><span class="n">lambda</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">lambda</span><span class="p">,</span><span class="w">
                  </span><span class="n">mu</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">mu</span><span class="p">,</span><span class="w">
                  </span><span class="n">psi</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">psi</span><span class="p">,</span><span class="w">
                  </span><span class="n">timeline</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">breakpoints</span><span class="p">,</span><span class="w">
                  </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"survival"</span><span class="p">,</span><span class="w">
                  </span><span class="n">rho</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">Probability</span><span class="p">(</span><span class="n">extant_taxa</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">total_taxa</span><span class="p">),</span><span class="w">
                  </span><span class="n">taxa</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">taxa</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>where <code class="language-plaintext highlighter-rouge">breakpoints</code> defines where the rate parameters change, if applicable, and we condition on the process surviving (leaving at least one extant descendant).</p>

<p>We have to place MCMC proposals on the tree topology and branch lengths:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># MCMC proposals on the tree</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvFNPR</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w">                       </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ntax</span><span class="w">                             </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvNarrow</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w">                     </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ntax</span><span class="w">                         </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvNodeTimeSlideBeta</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w">          </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ntax</span><span class="w">                         </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvRootTimeSlideUniform</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w">       </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ntax</span><span class="p">,</span><span class="w">        </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin_time</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvCollapseExpandFossilBranch</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_fossils</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin_time</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Next, we place proposals on the fossils: whether or not they are sampled ancestors, and also on their exact age (to accommodate stratigraphic uncertainty):</p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># MCMC proposals on whether fossils are sampled ancestors</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvCollapseExpandFossilBranch</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_fossils</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin_time</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">num_sampled_ancestors</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">timetree.numSampledAncestors</span><span class="p">()</span><span class="w">

</span><span class="c1"># MCMC proposals on the fossil ages</span><span class="w">
</span><span class="n">fossils</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timetree.getFossils</span><span class="p">()</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">fossils.size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># get the fossil age</span><span class="w">
  </span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmrca</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w"> </span><span class="n">clade</span><span class="p">(</span><span class="n">fossils</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w">

  </span><span class="c1"># specify the age contraint</span><span class="w">
  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fossils</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="n">.getMinAge</span><span class="p">()</span><span class="w">
  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fossils</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="n">.getMaxAge</span><span class="p">()</span><span class="w">

  </span><span class="nb">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnUniform</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">
  </span><span class="nb">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="n">.clamp</span><span class="p">(</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">)</span><span class="w">

  </span><span class="c1"># specify a proposal on the fossil age</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvFossilTimeSlideUniform</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w"> </span><span class="n">origin_time</span><span class="p">,</span><span class="w"> </span><span class="n">fossils</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Finally, we keep track of a tree for the extant species and the tree lengths.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># keep track of the extant tree</span><span class="w">
</span><span class="n">extant_tree</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">fnPruneTree</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w"> </span><span class="n">fossils</span><span class="p">)</span><span class="w">

</span><span class="c1"># keep track of the tree length</span><span class="w">
</span><span class="n">TL</span><span class="w">        </span><span class="o">:=</span><span class="w"> </span><span class="n">timetree.treeLength</span><span class="p">()</span><span class="w">
</span><span class="n">TL_extant</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">extant_tree.treeLength</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<h4 class="subsubsection" id="the-molecular-clock-model">The Molecular Clock Model</h4>
<hr class="subsubsection" />

<p>Now we specify the molecular clock model:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">########################################</span><span class="w">
</span><span class="c1"># specifying the molecular clock model #</span><span class="w">
</span><span class="c1">########################################</span><span class="w">

</span><span class="n">source</span><span class="p">(</span><span class="s2">"modules/mole_clock_models/"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mole_clock_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".Rev"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>In this header file, we assumed a strict molecular clock.</p>

<blockquote class="aside"><h2>Module: The Strict Molecular Clock</h2><p>This simple model (defined in <code class="language-plaintext highlighter-rouge">modules/mole_clock_models/strict.Rev</code>) assumes that the rate of evolution is the same across branches of the tree.
It therefore has a single parameter, which we parameterize on the log scale:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the strict molecular clock model</span><span class="w">
</span><span class="c1"># REQUIRED: mole_branch_rates (either one value, or one value per branch), mole_branch_rate_mean</span><span class="w">

</span><span class="c1"># the strict clock model on the log scale</span><span class="w">
</span><span class="n">mole_clock_rate_log</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnUniform</span><span class="p">(</span><span class="m">-10</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvSlide</span><span class="p">(</span><span class="n">mole_clock_rate_log</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">mole_clock_rate_log.setValue</span><span class="p">(</span><span class="m">-7</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>We then exponentiate to get the clock rate on the real scale:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># exponentiate</span><span class="w">
</span><span class="n">mole_clock_rate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">exp</span><span class="p">(</span><span class="n">mole_clock_rate_log</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Our relaxed clock models will allow one rate per branch, defined by the variable <code class="language-plaintext highlighter-rouge">mole_branch_rates</code> (a vector with one element per branch).
To keep our code generic, we’ll make sure we define <code class="language-plaintext highlighter-rouge">mole_branch_rates</code> for the constant model, but just set it equal to the strict clock rate:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the branch-specific rates</span><span class="w">
</span><span class="n">mole_branch_rates</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mole_clock_rate</span><span class="w">
</span></code></pre></div></div>
<p>Finally, we compute the mean rate of evolution among branches (sometimes we will use this for relaxed clock models, but in this case it is again equal to the clock rate itself).</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the mean of the branch rates</span><span class="w">
</span><span class="n">mole_branch_rate_mean</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mole_branch_rates</span><span class="w">
</span></code></pre></div></div>
</blockquote>

<h4 class="subsubsection" id="the-molecular-substitition-model">The Molecular Substitition Model</h4>
<hr class="subsubsection" />

<p>We source the molecular substitution model as so:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#####################################</span><span class="w">
</span><span class="c1"># specifying the substitution model #</span><span class="w">
</span><span class="c1">#####################################</span><span class="w">

</span><span class="n">source</span><span class="p">(</span><span class="s2">"modules/substn_models/"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">substn_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".Rev"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>In this analyses, we’re using the HYK substitution model, partitioned among alignments (which correspond to codon positions in the example rbcL dataset).</p>

<blockquote class="aside"><h2>Module: The HKY Substitution Model</h2><p>This model is defined in <code class="language-plaintext highlighter-rouge">modules/substn_models/HYK.Rev</code>.
It has a single parameter, $\kappa$, which defines the transition to transversion ratio, and a vector of stationary frequencies, $\pi$.
We allow each molecular partition to have different $\kappa$ and $\pi$ parameters.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the partitioned HKY substitution model</span><span class="w">
</span><span class="c1"># REQUIRED: mole_Q (one per partition), mole_site_rates (one per partition), and mole_relative_rates (one per partition)</span><span class="w">

</span><span class="c1"># define the Q matrix and site rates per partition</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">naln</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># the transition/transversion ratio</span><span class="w">
  </span><span class="n">mole_kappa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnLognormal</span><span class="p">(</span><span class="n">ln</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">)</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvScale</span><span class="p">(</span><span class="n">mole_kappa</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

  </span><span class="c1"># the stationary frequency</span><span class="w">
  </span><span class="n">mole_pi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnDirichlet</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">))</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvBetaSimplex</span><span class="p">(</span><span class="n">mole_pi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

  </span><span class="c1"># the Q matrices</span><span class="w">
  </span><span class="n">mole_Q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">fnHKY</span><span class="p">(</span><span class="n">mole_kappa</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">mole_pi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">

  </span><span class="c1"># the site rates</span><span class="w">
  </span><span class="c1"># NOTE: this model doesn't have ASRV</span><span class="w">
  </span><span class="n">mole_site_rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="m">1.0</span><span class="p">]</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>Because this model doesn’t allow rate variation among sites within a partition, we set <code class="language-plaintext highlighter-rouge">mole_site_rates[i] &lt;- [1.0]</code>.</p>

<p>We also want each partition to have a different overall rate.
We specify a proportional rate per partition from a Dirichlet distribution (which has a sum of one), then multiply by the number of partitions (so that the mean rate is 1):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># relative-rate multipliers</span><span class="w">
</span><span class="n">mole_proportional_rates</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnDirichlet</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">naln</span><span class="p">))</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvBetaSimplex</span><span class="p">(</span><span class="n">mole_proportional_rates</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">naln</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="c1"># rescale the rates so the mean is 1</span><span class="w">
</span><span class="n">mole_relative_rates</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="n">mole_proportional_rates</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">naln</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>(Once again, <code class="language-plaintext highlighter-rouge">abs</code> simply reassures RevBayes that these rates are positive numbers.)</p>
</blockquote>

<p>We then specify the phylogenetic CTMC models for each alignment, which depend on the tree, substitution model and molecular clock model:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make the CTMC for molecular data</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">naln</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnPhyloCTMC</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w"> </span><span class="n">mole_Q</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">branchRates</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mole_branch_rates</span><span class="p">,</span><span class="w"> </span><span class="n">siteRates</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mole_site_rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mole_relative_rates</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">
  </span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="n">.clamp</span><span class="p">(</span><span class="w"> </span><span class="n">moledata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 class="subsubsection" id="the-morphological-clock-model">The Morphological Clock Model</h4>
<hr class="subsubsection" />

<p>Our model must also specify how rates of morphological evolution vary among lineages (if at all).
We specify this model by sourcing the appropriate module file:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">############################################</span><span class="w">
</span><span class="c1"># specifying the morphological clock model #</span><span class="w">
</span><span class="c1">############################################</span><span class="w">

</span><span class="n">source</span><span class="p">(</span><span class="s2">"modules/morph_clock_models/"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">morph_clock_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".Rev"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>We’re using a “linked” morphological clock model, which assumes rates of morphological evolution are proportional to rates of molecular evolution (per branch).
In this case, because we’re using a strict <em>molecular</em> clock, this implies that rates of molecular evolution also follow a strict clock (though the absolute rate will be different between molecular and morphological characters).</p>

<blockquote class="aside"><h2>Module: The Linked Morphological Clock</h2><p>Here, we use the linked morphological clock, specified in the <code class="language-plaintext highlighter-rouge">modules/morph_clock_models/linked.Rev</code> module file.
This model has a single parameter: the absolute rate of morphological evolution, which we parameterize on the log scale and then exponentiate onto the real scale:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the linked morphological clock model</span><span class="w">
</span><span class="c1"># REQUIRED: morph_branch_rates (either one value, or one value per branch)</span><span class="w">

</span><span class="c1"># draw the log of the rate from a uniform distribution</span><span class="w">
</span><span class="n">morph_clock_rate_log</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnUniform</span><span class="p">(</span><span class="m">-10</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvSlide</span><span class="p">(</span><span class="n">morph_clock_rate_log</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">morph_clock_rate_log.setValue</span><span class="p">(</span><span class="m">-7</span><span class="p">)</span><span class="w">

</span><span class="c1"># exponentiate</span><span class="w">
</span><span class="n">morph_clock_rate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">exp</span><span class="p">(</span><span class="n">morph_clock_rate_log</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now we compute the branch-specific rates of morphological evolution.
Because we’re assuming these are proportional to the branch-specific rates of molecular evolution, we simply rescale the molecular branch rates like so:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the branch-specific rates</span><span class="w">
</span><span class="c1"># in this model, these are a multiple of the molecular branch rates</span><span class="w">
</span><span class="c1"># so, the morphological branch rate = morphological clock rate * molecular branch rate / morphological clock rate</span><span class="w">
</span><span class="n">morph_branch_rates</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">morph_clock_rate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mole_branch_rates</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">mole_branch_rate_mean</span><span class="w">
</span></code></pre></div></div>

<p>Because all molecular clock models will define a <code class="language-plaintext highlighter-rouge">mole_branch_rate_mean</code>, this module will work in combination with all molecular clock models.
In this example, we are effectively just rescaling the (global) molecular clock rate to get the (global) morphological clock rate.</p>
</blockquote>

<h4 class="subsubsection" id="the-morphological-transition-model">The Morphological Transition Model</h4>
<hr class="subsubsection" />

<p>This model component describes how morphological characters change among states.
(We’ll assume for simplicity that the characters are binary.
These modules would have to be modified to accommodate multistate characters.
See the <a href="/tutorials/morph_tree/V2.html">multistate tutorial</a> for ideas of how to achieve this.)</p>

<p>We source the morphological transition model:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#################################################</span><span class="w">
</span><span class="c1"># specifying the morphological transition model #</span><span class="w">
</span><span class="c1">#################################################</span><span class="w">

</span><span class="n">source</span><span class="p">(</span><span class="s2">"modules/morph_models/"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">morph_model</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".Rev"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>In this analysis, we’re using an Mk model <a class="citation" href="#Lewis2001">(Lewis 2001)</a>.</p>
<blockquote class="aside"><h2>Module: The Mk Model</h2><p>In this analysis we’re assuming that rates of transition between character states are the same, i.e., that the $Q$ matrix is symmetrical.
Because the rate matrix is normalized to have an average rate of 1, this model has no free parameters:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the Mk model of morphological evolution</span><span class="w">
</span><span class="c1"># REQUIRED: morph_Q (either one, or one per mixture category), morph_site_rates, site_matrices (TRUE or FALSE)</span><span class="w">

</span><span class="c1"># the Mk model</span><span class="w">
</span><span class="n">morph_Q</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">fnJC</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="w">

</span><span class="c1"># relative rates among sites</span><span class="w">
</span><span class="n">morph_site_rates</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="m">1.0</span><span class="p">]</span><span class="w">

</span><span class="c1"># make sure we don't use site matrices</span><span class="w">
</span><span class="n">site_matrices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="w">
</span></code></pre></div></div>
<p>The rates of change among characters are the same, so we use <code class="language-plaintext highlighter-rouge">morph_site_rates &lt;- [1.0]</code>, and the rate matrix $Q$ is the same for all characters, so we set <code class="language-plaintext highlighter-rouge">site_matrices = FALSE</code>.</p>
</blockquote>

<p>Just as with molecular substitution models, we hand the tree, transition model, and morphological-clock model to a phylogenetic CTMC, and clamp our observed data:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make the CMTC for morphological data</span><span class="w">
</span><span class="n">morph</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnPhyloCTMC</span><span class="p">(</span><span class="n">timetree</span><span class="p">,</span><span class="w"> </span><span class="n">morph_Q</span><span class="p">,</span><span class="w"> </span><span class="n">branchRates</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">morph_branch_rates</span><span class="p">,</span><span class="w"> </span><span class="n">siteRates</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">morph_site_rates</span><span class="p">,</span><span class="w"> </span><span class="n">coding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"variable"</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Standard"</span><span class="p">,</span><span class="w"> </span><span class="n">siteMatrices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">site_matrices</span><span class="p">)</span><span class="w">
</span><span class="n">morph.clamp</span><span class="p">(</span><span class="w"> </span><span class="n">morphdata</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>You may notice some difference between this CTMC and the ones we used for the molecular data.
First, we’re using <code class="language-plaintext highlighter-rouge">coding = "variable"</code> because we’re assuming we only included characters that are variable within our focal group.
This corresponds to the $v$ correction proposed by <a class="citation" href="#Lewis2001">Lewis (2001)</a>.
Second, we also supply a <code class="language-plaintext highlighter-rouge">siteMatrices</code> argument.
This argument (when <code class="language-plaintext highlighter-rouge">TRUE</code>) indicates that the Q matrix may vary among characters, which happens when we use mixtures of rate matrices among characters (e.g. as described by the <a href="/tutorials/morph_tree/">discrete morphology tutorial</a>).</p>

<h4 class="subsubsection" id="the-analysis">The Analysis</h4>
<hr class="subsubsection" />

<p>Now that we’ve specified the entire model, we source the specified analysis file:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">####################</span><span class="w">
</span><span class="c1"># running analysis #</span><span class="w">
</span><span class="c1">####################</span><span class="w">

</span><span class="n">source</span><span class="p">(</span><span class="s2">"modules/analysis/"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">analysis</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".Rev"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>This code is responsible for running whathever analyses we provide, whether it is MCMC, stepping-stone analysis, posterior-predictive simulation, etc.</p>

<p>We’ll begin by running a simple MCMC, which we will talk about in the next section.</p>

<!--  -->

<h2 class="section" id="MCMC">Inferring the Posterior Distribution for One Model</h2>
<hr class="section" />

<p>Now that we’ve specified a header file and a template file, we’ll want to run an MCMC to estimate the posterior distribution for our total-evidence analysis.
We do this by calling the <code class="language-plaintext highlighter-rouge">analysis/MCMC.Rev</code> module.
Let’s look at this script line-by-line.</p>

<p>The first thing we’ll want to do is decide how many runs to do (<code class="language-plaintext highlighter-rouge">nruns</code>), how many generations to run for (<code class="language-plaintext highlighter-rouge">ngen</code>), and how often to write sampled to file (<code class="language-plaintext highlighter-rouge">printgen</code>).
We’ll do a burnin analysis, so we’ll also need to decide how many burnin generations to run for (<code class="language-plaintext highlighter-rouge">nburnin</code>):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># analysis settings</span><span class="w">
</span><span class="n">nruns</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="w">
</span><span class="n">nburnin</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="m">2000</span><span class="w">
</span><span class="n">ngen</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="m">20000</span><span class="w">
</span></code></pre></div></div>

<p>We’ll also want to keep track of our MCMC analysis using monitors.
We’ll use a screen monitor to log the progress to our screen, as well as a model monitor to keep track of model parameters, and file monitors to keep track of the full tree and the extant tree.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the monitors</span><span class="w">
</span><span class="n">monitors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VectorMonitors</span><span class="p">()</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnScreen</span><span class="p">(</span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnModel</span><span class="p">(</span><span class="n">filename</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"params.log"</span><span class="p">,</span><span class="w"> </span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">,</span><span class="w"> </span><span class="n">exclude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">"F"</span><span class="p">])</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnFile</span><span class="p">(</span><span class="n">filename</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">,</span><span class="w"> </span><span class="n">timetree</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnFile</span><span class="p">(</span><span class="n">filename</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"extant_tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">,</span><span class="w"> </span><span class="n">extant_tree</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Note that these monitors make use of the <code class="language-plaintext highlighter-rouge">output_filename</code> that was constructed in our header file.
This ensures that, if we use a different model, we don’t risk accidentally overwriting or losing track of our output files.</p>

<p>Next, we create a model object by providing at least one of our parameters.
The timetree is a natural choice because it will always be in the model (regardless of what model components we are using).</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the model</span><span class="w">
</span><span class="n">mymodel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">timetree</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now, we create our MCMC analysis, which depends on our model, monitors and moves, as well as some information about how many runs to do, and how to combine the output files when we do multiple runs:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make the analysis</span><span class="w">
</span><span class="n">mymcmc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mcmc</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span><span class="w"> </span><span class="n">monitors</span><span class="p">,</span><span class="w"> </span><span class="n">moves</span><span class="p">,</span><span class="w"> </span><span class="n">nruns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nruns</span><span class="p">,</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"mixed"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>If we specified a burnin (that is, more than zero burnin generations, <code class="language-plaintext highlighter-rouge">nburnin &gt; 0</code>), we now run that part of the analysis.
This analysis will adjust MCMC proposals every <code class="language-plaintext highlighter-rouge">tuningInterval</code> iterations to improve the acceptance rates (to a target value of 23-44%).
We also print out the MCMC proposal information with <code class="language-plaintext highlighter-rouge">operatorSummary</code>, which tells us how often each proposal was accepted during the burnin phase.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># run the burnin</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nburnin</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">mymcmc.burnin</span><span class="p">(</span><span class="n">generations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nburnin</span><span class="p">,</span><span class="w"> </span><span class="n">tuningInterval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">)</span><span class="w">
  </span><span class="n">mymcmc.operatorSummary</span><span class="p">()</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>Note that we normally throw out the first chunk of our MCMC sampled (before the chain has converged) as “burnin”.
This <code class="language-plaintext highlighter-rouge">burnin</code> analysis is a bit different: it is a special “warm-up” MCMC where the tuning parameters are adjusted to achieve good acceptance rates.
While the chain may converge in this period, there are no guarantees!
It is good practice to still check the samples generated by the <code class="language-plaintext highlighter-rouge">run</code> step (next) to decide how many need to discard as burnin.</p>

<p>Now we are ready to run our MCMC analysis for <code class="language-plaintext highlighter-rouge">ngen</code> generations.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># run the analysis</span><span class="w">
</span><span class="n">mymcmc.run</span><span class="p">(</span><span class="n">generations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ngen</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>After the analysis completes, you’ll want to create summary trees.
If you did more than one run (<code class="language-plaintext highlighter-rouge">nruns &gt; 1</code>), you’ll create one summary tree for each run as well as the combined runs.
We’ll make maximum-clade-credibilty (MCC) trees, but you could also modify or extend this code to produce maximum <em>a posteriori</em> (MAP) trees.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make the summary trees</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">nruns</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># just make summary trees for the one run</span><span class="w">
  </span><span class="n">full_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
  </span><span class="n">mccTree</span><span class="p">(</span><span class="n">full_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_tree.tre"</span><span class="p">)</span><span class="w">

  </span><span class="n">extant_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"extant_tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
  </span><span class="n">mccTree</span><span class="p">(</span><span class="n">extant_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_extant_tree.tre"</span><span class="p">)</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># make a combined summary tree</span><span class="w">
  </span><span class="n">full_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
  </span><span class="n">mccTree</span><span class="p">(</span><span class="n">full_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_tree.tre"</span><span class="p">)</span><span class="w">

  </span><span class="n">extant_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"extant_tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
  </span><span class="n">mccTree</span><span class="p">(</span><span class="n">extant_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_extant_tree.tre"</span><span class="p">)</span><span class="w">

  </span><span class="c1"># and run-specific summary trees</span><span class="w">
  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">nruns</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">full_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"tree_run_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
    </span><span class="n">mccTree</span><span class="p">(</span><span class="n">full_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_tree_run_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".tre"</span><span class="p">)</span><span class="w">

    </span><span class="n">extant_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"extant_tree_run_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
    </span><span class="n">mccTree</span><span class="p">(</span><span class="n">extant_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_extant_tree_run_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".tre"</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>⚠ <em><strong>For the purposes of this tutorial, we’ll assume these MCMC worked!
However, for your own analyses, you’ll definitely want to make sure that your analyses converge and sample adequately from the posterior distribution.
See the <a href="/tutorials/convergence/">MCMC Diagnosis tutorial</a> for more details.</strong></em></p>

<h3 class="subsection" id="plotting-the-inferred-tree">Plotting the inferred tree</h3>
<hr class="subsection" />

<p>Congratulations! You’ve inferred a total-evidence-dated phylogeny!
You can plot this tree in <code class="language-plaintext highlighter-rouge">FigTree</code>, or use <code class="language-plaintext highlighter-rouge">RevGadgets</code> <a class="citation" href="#Tribble2022">(Tribble et al. 2022)</a> to create a publication-quality figure.</p>

<p>We’ve provided some <code class="language-plaintext highlighter-rouge">RevGadgets</code> code for plotting this tree.
Boot up Rstudio (or your preferred R console), and check out the script <code class="language-plaintext highlighter-rouge">posterior_summary/plot_trees.R</code>.
The first thing we do is load <code class="language-plaintext highlighter-rouge">RevGadgets</code>.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">RevGadgets</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Now we make a variable that stores where the summary tree is located.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># specify a tree file</span><span class="w">
</span><span class="n">treefile</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_strict_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/MCC_tree.tre"</span><span class="w">
</span></code></pre></div></div>
<p>Then we read the tree.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the tree</span><span class="w">
</span><span class="n">tree</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="n">treefile</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Finally, we plot the tree using <code class="language-plaintext highlighter-rouge">plotFBDTree</code>.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># plot the tree</span><span class="w">
</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">plotFBDTree</span><span class="p">(</span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">timeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">tip_labels_italics</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w">
            </span><span class="n">tip_labels_remove_underscore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w">
            </span><span class="n">geo_units</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"periods"</span><span class="p">,</span><span class="w">
            </span><span class="n">node_age_bars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">age_bars_colored_by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"posterior"</span><span class="p">,</span><span class="w">
            </span><span class="n">label_sampled_ancs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w">
            </span><span class="n">age_bars_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rev</span><span class="p">(</span><span class="n">colFun</span><span class="p">(</span><span class="m">2</span><span class="p">)))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">ggplot2</span><span class="o">::</span><span class="n">theme</span><span class="p">(</span><span class="n">legend.position</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">0.75</span><span class="p">,</span><span class="w"> </span><span class="m">0.4</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>Adjust this plot as you please, then export it as a pdf (or other type of image) like so:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pdf</span><span class="p">(</span><span class="s2">"figures/tree.pdf"</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">8</span><span class="p">)</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w">
</span><span class="n">dev.off</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>which produces <a href="#tree"></a>.</p>

<figure id="tree"><p><img src="files/figures/tree.png" width="80%" height="80%" /></p>
<figcaption><strong>The MCC tree inferred for Marattiales under a constant-rate FBD model, a strict molecular/morphological clock model, an HKY substitution model, and an Mk morphological model.</strong>
The bars represent 95% posterior credible intervals for node ages.
The color of each bar indicates the posterior probability of the clade (for internal nodes), of being a tip (for fossil tips), or for being a sampled ancestor (for sampled ancestor nodes).</figcaption>
</figure>

<h3 class="subsection" id="exercise-comparing-phylogenies-estimated-under-different-total-evidence-models">Exercise: Comparing phylogenies estimated under different total-evidence models</h3>
<hr class="subsection" />

<p>Now that we’ve run one header file start-to-finish, it’s time to start using other models.
This is where the header/template/module structure really pays off.
To specify a new model, we simply create a header file and a module file for the new model.</p>

<p>Let’s modify our first header file, <code class="language-plaintext highlighter-rouge">headers/MCMC/strict_Mk.Rev</code> to use an uncorrelated lognormal relaxed molecular clock.
Duplicate this file and rename it <code class="language-plaintext highlighter-rouge">UCLN_Mk.Rev</code>.
Then, change the value of <code class="language-plaintext highlighter-rouge">mole_clock_model</code> like so:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mole_clock_model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"UCLN"</span><span class="w">
</span></code></pre></div></div>

<blockquote class="aside"><h2>Module: The Uncorrelated Lognormal Molecular Clock Model</h2><p>The uncorrelated lognormal (UCLN) relaxed molecular clock allows the rates of molecular evolution to vary among branches.
Each branch draws its rate from an underlying lognormal distribution with some mean and variance.
Since we don’t know what the mean and variance are, we treat them as free parameters, place a prior on them, and estimate them from the data.
In the parlance of hierarchical modeling, we would the mean and standard deviation “hyperparameters” of the branch-rate prior.</p>

<p>We’ll use the same prior on the mean as we used on the strict clock rate:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the UCLN morphological clock model</span><span class="w">
</span><span class="c1"># REQUIRED: morph_branch_rates (either one value, or one value per branch)</span><span class="w">

</span><span class="c1"># draw the log of the mean from a uniform distribution</span><span class="w">
</span><span class="n">mole_clock_rate_mean_log</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnUniform</span><span class="p">(</span><span class="m">-10</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvSlide</span><span class="p">(</span><span class="n">mole_clock_rate_mean_log</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">mole_clock_rate_mean_log.setValue</span><span class="p">(</span><span class="m">-7</span><span class="p">)</span><span class="w">

</span><span class="c1"># exponentiate to get the true mean</span><span class="w">
</span><span class="n">mole_clock_rate_mean</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">exp</span><span class="p">(</span><span class="n">mole_clock_rate_mean_log</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>We also need to estimate the standard deviation of this lognormal clock model.
We use an exponential distribution with a mean value of <code class="language-plaintext highlighter-rouge">H</code>, which means we expect molecular rates to vary over branches by about an order of magnitude.
Using an exponential prior here lets the standard deviation more easily shrink to zero, which corresponds to a strict molecular clock.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># draw the standard deviation from an exponential</span><span class="w">
</span><span class="n">mole_clock_rate_sd</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnExponential</span><span class="p">(</span><span class="nf">abs</span><span class="p">(</span><span class="m">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">H</span><span class="p">))</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvScale</span><span class="p">(</span><span class="n">mole_clock_rate_sd</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now that we have the mean and standard deviation, we’ll draw each branch rate from the corresponding lognormal prior.
We draw these on the log scale, then exponentiate (just as we did with the mean):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the branch-specific rates</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">nbranch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># draw the log of the rate</span><span class="w">
  </span><span class="n">mole_branch_rates_log</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnNormal</span><span class="p">(</span><span class="n">mole_clock_rate_mean_log</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mole_clock_rate_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mole_clock_rate_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">mole_clock_rate_sd</span><span class="p">)</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvSlide</span><span class="p">(</span><span class="n">mole_branch_rates_log</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">)</span><span class="w">
  </span><span class="n">mole_branch_rates_log</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="n">.setValue</span><span class="p">(</span><span class="n">mole_clock_rate_mean_log</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mole_clock_rate_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mole_clock_rate_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.5</span><span class="p">)</span><span class="w">

  </span><span class="c1"># exponentiate to get the rate</span><span class="w">
  </span><span class="n">mole_branch_rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">exp</span><span class="p">(</span><span class="n">mole_branch_rates_log</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>We keep track of the mean rate among branches for use with the linked morphological clock model:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the mean of the branch rate</span><span class="w">
</span><span class="n">mole_branch_rate_mean</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mean</span><span class="p">(</span><span class="n">mole_branch_rates</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Because we parameterized the log of the branch rates, we can use very nice proposals on the branch rates that simultaneously update the mean and variance of the lognormal distribution:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># add a joint move on the branch rates and hyperparameters</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvVectorSlideRecenter</span><span class="p">(</span><span class="n">mole_branch_rates_log</span><span class="p">,</span><span class="w"> </span><span class="n">mole_clock_rate_mean_log</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvShrinkExpand</span><span class="p">(</span><span class="n">mole_branch_rates_log</span><span class="p">,</span><span class="w"> </span><span class="n">mole_clock_rate_sd</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
</blockquote>

<p>Note that the output filename will automatically be updated to reflect the change in model!
Also, since we’re still using the linked morphological clock, this model allows morphological branch rates to vary among branches (in proportion to the molecular branch rates).</p>

<p>Now, prepare header files by duplicating and modifying the <code class="language-plaintext highlighter-rouge">strict_Mk.Rev</code> header file, and run the following analyses:</p>
<ol>
  <li>A strict clock/Mk model (the first analyses we ran).</li>
  <li>The same as 1, but with an uncorrelated relaxed molecular clock (the modified header file we just made).</li>
  <li>An uncorrelated exponential relaxed molecular clock.</li>
  <li>An uncorrelated lognormal relaxed molecular clock, with an F81 mixture model among morphological characters.</li>
  <li>A model with rates of diversification and fossilization that vary among epochs (but is otherwise the same as <code class="language-plaintext highlighter-rouge">strict_Mk.Rev</code>).</li>
</ol>

<p>⚠ These header files are already provided for you as <code class="language-plaintext highlighter-rouge">headers/MCMC</code>, but it’s good practice to create your own header files to get a sense of how everything fits together.</p>

<p>To perform these analyses, you’ll need to use the following module files:</p>

<blockquote class="aside"><h2>Module: The Uncorrelated Exponential Relaxed Molecular Clock</h2><p>This relaxed clock model has a single parameter: the mean rate of evolution among branches.
The branch-rates then follow an exponential distribution with the specified mean.
The logic is otherwise similar to the UCLN model.
This model is defined in <code class="language-plaintext highlighter-rouge">modules/mole_clock_models/UCE.Rev</code></p>

<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the UCE clock model</span><span class="w">
</span><span class="c1"># REQUIRED: mole_branch_rates (either one value, or one value per branch), mole_branch_rate_mean</span><span class="w">

</span><span class="c1"># draw the log of the mean from a uniform distribution</span><span class="w">
</span><span class="n">mole_clock_rate_mean_log</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnUniform</span><span class="p">(</span><span class="m">-10</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvSlide</span><span class="p">(</span><span class="n">mole_clock_rate_mean_log</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">mole_clock_rate_mean_log.setValue</span><span class="p">(</span><span class="m">-7</span><span class="p">)</span><span class="w">

</span><span class="c1"># exponentiate to get the true mean</span><span class="w">
</span><span class="n">mole_clock_rate_mean</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">exp</span><span class="p">(</span><span class="n">mole_clock_rate_mean_log</span><span class="p">)</span><span class="w">

</span><span class="c1"># the branch-specific rates</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">nbranch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># draw the rate</span><span class="w">
  </span><span class="n">mole_branch_rates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnExponential</span><span class="p">(</span><span class="m">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">mole_clock_rate_mean</span><span class="p">)</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvScale</span><span class="p">(</span><span class="n">mole_branch_rates</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="p">}</span><span class="w">

</span><span class="c1"># the mean of the branch rate</span><span class="w">
</span><span class="n">mole_branch_rate_mean</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mean</span><span class="p">(</span><span class="n">mole_branch_rates</span><span class="p">)</span><span class="w">

</span><span class="c1"># add a joint move on the branch rates and hyperparameters</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvVectorScale</span><span class="p">(</span><span class="n">mole_branch_rates</span><span class="p">,</span><span class="w"> </span><span class="n">mole_clock_rate_mean</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
</blockquote>

<blockquote class="aside"><h2>Module: The F81 Mixture Model</h2><p>The <em>Mk</em> model assumes that relative transition rates are the same among all character states.
For binary characters, <em>F81</em> assumes that each character state has a stationary frequency, $\pi$, that is estimated from the data.
This stationary frequency reflects the tendency for the character to evolve toward one state or the other.
While this model may be appropriate for a single character, it is difficult to justify for many characters because the state labels are arbitrary (0 and 1 don’t have the same meaning for all characters), and the process of evolution is certainly very different among characters.</p>

<p>We therefore use a relaxed version of the F81 model, called an F81 mixture model, that allows the stationary frequency to vary among characters.
We draw a set of stationary frequencies from a discretized Beta distribution, and average the likelihood of each character over all possible stationary frequencies.
We define a shape parameter, $\alpha$, that describes how much variation there is among characters.
When $\alpha &lt; 1$, that means that, on average, character evolution is ery biased; conversely, when $\alpha &gt; 1$, character evolution tends to be balanced (0 -&gt; 1 rates and 1 -&gt; 0 rates are more similar.)
Please see the <a href="/tutorials/morph_tree/">morphological phylogenetics tutorial</a> for more details of this model.</p>

<p>Here’s how we specify this model in RevBayes:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the F81 mixture model of morphological evolution</span><span class="w">
</span><span class="c1"># REQUIRED: morph_Q (either one, or one per mixture category), morph_site_rates, site_matrices (TRUE or FALSE)</span><span class="w">

</span><span class="c1"># process variation among characters</span><span class="w">
</span><span class="n">num_pi_cats_morph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="w">

</span><span class="n">morph_pi_alpha</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnExponential</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvScale</span><span class="p">(</span><span class="n">morph_pi_alpha</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="n">morph_pis</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">fnDiscretizeBeta</span><span class="p">(</span><span class="n">morph_pi_alpha</span><span class="p">,</span><span class="w"> </span><span class="n">morph_pi_alpha</span><span class="p">,</span><span class="w"> </span><span class="n">num_pi_cats_morph</span><span class="p">)</span><span class="w">

</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">num_pi_cats_morph</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">morph_pi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">simplex</span><span class="p">([</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="n">morph_pis</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="m">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">morph_pis</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span><span class="w">
  </span><span class="n">morph_Q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">fnF81</span><span class="p">(</span><span class="n">morph_pi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># relative rates among characters</span><span class="w">
</span><span class="n">morph_site_rates</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="m">1.0</span><span class="p">]</span><span class="w">

</span><span class="c1"># make sure we don't use site matrices</span><span class="w">
</span><span class="n">site_matrices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="w">
</span></code></pre></div></div>
<p>Note that this model (as defined above) assumes that the <em>overall rate of evolution</em> is the same among characters (<code class="language-plaintext highlighter-rouge">morph_site_rates &lt;- [1.0]</code>).
We could relax this assumption, for example, by allowing rates to vary among characters according to a Gamma distribution (analogous to the ${+}\Gamma$ model of molecular evolution.
Check out the <code class="language-plaintext highlighter-rouge">modules/morph_models/MkG.Rev</code> model for an example of how to specify the discrete Gamma model.
Note that the discrete Gamma and F81 mixture model can be combined!
But to do that, you’d have to write a new module file, like <code class="language-plaintext highlighter-rouge">F81MixG.Rev</code>!
We’ll leave that one to you :)</p>
</blockquote>

<blockquote class="aside"><h2>Module: The Epochal FBD Model</h2><p>The fossilized birth-death model can easily accommodate diversification (speciation and extinction) and/or fossilization-rate variation over time.
In our analyses, we’ll assume (for convenience) that these rates are different among different geological epochs, though you could use any time intervals you like by modifying the <code class="language-plaintext highlighter-rouge">data/epoch_timescale.csv</code> file.</p>

<p>In this example, we’ll let both diversification and fossilization rates to vary.
Let’s look at the epoch-variable diversification model in <code class="language-plaintext highlighter-rouge">modules/diversification_models/epochal.Rev</code>.
Rather than letting each epoch have an independent rate, we’ll simplify things by assuming there are three rate categories, and try to infer which rate category each epoch belongs to.
We begin by specifying the prior on the diversification rates per epoch.
As with the constant-rate model, we use an empirical approach to specify the mean.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the epochal diversification model</span><span class="w">
</span><span class="c1"># REQUIRED: lambda, mu (both one per time interval)</span><span class="w">

</span><span class="c1"># empirical prior on the diversification rate</span><span class="w">
</span><span class="n">diversification_prior_mean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ln</span><span class="p">(</span><span class="n">total_taxa</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">origin_time</span><span class="w">
</span><span class="n">diversification_prior_sd</span><span class="w">   </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">H</span><span class="w">

</span><span class="c1"># the diversitication rate</span><span class="w">
</span><span class="n">diversification_prior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dnLognormal</span><span class="p">(</span><span class="w"> </span><span class="n">ln</span><span class="p">(</span><span class="n">diversification_prior_mean</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">diversification_prior_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">diversification_prior_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">diversification_prior_sd</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Note that we create a prior distribution object (<code class="language-plaintext highlighter-rouge">diversification_prior</code>) rather than a parameter here!</p>

<p>We do the same thing for the relative-extinction rate:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># empirical prior on the relative-extinction rate</span><span class="w">
</span><span class="n">relext_prior_mean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1.0</span><span class="w">
</span><span class="n">relext_prior_sd</span><span class="w">   </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">H</span><span class="w">

</span><span class="c1"># the relative extinction rate</span><span class="w">
</span><span class="n">relext_prior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dnLognormal</span><span class="p">(</span><span class="w"> </span><span class="n">ln</span><span class="p">(</span><span class="n">relext_prior_mean</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">relext_prior_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">relext_prior_sd</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">relext_prior_sd</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>We let this distribution have a prior mean of 1, because it’s possible that the extinction rate is higher or lower than the speciation rate for some epochs.</p>

<p>Now we specify how many categories to use.
We’ll keep it simple and use three categories.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># specify the mixture model</span><span class="w">
</span><span class="n">num_div_cats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></code></pre></div></div>

<p>We now draw the diversification and relative-extinction rates for each category.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># draw the rates for each category</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">num_div_cats</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">diversification_rate_cat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">diversification_prior</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvScale</span><span class="p">(</span><span class="n">diversification_rate_cat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># draw the rates for each category</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">num_div_cats</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">relext_rate_cat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">relext_prior</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvScale</span><span class="p">(</span><span class="n">relext_rate_cat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Some categories may include more epochs than others.
We therefore want to let the different categories have different “weights”, or prior probabilities that any given epoch is drawn from that category.
Again we do this separately for diversification and relative-extinction rates.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># draw the mixture weights for each category</span><span class="w">
</span><span class="n">div_mixture_weights</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnDirichlet</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">num_div_cats</span><span class="p">))</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvBetaSimplex</span><span class="p">(</span><span class="n">div_mixture_weights</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvElementSwapSimplex</span><span class="p">(</span><span class="n">div_mixture_weights</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="c1"># draw the mixture weights for each category</span><span class="w">
</span><span class="n">relext_mixture_weights</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnDirichlet</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">num_div_cats</span><span class="p">))</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvBetaSimplex</span><span class="p">(</span><span class="n">relext_mixture_weights</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvElementSwapSimplex</span><span class="p">(</span><span class="n">relext_mixture_weights</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now that we’ve defined the rate categories, we draw each epoch rate from the rate categories (using a mixture distribution, i.e., a model that says the rate for an epoch takes one of a set of values with some probability):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># draw the rates for each epoch</span><span class="w">
</span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="p">(</span><span class="n">breakpoints.size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">

	</span><span class="c1"># diversification rate</span><span class="w">
  </span><span class="n">diversification</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnMixture</span><span class="p">(</span><span class="n">diversification_rate_cat</span><span class="p">,</span><span class="w"> </span><span class="n">div_mixture_weights</span><span class="p">)</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvMixtureAllocation</span><span class="p">(</span><span class="n">diversification</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

  </span><span class="c1"># relative-extinction rate</span><span class="w">
  </span><span class="n">relext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">dnMixture</span><span class="p">(</span><span class="n">relext_rate_cat</span><span class="p">,</span><span class="w"> </span><span class="n">relext_mixture_weights</span><span class="p">)</span><span class="w">
  </span><span class="n">moves.append</span><span class="p">(</span><span class="w"> </span><span class="n">mvMixtureAllocation</span><span class="p">(</span><span class="n">relext</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Finally, we transform the diversification and relative-extinction rates into speciation and extinction rates.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># transform to real parameters</span><span class="w">
</span><span class="n">lambda</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="n">diversification</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="m">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">relext</span><span class="p">))</span><span class="w">
</span><span class="n">mu</span><span class="w">     </span><span class="o">:=</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="n">lambda</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">relext</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>To allow fossilization rates to vary, we basically repeat this process but for the <code class="language-plaintext highlighter-rouge">psi</code> parameter.
See the <code class="language-plaintext highlighter-rouge">modules/fossilization_models/epochal.Rev</code> model for the code.</p>
</blockquote>

<p>After running the analyses, plot the summary tree for each analysis.
Do divergence-time estimates vary among models?
How about posterior probabilities for tree topologies or tip/sampled-ancestor relationships?</p>

<p>It may be difficult or impossible to get a good sense of how these inferences vary by eye-balling the tree.
In the next section, we’ll explore some more useful ways of exploring the impact of model choice on our estimates.</p>

<!--  -->

<h2 class="section" id="sensitivity">Assessing model sensitivity</h2>
<hr class="section" />

<p>In this section, we’ll discuss how to tell whether different models affect phylogenetic estimates.
We’ll use two tools for assessing model sensitivity: lineage-through-time (LTT) plots to visualize the inferred number of lineages over time and multidimensional scaling (MDS) plots to visualize differences in posterior distributions of trees.
The code for plotting LTT curves and MDS plots can all be found in the <code class="language-plaintext highlighter-rouge">R</code> script <code class="language-plaintext highlighter-rouge">posterior_summary/sensitivity.R</code></p>

<p>For these examples, we’ll assume you’ve already estimated the posterior distribution of total-evidence trees for the five models we explored in the last exercise.
(If you have just skipped to this section, you can generate the necessary output by running the following header files: <code class="language-plaintext highlighter-rouge">strict_Mk.Rev</code>, <code class="language-plaintext highlighter-rouge">UCLN_Mk.Rev</code>, <code class="language-plaintext highlighter-rouge">UCE_Mk.Rev</code>, <code class="language-plaintext highlighter-rouge">UCLN_F81Mix.Rev</code>, and <code class="language-plaintext highlighter-rouge">epochal_Mk.Rev</code> in the <code class="language-plaintext highlighter-rouge">headers/MCMC</code> directory.)</p>

<h3 class="subsection" id="lineage-through-time-plots">Lineage-Through-Time Plots</h3>
<hr class="subsection" />

<p>A lineage-through-time curve displays the number of branches in the inferred tree at any given time, so we can use LTTS to summarize overall differences in divergence-time estimates between different models.
We’ll use <code class="language-plaintext highlighter-rouge">R</code> and <code class="language-plaintext highlighter-rouge">RevGadgets</code> to plot the LTT curves for our different models.</p>

<p>First, we load some required packages and code:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">RevGadgets</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">phytools</span><span class="p">)</span><span class="w">
</span><span class="n">source</span><span class="p">(</span><span class="s2">"posterior_summary/utils.R"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now, we read in the trees that were sampled by a set of analyses:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the samples</span><span class="w">
</span><span class="n">strict_samples</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_strict_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span><span class="n">UCLN_samples</span><span class="w">    </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_UCLN_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span><span class="n">UCE_samples</span><span class="w">     </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_UCE_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span><span class="n">epochal_samples</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_epochal_foss_epochal_moleclock_UCLN_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span><span class="n">F81Mix_samples</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_UCLN_moleQ_HKY_morphclock_linked_morphQ_F81Mix_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">treename</code> argument tells <code class="language-plaintext highlighter-rouge">RevGadgets</code> what the tree variable was called in your <code class="language-plaintext highlighter-rouge">RevBayes</code> analyses.
Since we named our tree <code class="language-plaintext highlighter-rouge">timetree</code> in our template file, we use <code class="language-plaintext highlighter-rouge">tree_name = "timetree"</code>.</p>

<p>Next, we combine the trees into a single list:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># combine the samples into one list</span><span class="w">
</span><span class="n">combined_samples</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">strict</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">strict_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="w">
                         </span><span class="n">UCLN</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">UCLN_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="w">
                         </span><span class="n">UCE</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">UCE_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="w">
                         </span><span class="n">epochal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">epochal_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="w">
                         </span><span class="n">F81Mix</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">F81Mix_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>
<p>Note that we’ve named each element of the list.
For example, <code class="language-plaintext highlighter-rouge">strict  = strict_samples[[1]]</code> indicates that the first element of the list will be named <code class="language-plaintext highlighter-rouge">strict</code>.
This lets us color our LTT curves by the model name.</p>

<p>Now, we compute the lineage through time curves for each model:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># plot the LTTs</span><span class="w">
</span><span class="n">LTTs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">processLTT</span><span class="p">(</span><span class="n">combined_samples</span><span class="p">,</span><span class="w"> </span><span class="n">num_bins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1001</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>We evaulate the number of lineages at a finite set of time points, defined by <code class="language-plaintext highlighter-rouge">num_bins</code>.
Turning up the value of <code class="language-plaintext highlighter-rouge">num_bins</code> may make the curves look smoother, but they will also take longer to compute and may exaggerate MCMC noise.</p>

<p>Finally, we plot the LTT curves with <code class="language-plaintext highlighter-rouge">plotLTT</code>.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plotLTT</span><span class="p">(</span><span class="n">LTTs</span><span class="p">,</span><span class="w"> </span><span class="n">plotCI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>For ease of interpretation, we’re omitting the 95% credible intervals around the number of lineages, but you may choose to turn them on with <code class="language-plaintext highlighter-rouge">plotCI = TRUE</code>.
(You can also adjust the size of the credible interval, e.g., you can use the 50% credible interval by specifying <code class="language-plaintext highlighter-rouge">CI = 0.5</code> in the <code class="language-plaintext highlighter-rouge">processLTT</code> function.)</p>

<p>We can save our LTT plot to a file like so:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pdf</span><span class="p">(</span><span class="s2">"LTTs.pdf"</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">)</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">plotLTT</span><span class="p">(</span><span class="n">LTTs</span><span class="p">,</span><span class="w"> </span><span class="n">plotCI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">))</span><span class="w">
</span><span class="n">dev.off</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>which produces <a href="#LTT"></a>:</p>

<figure id="LTT"><p><img src="files/figures/LTTs.png" width="75%" height="75%" /></p>
<figcaption><strong>Lineage-through-time curves for the five models we used.</strong> The strict clock model appears to imply a quite different diversity trajectory, in particular, it predicts more species appeared earlier.
The effect of the remaining models appears to depend on time: the UCE and epochal models predict a smaller number of species in the earlier part of the history; the epochal model predicts the largest number of lineages at the end of the Pennsylvanian; and the UCE model predicts more recent divergence times near the present.</figcaption>
</figure>

<h3 class="subsection" id="multidimensional-scaling-plots">Multidimensional Scaling Plots</h3>
<hr class="subsection" />

<p>The lineage-through-time curves lose some information, both because we just examined the posterior average number of lineages (at least in the above example; in principle we can also plot the LTT credible intervals), and because it obscured tree topology and branch lengths.</p>

<p>We can use multidimensional scaling (MDS) of tree-distance metrics to compare the tree topologies and branch lengths inferred under these models (see <a class="citation" href="#Hillis2005">Hillis et al. (2005), Huang et al. (2016)</a>).
This involves computing a “distance” between each pair of trees within and between the posterior distributions of trees for each model.
MDS then projects these pairwise distances into a lower dimensional—and therefore easier to visualize—representation of tree space.</p>

<p>Two convenient distance metrics are the Robinson-Foulds distance <a class="citation" href="#Robinson1981">(Robinson and Foulds 1981)</a>, which measures the topological distance between two trees, and the Kühner-Felsenstein distance <a class="citation" href="#Kuhner1994">(Kühner and Felsenstein 1994)</a>, which incorporates both topology and branch lengths.</p>

<p>We’ll be using the <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">phangorn</code> <a class="citation" href="#Schliep2011">(Schliep 2011)</a> to compute the distances, and <code class="language-plaintext highlighter-rouge">RevGadgets</code> to create the plots.
We’ll start by reading in the data (you don’t have to repeat this step if you’ve already read in the trees to make LTT plots, above):</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the samples</span><span class="w">
</span><span class="n">strict_samples</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_strict_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span><span class="n">UCLN_samples</span><span class="w">    </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_UCLN_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span><span class="n">UCE_samples</span><span class="w">     </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_UCE_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span><span class="n">epochal_samples</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_epochal_foss_epochal_moleclock_UCLN_moleQ_HKY_morphclock_linked_morphQ_Mk_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span><span class="n">F81Mix_samples</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output_MCMC/div_constant_foss_constant_moleclock_UCLN_moleQ_HKY_morphclock_linked_morphQ_F81Mix_MCMC_run_01/tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">tree_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"timetree"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Again, we combine the tree samples into a single named list:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># combine the samples into one list</span><span class="w">
</span><span class="n">combined_samples</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">strict</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">strict_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="w">
                         </span><span class="n">UCLN</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">UCLN_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="w">
                         </span><span class="n">UCE</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">UCE_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="w">
                         </span><span class="n">epochal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">epochal_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]],</span><span class="w">
                         </span><span class="n">F81Mix</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">F81Mix_samples</span><span class="p">[[</span><span class="m">1</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<p>Now we call the <code class="language-plaintext highlighter-rouge">processMDS</code> function with the argument <code class="language-plaintext highlighter-rouge">type = "RF"</code> to compute RF distances:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make the RF MDS plots</span><span class="w">
</span><span class="n">RF_MDS</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">processMDS</span><span class="p">(</span><span class="n">combined_samples</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"RF"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>The argument <code class="language-plaintext highlighter-rouge">n</code> determines how many trees to use from each posterior distribution.
In this case, we’re using 100 trees from each of five analyses, so there will be a total of 500 trees.
Keep in mind that we have to compute the distance for each <em>pair</em> of trees, so the total number of distances grows quickly as <code class="language-plaintext highlighter-rouge">n</code> increases.
Large values of <code class="language-plaintext highlighter-rouge">n</code> will provide better representations of tree space, but will also take a potentially very long time to compute!
Be wary of increasing <code class="language-plaintext highlighter-rouge">n</code> too much.</p>

<p>We then create the MDS plot:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># plot the RF MDS</span><span class="w">
</span><span class="n">RF_plot</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">plotMDS</span><span class="p">(</span><span class="n">RF_MDS</span><span class="p">)</span><span class="w">

</span><span class="c1"># save the plot</span><span class="w">
</span><span class="n">pdf</span><span class="p">(</span><span class="s2">"figures/mds_RF.pdf"</span><span class="p">)</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">RF_plot</span><span class="p">)</span><span class="w">
</span><span class="n">dev.off</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>

<p>which produces <a href="#RF_MDS"></a></p>

<figure id="RF_MDS"><p><img src="files/figures/mds_RF.png" width="50%" height="50%" /></p>
<figcaption><strong>Multidimensional scaling of tree space sampled by different models using the Robinson-Foulds distance.</strong>
The RF metric measures the topological distance between pairs of trees, so this MDS plot represents how different inferred tree topologies are among different models.
The strict clock model in particular appears to be sampling tree topologies in only a subset of the tree space explored by other models.</figcaption>
</figure>

<p>We can produce an MDS plot of Kühner-Felsenstein distance likewise:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make the KF MDS plots</span><span class="w">
</span><span class="n">KF_MDS</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">processMDS</span><span class="p">(</span><span class="n">combined_samples</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"KF"</span><span class="p">)</span><span class="w">

</span><span class="c1"># plot the KF MDS</span><span class="w">
</span><span class="n">KF_plot</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">plotMDS</span><span class="p">(</span><span class="n">KF_MDS</span><span class="p">)</span><span class="w">

</span><span class="c1"># save the plot</span><span class="w">
</span><span class="n">pdf</span><span class="p">(</span><span class="s2">"figures/mds_KF.pdf"</span><span class="p">)</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">KF_plot</span><span class="p">)</span><span class="w">
</span><span class="n">dev.off</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>which produces <a href="#KF_MDS"></a></p>

<figure id="KF_MDS"><p><img src="files/figures/mds_KF.png" width="50%" height="50%" /></p>
<figcaption><strong>Multidimensional scaling of tree space sampled by different models using the Kühner-Felsenstein distance.</strong>
The KF metric incorporates both tree topology and branch lengths.
Because this MDS plot looks very similar to the MDS plot for RF distances (<a href="#RF_MDS"></a>; note that the directions of the axes are arbitrary, so rotations don’t matter), we might conclude that the main differences between these models are in the inferred tree topologies.
(Of course, we don’t expect this to be a general result, just a feature of the example dataset!)</figcaption>
</figure>

<h2 class="section" id="bayes_factors">Comparing Model Fit with Bayes Factors</h2>
<hr class="section" />

<p>If we assess model sensitivity and determine that our estimates depend on the choice of model (as they often do), we will naturally want to ask: <em>Which of the models best describes my dataset?</em> or <em>which of the estimates should I trust the most/report in my results?</em>.
We can use <em>Bayes factors</em> to compare the relative fit of different models to our data, which allows us to decide which results are the most trustworthy.</p>

<p>The <em>Bayes factor</em> represents how well one model, $M_0$, fits the data relative to an alternative model, $M_1$.
The Bayes factor between models $M_0$ and $M_1$ ($\text{BF}_{01}$) is calculated as:</p>

\[\begin{equation*}
\text{BF}_{01} = \frac{ P(X \mid M_0) }{ P(X \mid M_1) }
\end{equation*}\]

<p>where $P(X \mid M_i)$ is the marginal likelihood of model $M_i$.
A Bayes factor greater than 1 indicates support for model $M_0$, while a Bayes factor between 0 and 1 indicates support for model $M_1$.
We often report \(2 \ln \text{BF}_{01}\) (twice the Bayes factor on the log scale), in which case values greater than 0 indicate support for model $M_0$ and less than 0 indicate support for model $M_1$.
The nice thing about the log scale is that it is <em>symmetrical</em> around 0: \(2\ln\text{BF}_{01} = 5\) represents the same amount of support for $M_0$ as \(2\ln\text{BF}_{01} = -5\) represents for $M_1$.</p>

<p>The <em>marginal likelihood</em> for a given model (the denominator of Bayes’ theorem) is the probability of the data (the likelihood) averaged over all possible parameter values in proportion to their prior probability.
Because it is the <em>average</em> probability of the data, Bayes factors intuitively represent our preference for models that have a higher average probability of producing the data.
Also, because the must integrate over each prior distribution, increasing the number of parameters will tend to <em>reduce</em> the marginal likelihoods unless the additional parameters improve the fit of the model; that is, Bayes factors provide a natural way of penalizing additional parameters.</p>

<p>For more details of Bayes factors and how to interpret them, please see the <a href="/tutorials/model_selection_bayes_factors/bf_intro.html">Model Selection tutorial</a>.</p>

<h3 class="subsection" id="estimating-the-marginal-likelihood-with-power-posterior-analysis">Estimating the Marginal Likelihood with Power-Posterior Analysis</h3>
<hr class="subsection" />

<p>The only difference between estimating the posterior distribution and estimating the marginal likelihood is that we must run a variant of Markov-chain Monte Carlo called <em>power-posterior</em> analysis.
This involves running a set of $k$ MCMC runs, each of which experiences a “distorted” version of the posterior distribution.
Each run is sometimes called a “stone” or a “cat” (category).
This distortion is represented by a parameter, $\beta$, which is used to “heat” the likelihood function:</p>

\[\begin{equation*}
P_\beta(\theta \mid X) = \frac{ P(X \mid \theta)^\beta P(\theta)}{ P_\beta(X) }
\end{equation*}\]

<p>(Because we raise the likelihood function to a <em>power</em>, this is called a <em>power posterior</em> analysis.)
We run a set of Markov chains with $\beta$ ranging from 0 (the prior) to 1 (the posterior), and use the resulting samples of the likelihoods sampled by each run to estimate the marginal likelihood using either a “Path-Sampling” estimator or a “Stepping-Stone” estimator.
In theory, these two estimates are the same, but they can be different if we don’t use enough stones or if we don’t sample enough from each stone.
See the <a href="/tutorials/model_selection_bayes_factors/bf_intro.html">Model Selection tutorial</a> for more details about how this algorithm works.</p>

<p>Practically, rather than using <code class="language-plaintext highlighter-rouge">modules/analysis/MCMC.Rev</code>, we need to set up a new analysis type for the power-posterior analysis.
(This analysis script is already provided in <code class="language-plaintext highlighter-rouge">modules/analysis/PP.Rev</code>.)
To run a power-posterior analysis, we first have to decide on some settings, in particular: how frequently to write a sample of the chain to a file, how many stones to use, and how many generations to run per stone:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># analysis settings</span><span class="w">
</span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="w">
</span><span class="n">nstones</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="m">30</span><span class="w">
</span><span class="n">ngen</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="m">1000</span><span class="w">
</span></code></pre></div></div>
<p>The number of generations is <em>per stone</em>, so the total number of generations is the number of stones times the number of generations!
The quality of the marginal-likelihood estimate will depend on the number of generations; we number of stones and generations we use is small because our dataset is relatively small, but you will probably need to use more to get accurate estimates for larger datasets.</p>

<p>We then create a screen monitor to give us a progress bar:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the monitors</span><span class="w">
</span><span class="n">monitors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VectorMonitors</span><span class="p">()</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnScreen</span><span class="p">(</span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>(Note that we aren’t creating other monitors here, like an <code class="language-plaintext highlighter-rouge">mnModel</code> or <code class="language-plaintext highlighter-rouge">mnFile</code> monitor to keep track of parameter samples. Because the chains in a power-posterior analysis experience a distorted posterior distribution, the sampled parameters are not a valid approximation of the posterior distribution, except when $\beta = 1$.
If you want to estimate the posterior distribution, you should use the <code class="language-plaintext highlighter-rouge">MCMC.Rev</code> analysis module.)</p>

<p>As with MCMC, we define a model object:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the model</span><span class="w">
</span><span class="n">mymodel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">timetree</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Next, we define our power-posterior analysis object.
This function takes the number of stones (the <code class="language-plaintext highlighter-rouge">cats</code>) argument, as well as the filename for the samples per stone.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make the analysis</span><span class="w">
</span><span class="n">mymcmc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">powerPosterior</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span><span class="w"> </span><span class="n">monitors</span><span class="p">,</span><span class="w"> </span><span class="n">moves</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"/stones/pp.log"</span><span class="p">,</span><span class="w"> </span><span class="n">cats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nstones</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">sampleFreq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>(This function automatically decides where to place the $\beta$ values for each stone, but advanced users may want to control where the stones go using the <code class="language-plaintext highlighter-rouge">powers</code> or <code class="language-plaintext highlighter-rouge">alpha</code> arguments, describes in the documentation. The placement of stones can have some affect on the accuracy of marginal-likelihood estimates, but the default values are usually pretty good.)</p>

<p>We then run the power-posterior analysis.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># run the analysis</span><span class="w">
</span><span class="n">mymcmc.run</span><span class="p">(</span><span class="n">generations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ngen</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>After the analysis finishes, we read in the samples to compute both the path-sampling and stepping-stone estimates of the marginal likelihood.
If these estimates are different, it indicates that we did not use enough stones and/or did not sample enough generations per stone!
We print each estimate to screen, but also write them into a file named <code class="language-plaintext highlighter-rouge">ml.txt</code> for later reference.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># compute the path-sampling estimate of the marginal likelihood</span><span class="w">
</span><span class="n">ps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pathSampler</span><span class="p">(</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"/stones/pp.log"</span><span class="p">,</span><span class="w"> </span><span class="n">powerColumnName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"power"</span><span class="p">,</span><span class="w"> </span><span class="n">likelihoodColumnName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"likelihood"</span><span class="p">)</span><span class="w">
</span><span class="n">ps_ml</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ps.marginal</span><span class="p">()</span><span class="w">
</span><span class="s2">"Path-sampling estimate of ML: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ps_ml</span><span class="w">

</span><span class="c1"># compute the stepping-stone estimate of the marginal likelihood</span><span class="w">
</span><span class="n">ss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">steppingStoneSampler</span><span class="p">(</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"/stones/pp.log"</span><span class="p">,</span><span class="w"> </span><span class="n">powerColumnName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"power"</span><span class="p">,</span><span class="w"> </span><span class="n">likelihoodColumnName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"likelihood"</span><span class="p">)</span><span class="w">
</span><span class="n">ss_ml</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ss.marginal</span><span class="p">()</span><span class="w">
</span><span class="s2">"Stepping-stone sampling estimate of ML: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ps_ml</span><span class="w">

</span><span class="c1"># write the estimates to file</span><span class="w">
</span><span class="n">write</span><span class="p">(</span><span class="n">ps_ml</span><span class="p">,</span><span class="w"> </span><span class="n">ss_ml</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"/ml.txt"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>⚠ <strong><em>NOTE: The values reported by these marginal likelihood estimates are in fact the log marginal likelihoods! If you want to compute the Bayes factor between two models, plug these log marginal likelihoods into the following equation:</em></strong></p>

\[\begin{equation*}
2 \ln \text{BF}_{01} = 2 \times \left[ \text{log-marginal-likelihood of }M_0 - \text{log-marginal-likelihood of }M_1 \right]
\end{equation*}\]

<p>That’s it!
The rest of the model files do not need to change, because the power-posterior analysis does not involve modifications to the model itself.</p>

<h3 class="subsection" id="exercise-2-comparing-among-models">Exercise 2: Comparing among models</h3>
<hr class="subsection" />

<p>Now that we’ve written a <code class="language-plaintext highlighter-rouge">PP.Rev</code> analysis script for doing a power-posterior analysis, we want to compare the fit of our models.
Prepare a header file for each of the four models in the tables below (a subset of the models we used above for the MCMC analyses).
(We also provide the relevant header files in <code class="language-plaintext highlighter-rouge">headers/PowerPosterior</code>.
Note that these model comparisons are <em>not exhaustive</em>, and you might want to consider more combinations of models to pinpoint which parts of the model are affecting model fit.)</p>

<p>Use these header files to estimate the marginal likelihood for each model.
For each model, assess whether the path-sampling and and stepping-stone estimates are similar.</p>

<figure id="tab_ml_ted_models"><table>
  <thead>
    <tr>
      <th style="text-align: right"><strong>Model</strong></th>
      <th style="text-align: center"><strong>Path-Sampling</strong></th>
      <th style="text-align: center"><strong>Stepping-Stone-Sampling</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">strict_Mk</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">UCLN_Mk</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">UCE_Mk</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">UCLN_F81Mix</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<figcaption>Marginal likelihoods for total-evidence models.</figcaption>
</figure>

<p>Now, compare the relative fit by computing the Bayes factor between each pair of models.
Which is the favored model?</p>

<figure id="tab_bf_ted_models"><table>
  <thead>
    <tr>
      <th style="text-align: right"><strong>Model</strong></th>
      <th style="text-align: center"><code class="language-plaintext highlighter-rouge">strict_Mk</code></th>
      <th style="text-align: center"><code class="language-plaintext highlighter-rouge">UCLN_Mk</code></th>
      <th style="text-align: center"><code class="language-plaintext highlighter-rouge">UCE_Mk</code></th>
      <th style="text-align: center"><code class="language-plaintext highlighter-rouge">UCLN_F81Mix</code></th>
      <th style="text-align: center"><code class="language-plaintext highlighter-rouge">epochal_Mk</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">strict_Mk</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">UCLN_Mk</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">UCE_Mk</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">UCLN_F81Mix</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<figcaption>Bayes factors between total-evidence models.</figcaption>
</figure>

<!--  -->

<h2 class="section" id="posterior_prediction">Assessing Model Adequacy with Posterior-Predictive Simulation</h2>
<hr class="section" />

<p>In addition to comparing the <em>relative fit</em> of competing models using Bayes factors, we may wish to assess whether a given model (perhaps the best fit model) provides an adequate description of the true process that give rise to our data, sometimes called “model adequacy”.
This may be particularly important for morphological data, since we may be especially skeptical that our models of morphological evolution can provide a realistic description of the process of morphological evolution.
We will use posterior-predictive simulation to assess model adequacy, as described in the <a href="/tutorials/model_testing_pps/pps_data.html">P^3 tutorial</a>.</p>

<p>The basic idea of posterior-predictive simulation is to ask: if we simulate data from our model, does that data resemble our observed data (in some quantifiable way)?
A model that is adequate will be able to simulate datasets that resemble our observed dataset, while an inadequate model will simulate datasets that do not resemble our observed data.
We capture the notion of “resemblance” by computing a statistic for a dataset, and looking at the distribution of that statistic computed over simulated datasets compared to the same statistic computed on our observed dataset.</p>

<p>To simulate a single dataset from our model, we take one sample from our posterior distribution, and forward simulate a character dataset given the parameters of that sample from the posterior.
We repeat this procedure many times (e.g., one per posterior sample) to generate a posterior-predictive distribution of simulated datasets, then compute our statistic for each simulated dataset.</p>

<p>We can compute compute a posterior-predictive <em>p</em>-value as the fraction of simulated statistics that are greater than the observed statistic:</p>

\[\begin{equation*}
P = \frac{1}{n} \sum_{i=1}^n T(X^\text{sim}_i) &gt; T(X^\text{obs})
\end{equation*}\]

<p>where $n$ is the number of simulated datasets, $T(X)$ is our test statistic, $X^\text{\sim}_i$ is the $i^\text{th}$ simulated dataset, and $X^\text{obs}$ is the observed dataset.
Note that this is the same as subtracting the simulated and observed statistics, and then computing the fraction of these differences that is larger than zero:</p>

\[\begin{equation*}
P = \frac{1}{n} \sum_{i=1}^n \left[ T(X^\text{sim}_i) - T(X^\text{obs}) \right] &gt; 0
\end{equation*}\]

<p>A <em>p</em>-value greater than \(1 - \alpha \div 2\) or less than \(\alpha \div 2\) indicates model inadequacy at the critical value of \(\alpha\).
For example, a <em>p</em> value greater than 0.975 or less than 0.025 indicates inadequacy at the $\alpha = 0.05$ level.</p>

<p>There are many statistics one could consider using, and which statistics are best at diagnosing inadequacy is discussion.
In this tutorial, we’ll recreate the statistics we used in <a class="citation" href="#May2021">(May et al. 2021)</a>: the total parsimony score among discrete morphological characters (intended to characterize whether the model adequately describes overall rates of morphological evolution), and the variance in parsimony scores among characters (intended to characterize whether the model adequately describes how the process varies among characters).</p>

<h3 class="subsection" id="simulating-the-posterior-predictive-datasets">Simulating the Posterior-Predictive Datasets</h3>
<hr class="subsection" />

<p>Similar to the power-posterior analysis we’ll create a new posterior-predictive analysis script (called <code class="language-plaintext highlighter-rouge">modules/analysis/PPS.Rev</code>) for simulating morphological character datasets from our posterior distribution.
Let’s look at this analysis line-by-line.</p>

<p>The first step of the posterior-predictive analysis is a fairly standard MCMC run, as we implemented in <code class="language-plaintext highlighter-rouge">modules/analysis/MCMC.Rev</code>.
As usual, we first decide how many runs to do, how many generations to run the MCMC for, etc.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># analysis settings</span><span class="w">
</span><span class="n">nruns</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="w">
</span><span class="n">nburnin</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="m">2000</span><span class="w">
</span><span class="n">ngen</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="m">20000</span><span class="w">
</span></code></pre></div></div>

<p>We then specify our model monitors; in this case, we’re including an additional monitor, <code class="language-plaintext highlighter-rouge">mnStochasticVariable</code>, that keeps track of all the model parameters in one file to be used to generate the posterior simulations.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the monitors</span><span class="w">
</span><span class="n">monitors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VectorMonitors</span><span class="p">()</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnScreen</span><span class="p">(</span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnModel</span><span class="p">(</span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"params.log"</span><span class="p">,</span><span class="w"> </span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">,</span><span class="w"> </span><span class="n">exclude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">"F"</span><span class="p">])</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnFile</span><span class="p">(</span><span class="n">filename</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">,</span><span class="w"> </span><span class="n">timetree</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnFile</span><span class="p">(</span><span class="n">filename</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"extant_tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">,</span><span class="w"> </span><span class="n">extant_tree</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">monitors.append</span><span class="p">(</span><span class="w"> </span><span class="n">mnStochasticVariable</span><span class="p">(</span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"stoch.var"</span><span class="p">,</span><span class="w"> </span><span class="n">printgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printgen</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Next, we make our model and MCMC analysis, then run the chain and create a summary tree.
We’ll hide this code behind a fold because we’ve already seen in before in our MCMC analyses.</p>

<blockquote class="aside"><h2>Running the MCMC analysis</h2><div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the model</span><span class="w">
</span><span class="n">mymodel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">timetree</span><span class="p">)</span><span class="w">

</span><span class="c1"># make the analysis</span><span class="w">
</span><span class="n">mymcmc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mcmc</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span><span class="w"> </span><span class="n">monitors</span><span class="p">,</span><span class="w"> </span><span class="n">moves</span><span class="p">,</span><span class="w"> </span><span class="n">nruns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nruns</span><span class="p">)</span><span class="w">

</span><span class="c1"># run the burnin</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nburnin</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">mymcmc.burnin</span><span class="p">(</span><span class="n">generations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nburnin</span><span class="p">,</span><span class="w"> </span><span class="n">tuningInterval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">)</span><span class="w">
  </span><span class="n">mymcmc.operatorSummary</span><span class="p">()</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># run the analysis</span><span class="w">
</span><span class="n">mymcmc.run</span><span class="p">(</span><span class="n">generations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ngen</span><span class="p">)</span><span class="w">

</span><span class="c1"># make the summary trees</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">nruns</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># just make summary trees for the one run</span><span class="w">
  </span><span class="n">full_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
  </span><span class="n">mccTree</span><span class="p">(</span><span class="n">full_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_tree.tre"</span><span class="p">)</span><span class="w">

  </span><span class="n">extant_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"extant_tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
  </span><span class="n">mccTree</span><span class="p">(</span><span class="n">extant_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_extant_tree.tre"</span><span class="p">)</span><span class="w">

</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># make a combined summary tree</span><span class="w">
  </span><span class="n">full_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
  </span><span class="n">mccTree</span><span class="p">(</span><span class="n">full_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_tree.tre"</span><span class="p">)</span><span class="w">

  </span><span class="n">extant_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"extant_tree.trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
  </span><span class="n">mccTree</span><span class="p">(</span><span class="n">extant_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_extant_tree.tre"</span><span class="p">)</span><span class="w">

  </span><span class="c1"># and run-specific summary trees</span><span class="w">
  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">nruns</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">full_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"tree_run_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
    </span><span class="n">mccTree</span><span class="p">(</span><span class="n">full_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_tree_run_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".tre"</span><span class="p">)</span><span class="w">

    </span><span class="n">extant_trees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readTreeTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"extant_tree_run_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".trees"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clock"</span><span class="p">)</span><span class="w">
    </span><span class="n">mccTree</span><span class="p">(</span><span class="n">extant_trees</span><span class="p">,</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"MCC_extant_tree_run_"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">".tre"</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
</blockquote>

<p>Now we read in the posterior samples and simulate our posterior-predictive datasets:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read in the posterior samples</span><span class="w">
</span><span class="n">trace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readStochasticVariableTrace</span><span class="p">(</span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"stoch.var"</span><span class="p">)</span><span class="w">

</span><span class="c1"># setup the PPS simulations</span><span class="w">
</span><span class="n">pps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">posteriorPredictiveSimulation</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span><span class="w"> </span><span class="n">directory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_filename</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">"/simulations"</span><span class="p">,</span><span class="w"> </span><span class="n">trace</span><span class="p">)</span><span class="w">

</span><span class="c1"># run the PPS simulations</span><span class="w">
</span><span class="n">pps.run</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>(Note that we’re reading in the stochastic variable trace created by <code class="language-plaintext highlighter-rouge">mnStochasticVariable</code>.)
The <code class="language-plaintext highlighter-rouge">pps.run()</code> command will generate one simulated dataset per MCMC sample, and write them in the <code class="language-plaintext highlighter-rouge">/simulations</code> subdirectory.</p>

<p>We repeat this procedure for each model under consideration, though in principle we can do model adequacy with a single model!
We provide the analysis headers in <code class="language-plaintext highlighter-rouge">headers/PPS</code>—these are the same models we have used in our previous sections.</p>

<h3 class="subsection" id="summarizing-posterior-predictive-simulations">Summarizing Posterior-Predictive Simulations</h3>
<hr class="subsection" />

<p>Now that we’ve simulated our datasets for each model, it’s time to move to <code class="language-plaintext highlighter-rouge">R</code> to compute our statistics and compute posterior-predictive <em>p</em>-values.
(This code is provided in the script <code class="language-plaintext highlighter-rouge">posterior_summary/PPS.R</code>)
We begin by loading the required packages:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">RevGadgets</span><span class="p">)</span><span class="w">
</span><span class="n">source</span><span class="p">(</span><span class="s2">"posterior_summary/utils.R"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Next, we read in our observed morphological dataset.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the observed data</span><span class="w">
</span><span class="n">data_file</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"data/morpho.nex"</span><span class="w">
</span><span class="n">data</span><span class="w">      </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readMorphoData</span><span class="p">(</span><span class="n">data_file</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now, we specify the output directories for each of our posterior-predictive analyses.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># specify the output directory for each model</span><span class="w">
</span><span class="n">output_strict_Mk</span><span class="w">   </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"output_PPS/div_constant_foss_constant_moleclock_strict_moleQ_HKY_morphclock_linked_morphQ_Mk_PPS_run_01/"</span><span class="w">
</span><span class="n">output_UCLN_Mk</span><span class="w">     </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"output_PPS/div_constant_foss_constant_moleclock_UCLN_moleQ_HKY_morphclock_linked_morphQ_Mk_PPS_run_01/"</span><span class="w">
</span><span class="n">outout_UCE_Mk</span><span class="w">      </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"output_PPS/div_constant_foss_constant_moleclock_UCE_moleQ_HKY_morphclock_linked_morphQ_Mk_PPS_run_01/"</span><span class="w">
</span><span class="n">output_UCLN_F81Mix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"output_PPS/div_constant_foss_constant_moleclock_UCLN_moleQ_HKY_morphclock_linked_morphQ_F81Mix_PPS_run_01/"</span><span class="w">
</span></code></pre></div></div>

<p>Next, we read in the simulated morphological datasets with <code class="language-plaintext highlighter-rouge">readMorphoPPS</code>:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># read the output files</span><span class="w">
</span><span class="n">samples_strict_Mk</span><span class="w">   </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readMorphoPPS</span><span class="p">(</span><span class="n">output_strict_Mk</span><span class="p">)</span><span class="w">
</span><span class="n">samples_UCLN_Mk</span><span class="w">     </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readMorphoPPS</span><span class="p">(</span><span class="n">output_UCLN_Mk</span><span class="p">)</span><span class="w">
</span><span class="n">samples_UCE_Mk</span><span class="w">      </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readMorphoPPS</span><span class="p">(</span><span class="n">outout_UCE_Mk</span><span class="p">)</span><span class="w">
</span><span class="n">samples_UCLN_F81Mix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readMorphoPPS</span><span class="p">(</span><span class="n">output_UCLN_F81Mix</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now, we compute the posterior-predictive statistics with <code class="language-plaintext highlighter-rouge">processMorphoPPS</code>:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># compute the statistics</span><span class="w">
</span><span class="n">stats_strict_Mk</span><span class="w">   </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">processMorphoPPS</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">samples_strict_Mk</span><span class="p">)</span><span class="w">
</span><span class="n">stats_UCLN_Mk</span><span class="w">     </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">processMorphoPPS</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">samples_UCLN_Mk</span><span class="p">)</span><span class="w">
</span><span class="n">stats_UCE_Mk</span><span class="w">      </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">processMorphoPPS</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">samples_UCE_Mk</span><span class="p">)</span><span class="w">
</span><span class="n">stats_UCLN_F81Mix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">processMorphoPPS</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">samples_UCLN_F81Mix</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>By default, this function will compute the parsimony-sum and parsimony-variance statistics, as described in <a class="citation" href="#May2021">May et al. (2021)</a>.
You can also make your own user-defined statistics.
However, this may take a bit of work, which you may only want to do if you’re a fairly advanced <code class="language-plaintext highlighter-rouge">R</code> user.</p>

<blockquote class="aside"><h2>Advanced: User-Defined Test Statistics</h2><p>There is a hidden <code class="language-plaintext highlighter-rouge">statistics</code> argument to the <code class="language-plaintext highlighter-rouge">processMorphoPPS</code> function.
This argument accepts a list with elements that are either names of default statistics (which can be <code class="language-plaintext highlighter-rouge">"Parsimony Sum"</code> or <code class="language-plaintext highlighter-rouge">"Parsimony Variance"</code>), or functions.
You can provide any user defined function which has arguments <code class="language-plaintext highlighter-rouge">tree</code>, <code class="language-plaintext highlighter-rouge">observed_data</code>, and <code class="language-plaintext highlighter-rouge">simulated_data</code>.
The <code class="language-plaintext highlighter-rouge">tree</code> argument should expect to receive the tree that was used to simulate a particular dataset; the <code class="language-plaintext highlighter-rouge">observed_data</code> object expects a matrix object with named rows for species, and numeric values for character stats in columns.</p>

<p>For example, we can look at the internal <code class="language-plaintext highlighter-rouge">parsimony_sum</code> statistic to see how the function should work.
This function translates the provided datasets to the <code class="language-plaintext highlighter-rouge">phangorn</code> format <code class="language-plaintext highlighter-rouge">phyDat</code>, then computes the parsimony scores using the <code class="language-plaintext highlighter-rouge">phangorn</code> function <code class="language-plaintext highlighter-rouge">parsimony</code>.
It then computes the statistic as the difference in parsimony scores between the simulated and observed datasets.</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parsimony_sum</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">observed_data</span><span class="p">,</span><span class="w"> </span><span class="n">simulated_data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">

  </span><span class="c1"># get the state space</span><span class="w">
  </span><span class="n">all_chars</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.vector</span><span class="p">(</span><span class="n">observed_data</span><span class="p">)</span><span class="w">
  </span><span class="n">all_chars</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">all_chars</span><span class="p">[</span><span class="n">all_chars</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"?"</span><span class="p">,</span><span class="s2">"-"</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">]</span><span class="w">
  </span><span class="n">states</span><span class="w">    </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sort</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">all_chars</span><span class="p">))</span><span class="w">

  </span><span class="c1"># transform to phyDat for phangorn</span><span class="w">
  </span><span class="n">observed_phydat</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">phyDat</span><span class="p">(</span><span class="n">observed_data</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"USER"</span><span class="p">,</span><span class="w"> </span><span class="n">levels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">states</span><span class="p">)</span><span class="w">
  </span><span class="n">simulated_phydat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">phyDat</span><span class="p">(</span><span class="n">simulated_data</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"USER"</span><span class="p">,</span><span class="w"> </span><span class="n">levels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">states</span><span class="p">)</span><span class="w">

  </span><span class="c1"># compute the parsimony scores for the observed and simulated data</span><span class="w">
  </span><span class="n">observed_statistic</span><span class="w">  </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">parsimony</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">observed_phydat</span><span class="p">,</span><span class="w"> </span><span class="n">site</span><span class="o">=</span><span class="s2">"site"</span><span class="p">))</span><span class="w">
  </span><span class="n">simulated_statistic</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">parsimony</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">simulated_phydat</span><span class="p">,</span><span class="w"> </span><span class="n">site</span><span class="o">=</span><span class="s2">"site"</span><span class="p">))</span><span class="w">

  </span><span class="c1"># compute the statistic</span><span class="w">
  </span><span class="n">statistic</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">simulated_statistic</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">observed_statistic</span><span class="w">
  </span><span class="nf">return</span><span class="p">(</span><span class="n">statistic</span><span class="p">)</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>This function should serve as a template for any new statistics you choose to implement.</p>
</blockquote>

<p>We’ve now computed all of our posterior-predictive statistics.
It’s time to plot the posterior-predictive distributions and <em>p</em>-values!
There are several ways to do this, but one easy way is to plot the posterior-predictive distributions as boxplots and annotate them with <em>p</em>-values using <code class="language-plaintext highlighter-rouge">boxplotPostPredStats</code>:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pdf</span><span class="p">(</span><span class="s2">"figures/pps.pdf"</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">)</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">boxplotPostPredStats</span><span class="p">(</span><span class="n">combined_stats</span><span class="p">))</span><span class="w">
</span><span class="n">dev.off</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>which produces <a href="#posterior_predictive_figure"></a>.
For this example dataset and these models, all of the models appear to adequately describe the process of morphological evolution!
However, we should not expect this to be a general result: different datasets will behave differently, and the example dataset we are using is quite small and may not provide enough information to diagnose inadequacy.</p>

<figure id="posterior_predictive_figure"><p><img src="files/figures/pps.png" width="50%" height="50%" /></p>
<figcaption><strong>Posterior-predictive distributions of parsimony-sum and parsimony-variance statistics under each model.</strong>
  Since we’ve subtracted the observed statistic from the simulated statistic, the posterior-predictive <em>p</em>-value is the fraction of statistics that are greater than 0.
  In this case, all of the models appear to be adequate at the $\alpha = 0.05$ level: all of the distributions overlap with 0, and none of the <em>p</em>-values are less than 0.025 or greater than 0.975.</figcaption>
</figure>

<h2 class="section" id="conclusion">Conclusion</h2>
<hr class="section" />

<p>This concludes the total-evidence-dating workflow tutorial!
We’ve shown you how to specify complex analyses in a generic way, that hopefully you can extend and modify to accommodate your own dataset.
We’ve also provided some examples of how to assess model sensitivity—the degree to which phylogenetic divergence-time estimates are sensitive to modeling choices—and how to compare models on both relative (Bayes factor) and absolute (posterior-predictive simulation) scales.
We encourage you to try this workflow out with your own dataset, and let us know how it goes!
For a more complete set of models and analyses, you can check out the supplemental archive of our Marattiales study—which explored a larger number of models and model combinations than we presented here—at our <a href="https://github.com/mikeryanmay/marattiales_supplemental">GitHub supplemental repository</a>.</p>

<!--  -->

<ol class="bibliography"><li><span id="Gavryushkina2016">Gavryushkina A., Heath T.A., Ksepka D.T., Stadler T., Welch D., Drummond A.J. 2017. Bayesian Total-Evidence Dating Reveals the Recent Crown Radiation of Penguins. Systematic Biology. 66:57–73.</span>

<a href="https://doi.org/10.1093/sysbio/syw060">10.1093/sysbio/syw060</a>

</li>
<li><span id="Heath2014">Heath T.A., Huelsenbeck J.P., Stadler T. 2014. The fossilized birth-death process for coherent calibration of divergence-time estimates. Proceedings of the National Academy of Sciences. 111:E2957–E2966.</span>

<a href="https://doi.org/10.1073/pnas.1319091111">10.1073/pnas.1319091111</a>

</li>
<li><span id="Hillis2005">Hillis D.M., Heath T.A., John K.S. 2005. Analysis and visualization of tree space. Systematic Biology. 54:471–482.</span>

</li>
<li><span id="Huang2016">Huang W., Zhou G., Marchand M., Ash J.R., Morris D., Van Dooren P., Brown J.M., Gallivan K.A., Wilgenbusch J.C. 2016. TreeScaper: visualizing and extracting phylogenetic signal from sets of trees. Molecular Biology and Evolution. 33:3314–3316.</span>

</li>
<li><span id="Kuhner1994">Kühner M.K., Felsenstein J. 1994. A simulation comparison of phylogeny algorithms under equal and unequal evolutionary rates. Molecular Biology and Evolution. 11:459–468.</span>

</li>
<li><span id="Lewis2001">Lewis P.O. 2001. A Likelihood Approach to Estimating Phylogeny from Discrete Morphological Character Data. Systematic Biology. 50:913–925.</span>

<a href="https://doi.org/10.1080/106351501753462876">10.1080/106351501753462876</a>

</li>
<li><span id="May2021">May M.R., Contreras D.L., Sundue M.A., Nagalingum N.S., Looy C.V., Rothfels C.J. 2021. Inferring the Total-Evidence Timescale of Marattialean Fern Evolution in the Face of Model Sensitivity. Systematic Biology. 70:1232–1255.</span>

</li>
<li><span id="Robinson1981">Robinson D.F., Foulds L.R. 1981. Comparison of phylogenetic trees. Mathematical Biosciences. 53:131–147.</span>

</li>
<li><span id="Ronquist2012a">Ronquist F., Klopfstein S., Vilhelmsen L., Schulmeister S., Murray D.L., Rasnitsyn A.P. 2012. A total-evidence approach to dating with fossils, applied to the early radiation of the Hymenoptera. Systematic Biology. 61:973–999.</span>

</li>
<li><span id="Schliep2011">Schliep K.P. 2011. phangorn: phylogenetic analysis in R. Bioinformatics. 27:592–593.</span>

</li>
<li><span id="Tribble2022">Tribble C.M., Freyman W.A., Landis M.J., Lim J.Y., Barido-Sottani J., Kopperud B.T., Höhna S., May M.R. 2022. RevGadgets: An R package for visualizing Bayesian phylogenetic analyses from RevBayes. Methods in Ecology and Evolution. 13:314–323.</span>

<a href="https://doi.org/https://doi.org/10.1111/2041-210X.13750">https://doi.org/10.1111/2041-210X.13750</a>

</li>
<li><span id="Zhang2016">Zhang C., Stadler T., Klopfstein S., Heath T.A., Ronquist F. 2016. Total-Evidence Dating under the Fossilized Birth-Death Process. Systematic Biology. 65:228–249.</span>

<a href="https://doi.org/10.1093/sysbio/syv080">10.1093/sysbio/syv080</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://github.com/revbayes/revbayes/discussions">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
