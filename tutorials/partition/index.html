<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Partitioned data analysis</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Partitioned data analysis</h1>
	<h3 class="subtitle">Current Protocols in Bioinformatics - Phylogenetic Inference using RevBayes (Protocol &#35;2)</h3>
	<h4 class="authors">Sebastian Höhna, Michael J. Landis and Tracy A. Heath</h4>
  <h5>Last modified on October 12, 2023</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/ctmc/">Nucleotide substitution models</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Data Files</strong>
        <ul id="data_files">
        
        
        
          <li><a href="/tutorials/partition/data/primates_and_galeopterus_cox2.nex">primates_and_galeopterus_cox2.nex</a></li>
        
          <li><a href="/tutorials/partition/data/primates_and_galeopterus_cytb.nex">primates_and_galeopterus_cytb.nex</a></li>
        
        </ul>
    
        
        <strong>Scripts</strong>
        <ul id="scripts">
        
        
        
          <li><a href="/tutorials/partition/scripts/mcmc_Partition_codon.Rev">mcmc_Partition_codon.Rev</a></li>
        
          <li><a href="/tutorials/partition/scripts/mcmc_Partition_gene.Rev">mcmc_Partition_gene.Rev</a></li>
        
          <li><a href="/tutorials/partition/scripts/mcmc_Partition_uniform.Rev">mcmc_Partition_uniform.Rev</a></li>
        
          <li><a href="/tutorials/partition/scripts/ml_Partition_uniform.Rev">ml_Partition_uniform.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<p>This tutorial comes with a recorded video walkthrough, available here: <a href="https://youtu.be/LPPYGUP1FZc"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough playlist" height="36" width="36" /></a>. The video corresponding to each section of the exercise is linked next to the section title.</p>

<h2 class="section" id="overview">Overview</h2>
<hr class="section" />

<p><a href="https://youtu.be/LPPYGUP1FZc"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>This tutorial provides the second protocol from our recent publication
<a class="citation" href="#Hoehna2017a">(Höhna et al. 2017)</a>. The first protocol is described in the <a href="/tutorials/ctmc/">Nucleotide substitution models</a>
and the third protocol is described in the <a href="/tutorials/model_selection_bayes_factors/bf_subst_model.html">Model selection of common substitution models for one locus</a>.</p>

<p>This tutorial demonstrates how to accommodate variation in the
substitution process across sites of an alignment. In the preceding
tutorials, we assumed that all sites in an alignment evolved under an
identical substitution process. This assumption is likely to be violated
biologically, since different nucleotide sites are subject to different
selection pressures, such as depending on which gene or codon position
the site belongs to. Here, we will demonstrate how to specify—and select
among—alternative <em>data partition schemes</em> using ‘RevBayes‘. This is
commonly referred to as partitioned-data analysis, where two or more
subsets of sites in our alignment are assumed to evolve under distinct
processes.</p>

<p>This tutorial will construct three multi-gene models. The first model,
Partition_uniform, assumes all genes evolve under the same process
parameters. The second model, Partition_gene, assumes all genes evolve
according to the same process, but each gene has its own set of process
parameters. The third model, Partition_codon, partitions the data not
only by gene, but also by codon position. Each analysis will generate a
<em>maximum a posteriori</em> tree to summarize the inferred phylogeny. An
advanced exercise introduces how to compute Bayes factors to select
across various partitioning schemes.</p>

<p>All of the files for this analysis are provided for you and you can run
these without significant effort using the ‘source()‘ function in the
‘RevBayes‘ console, <em>e.g.,</em></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mcmc_Partition_uniform.Rev")
</code></pre></div></div>
<p>If everything loaded properly, then you should see the program begin
running the Markov chain Monte Carlo analysis needed for estimating the
posterior distribution. If you continue to let this run, you will
see it output the states of the Markov chain once the MCMC analysis
begins.</p>

<h2 class="section" id="overview-introduction--background">Overview Introduction &amp; Background</h2>
<hr class="section" />

<p>Variation in the evolutionary process across the sites of nucleotide
sequence alignments is well established, and is an increasingly
pervasive feature of datasets composed of gene regions sampled from
multiple loci and/or different genomes. Inference of phylogeny from
these data demands that we adequately model the underlying process
heterogeneity; failure to do so can lead to biased estimates of
phylogeny and other parameters <a class="citation" href="#Brown2007">(Brown and Lemmon 2007)</a>.</p>

<p>Accounting for process heterogeneity involves adopting a partitioned
data approach (sometimes also called a ‘mixed-model’ approach
<a class="citation" href="#Ronquist2003">(Ronquist and Huelsenbeck 2003)</a>), in which the sequence alignment is first parsed into a
number of data subsets that are intended to capture plausible process
heterogeneity within the data. The determination of the partitioning
scheme is guided by biological considerations regarding the dataset at
hand. For example, we might wish to evaluate possible variation in the
evolutionary process within a single gene region
(e.g., between stem and loop regions of
ribosomal sequences), or among gene regions in a concatenated alignment
(e.g., comprising multiple nuclear loci
and/or gene regions sampled from different genomes). The choice of
partitioning scheme is up to the investigator and many possible
partitions might be considered for a typical dataset.</p>

<p>In this exercise, we assume that each data subset evolved under an
independent general-time reversible model with gamma-distributed rates
across sites (GTR+$\Gamma$). Under this model the observed data are
conditionally dependent on the exchangeability rates ($\theta$),
stationary base frequencies ($\pi$), and the degree of gamma-distributed
among-site rate variation ($\alpha$), as well as the rooted tree
($\Psi$) and branch lengths. When we assume different GTR+$\Gamma$
models for each data subset, this results in a composite model, in which
all sites are assumed to share a common, rooted tree topology and
proportional branch lengths, but subsets of sites are assumed to have
independent substitution model parameters. Finally, we perform a
separate MCMC simulation to approximate the joint posterior probability
density of the phylogeny and other parameters.</p>

<p>For most sequence alignments, several (possibly many) partition schemes
of varying complexity are plausible <em>a priori</em>, which therefore requires
a way to objectively identify the partition scheme that balances
estimation bias and error variance associated with under- and
over-parameterized mixed models, respectively. Increasingly,
partition-model selection is based on <em>Bayes factors</em>
[e.g., <a class="citation" href="#Suchard2001">(Suchard et al. 2001)</a>], which involves first
calculating the marginal likelihood under each candidate partition
scheme and then comparing the ratio of the marginal likelihoods for the
set of candidate partition schemes
(missing reference). 
The analysis pipeline that we will use in this tutorial is depicted in Figure [fig:pipeline].</p>

<blockquote class="figure">
  <p><img src="figures/pipeline.png" alt="" /> 
The analysis pipeline for
Exercise 1. We will explore three partition schemes for the primates
dataset. The first model (the ‘uniform model’, $M_0$) assumes that all
sites evolved under a common GTR+$\Gamma$ substitution model. The second
model (the ‘moderately partitioned’ model, $M_1$) invokes two data
subsets corresponding to the two gene regions (cytB and cox2), and
assumes each subset of sites evolved under an independent GTR+$\Gamma$
model. The final partition model (the ‘highly partitioned’ model, $M_2$)
invokes four data subsets—the first two subsets corresponds to the cytB
gene region, where the first and second codon position sites are
combined into one subset distinct from the third codon position sites,
and the cox2 gene has two subsets of its own, partitioned by codon
positions in the same way—and each data subset is assumed evolved under
an independent GTR+$\Gamma$ substitution model. Note that we assume that
all sites share a common tree topology, $\Psi$, and branch-length
proportions, for each of the candidate partition schemes.We perform two
separate sets of analyses for each partition model—a MCMC simulation to
approximate the joint posterior probability density of the
partition-model parameters, and a ‘power-posterior’ MCMC simulation to
approximate the marginal likelihood for each mixed model. The resulting
marginal-likelihood estimates are then evaluated using Bayes factors to
assess the fit of the data to the three candidate partition models.</p>
</blockquote>

<h2 class="section" id="concatenated-non-partitioned">Concatenated, Non-partitioned</h2>
<hr class="section" />

<p><a href="https://youtu.be/LPPYGUP1FZc#t=2m48s"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>Our first exercise is to construct a multi-gene analysis where all genes
evolve under the same process and parameters.</p>

<h3 class="subsection" id="setting-up-the-model">Setting up the model</h3>
<hr class="subsection" />

<h4 class="subsubsection" id="loading-and-preparing-the-data">Loading and preparing the data</h4>
<hr class="subsubsection" />

<p>To begin, load in the sequences using the ‘readDiscreteCharacterData()‘
function.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data_cox2 = readDiscreteCharacterData("data/primates_and_galeopterus_cox2.nex")
data_cytb = readDiscreteCharacterData("data/primates_and_galeopterus_cytb.nex")
</code></pre></div></div>
<p>Since the first step in this exercise is to assume a single model across
genes, we need to combine the two datasets using
‘concatenate()‘</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data = concatenate( data_cox2, data_cytb )
</code></pre></div></div>
<p>Typing ‘data‘ reports the dimensions of the concatenated matrix, this
provides information about the alignment:</p>

<div class="language-plaintext Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   DNA character matrix with 23 taxa and 1837 characters
   =====================================================
   Origination:                   "primates_and_galeopterus_cox2.nex"
   Number of taxa:                23
   Number of included taxa:       23
   Number of characters:          1837
   Number of included characters: 1837
   Datatype:                      DNA
</code></pre></div></div>
<p>For later use, we will store the taxon information (‘taxa‘) and the
number of taxa and branches.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_taxa &lt;- data.ntaxa()
num_branches &lt;- 2 * n_taxa - 3
taxa &lt;- data.taxa()
</code></pre></div></div>
<p>Additionally, we will create our move and monitor vectors.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves    = VectorMoves()
monitors = VectorMonitors()
</code></pre></div></div>

<h4 class="subsubsection" id="substitution-model">Substitution model</h4>
<hr class="subsubsection" />

<p>Now we can proceed with building our GTR$+\Gamma$ model. First, we will
define and specify a prior on the exchangeability rates of the GTR model</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>er_prior &lt;- v(1,1,1,1,1,1) 
er ~ dnDirichlet( er_prior )
</code></pre></div></div>
<p>and assign its moves</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvBetaSimplex(er, alpha=10, tune=true, weight=3) )
moves.append( mvDirichletSimplex(er, alpha=10.0, tune=true, weight=1.0) )
</code></pre></div></div>
<p>We can use the same type of distribution as a prior on the 4 stationary
frequencies ($\pi_A, \pi_C, \pi_G, \pi_T$) since these parameters also
represent proportions. Specify a flat Dirichlet prior density on the
base frequencies:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi_prior &lt;- v(1,1,1,1) 
pi ~ dnDirichlet( pi_prior )
</code></pre></div></div>
<p>Now add the simplex scale move on the stationary frequencies to the
moves vector</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvBetaSimplex(pi, alpha=10, tune=true, weight=2) )
moves.append( mvDirichletSimplex(pi, alpha=10.0, tune=true, weight=1.0) )
</code></pre></div></div>
<p>We can finish setting up this part of the model by creating a
deterministic node for the GTR rate matrix ‘Q‘. The ‘fnGTR()‘ function
takes a set of exchangeability rates and a set of base frequencies to
compute the rate matrix used when calculating the likelihood of our
model.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnGTR(er,pi)
</code></pre></div></div>

<h4 class="subsubsection" id="among-site-rate-variation">Among site rate variation</h4>
<hr class="subsubsection" />

<p>We will also assume that the substitution rates vary among sites
according to an one-parametric gamma distribution,
i.e., where the shape equals the rate
($\alpha=\beta$) and thus with mean 1.0 <a class="citation" href="#Yang1994a">(Yang 1994)</a>. Since we do not
have good prior knowledge about the variance in site rates, we apply a uniform distribution between $1$ and $10^8$.
Then create a stochastic node called ‘alpha‘ with a uniform prior:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha ~ dnUniform( 0, 1E8 )
</code></pre></div></div>
<p>The way the ASRV model is implemented involves discretizing the mean-one
gamma distribution into a set number of rate categories. Thus, we can
analytically marginalize over the uncertainty in the rate at each site.
To do this, we need a deterministic node that is a vector of rates
calculated from the gamma distribution and the number of rate
categories. The ‘fnDiscretizeGamma()‘ function returns this
deterministic node and takes three arguments: the shape and rate of the
gamma distribution and the number of categories. Since we want to
discretize a mean-one gamma distribution, we can pass in ‘alpha‘ for
both the shape and rate.</p>

<p>Initialize the ‘gamma_rates‘ deterministic node vector using the
‘fnDiscretizeGamma()‘ function with ‘4‘ bins:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gamma_rates := fnDiscretizeGamma( alpha, alpha, 4, false )
</code></pre></div></div>
<p>The random variable that controls the rate variation is the stochastic
node ‘alpha‘. This variable is a single, real positive value (‘RevType =
RealPos‘). We will apply a simple scale move to this parameter. The
scale move’s tuning parameter is called ‘lambda‘ and this value dictates
the size of the proposal.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale(alpha, lambda=0.1, tune=false, weight=4.0) )
</code></pre></div></div>

<h2 class="section" id="invariant-sites">Invariant sites</h2>
<hr class="section" />

<p>Invariant sites (sites that remain fixed throughout their evolutionary
history) may be seen as an extreme case of among-site rate variation. In
contrast to $+ \Gamma$ models, the $+I$ model allows site some
probability of having substitution rate equal to zero. Here, we give the
probability of a site being invariant with ‘pinvar‘</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pinvar ~ dnBeta(1,1)
moves.append( mvBetaProbability(pinvar, delta=10.0, tune=true, weight=2.0) )
</code></pre></div></div>

<h2 class="section" id="tree-prior">Tree prior</h2>
<hr class="section" />

<p>The tree topology and branch lengths are also stochastic nodes in our
model. For simplicity, we will use the same prior distribution on the
tree topology, a uniform topology prior, and branch lengths, independent
exponential prior distributions, as done in the <a href="/tutorials/ctmc/">Nucleotide substitution models</a>.</p>

<p>We will assume that all possible labeled, unrooted tree topologies have
equal probability. This is the ‘dnUniformTopology()‘ distribution in
‘RevBayes‘. Note that in ‘RevBayes‘ it is advisable to specify the
outgroup for your study system if you use an unrooted tree prior,
whereas other software, e.g.,<code class="language-plaintext highlighter-rouge">MrBayes</code> uses the first
taxon in the data matrix file as the outgroup. Specify the ‘topology‘
stochastic node by passing in the tip labels ‘names‘ to the
‘dnUniformTopology()‘ distribution:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>out_group = clade("Galeopterus_variegatus")
topology ~ dnUniformTopology(taxa, outgroup=out_group)
</code></pre></div></div>
<p>To update the unrooted tree topology, we can use both a nearest-neighbor
interchange move (‘mvNNI‘) and a subtree-prune and regrafting move
(‘mvSPR‘). These moves do not have tuning parameters associated with
them, thus you only need to pass in the ‘topology‘ node and proposal
‘weight‘.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvNNI(topology, weight=n_taxa/2.0) )
moves.append( mvSPR(topology, weight=n_taxa/10.0) )
</code></pre></div></div>
<p>The weight specifies how often the move will be applied either on
average per iteration or relative to all other moves. Have a look at the
<a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_MCMC_Tutorial/RB_MCMC_Tutorial.pdf">MCMC Diagnosis
tutorial</a>
for more details about moves and MCMC strategies.</p>

<p>Next we have to create a stochastic node for each of the $2N-3$ branches
in our tree (where $N=$ ‘n_species‘). We can do this using a ‘for‘ loop
— this is a plate in our graphical model. In this loop, we can create
each of the branch-length nodes and assign each move. Copy this entire
block of ‘Rev‘ code into the console:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:num_branches) {
    br_lens[i] ~ dnExponential(10.0)
    moves.append( mvScale(br_lens[i]) )
}
</code></pre></div></div>
<p>It is convenient for monitoring purposes to add the tree length as
deterministic variable. The tree length is simply the sum of all branch
lengths. . Accordingly, the tree length can be computed using the
‘sum()‘ function, which calculates the sum of any vector of values.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TL := sum(br_lens)
</code></pre></div></div>
<p>Finally, we can create a <em>phylogram</em> (a phylogeny in which the branch
lengths are proportional to the expected number of substitutions/site)
by combining the tree topology and branch lengths. We do this using the
‘treeAssembly()‘ function, which applies the value of the $i^{th}$
member of the ‘br_lens‘ vector to the branch leading to the $i^{th}$
node in ‘topology‘. Thus, the ‘psi‘ variable is a deterministic node:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi := fnTreeAssembly(topology, br_lens)
</code></pre></div></div>

<h3 class="subsection" id="putting-it-all-together">Putting it All Together</h3>
<hr class="subsection" />

<p>We now have all the parameters needed to model the phylogenetic
molecular substitution process</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC(tree=psi, Q=Q,  siteRates=gamma_rates, pInv=pinvar, type="DNA")
</code></pre></div></div>
<p>To compute the likelihood, we condition the process on the data observed
at the tips of the tree</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq.clamp(data)
</code></pre></div></div>
<p>Since the model is now specified, we wrap the components in a
Model object.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_model = model(Q)
</code></pre></div></div>

<h4 class="subsubsection" id="specifying-monitors">Specifying Monitors</h4>
<hr class="subsubsection" />

<p>For our MCMC analysis we need to set up a vector of <em>monitors</em> to save
the states of our Markov chain. The monitor functions are all called
‘mn*‘, where ‘*‘ is the wildcard representing the monitor type. First,
we will initialize the model monitor using the ‘mnModel‘ function. This
creates a new monitor variable that will output the states for all model
parameters when passed into a MCMC function.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/PS_uniform.log",printgen=10) )
</code></pre></div></div>
<p>The ‘mnFile‘ monitor will record the states for only the parameters
passed in as arguments. We use this monitor to specify the output for
our sampled trees and branch lengths.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnFile(psi, filename="output/PS_uniform.trees", printgen=10) )
</code></pre></div></div>
<p>Finally, create a screen monitor that will report the states of
specified variables to the screen with ‘mnScreen‘:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(alpha, pinvar, TL, printgen=1000) )
</code></pre></div></div>

<h4 class="subsubsection" id="initializing-and-running-the-mcmc-simulation">Initializing and Running the MCMC Simulation</h4>
<hr class="subsubsection" />

<p>With a fully specified model, a set of monitors, and a set of moves, we
can now set up the MCMC algorithm that will sample parameter values in
proportion to their posterior probability. The ‘mcmc()‘ function will
create our MCMC object:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(my_model, monitors, moves, nruns=2, combine="mixed")
</code></pre></div></div>
<p>Note that this will automatically run two independent replicated MCMC
simulations because we specified ‘nruns=2‘.</p>

<p>Now, run the MCMC:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=30000, tuningInterval=200)
</code></pre></div></div>
<p>When the analysis is complete, you will have the monitor files in your
output directory.</p>

<p>‘RevBayes‘ can also summarize the tree samples by reading in the
tree-trace file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>treetrace = readTreeTrace("output/PS_uniform.trees", treetype="non-clock")
treetrace.summarize()
</code></pre></div></div>
<p>The ‘mapTree()‘ function will summarize the tree samples and write the
maximum a posteriori tree to file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>map_tree = mapTree(treetrace,"output/PS_uniform_map.tre")
</code></pre></div></div>
<p>This completes the uniform partition analysis. The next two sections
will implement more complex partitioning schemes in a similar manner.</p>

<h2 class="section" id="partitioning-by-gene-region">Partitioning by Gene Region</h2>
<hr class="section" />

<p><a href="https://youtu.be/LPPYGUP1FZc#t=17m06s"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>The uniform model used in the previous section assumes that all sites in
the alignment evolved under the same process described by a shared tree,
branch length proportions, and parameters of the GTR+$\Gamma$
substitution model. However, our alignment contains two distinct gene
regions—cytB and cox2—so we may wish to explore the possibility that the
substitution process differs between these two gene regions. This
requires that we first specify the data partitions corresponding to
these two genes, then define an independent substitution model for each
data partition.</p>

<p>First, we’ll clear the workspace of all declared variables</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear()
</code></pre></div></div>
<p>Since we wish to avoid individually specifying each parameter of the
GTR+$\Gamma$ model for each of our data partitions, we can <em>loop</em> over
our datasets and create vectors of nodes. To do this, we begin by
creating a vector of data file names:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filenames &lt;- v("data/primates_and_galeopterus_cox2.nex", "data/primates_and_galeopterus_cytb.nex")
</code></pre></div></div>
<p>Set a variable for the number of partitions:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_data_subsets &lt;- filenames.size()
</code></pre></div></div>
<p>Next we’ll create a vector of data matrices called ‘data‘, and a corresponding vector recording the number of sites in each partition:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_data_subsets){
    data[i] = readDiscreteCharacterData(filenames[i])
    num_sites[i] = data[i].nchar()
}
</code></pre></div></div>
<p>Now we can initialize some important variables. This does require,
however, that both of our alignments have the same number of species and
matching tip names.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taxa &lt;- data[1].taxa()
n_taxa &lt;- data[1].ntaxa()
num_branches &lt;- 2 * n_taxa - 3

moves    = VectorMoves()
monitors = VectorMonitors()
</code></pre></div></div>

<h3 class="subsection" id="specify-the-parameters-by-looping-over-partitions">Specify the Parameters by Looping Over Partitions</h3>
<hr class="subsection" />

<p>We can avoid creating unique names for every node in our model if we use
a ‘for‘ loop to iterate over our partitions. Thus, we will only have to
type in our entire GTR+$\Gamma$ model parameters once. This will produce
a vector for each of the unlinked parameters
—e.g., there will be a vector of ‘alpha‘
nodes where the stochastic node for the first partition (cytB) will be
‘alpha[1]‘ and the stochastic node for the second partition (cox2)
will be called ‘alpha[2]‘.</p>

<p>The script for the model,
RevBayes_scripts/mcmc_Partition_gene.Rev, creates the
model parameters for each partition in one large loop. Here, we will
split the loop into smaller parts to achieve the same end.</p>

<p>First, we will create the GTR rate matrix for partition $i$ by first
creating exchangeability rates</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_data_subsets) {
    er_prior[i] &lt;- v(1,1,1,1,1,1)
    er[i] ~ dnDirichlet(er_prior[i])
    moves.append( mvBetaSimplex(er[i], alpha=10, tune=true, weight=3) )
}
</code></pre></div></div>
<p>and stationary frequencies</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_data_subsets) {
    pi_prior[i] &lt;- v(1,1,1,1)
    pi[i] ~ dnDirichlet(pi_prior[i])
    moves.append( mvBetaSimplex(pi[i], alpha=10, tune=true, weight=2) )
}
</code></pre></div></div>
<p>then passing those parameters into a rate matrix function</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_data_subsets) {
    Q[i] := fnGTR(er[i],pi[i]) 
}
</code></pre></div></div>
<p>which states the rate matrix (Q[i]) for partition $i$ is
determined by the exchangeability rates (er[i]) and
stationary frequencies (pi[i]) also defined for partition
$i$. Following this format, we construct the remaining partition
parameters: the $+\Gamma$ mixture model</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_data_subsets) {
    alpha[i] ~ dnUniform( 0.0, 1E8 )
    gamma_rates[i] := fnDiscretizeGamma( alpha[i], alpha[i], 4, false )

    moves.append( mvScale(alpha[i],weight=2) )
}
</code></pre></div></div>
<p>the $+I$ invariant sites model</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_data_subsets) {
    pinvar[i] ~ dnBeta(1,1)
    moves.append( mvBetaProbability(pinvar[i], delta=10.0, tune=true, weight=2.0) )
}
</code></pre></div></div>
<p>and the per-partition substitution rate multipliers</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># specify a rate multiplier for each partition
part_rate_mult ~ dnDirichlet( rep(10.0, n_data_subsets) )
moves.append( mvBetaSimplex(part_rate_mult, alpha=1.0, tune=true, weight=n_data_subsets) )
moves.append( mvDirichletSimplex(part_rate_mult, alpha=1.0, tune=true, weight=2.0) )

# Note that here we are dividing two vectors element-wise, i.e., 
# each element of part_rate_mult gets divided by the corresponding
# element of num_sites. Then we multiply the result by sum(num_sites),
# which is just a scalar. This operation ensures that the mean of
# partition-specific branch lengths, weighted by the number of sites
# in each partition, stays equal to the branch lengths we are 
# actually sampling.

part_rate := part_rate_mult / num_sites * sum(num_sites)
</code></pre></div></div>

<blockquote class="aside"><h2>Different Substitution Models for each Gene</h2><p>Alternatively, we might be interested in applying different substitution
models for each gene independently instead of assuming the same
substitution albeit with different parameters for each gene. In this two
gene case this is rather simple to do by specifying the substitution
model for each gene independently. For many genes this might become
lengthy and you might want to write a script to generate this section
(note: we may provide such scripts soon).</p>

<p>For simplicity and sake of demonstration, we assume that the cytochrome
b region evolves under a Jukes-Cantor substitution model and the COX-II
gene under an HKY substitution model. We begin with the cytochrome b
gene and the Jukes-Cantor substitution model:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># specify the JC rate matrix
Q[1] &lt;- fnJC(4)
</code></pre></div></div>
<p>Second, we specify the HKY substitution model for the COX-II gene:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi_prior &lt;- v(1,1,1,1) 
pi ~ dnDirichlet(pi_prior)

# specify a move to propose updates to on pi
moves.append( mvBetaSimplex(pi, weight=2) )
moves.append( mvDirichletSimplex(pi, weight=1) )

# specify a lognormal distribution as the prior distribution on kappa
kappa ~ dnLognormal(0.0,1.25)

# a simple scaling move to update kappa
moves.append( mvScale(kappa) )

# Finally, create the HKY rate matrix
Q[2] := fnHKY(kappa,pi)
</code></pre></div></div>
<p>Note that we specified manually in this way our vector of rate matrices
‘Q‘. We can thus specify any substitution model manually for a given
gene. We hope that this brief example conveys the idea how to specify
gene-specific substitution models. You can add rate-variation among
sites and/or probabilities for a site being invariant for each gene too.
Finally, you can then either loop over all genes to create the
‘dnPhyloCTMC‘ distribution (see below) if the structure of the model
allows it (<em>i.e.,</em>if all models have a
variable for site-rate-variation and probabilities for invariant site),
or you efficiently set these variables to default values
(<em>e.g.,</em>‘pinvar[i]=0.0‘ if there is no
probability for a site being invariant for this gene), or you create the
‘seq[i] $\sim$ dnPhyloCTMC(…)‘ manually outside a loop as well.</p>
</blockquote>

<h4 class="subsubsection" id="tree-prior">Tree prior</h4>
<hr class="subsubsection" />

<p>We assume that both genes evolve along the same tree. Hence, we need to
specify a random variable for our tree parameter which is the same as
was specified for mcmc_Partition_uniform.Rev.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>out_group = clade("Galeopterus_variegatus")
# Prior distribution on the tree topology
topology ~ dnUniformTopology(taxa, outgroup=out_group)
moves.append( mvNNI(topology, weight=n_taxa/2.0) )
moves.append( mvSPR(topology, weight=n_taxa/10.0) )

# Branch length prior
for (i in 1:num_branches) {
    bl[i] ~ dnExponential(10.0)
    moves.append( mvScale(bl[i]) )
}

TL := sum(bl)

psi := treeAssembly(topology, bl)
</code></pre></div></div>

<h3 class="subsection" id="putting-it-all-together">Putting it all together</h3>
<hr class="subsection" />

<p>Since we have a rate matrix and a site-rate model for each partition, we
must create a phylogenetic CTMC for each gene. Additionally, we must fix
the values of these nodes by attaching their respective data matrices.
These two nodes are linked by the ‘psi‘ node and their log-likelihoods
are added to get the likelihood of the whole DAG.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_data_subsets) {
    seq[i] ~ dnPhyloCTMC(tree=psi, Q=Q[i], branchRates=part_rate[i], siteRates=gamma_rates[i], pInv=pinvar[i], type="DNA")
    seq[i].clamp(data[i])
}
</code></pre></div></div>
<p>The remaining steps should be familiar: wrap the model components in a
model object</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_model = model(psi)
</code></pre></div></div>

<h4 class="subsubsection" id="create-monitors">Create monitors</h4>
<hr class="subsubsection" />

<p>create the monitors</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/PS_gene.log",printgen=10) )
monitors.append( mnFile(psi, filename="output/PS_gene.trees", printgen=100) )
monitors.append( mnScreen(TL, printgen=1000) )
</code></pre></div></div>
<p>configure and run the MCMC analysis</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(my_model, moves, monitors, nruns=2, combine="mixed")
mymcmc.run(30000,tuningInterval=200)
</code></pre></div></div>
<p>and summarize the posterior density of trees with a MAP tree</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>treetrace = readTreeTrace("output/PS_gene.trees", treetype="non-clock")
treetrace.summarize()
mapTree(treetrace,"output/PS_gene_MAP.tre")
</code></pre></div></div>

<h2 class="section" id="partitioning-by-codon-position-and-by-gene">Partitioning by Codon Position and by Gene</h2>
<hr class="section" />

<p><a href="https://youtu.be/LPPYGUP1FZc#t=25m37s"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<p>Because of the genetic code, we often find that different positions
within a codon (first, second, and third) evolve at different rates.
Thus, using our knowledge of biological data, we can devise a third
approach that further partitions our alignment. For this exercise, we
will partition sites within the cytB and cox2 gene by codon position.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clear()
data_cox2 &lt;- readDiscreteCharacterData("data/primates_and_galeopterus_cox2.nex")
data_cytb &lt;- readDiscreteCharacterData("data/primates_and_galeopterus_cytb.nex")
</code></pre></div></div>
<p>We must now add our codon-partitions to the ‘data‘ vector. The first and
second elements in the data vector will describe cytB data,
and the third and fourth elements will describe cox2 data. Moreover, the
first and third elements will describe the evolutionary process for the
first and second codon position sites, while the second and fourth
elements describe the process for the third codon position sites alone.</p>

<p>We can create this by calling the helper function ‘setCodonPartition()‘,
which is a member function of the data matrix. We are assuming that the
gene is <em>in frame</em>, meaning the first column in your alignment is a
first codon position. The ‘setCodonPartition()‘ function takes a single
argument, the position of the alignment you wish to extract. It then
returns every third column, starting at the index provided as an
argument.</p>

<p>Before we can use the use the ‘setCodonPartition()‘ function, we must
first populate the position in the ‘data‘ matrix with some sequences.
Then we call the member function of ‘data[1]‘ to exclude all but the
1$^{st}$ and 2$^{nd}$ positions for cox2.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data[1] &lt;- data_cox2
data[1].setCodonPartition( v(1,2) )
</code></pre></div></div>
<p>Assign the 3$^{rd}$ codon positions for cox2 to ‘data[2]‘:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data[2] &lt;- data_cox2
data[2].setCodonPartition( 3 )
</code></pre></div></div>
<p>Then repeat for cytB, being careful to store the subsetted data to
elements 3 and 4:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data[3] &lt;- data_cytb
data[3].setCodonPartition( v(1,2) )
data[4] &lt;- data_cytb
data[4].setCodonPartition( 3 )
</code></pre></div></div>
<p>Now we have a data vector containing each subset. We can then specify
the independent substitution models per data subset. The remaining parts
of the model are identical to the previous exercise where we partitioned
by gene.</p>

<p>Don’t forget to rename the output files!</p>

<h2 class="section" id="exercises">Exercises</h2>
<hr class="section" />

<p><a href="https://youtu.be/LPPYGUP1FZc#t=29m11s"><img src="/assets/img/YouTube_icon.svg" alt="Walkthrough video" height="36" width="36" /></a></p>

<ol>
  <li>
    <p><strong>Reviewing posterior estimates.</strong> Open the
PS_codon.log file in <code class="language-plaintext highlighter-rouge">Tracer</code>. Remember
that data subsets 1 and 2 are for cox2, partitions 3 and 4 are for
cytB, subsets 1 and 3 are for sites in the first and second codon
positions (per gene), and subsets 2 and 4 are for sites in the third
and fourth codon positions (per gene).</p>

    <p>Aside from the tree topology and branch lengths, each data subset is
modeled to have its own set of parameters. However, the posterior
estimates for some parameters appear quite similar between some
pairs of subsets yet different between other pairs of subsets. For
example, part_rate is the per-subset substitution
rate. This clock is approximately one order of magnitude faster for
partitions 2 and 4 (third codon position sites) than it is for
subsets 1 and 3 (non-third codon position sites).</p>

    <p>Identify other parameter-subset relationships like this in the
posterior. Under this model, would you consider the gene or the
codon site position to hold greater influence over the site’s
evolutionary mode?</p>
  </li>
  <li>
    <p><strong>Comparison of MAP trees.</strong> Open the three inferred
MAP trees in <code class="language-plaintext highlighter-rouge">FigTree</code>. Check to enable “Node Labels”,
click “Display” and select “posterior” from the dropdown menu.
Internal nodes now report the probability of the clade appearing in
the posterior density of sampled trees. Do different models yield
different tree topologies? Generally, do complex models provide
higher or lower clade support?</p>
  </li>
  <li>
    <p><strong>Partitioned model selection.</strong> Bayes factors are
computed as the ratio of marginal likelihoods (see <a href="/tutorials/model_selection_bayes_factors/bf_intro.html">General Introduction to Model selection</a>
for more details). Rather than constructing the analysis with an
mcmc object, marginal likelihood computations rely on
output from a powerPosterior object.</p>

    <p>Copy mcmc_Partition_uniform.Rev to
ml_Partition_uniform.Rev. In
ml_Partition_uniform.Rev, delete all lines after the
model function is called, so the MCMC is never run and
the MAP tree is never computed.</p>

    <p>Instead, configure and run a power posterior analysis</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pow_p = powerPosterior(mymodel, moves, monitors, "output/model_uniform.out", cats=127)
pow_p.burnin(generations=5000,tuningInterval=200)
pow_p.run(generations=2000)
</code></pre></div>    </div>
    <p>then compute the marginal likelihood using the stepping stone
sampler</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ss = steppingStoneSampler(file="output/model_uniform.out", powerColumnName="power", likelihoodColumnName="likelihood")
ss.marginal()
</code></pre></div>    </div>
    <p>and again using the path sampler</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps = pathSampler(file="model_uniform.out", powerColumnName="power", likelihoodColumnName="likelihood")
ps.marginal()
</code></pre></div>    </div>
  </li>
</ol>


<ol class="bibliography"><li><span id="Brown2007">Brown J.M., Lemmon A.R. 2007. The importance of data partitioning and the utility of Bayes factors in Bayesian phylogenetics. Systematic Biology. 56:643–655.</span>

<a href="https://doi.org/10.1080/10635150701546249">10.1080/10635150701546249</a>

</li>
<li><span id="Hoehna2017a">Höhna S., Landis M.J., Heath T.A. 2017. Phylogenetic Inference using RevBayes. Current Protocols in Bioinformatics.</span>

<a href="https://doi.org/10.1002/cpbi.22">10.1002/cpbi.22</a>

</li>
<li><span id="Ronquist2003">Ronquist F., Huelsenbeck J.P. 2003. MrBayes 3: Bayesian phylogenetic inference under mixed models. Bioinformatics. 19:1572–1574.</span>

<a href="https://doi.org/10.1093/bioinformatics/btg180">10.1093/bioinformatics/btg180</a>

</li>
<li><span id="Suchard2001">Suchard M.A., Weiss R.E., Sinsheimer J.S. 2001. Bayesian Selection of Continuous-Time Markov Chain Evolutionary Models. Molecular Biology and Evolution. 18:1001–1013.</span>

</li>
<li><span id="Yang1994a">Yang Z. 1994. Maximum Likelihood Phylogenetic Estimation from DNA Sequences with Variable Rates Over Sites: Approximate Methods. Journal of Molecular Evolution. 39:306–314.</span>

<a href="https://doi.org/10.1007/BF00160154">10.1007/BF00160154</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
