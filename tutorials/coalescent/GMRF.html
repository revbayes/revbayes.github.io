<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Skyline Models with GMRF</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="https://revbayes.github.io/revscripter/">RevScripter</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><<a href="/gui">GUI</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Skyline Models with GMRF</h1>
	<h3 class="subtitle">Estimating Demographic Histories with Skyline Models using a Gaussian Markov Random Field Prior</h3>
	<h4 class="authors">Ronja Billenstein and Sebastian Höhna</h4>
  <h5>Last modified on February 25, 2022</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/coalescent/">Coalescent Analyses</a></li>
          
            <li><a href="/tutorials/coalescent/constant.html">Constant Coalescent Process</a></li>
          
            <li><a href="/tutorials/coalescent/skyline.html">Skyline Models</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Other</strong>
        <ul id="other_files">
        
        
        
          <li><a href="/tutorials/coalescent/data/horses_homochronous_sequences.fasta">horses_homochronous_sequences.fasta</a></li>
        
          <li><a href="/tutorials/coalescent/scripts/mcmc_homochronous_GMRF.Rev">mcmc_homochronous_GMRF.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="overview">Overview</h2>
<hr class="section" />

<p>This tutorial describes how to run a Coaelescent Skyline Analysis with a Gaussian Markov Random Field (GMRF) prior in <code class="language-plaintext highlighter-rouge">RevBayes</code>.
This is a special case of a skyline plot.
The most notable difference to the previous exercise is that the population size is autocorrelated, <em>i.e.</em>, each population size has a prior distribution that is centered on the population size from the previous, more recent, interval.
This leads to a smoothing effect of the population size trajectory with adjacent intervals most likely having similar population size values.
In case of a strong signal from the data indicating a change in population size, however, this can also be reflected in the resulting trajectory.
Here, the intervals additionally are equally spaced and thus their start and end points are independent from the coalescent events (see <a href="#equalsize-skyline"></a> for a hypothetical example).
<!--- Furthermore, each interval's population size has a prior based on the previous, more recent interval (remember that we start in the present and go backwards in time for coalescent processes). ---></p>

<figure id="equalsize-skyline"><p align="middle">
  <img src="figures/scheme_equalsize_skyline.png" />
</p>
<figcaption>Hypothetical example of a Bayesian skyline plot with equally sized intervals, independent from the number of coalescent events (equal-sized).</figcaption>
</figure>

<blockquote class="aside"><h2>Likelihood Calculation</h2><p><strong>ADD</strong></p>

<p>We assume that the phylogeny of the samples is known.
There are $n$ samples, with $k$ active lineages at the current point in time $t$.
Time starts at $t = 0$.
The waiting times between coalescent events $w_k$ are exponentially distributed with rate $c = \frac{k (k-1)}{2N_e(t)}$ with $N_e$ being the population size.
<!--- In the case of a skyline plot, the population size curve is split into $m$ intervals which each have a starting point $t_i$. ---></p>

<p>The likelihood for a Skyline Plot is the product of the probability density functions of the coalescent waiting times, which are calculated as follows:</p>

\[p(w_k | t_k) = \frac{k (k -1)}{2N_e(t_k + w_k)} exp \left[ \int_{t_k}^{t_k+w_k} \frac{k (k -1)}{2N_e(t)} dt \right]\]

<p>Each $t_k$ is the beginning of the respective kth coalescent interval.
The waiting times $w_k$ refer to the waiting time starting when there are $k$ active lineages.</p>

<!--- In our case, $N_e(t)$ is a piecewise constant demographic function with $m$ intervals which each have a starting point $t_i$ and the length $l$.
**Do I need to go into the intervals here?** --->
</blockquote>

<h2 class="section" id="inference-example">Inference Example</h2>
<hr class="section" />

<blockquote class="info">
  <h2 id="for-your-info">For your info</h2>
  <p>The entire process of the GMRF based estimation can be executed by using the <strong>mcmc_homochronous_GMRF.Rev</strong> script in the <strong>scripts</strong> folder.
You can type the following command into <code class="language-plaintext highlighter-rouge">RevBayes</code>:</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mcmc_homochronous_GMRF.Rev")
</code></pre></div>  </div>
  <p>We will walk you through the script in the following section.</p>
</blockquote>

<p>We will mainly highlight the parts of the script that change compared to the <a href="/tutorials/coalescent/constant">constant coalescent model</a> and the <a href="/tutorials/coalescent/skyline">skyline model</a>.</p>

<h3 class="subsection" id="read-the-data">Read the data</h3>
<hr class="subsection" />

<p>Read in the data as described in the first exercise.</p>

<h3 class="subsection" id="the-gmrf-model">The GMRF Model</h3>
<hr class="subsection" />

<p>For the GMRF model, you need to decide on the number of intervals.
These are equally distributed in time.
For a simple, quickly computed, example, we choose $10$ intervals here.
Later, feel free to try the analysis with more intervals, for example $100$.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NUM_INTERVALS = 10
</code></pre></div></div>

<p>You will also need to define the points of change in time to reflect the equal size of the intervals.
Here, we define the maximal age to be $500000$ which should cover the whole tree (based on our results from the previous exercises).
Further backwards in time the population size is thought to be in equilibrium and to be equal to the population size of the most ancient interval.
The first interval (automatically) starts at $t = 0$, the other starting points depend on the number of intervals and the maximal age.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MAX_AGE = 500000

for (i in 1:(NUM_INTERVALS-1)) {

    changePoints[i] &lt;- i * ((MAX_AGE)/NUM_INTERVALS)

}
</code></pre></div></div>

<p>For each interval, a population size will be estimated.
In this case, the most recent population size (<code class="language-plaintext highlighter-rouge">population_size_at_present</code>) is treated differently to the other population sizes.
This is due to the fact that all other population size priors depend on the one more recent.
For <code class="language-plaintext highlighter-rouge">population_size_at_present</code> we assume the same prior distribution and initial value as in the previous exercises.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_size_at_present ~ dnUniform(0,1E8)
population_size_at_present.setValue(100)
</code></pre></div></div>

<p>Note that we apply three different moves to the recent population size here: a scaling move (<code class="language-plaintext highlighter-rouge">mvScaleBactrian</code>), a mirror move (<code class="language-plaintext highlighter-rouge">mvMirrorMultiplier</code>) and a random dive move (<code class="language-plaintext highlighter-rouge">mvRandomDive</code>).
The scaling move multiplies the currently proposed value with a scaling factor, the mirror move “mirrors” a value from a normal distribution on the other side of the posterior mean and the random dive move is a different type of scaling move.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScaleBactrian(population_size_at_present,weight=5) )
moves.append( mvMirrorMultiplier(population_size_at_present,weight=5) )
moves.append( mvRandomDive(population_size_at_present,weight=5) )
</code></pre></div></div>

<p>In the GMRF model implemented in <code class="language-plaintext highlighter-rouge">RevBayes</code>, we do not set priors on the remaining population sizes, but on the log-scale differences between population sizes (<code class="language-plaintext highlighter-rouge">delta_log_population_size</code>).
This way, the estimated parameters can be treated as independent even with the auto-correlation of the population sizes and MCMC sampling is easier.
The overall variability of the trajectory is controlled by the standard deviation of the Normal distribution from which these <code class="language-plaintext highlighter-rouge">delta_log_population_size</code> values are drawn.
This standard deviation is the product of a global scale parameter and its hyperprior.
Therefore, you first need to define the hyperprior for the global scale parameter. <!--- which controls the overall variability of population sizes from present to past. --->
You can get the appropriate value for this hyperprior dependent on the number of change points by using the <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">RevGadgets</code>.
Here, we ran the function <code class="language-plaintext highlighter-rouge">setMRFGlobalScaleHyperpriorNShifts(9, "GMRF")</code> to know the value of $0.1203$ (remember that there are nine change points with ten intervals).
To have a prior distribution on <code class="language-plaintext highlighter-rouge">delta_log_population_size</code> which favors autocorrelation, but allows for sudden changes, a halfCauchy distribution is chosen for the global scale.
We also add a scaling move to the global scale.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_size_global_scale_hyperprior &lt;- 0.1203
population_size_global_scale ~ dnHalfCauchy(0,1)

moves.append( mvScaleBactrian(population_size_global_scale,weight=5.0) )
</code></pre></div></div>

<!--- For each interval we define the prior for the delta log population size to be a Normal Distribution with the standard deviation dependent on the global scale and its hyperprior. --->
<p>The standard deviation of the aforementioned Normal distribution of the <code class="language-plaintext highlighter-rouge">delta_log_population_size</code> values can now be defined by multiplying the global scale hyperprior with the global scale.
Here, we achieve all desired properties (favoring similar values but allowing for flexibility) by multiplying a halfCauchy(0,1) distribution with the value of the hyperprior ($0.1203$) that we calculated before.
This is just a hierarchical way of defining a halfCauchy(0,$0.1203$) distribution. <strong>(Is this true?)</strong>
We add a sliding move to the <code class="language-plaintext highlighter-rouge">delta_log_population_size</code> values.
Note that in <code class="language-plaintext highlighter-rouge">RevBayes</code> the standard deviation (<code class="language-plaintext highlighter-rouge">sd</code>) is used as input for the Normal distribution instead of the variance of the distribution (which would be the square of the standard deviation).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:(NUM_INTERVALS-1)) {
  # non-centralized parameterization
  delta_log_population_size[i] ~ dnNormal( mean=0, sd=population_size_global_scale*population_size_global_scale_hyperprior )
  # Make sure values initialize to something reasonable
  delta_log_population_size[i].setValue(runif(1,-0.1,0.1)[1])
  moves.append( mvSlideBactrian(delta_log_population_size[i], weight=5) )
}
</code></pre></div></div>

<p>Finally, the different population sizes need to be combined to form the vector of population sizes that we want to see as result in the end.
In <code class="language-plaintext highlighter-rouge">RevBayes</code>, a function for this kind of assembly is implemented: <code class="language-plaintext highlighter-rouge">fnassembleContinuousMRF</code>.
Note that you could also define the first value on a log scale, but then need to adjust the value of <code class="language-plaintext highlighter-rouge">initialValueIsLogScale</code> to be <code class="language-plaintext highlighter-rouge">TRUE</code>.
This analysis is based on a GMRF of order $1$.
Higher order GMRF also exist, but will not be discussed here.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>population_size := fnassembleContinuousMRF(population_size_at_present,delta_log_population_size,initialValueIsLogScale=FALSE,order=1)
</code></pre></div></div>

<p>For this kind of analysis, the <code class="language-plaintext highlighter-rouge">mvEllipticalSliceSamplingSimple</code> move has to be added.
Without it, convergence would be difficult to achive.
Of course, we also need to add moves for the different population size parameters.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Move all field parameters in one go
moves.append( mvEllipticalSliceSamplingSimple(delta_log_population_size,weight=5,tune=FALSE) )
# joint sliding moves of all vector elements
moves.append( mvVectorSlide(delta_log_population_size, weight=10) )
# up-down slide of the entire vector and the rate at present
rates_up_down_move = mvUpDownScale(weight=10.0)
rates_up_down_move.addVariable(population_size_at_present,FALSE)
rates_up_down_move.addVariable(delta_log_population_size,TRUE)
moves.append( rates_up_down_move )
# shrink expand moves
moves.append( mvShrinkExpand( delta_log_population_size, sd=population_size_global_scale, weight=10 ) )
</code></pre></div></div>

<p>If you are interested in more details on why the analysis is set up in this way, have a look at the <a href="/tutorials/divrate/ebd.html">Episodic Diversification Rate Estimation</a> tutorial where an analysis is performed with a similar model.
Also, the <a class="citation" href="#Magee2020">Magee et al. (2020)</a> paper provides further background information on these kinds of analysis.</p>

<h3 class="subsection" id="the-tree">The Tree</h3>
<hr class="subsection" />

<p>Now, we will instantiate the stochastic node for the tree.
Similar to the skyline exercise, we use the <code class="language-plaintext highlighter-rouge">dnCoalescentSkyline</code> distribution for the tree.
In the GMRF case, however, the method is not based on events, but has specified intervals.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi ~ dnCoalescentSkyline(theta=population_size, times=changePoints, method="specified", taxa=taxa)
</code></pre></div></div>

<p>In order to be able to later plot and analyze the population size curve, we can retrieve the resulting interval times as for the skyline exercise.
Here, they should not change, so you might as well omit this line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interval_times := psi.getIntervalAges()
</code></pre></div></div>

<p>Again, we constrain the root age as before and add the same moves for the tree.</p>

<h3 class="subsection" id="substitution-model-and-other-parameters">Substitution Model and other parameters</h3>
<hr class="subsection" />

<p>This part is also taken from the constant coalescent exercise.</p>

<h3 class="subsection" id="finalize-and-run-the-analysis">Finalize and run the analysis</h3>
<hr class="subsection" />

<p>In the end, we need to wrap our model as before.</p>

<p>Finally, we add the monitors and then run the MCMC.
Remember to change the file names to avoid overwriting your previous results.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/horses_GMRF.log",printgen=THINNING) )
monitors.append( mnFile(filename="output/horses_GMRF.trees",psi,printgen=THINNING) )
monitors.append( mnFile(filename="output/horses_GMRF_NEs.log",population_size,printgen=THINNING) )
# monitors.append( mnFile(filename="output/horses_GMRF_times.log",interval_times,printgen=THINNING) )
monitors.append( mnScreen(population_size, root_age, printgen=100) )

mymcmc = mcmc(mymodel, monitors, moves)
mymcmc.burnin(NUM_MCMC_ITERATIONS*0.1,100)
mymcmc.run(NUM_MCMC_ITERATIONS, tuning = 100)
</code></pre></div></div>

<h2 class="section" id="results">Results</h2>
<hr class="section" />

<p>After running your analysis, you can plot the results using the <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">RevGadgets</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(RevGadgets)

burnin = 0.1
probs = c(0.025, 0.975)
summary = "median"

population_size_log = "output/horses_GMRF_NEs.log"
interval_change_points_log = "output/horses_GMRF_times.log"
df &lt;- processPopSizes(population_size_log, interval_change_points_log, method = "specified", burnin = burnin, probs = probs, summary = summary)
p &lt;- plotPopSizes(df, method = "specified") + ggplot2::coord_cartesian(ylim = c(1e3, 1e8))
ggplot2::ggsave("horses_GMRF.png", p)
</code></pre></div></div>

<!--- In the example, we set the limits of the x-axis to the root age value from the next exercise (see below).
This was done to be able to easily compare the plots. --->

<figure id="example_skyline"><p><img src="figures/horses_GMRF.png" width="800" /></p>
<figcaption>This is how the resulting GMRF skyline plot should roughly look like.</figcaption>
</figure>

<h2 class="section" id="the-horseshoe-markov-random-field-prior">The Horseshoe Markov Random Field Prior</h2>
<hr class="section" />

<p>Related to the GMRF, there also is the Horseshoe Markov Random Field (HSMRF) prior.
It can be seen as a more generalized version of the GMRF with the difference lying in the definition of the standard deviation of the values in the intervals <a class="citation" href="#Faulkner2020">(Faulkner et al. 2020; Magee et al. 2020)</a>.
It is even more flexible, because each interval has an additional variable assigned to the variation.
Thus, you don’t only change the global scale of variability, but the local scale in each interval.
The GMRF can be seen as a special case, where this local scale value is set to $1$.
In the tutorial <a href="/tutorials/divrate/ebd.html">Episodic Diversification Rate Estimation</a>, the HSMRF prior is applied to the estimation of diversification rates.
Have a look at the <strong>Specifying the model</strong> section and try to change the respective lines in your current script to follow the HSMRF procedure.
Do your results look different?</p>

<blockquote class="aside"><h2>Hint</h2><p>The lines you should look at are lines 67 to 73 in the script.
There, you can change the way the standard deviation of the population sizes per interval is calculated.
It now has an additional value <code class="language-plaintext highlighter-rouge">sigma_population_size</code> for each interval.
This is the local scale parameter.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:(NUM_INTERVALS-1)) {
  # Variable-scaled variances for hierarchical horseshoe
  sigma_population_size[i] ~ dnHalfCauchy(0,1)
  # Make sure values initialize to something reasonable
  sigma_population_size[i].setValue(runif(1,0.005,0.1)[1])
  # moves on the single sigma values
  moves.append( mvScaleBactrian(sigma_population_size[i], weight=5) )
  # non-centralized parameterization of horseshoe
  delta_log_population_size[i] ~ dnNormal( mean=0, sd=sigma_population_size[i]*population_size_global_scale*population_size_global_scale_hyperprior )
  # Make sure values initialize to something reasonable
  delta_log_population_size[i].setValue(runif(1,-0.1,0.1)[1])
  moves.append( mvSlideBactrian(delta_log_population_size[i], weight=5) )
}
</code></pre></div></div>

<p>Remember to change the hyperprior value (<code class="language-plaintext highlighter-rouge">setMRFGlobalScaleHyperpriorNShifts(10, "HSMRF")</code> in <code class="language-plaintext highlighter-rouge">RevGadgets</code>) and to add extra moves.</p>

<p>In case you prefer to download a whole HSMRF script to compare it to the GMRF script, have a look at <a href="/tutorials/coalescent/HSMRF">the HSMRF</a>.</p>
</blockquote>

<h2 class="section" id="the-compound-poisson-process-prior">The Compound Poisson Process Prior</h2>
<hr class="section" />

<p>It is also possible to have a flexible number of intervals instead of specifying it before the analysis.
In this case, the number of intervals is also estimated.
Here, we use a compound poisson process (CPP) prior with a poisson prior on the number of interval change points and two different uniform priors on the population sizes and the change points.
In this case, a reversible jump MCMC (rjMCMC) is needed to be able to sample from the posterior distribution.
In <code class="language-plaintext highlighter-rouge">RevBayes</code>, this functionality is implemented in the <code class="language-plaintext highlighter-rouge">dnMultiValueEvent</code> distribution.</p>

<blockquote class="aside"><h2>Reversible Jump MCMC with CPP prior</h2><!--- In RevBayes, there also is the possibility to estimate the number of intervals via reversible jump MCMC (rjMCMC).
In this approach, you don't specifically set the number of intervals before the analysis, but make it a parameter that is estimated as part of the analysis.
--->
<p>For the <code class="language-plaintext highlighter-rouge">eventDistribution</code> parameter, a distribution on natural numbers has to be chosen.
These “events” are the number of change points seperating intervals in this case and not coalescent events.
In this example, we use a Poisson distribution with an expected value of $10$.
The <code class="language-plaintext highlighter-rouge">valueDistribution</code> is a vector of prior distributions for the population sizes and the interval times.
We also should call the variables by their names.
The <code class="language-plaintext highlighter-rouge">minNumberEvents</code> are $1$ population size and $0$ times corresponding to interval changes.
We expect to always have one more population size than change points.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>events ~ dnMultiValueEvent (eventDistribution = dnPoisson(lambda=10),
                   valueDistribution=[dnUniform(1E4,1E8),
                                      dnUniform(0.0,MAX_AGE)],
                   names=["theta","time"],
                   minNumberEvents=[1,0])
</code></pre></div></div>
<p>Fo the <code class="language-plaintext highlighter-rouge">dnMultiValueEvent</code> distribution, we add specific moves.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># apply a move that adds and removes pairs of theta+time
moves.append( mvMultiValueEventBirthDeath(events, weight=50) )
# add a move that changes the theta variables
moves.append( mvMultiValueEventScale(events, name="theta", lambda=1.0, weight=10, tune=!FALSE) )
# add a move that changes the time variables
moves.append( mvMultiValueEventSlide(events, name="time", lambda=10.0, weight=10, tune=!FALSE) )
moves.append( mvMultiValueEventScale(events, name="time", lambda=0.5, weight=10, tune=!FALSE) )
</code></pre></div></div>
<p>Finally, we need to track the different parameters by assigning them to variables.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_events := events.getNumberOfEvents()
population_size := events.getRealPosValues(name="theta")
changePoints := events.getRealPosValues(name="time")
</code></pre></div></div>
<p>In the end, all the parameters can be put into the <code class="language-plaintext highlighter-rouge">dnCoalescentSkyline</code> distribution.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi ~ dnCoalescentSkyline(theta=population_size, times=changePoints, method="specified", taxa=taxa)
</code></pre></div></div>

<p>You can have a look at the results <a href="/tutorials/coalescent/CPP">here</a></p>
</blockquote>

<h2 class="section" id="next-exercise">Next Exercise</h2>
<hr class="section" />

<p>When you are done, have a look at the next exercise.</p>

<ul>
  <li><a href="/tutorials/coalescent/GMRF_treebased">The GMRF model with trees as input data</a></li>
</ul>

<ol class="bibliography"><li><span id="Faulkner2020">Faulkner J.R., Magee A.F., Shapiro B., Minin V.N. 2020. Horseshoe-based Bayesian nonparametric estimation of effective population size trajectories. Biometrics. 76:677–690.</span>

<a href="https://doi.org/https://doi.org/10.1111/biom.13276">https://doi.org/10.1111/biom.13276</a>

</li>
<li><span id="Magee2020">Magee A.F., Höhna S., Vasylyeva T.I., Leaché A.D., Minin V.N. 2020. Locally adaptive Bayesian birth-death model successfully detects slow and rapid rate shifts. PLoS Computational Biology. 16:e1007999.</span>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

  </body>
</html>
