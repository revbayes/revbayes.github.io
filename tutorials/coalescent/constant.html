<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Constant Coalescent Process</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="https://revbayes.github.io/revscripter/">RevScripter</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><<a href="/gui">GUI</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Constant Coalescent Process</h1>
	<h3 class="subtitle">Estimating Demographic Histories with a Constant Coalescent Process</h3>
	<h4 class="authors">Ronja Billenstein and Sebastian Höhna</h4>
  <h5>Last modified on February 23, 2022</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/coalescent/">Coalescent Analyses</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Other</strong>
        <ul id="other_files">
        
        
        
          <li><a href="/tutorials/coalescent/data/horses_homochronous_sequences.fasta">horses_homochronous_sequences.fasta</a></li>
        
          <li><a href="/tutorials/coalescent/scripts/mcmc_homochronous_constant.Rev">mcmc_homochronous_constant.Rev</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="overview">Overview</h2>
<hr class="section" />

<p>This exercise describes how to run a simple coalescent analysis in <code class="language-plaintext highlighter-rouge">RevBayes</code>.
The simplest coalescent model is one with a constant population size through time.
This population size is estimated solely based on the waiting times between coalescent events.</p>

<h3 class="subsection" id="the-coalescent">The Coalescent</h3>
<hr class="subsection" />

<p>The coalescent process constructs a tree backwards in time.
Starting from the samples, lineages are merged (<em>i.e.,</em> coalesced), always two at a time.
Under the coalescent process, the waiting time between two coalescent events is exponentially distributed and depends on the number of ‘active’ lineages and the effective population size $N_e$.
Active lineages are the ones that can coalesce, the number is reduced by one with every coalescent event.
The coalescent process was first introduced by Kingman in 1982 for a constant population size <a class="citation" href="#Kingman1982">(Kingman 1982)</a>.
<!---Griffiths and Tavaré then extended the model to be applicable to varying population sizes <a class="citation" href="#Griffiths1994">(Griffiths et al. 1994)</a>.---></p>

<p>In the constant coalescent process, a single population size is assumed for the whole tree.
The relationship betweeen coalescent waiting times and effective population size is defined through the coalescent rate: $c = \frac{k (k-1)}{2N_e}$ with $k$ being the number of currently active lineages and $N_e$ being the effective population size.</p>

<p>In <a href="#coalescent"></a>, a general scheme is shown.
Waiting times are in between coalescent events.
In later exercises, we will not have a single constant population size, but population sizes in different intervals.
The <a href="/tutorials/coalescent/skyline">skyline model</a> applies an event-based system (violet), whereas the <a href="/tutorials/coalescent/GMRF">Gaussian Markov Random Field (GMRF) model</a> has equally sized intervals (green).</p>

<figure id="coalescent"><p><img src="figures/scheme_constant.png" width="800" /></p>
<figcaption>Schematic figure of a coalescent tree and the different times associated with it. $w_k$ are the waiting times with $k$ active lineages, $t_{ck}$ are the coalescent events at the beginning of such a coalescent interval. Here, an example of a constant population size trajectory is shown. The bold line represents the median of the posterior distribution and the shaded are shows the $95%$ credible intervals.</figcaption>
</figure>

<!--- <blockquote class="aside"><h2>Likelihood Calculation</h2><p>…</p>
</blockquote> --->

<h2 class="section" id="inference-example">Inference Example</h2>
<hr class="section" />

<blockquote class="info">
  <h2 id="for-your-info">For your info</h2>
  <p>The entire process of the estimation can be executed by using the <strong>mcmc_homochronous_constant.Rev</strong> script that you can download on the left side of the page.
Save it in your <strong>scripts</strong> directory.
You can type the following command into <code class="language-plaintext highlighter-rouge">RevBayes</code>:</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mcmc_homochronous_constant.Rev")
</code></pre></div>  </div>
  <p>We will walk you through every single step in the following section.</p>
</blockquote>

<p>For every MCMC analysis, convergence assessment is an important step.
In the tutorial <a href="/tutorials/convergence/">Convergence assessment</a>, you can find information and instructions on how to run the convergence assessment with the <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">convenience</code>.
It is generally recommended to have at least two replicates per MCMC analysis to be able to compare convergence between runs.
Thus, we first set the number of replicates:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NUM_REPLICATES      = 2
</code></pre></div></div>

<p>In the beginning, we also define a few variables for running the MCMC.
These are the number of iterations, and the so-called “thinning” which we use to say that we want to sample every $10^{th}$ iteration.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NUM_MCMC_ITERATIONS = 10000
THINNING            = 10
</code></pre></div></div>

<p>We also need to create vectors for the monitors and moves of the MCMC.
Moves are functions that propose new parameter values in your MCMC, based on the current value.
These newly proposed parameters can either be accepted or rejected.
Depending on this acceptance / rejection, the posterior distribution of your parameters will be formed.
See for example <a href="/tutorials/mcmc/poisson.html">Introduction to MCMC</a> for more information on the acceptance / rejection procedure.
Monitors are later used to track the progress of your analysis, but are also needed to write output files.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves     = VectorMoves()
monitors  = VectorMonitors()
</code></pre></div></div>

<h3 class="subsection" id="read-the-data">Read the data</h3>
<hr class="subsection" />

<p>Start by reading in the aligned sequences of the homochronous horse data.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sequences &lt;- readDiscreteCharacterData("data/horses_homochronous_sequences.fasta")
</code></pre></div></div>

<p>You will also need the names of the taxa and their number.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taxa &lt;- sequences.taxa()
n_taxa &lt;- taxa.size()
</code></pre></div></div>

<h3 class="subsection" id="the-tree-model">The Tree Model</h3>
<hr class="subsection" />

<p>For the constant coalescent model, only one population size is estimated.
For this population size, a prior needs to be set.
Without knowing much about the population size of our horse sample, we set a uniform prior.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pop_size ~ dnUniform(0,1E8)
</code></pre></div></div>

<p>You may realize that in the full script, we initialize the population size to have a first value of $100$.
Later in the tutorial, we will constrain the root age of the tree to be inside the interval $[250 000, 500 000]$.
In order for our first proposed tree to comply with this constraint, an initial value of $100$ proved to lead to reasonable initial proposals.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pop_size.setValue(100)
</code></pre></div></div>

<p>We also add a move for the population size.
Here, we chose a scaling move which means that the current values is multiplied by a scaling factor to propose a new value.
See for example <a href="/tutorials/mcmc/binomial.html">Introduction to MCMC using RevBayes</a> for information on moves.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvScale(pop_size, lambda=0.1, tune=true, weight=2.0) )
</code></pre></div></div>

<p>Now, we will instantiate the stochastic node for the tree.
The <code class="language-plaintext highlighter-rouge">dnCoalescent</code> distribution should be used for a constant coalescent process.
It takes a value for the population size (<code class="language-plaintext highlighter-rouge">theta</code>) and the taxa as input.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi ~ dnCoalescent(theta=pop_size, taxa=taxa)
</code></pre></div></div>

<p>We calibrate the tree based on the root age.
We chose a Normal distribution with a mean of $375 000$ and a standard deviation of $60 000$.
As mentioned above, the root age will be constrained to the interval $[250 000, 500 000]$.
As we have access to the original analysis from <a class="citation" href="#Vershinina2021">Vershinina et al. (2021)</a>, we could see that this should be the rough range of the root.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root_age := psi.rootAge()
obs_root_age ~ dnNormal(mean = root_age, sd = 60000, min = 250000, max = 500000)
obs_root_age.clamp(375000)
</code></pre></div></div>

<p>We should also add moves for the tree.
These include moves on a single branch, subtrees or the whole tree.
Here, the weight of the different moves is based on the number of taxa.
If a move changes a single branch (<em>e.g.</em> <code class="language-plaintext highlighter-rouge">mvNNI</code>), it will be applied more often and thus have a higher weight than a move which changes the whole tree (<em>e.g.</em> <code class="language-plaintext highlighter-rouge">mvTreeScale</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvNarrow(psi, weight=n_taxa) )
moves.append( mvNNI(psi, weight=n_taxa) )
moves.append( mvFNPR(psi, weight=n_taxa/4.0) )
moves.append( mvSubtreeScale(psi, weight=n_taxa/5.0) )
moves.append( mvNodeTimeSlideUniform(psi, weight=n_taxa) )
moves.append( mvRootTimeScaleBactrian(psi, weight=n_taxa/5.0) )
moves.append( mvTreeScale(psi, weight=n_taxa/5.0) )
</code></pre></div></div>

<h3 class="subsection" id="substitution-model-and-other-parameters">Substitution Model and other parameters</h3>
<hr class="subsection" />

<p>Finally, sequence data should be added to the analysis. Here, we assume a GTR+$\Gamma$+I substitution model, but you can of course use others. Have a look at the <a href="/tutorials/ctmc/">Nucleotide substitution models</a> tutorial to see how you can define different substitution models.
<!--- The `dnPhyloCTMC` function can take several arguments, here it is enough to specify the tree, the Q matrix and the type of data. ---></p>

<p>For the GTR model, we need to add exchangeability rates (<code class="language-plaintext highlighter-rouge">er</code>) and stationary frequences (<code class="language-plaintext highlighter-rouge">pi</code>).
Of course, we also add moves for these.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>er_prior &lt;- v(1,1,1,1,1,1)
pi_prior &lt;- v(1,1,1,1)
er ~ dnDirichlet(er_prior)
pi ~ dnDirichlet(pi_prior)

moves.append( mvBetaSimplex(er, weight=3) )
moves.append( mvDirichletSimplex(er, weight=1) )
moves.append( mvBetaSimplex(pi, weight=2) )
moves.append( mvDirichletSimplex(pi, weight=1) )
</code></pre></div></div>
<p>This is everything needed for the Q matrix of the GTR model.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnGTR(er,pi)
</code></pre></div></div>
<p>For the $\Gamma$ extension to the GTR model, we need to draw the site rates (<code class="language-plaintext highlighter-rouge">sr</code>) from a discretized Gamma function with two parameters.
Here, we use <code class="language-plaintext highlighter-rouge">alpha</code> for both parameters.
We also add a scaling move for <code class="language-plaintext highlighter-rouge">alpha</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha ~ dnUniform( 0.0, 1E6 )
alpha.setValue( 1.0 )
sr := fnDiscretizeGamma( alpha, alpha, 4 )
moves.append( mvScale(alpha, weight=2.0) )
</code></pre></div></div>
<p>We draw the proportion of invariant sites (<code class="language-plaintext highlighter-rouge">p_inv</code>) from a Beta distribution and add a sliding window move.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p_inv ~ dnBeta(1,1)
moves.append( mvSlide(p_inv) )
</code></pre></div></div>
<p>The last step is to set the clock rate.
We draw it from a uniform distribution here.
Again, we know from the original analysis <a class="citation" href="#Vershinina2021">(Vershinina et al. 2021)</a> that the true value should be around $5*10^{-8}$ and thus set the upper bound of the distribution to $1*10^{-6}$.
<!--- We also add a scaling move for the clock rate. --->
We also add a scaling move which makes sure to regulate clock rate and the root age.
This needs to be done as root age and clock rate are intertwined and can not be clearly seperated.
Note that you could also calibrate the clock rate instead of the root age of the tree as we do it here.
<!--- We draw it from an exponential distribution with mean $4.68e-8$ which we also use as initial value.
This value is taken from the original analsis published in <a class="citation" href="#Vershinina2021">Vershinina et al. (2021)</a>. ---></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clock ~ dnUniform(0,1e-6)
# moves.append( mvScale(clock, weight=2.0) )

up_down_move = mvUpDownScale(weight=5.0)
up_down_move.addVariable(clock,up=TRUE)
up_down_move.addVariable(psi,up=FALSE)
moves.append( up_down_move)
</code></pre></div></div>
<p>The final <code class="language-plaintext highlighter-rouge">dnPhyloCTMC</code> function combines all of the previous defined parameters.
We also need to clamp the sequence data.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC(tree=psi, Q=Q, siteRates=sr, pInv=p_inv, type="DNA", branchRates=clock)
seq.clamp(sequences)
</code></pre></div></div>

<h3 class="subsection" id="finalize-and-run-the-analysis">Finalize and run the analysis</h3>
<hr class="subsection" />

<p>In the end, we need to wrap our model.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(psi)
</code></pre></div></div>

<p>Now, we add some monitors.
The <code class="language-plaintext highlighter-rouge">mndModel</code> monitor keeps track of all model parameters and thus is written into our main <code class="language-plaintext highlighter-rouge">.log</code> file.
With <code class="language-plaintext highlighter-rouge">mnFile</code>, you can keep track of the trees or parameters that you would like to keep in an extra file.
<code class="language-plaintext highlighter-rouge">mnScreen</code> is responsible for having output printed directly to your screen.
This output will not per se be saved in a file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/horses_constant.log",printgen=THINNING) )
monitors.append( mnFile(filename="output/horses_constant.trees",psi,printgen=THINNING) )
monitors.append( mnFile(filename="output/horses_constant_NE.log",pop_size,printgen=THINNING) )
monitors.append( mnScreen(pop_size, root_age, printgen=100) )
</code></pre></div></div>

<p>The final step is to run the mcmc.
Make sure to set <code class="language-plaintext highlighter-rouge">combine="mixed"</code> for the output of the two replicates to be combined in the end.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves, nruns=NUM_REPLICATES, combine="mixed") 
mymcmc.burnin(NUM_MCMC_ITERATIONS*0.1,100)
mymcmc.run(NUM_MCMC_ITERATIONS, tuning = 100)
</code></pre></div></div>

<h2 class="section" id="check-convergence">Check Convergence</h2>
<hr class="section" />

<p>To check whether your analysis has converged, you can use the <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">convenience</code>.
Have a look at the <a href="/tutorials/convergence/">Convergence assessment</a> tutorial.</p>

<p><strong>Add convergence results here</strong></p>

<h2 class="section" id="results">Results</h2>
<hr class="section" />

<p>After running your analysis, you can plot the results using the <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">RevGadgets</code>.
See the <a href="https://github.com/revbayes/RevGadgets">RevGadgets Github repository</a> for information on how to install the package.
After installing the package, open <code class="language-plaintext highlighter-rouge">R</code> or <code class="language-plaintext highlighter-rouge">RStudio</code> and set the tutorial directory as your working directory.
You can plot the <code class="language-plaintext highlighter-rouge">RevBayes</code> output as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(RevGadgets)

burnin = 0.1
probs = c(0.025, 0.975)
summary = "median"

population_size_log = "output/horses_constant_NE.log"
df &lt;- processPopSizes(population_size_log, method = "constant", burnin = burnin, probs = probs, summary = summary)
p &lt;- plotPopSizes(df, method = "constant") + ggplot2::coord_cartesian(ylim = c(1e3, 1e8), xlim = c(1e5, 0))
ggplot2::ggsave("horses_constant.png", p)
</code></pre></div></div>

<p>Your output should look roughly like the following figure.</p>

<figure id="coalescent"><p><img src="figures/horses_constant.png" width="800" /></p>
<figcaption>Example output from plotting the constant coalescent analysis run in this exercise.</figcaption>
</figure>

<h2 class="section" id="next-exercise">Next Exercise</h2>
<hr class="section" />

<p>When you are done, have a look at the next exercise.</p>

<ul>
  <li><a href="/tutorials/coalescent/skyline">The skyline model</a></li>
</ul>

<ol class="bibliography"><li><span id="Griffiths1994">Griffiths R.C., Tavare S., Bodmer W.F., Donnelly P.J. 1994. Sampling theory for neutral alleles in a varying environment. Philosophical Transactions of the Royal Society of London. Series B: Biological Sciences. 344:403–410.</span>

<a href="https://doi.org/10.1098/rstb.1994.0079">10.1098/rstb.1994.0079</a>

</li>
<li><span id="Kingman1982">Kingman J.F.C. 1982. On the Genealogy of Large Populations. Journal of Applied Probability. 19:27–43.</span>

<a href="https://doi.org/10.2307/3213548">10.2307/3213548</a>

</li>
<li><span id="Vershinina2021">Vershinina A.O., Heintzman P.D., Froese D.G., Zazula G., Cassatt-Johnstone M., Dalén L., Der Sarkissian C., Dunn S.G., Ermini L., Gamba C., Groves P., Kapp J.D., Mann D.H., Seguin-Orlando A., Southon J., Stiller M., Wooller M.J., Baryshnikov G., Gimranov D., Scott E., Hall E., Hewitson S., Kirillova I., Kosintsev P., Shidlovsky F., Tong H.-W., Tiunov M.P., Vartanyan S., Orlando L., Corbett-Detig R., MacPhee R.D., Shapiro B. 2021. Ancient horse genomes reveal the timing and extent of dispersals across the Bering Land Bridge. Molecular Ecology. 30:6144–6161.</span>

<a href="https://doi.org/https://doi.org/10.1111/mec.15977">https://doi.org/10.1111/mec.15977</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

  </body>
</html>
