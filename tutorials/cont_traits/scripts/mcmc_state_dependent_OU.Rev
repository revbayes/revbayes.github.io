################################################################################
#
# RevBayes Example: The state-dependent Ornstein-Uhlenbeck model under
#                   a joint-inference approach
#
#
# authors: Priscilla Lau and Sebastian HÃ¶hna
#
################################################################################

#######################
# Reading in the Data #
#######################

### Select the trait to analyze
char_disc <- 1
char_cont <- 1

### Read in the trees
tree <- readTrees("data/diprotodontia_tree.nex")[1]

ntips     <- tree.ntips()
nbranches <- 2 * ntips - 2
root_age <- tree.rootAge()

### Read in the character data
disc <- readDiscreteCharacterData("data/diprotodontia_discrete_diet.nex")
disc.excludeAll()
disc.includeCharacter( char_disc )
num_disc_states <- disc.getStateDescriptions().size()

cont <- readContinuousCharacterData("data/diprotodontia_continuous.nex")
cont.excludeAll()
cont.includeCharacter( char_cont )

# Create some vector for the moves and monitors of this analysis
moves    = VectorMoves()
monitors = VectorMonitors()
avmvn_disc = mvAVMVN(weight=20, waitBeforeLearning=500, waitBeforeUsing=1000)
avmvn_cont = mvAVMVN(weight=20, waitBeforeLearning=500, waitBeforeUsing=1000)

##############################
# Specify the discrete model #
##############################
num_type_transition <- num_disc_states * (num_disc_states - 1)
rates ~ dnDirichlet( rep(1, num_type_transition) )
moves.append( mvBetaSimplex( rates, weight=2 ) )
moves.append( mvDirichletSimplex( rates, weight=2 ) )
avmvn_disc.addVariable( rates )

Q := fnFreeK( rates, rescaled=TRUE )

lambda ~ dnExponential(200)
moves.append( mvScale(lambda, weight=1.0) )
avmvn_disc.addVariable(lambda)

moves.append( avmvn_disc )

X ~ dnPhyloCTMCDASiteIID(tree, Q, branchRates=lambda, type="Standard", nSites=1)
X.clamp(disc)

moves.append( mvCharacterHistory(ctmc=X, qmap_site=Q, graph="node",   proposal="rejection", weight=100.0) )
moves.append( mvCharacterHistory(ctmc=X, qmap_site=Q, graph="branch", proposal="rejection", weight=50.0) )

for(i in 1:nbranches) {
    num_changes[i] := sum(X.numCharacterChanges(i))
}
total_num_changes := sum(num_changes)

char_hist := X.characterHistories()

##############################
# Specify the continuous model #
##############################
root_age <- tree.rootAge()
v_emp <- cont.var(char_cont)

for (i in 1:num_disc_states){
  theta[i] ~ dnUniform(-10, 10)
  moves.append(mvSlide(theta[i], weight = 1.0) )
  avmvn_cont.addVariable(theta[i])
}

# The hyperprior option
for (i in 1:num_disc_states){
  t_half[i] ~ dnLognormal(ln(root_age/2), 0.587405)
  moves.append(mvScale(t_half[i], weight = 1.0) )
  avmvn_cont.addVariable(t_half[i])
  alpha[i] := abs(ln(2)/t_half[i])

  Vy[i] ~ dnLognormal(ln(v_emp), 0.587405)
  moves.append(mvScale(Vy[i], weight = 3.0) )
  avmvn_cont.addVariable(Vy[i])
  sigma2[i] := Vy[i] * 2 * alpha[i]
}


# The direct prior option
# for (i in 1:num_disc_states){
#   alpha[i] ~ dnExponential(root_age/2/ln(2))
#   moves.append(mvScale(alpha[i], weight = 1.0) )
#   avmvn_cont.addVariable(alpha[i])
# 
#   sigma2[i] ~ dnLognormal(ln(sqrt(v_emp), 0.587405))
#   moves.append(mvScale(sigma2[i], weight = 3.0) )
#   avmvn_cont.addVariable(sigma2[i])
# }

moves.append( avmvn_cont )


#############
# The Model #
#############
Y ~ dnPhyloOUSD(char_hist, theta=theta, rootTreatment="optimum", alpha=alpha, sigma=sigma2^0.5)
Y.clamp(cont)

mymodel = model(Y)

### set up the monitors that will output parameter values to file and screen
monitors.append( mnModel(filename="output/trace.log", printgen=10) )
monitors.append( mnScreen(printgen=1000, theta) )
monitors.append( mnFile( char_hist, filename="output/char_hist.trees", printgen=10 ) )


################
# The Analysis #
################

### workspace mcmc ###
mymcmc = mcmc(mymodel, monitors, moves, nruns=2, combine="mixed")

### run the MCMC ###
mymcmc.run(generations=10000, tuningInterval=200)

## quit ##
q()