<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Relaxed Ornstein-Uhlenbeck Models</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="https://revbayes.github.io/revscripter/">RevScripter</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><<a href="/gui">GUI</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Relaxed Ornstein-Uhlenbeck Models</h1>
	<h3 class="subtitle">Estimating lineage-specific optima under Ornstein-Uhlenbeck evolution</h3>
	<h4 class="authors">Michael R. May</h4>
  <h5>Last modified on April 14, 2021</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/intro/revgadgets.html">Introduction to RevGadgets</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
            <li><a href="/tutorials/cont_traits/cont_trait_intro.html">Introduction to Models of Continuous-Character Evolution</a></li>
          
            <li><a href="/tutorials/cont_traits/simple_ou.html">Simple Ornstein-Uhlenbeck Models</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





<blockquote class="tutorial_files" id="tutorial_files">
    <h2>Data files and scripts</h2>
    
        
        <strong>Other</strong>
        <ul id="other_files">
        
        
        
          <li><a href="/tutorials/cont_traits/scripts/mcmc_relaxed_OU.Rev">mcmc_relaxed_OU.Rev</a></li>
        
          <li><a href="/tutorials/cont_traits/scripts/plot_relaxed_OU.R">plot_relaxed_OU.R</a></li>
        
          <li><a href="/tutorials/cont_traits/data/traits.nex">traits.nex</a></li>
        
          <li><a href="/tutorials/cont_traits/data/trees.nex">trees.nex</a></li>
        
        </ul>
    
</blockquote>


</div>
<h2 class="section" id="estimating-branch-specific-evolutionary-optima">Estimating Branch-Specific Evolutionary Optima</h2>
<hr class="section" />

<p>This tutorial demonstrates how to specify an Ornstein-Uhlenbeck model where the optimal phenotype is allowed to vary over branches of a time-calibrated phylogeny <a class="citation" href="#Uyeda2014">(Uyeda and Harmon 2014)</a> using the datasets of (log) body-size across vertebrate clades from (missing reference). We provide the probabilistic graphical model representation of each component for this tutorial. After specifying the model, you will estimate the parameters of branch-specific Ornstein-Uhlenbeck evolution using reversible-jump Markov chain Monte Carlo (rjMCMC).</p>

<h2 class="section" id="relaxing-the-ou-model">Relaxing the OU Model</h2>
<hr class="section" />

<p>Under a simple Ornstein-Uhlenbeck (OU) model, the optimal of a continuous character is determined by a single rate parameter, $\theta$. Many evolutionary questions are related to how the optimal phenotype changes among lineages. In a Bayesian setting, we can specify a ‘‘relaxed’’ OU prior model that allows the optimal phenotype to vary over the phylogeny.</p>

<p>Here, we will use the ‘‘random local clock’’ model, similar to the one described by <a class="citation" href="#Uyeda2014">Uyeda and Harmon (2014)</a> in the software <code class="language-plaintext highlighter-rouge">bayOU</code>. In this model, we assume that each branch in the phylogeny either does or does not have a optimum shift. When there is no shift on a branch, the optimum on the branch is inherited directly from its ancestral branch; when there <em>is</em> a shift, the ancestral optimum is shifted by an amount that is drawn from a specified prior distribution. We specify a prior probability, $p$, that a given branch experiences a shift. For a tree with $n$ branches, the expected number of shifts is $E(k) = n \times p$. To control the number of shifts, we specify a prior on the <em>expected number of shifts</em>, $E(k)$, and then calculate the prior probability for a shift on a particular branch, $p = E(k) / n$. The graphical model shows the relationship between the branch-specific optima and priors (fig_ou_relaxed_gm).</p>

<figure id="fig_ou_relaxed_gm"><p><img src="figures/relaxed_ou_gm.png" width="50%" height="50%" /></p>
<figcaption>The graphical model representation of the relaxed Ornstein-Uhlenbeck (OU) process under the random local clock. For more information about graphical model representations see <a class="citation" href="#Hoehna2014b">Höhna et al. (2014)</a>.</figcaption>
</figure>

<p>In this tutorial, we use the 66 vertebrate phylogenies and (log) body-size datasets from <a class="citation" href="#Landis2017b">(Landis and Schraiber 2017)</a> to estimate branch-specific optima of body-size evolution.</p>

<p>⇨ The full relaxed BM-model specification is in the file called <code class="language-plaintext highlighter-rouge">mcmc_relaxed_OU.Rev</code>.</p>

<h3 class="subsection" id="read-the-data">Read the data</h3>
<hr class="subsection" />

<p>We begin by deciding which of the 66 vertebrate datasets to use. Here, we assume we are analyzing the 5th dataset (<em>Acanthuridae</em>), but you should feel free to choose any of the datasets.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dataset &lt;- 1
</code></pre></div></div>

<p>Now, we read in the (time-calibrated) tree corresponding to our chosen dataset.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T &lt;- readTrees("data/trees.nex")[dataset]
</code></pre></div></div>
<p>We also want to keep track of the number of branches for our relaxed clock model.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ntips     &lt;- T.ntips()
nbranches &lt;- 2 * ntips - 2
</code></pre></div></div>

<p>Next, we read in the character data for the same dataset.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data &lt;- readContinuousCharacterData("data/traits.nex")[dataset]
</code></pre></div></div>

<p>Additionally, we initialize a variable for our vector of
moves and monitors:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves    = VectorMoves()
monitors = VectorMonitors()
</code></pre></div></div>

<h3 class="subsection" id="specifying-the-model">Specifying the model</h3>
<hr class="subsection" />

<h4 class="subsubsection" id="tree-model">Tree model</h4>
<hr class="subsubsection" />

<p>In this tutorial, we assume the tree is known without area. We create a constant node for the tree that corresponds to the observed phylogeny.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree &lt;- T
</code></pre></div></div>

<h4 class="subsubsection" id="rate-parameter">Rate parameter</h4>
<hr class="subsubsection" />

<p>The stochastic rate of evolution is controlled by the rate parameter, $\sigma^2$. We draw the rate parameter from a loguniform prior. This prior is uniform on the log scale, which means that it is represents ignorance about the <em>order of magnitude</em> of the rate. As before, we provide a scale move that proposes changes to the parameter during MCMC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigma2 ~ dnLoguniform(1e-3, 1)
moves.append( mvScale(sigma2, weight=1.0) )
</code></pre></div></div>

<h4 class="subsubsection" id="adaptation-parameter">Adaptation parameter</h4>
<hr class="subsubsection" />

<p>The rate of adaptation toward the optimum is determined by the parameter $\alpha$. We draw $\alpha$ from an exponential prior distribution, and place a scale proposal on it. This parameter is assumed to be constant across the tree (even though the optimum will vary).</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha ~ dnExponential(10)
moves.append( mvScale(alpha, weight=1.0) )
</code></pre></div></div>

<h4 class="subsubsection" id="optima">Optima</h4>
<hr class="subsubsection" />

<p>We begin by drawing the optimum value at the root of the tree, and including a slide move.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>theta_root ~ dnUniform(-10, 10)
moves.append( mvSlide(theta_root, weight=1.0) )
</code></pre></div></div>

<p>We specify the relaxed-optimum model by specifying a prior on the probability of shifts for each branch. We parameterize our prior expected number of shifts, and then compute the probability of a shift on a given branch.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>expected_number_of_shifts &lt;- 5
shift_probability &lt;- expected_number_of_shifts / nbranches
</code></pre></div></div>

<p>Next, we specify the prior distribution on the size of shifts (when they occur). We draw each rate shift from a uniform distribution.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shift_distribution = dnNormal(0, 0.587)
</code></pre></div></div>
<p>Now, we loop over each branch, drawing a the change in the optima value from a mixture distribution. This mixture distribution places prior probability $p$ on the rate shift being drawn from the uniform distribution we just specified, and prior probability $1 - p$ on the shift being exactly equal to 0 (<em>i.e.</em>, no shift). We then compute the optimum on the branch by adding the change in the optimum to the ancestral optimum. Note that we loop over the branches in reverse order; this ensures that the ancestral optimum exists when we specify the optimum for a given branch.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(i in nbranches:1) {

    # draw the theta shift from a mixture distribution
    branch_deltas[i] ~ dnReversibleJumpMixture(0, shift_distribution, Probability(1 - shift_probability) )

    # compute the theta for the branch
    if ( tree.isRoot( tree.parent(i) ) ) {
       branch_thetas[i] := theta_root + branch_deltas[i]
    } else {
       branch_thetas[i] := branch_thetas[tree.parent(i)] + branch_deltas[i]
    }

    # keep track of whether the branch has a shift
    branch_theta_shift[i] := ifelse( branch_deltas[i] == 0, 0, 1 )

    # use reversible-jump to move between models with and without
    # shifts on the branch
    moves.append( mvRJSwitch(branch_deltas[i], weight=1) )

    # include proposals on the shift (when it is not 1)
    moves.append( mvScale(branch_deltas[i], weight=1) )

}
</code></pre></div></div>
<p>We also keep track of the total number of rate shifts.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num_theta_changes := sum( branch_theta_shift )
</code></pre></div></div>

<h4 class="subsubsection" id="ou-model">OU model</h4>
<hr class="subsubsection" />

<p>Now that we have specified the branch-specific theta parameters, we can draw the character data from the corresponding phylogenetic OU model, just as we did for the simple OU models. In this case, we provide the vector of <code class="language-plaintext highlighter-rouge">branch_thetas</code> to the <code class="language-plaintext highlighter-rouge">theta</code> argument.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X ~ dnPhyloOrnsteinUhlenbeckREML(tree, alpha, branch_thetas, sigma2^0.5, rootStates=theta_root)
</code></pre></div></div>

<p>Noting that $X$ is the observed data (<a href="#fig_ou_relaxed_gm"></a>), we clamp the <code class="language-plaintext highlighter-rouge">data</code> to this stochastic node.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X.clamp(data)
</code></pre></div></div>

<p>Finally, we create a workspace object for the entire model with <code class="language-plaintext highlighter-rouge">model()</code>. Remember that workspace objects are initialized with the <code class="language-plaintext highlighter-rouge">=</code> operator, and are not themselves part of the Bayesian graphical model. The <code class="language-plaintext highlighter-rouge">model()</code> function traverses the entire model graph and finds all the nodes in the model that we specified. This object provides a convenient way to refer to the whole model object, rather than just a single DAG node.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(X)
</code></pre></div></div>

<h3 class="subsection" id="running-an-mcmc-analysis">Running an MCMC analysis</h3>
<hr class="subsection" />

<h4 class="subsubsection" id="specifying-monitors">Specifying Monitors</h4>
<hr class="subsubsection" />

<p>For our MCMC analysis, we need to set up a vector of <em>monitors</em> to record the states of our Markov chain. The monitor functions are all called <code class="language-plaintext highlighter-rouge">mn*</code>, where <code class="language-plaintext highlighter-rouge">*</code> is the wildcard representing the monitor type. First, we will initialize the model monitor using the <code class="language-plaintext highlighter-rouge">mnModel</code> function. This creates a new monitor variable that will output the states for all model parameters when passed into a MCMC function.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnModel(filename="output/relaxed_OU.log", printgen=10) )
</code></pre></div></div>
<p>Additionally, create a screen monitor that will report the states of
specified variables to the screen with <code class="language-plaintext highlighter-rouge">mnScreen</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(printgen=1000, sigma2, num_theta_changes) )
</code></pre></div></div>
<p>Finally, we include an extended Newick monitor to keep track of the branch-specific <code class="language-plaintext highlighter-rouge">theta</code> values on each branch of the tree.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnExtNewick(filename="output/relaxed_OU.trees", isNodeParameter=TRUE, printgen=10, separator=TAB, tree=tree, branch_thetas) )
</code></pre></div></div>

<h4 class="subsubsection" id="initializing-and-running-the-mcmc-simulation">Initializing and Running the MCMC Simulation</h4>
<hr class="subsubsection" />

<p>With a fully specified model, a set of monitors, and a set of moves, we
can now set up the MCMC algorithm that will sample parameter values in
proportion to their posterior probability. The <code class="language-plaintext highlighter-rouge">mcmc()</code> function will
create our MCMC object:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves, nruns=2, combine="mixed")
</code></pre></div></div>
<p>Now, run the MCMC:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=50000)
</code></pre></div></div>
<p>Finally, we summarize the branch-specific rate after we run the MCMC analysis.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>treetrace = readTreeTrace("output/relaxed_OU.trees")
map_tree = mapTree(treetrace,"output/relaxed_OU_MAP.tre")
</code></pre></div></div>

<p>When the analysis is complete, you will have the monitored files in your
output directory.</p>

<p>⇨ The <code class="language-plaintext highlighter-rouge">Rev</code> file for performing this analysis: <code class="language-plaintext highlighter-rouge">mcmc_relaxed_OU.Rev</code></p>

<p>You can then visualize the branch-specific rates by plotting them using our <code class="language-plaintext highlighter-rouge">R</code> package <code class="language-plaintext highlighter-rouge">RevGadgets</code>. Importantly, these plots allow you to tease apart the relative contributions of background- and state-dependent-rate variation to overall patterns of rate variation across the tree. Just start R in the main directory for this analysis and then type the following commands:</p>
<div class="language-R highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">RevGadgets</span><span class="p">)</span><span class="w">

</span><span class="c1"># read the annotated tree</span><span class="w">
</span><span class="n">tree</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readTrees</span><span class="p">(</span><span class="s2">"output/relaxed_OU_MAP.tre"</span><span class="p">)</span><span class="w">

</span><span class="c1"># plot the objects</span><span class="w">
</span><span class="n">plotTree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">color_branch_by</span><span class="o">=</span><span class="s2">"branch_thetas"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<figure id="fig_relaxed_OU"><p><img src="figures/relaxed_OU.png" width="50%" height="50%" /></p>
<figcaption><strong>Estimated branch-specific optima across branches of the tree.</strong>
Here we show the results of our example analysis.</figcaption>
</figure>

<h3 class="subsection" id="exercise-1">Exercise 1</h3>
<hr class="subsection" />

<ul>
  <li>Run an MCMC simulation to estimate the posterior distribution of the branch-specific thetas (<code class="language-plaintext highlighter-rouge">branch_thetas</code>) assuming a prior expected number of shifts of 5.</li>
  <li>Plot the thetas among branches under this prior.</li>
  <li>Change the prior expected number of shifts to 1, and then plot the branch-specific thetas on the tree.</li>
  <li>Compare the posterior distributions for the total number of shifts under both priors. Does the posterior distribution for the total number of shifts seem to be sensitive to the prior?</li>
  <li>Compare the posterior mean estimates under each prior. Do the posterior mean estimates estimates appear to be sensitive to this prior?</li>
</ul>


<ol class="bibliography"><li><span id="Hoehna2014b">Höhna S., Heath T.A., Boussau B., Landis M.J., Ronquist F., Huelsenbeck J.P. 2014. Probabilistic Graphical Model Representation in Phylogenetics. Systematic Biology. 63:753–771.</span>

<a href="https://doi.org/10.1093/sysbio/syu039">10.1093/sysbio/syu039</a>

</li>
<li><span id="Landis2017b">Landis M.J., Schraiber J.G. 2017. Pulsed evolution shaped modern vertebrate body sizes. Proceedings of the National Academy of Sciences. 114:13224–13229.</span>

<a href="https://doi.org/10.1073/pnas.1710920114">10.1073/pnas.1710920114</a>

</li>
<li><span id="Uyeda2014">Uyeda J.C., Harmon L.J. 2014. A novel Bayesian method for inferring and interpreting the dynamics of adaptive landscapes from phylogenetic comparative data. Systematic Biology. 63:902–918.</span>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

  </body>
</html>
