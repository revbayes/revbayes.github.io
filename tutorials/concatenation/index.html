<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Alignment concatenation</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Alignment concatenation</h1>
	<h3 class="subtitle">Species tree estimation from multiple concatenated gene sequence alignments</h3>
	<h4 class="authors">Bastien Boussau and Sebastian Höhna</h4>
  <h5>Last modified on September 12, 2019</h5>
</div>


<div class="sidebar no-print">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            <li><a href="/tutorials/intro/">Getting Started with RevBayes and Rev Language Syntax</a></li>
          
            <li><a href="/tutorials/mcmc/">Introduction to Markov chain Monte Carlo (MCMC) Sampling</a></li>
          
          </ul>
        
    </div>
  </div>
  
</blockquote>





</div>
<h1 id="overview-gene-tree-species-tree-models">Overview: Gene tree-species tree models</h1>

<p>Ever since (missing reference), researchers have acknowledged that
phylogenies reconstructed from homologous gene sequences could differ
from species phylogenies. As molecular sequences accumulated, the link
between gene trees and species trees started to be modeled. The first
models were based on parsimony, and aimed for instance at reconciling a
gene tree with a species tree by minimizing the number of events of gene
duplication and gene loss. In the past dozen years, probabilistic models
have been proposed to reconstruct gene trees and species trees in a
rigorous statistical framework. Models and algorithms have quickly grown
in complexity, to model biological processes with increasing realism, to
accommodate several processes at the same time, or to handle
genome-scale data sets. In this overview we will not detail these
models, and we invite the interested reader to take a look at recent
reviews (<em>e.g.</em>, (missing reference)).</p>

<h2 id="processes-of-discord">Processes of discord</h2>

<p>There are several reasons why a gene tree may differ from a species
tree. Of course, a gene tree may differ from the species tree just
because a mistake was made during the analysis of the gene sequences, at
any point in a pipeline going from the sequencing itself to the gene
tree reconstruction. Such a mistake would produce an incorrect gene
tree. Here we do not mean this kind of discord, but rather discord that
comes from a real biological process that generates true gene histories
that differ from true species histories. These processes include gene
duplication, gene loss, gene transfer (used loosely here to also include
reticulation, hybridization between species), and incomplete lineage
sorting (Fig. [fig1]). In this tutorial we focus on Incomplete lineage
sorting, which will be discussed in more details in the following
subsection.</p>

<p>Fig. [fig1] suggests that for all processes the gene tree can be seen
as the product of a branching process operating inside the species tree.
Indeed, all processes are modeled as some type of birth-death process
running along the species tree. For duplication/loss models, birth
correspond to gene duplication events, and death to gene loss events.
Transfers can be added to the model by introducing another type of
birth, with a child lineage appearing in another branch of the species
tree. Incomplete lineage sorting is also modeled with a birth-death type
of model, the coalescent. All these models can be made heterogeneous,
for instance by allowing different sets of parameters for different
branches of the species tree. This is useful to model differences in
rates of duplication, loss or transfer among species, or to model
different effective population sizes in a species tree. In
RevBayes so far only models of incomplete lineage sorting
have been implemented (models of duplication and loss and transfer will
soon be added). Thanks to RevBayes’ modular design, there
is quite a lot of flexibility in specifying the model, for instance by
associating different parameters to different branches of the species
tree, or by combining the gene tree-species tree model to other types of
models, for instance models of trait evolution, or models of relaxed
molecular clock.</p>

<h2 id="gene-tree-discordance-is-a-problem-for-species-tree-reconstruction">Gene tree discordance is a problem for species tree reconstruction</h2>

<p>There have been several approaches to species tree reconstruction:
concatenation and supertree approaches, which have been used for quite
some time now, and more recently methods that rely on gene tree-species
tree models.</p>

<ol>
  <li>
    <p>Concatenation simply consists in taking all gene alignments,
concatenating them into one super alignment, and then analyzing it
as if it were a single gene sequence. More sophisticated approaches
allow different partitions for different genes, but the main
assumption at the heart of this approach is that all sites of all
genes have evolved according to the same species tree. This
assumption is often not correct because all the processes of discord
presented above conspire to make gene trees different from the
species tree. In practice, this matters: simulation studies have
found that in the presence of incomplete lineage sorting, in some
particular areas of the parameter space, concatenation will often
return an incorrect species tree <a class="citation" href="#Leache2011">(Leaché and Rannala 2011)</a>. Concatenation may
also be a questionable approach in prokaryotic phylogenetics, where
the quest for a tree of life has been difficult, to the point that
some doubted that one could find a meaningful species tree
representing vertical descent. Nonetheless, the concatenation
approach may be fairly robust to lateral gene transfers, as it
returns good species trees (arguably better than small subunit or
large subunit rRNA trees) in a range of prokaryotic groups
(missing reference).</p>
  </li>
  <li>
    <p>Supertree approaches differ from concatenation notably by discarding
sequence information once individual gene trees have been built.
Contrary to concatenation approaches that combine individual gene
alignments, supertree approaches combine individual gene trees to
obtain a species tree. Most supertree methods are not based on an
explicit model of the processes causing discordance between gene
trees and species tree (although there are exceptions, notably
modelling incomplete lineage sorting, see below). Instead, they aim
at finding a tree that would best describe the distribution of gene
trees, according to some fairly arbitrary criterion. In practice,
these methods have been found to provide reasonable results in many
cases, but in simulations they are usually less accurate
than concatenation.</p>
  </li>
  <li>
    <p>Methods that rely on gene tree-species tree models appear very
promising as they explicitly model the processes of discord. The
advantage of these models is that we account for processes that we
know have taken a part in generating the data, thus possibly
improving the accuracy and robustness of our inferences. Further,
these models can be combined with
<em>e.g.</em>, models of sequence evolution,
models of co-evolution between gene trees, or models of trait
evolution. However, these models are computationally challenging to
use, because they require estimating jointly gene trees, species
trees, and other parameters that entertain strong correlations. As a
consequence, in many gene tree-species tree models, devising a
well-mixing MCMC strategy can be problematic.</p>
  </li>
</ol>

<h1 id="concatenating-genes-to-model-species-evolution">Concatenating genes to model species evolution</h1>

<p>The simplest model to estimate a species tree when you have several
genes is to concatenate your genes and to assume that all gene trees are
exactly equal to the species tree. You thus assume that there is no
discordance between gene trees in the hope that the combined information
in all genes will provide a reliable signal for the species tree.</p>

<p>The exercises assume you have a working installation of RevBayes. In
this introductory tutorial, we will apply the concatenated model to 10
gene alignments from 23 primate species. We will assume that:</p>

<ul>
  <li>
    <p>The species tree is drawn from a constant birth-death process.</p>
  </li>
  <li>
    <p>All genes share the same tree, that is, both the topology and
branch lengths.</p>
  </li>
  <li>
    <p>Each gene has its own set of substitution model and clock parameters
which are drawn from a shared prior distribution.</p>
  </li>
  <li>
    <p>Gene sequences are evolved according to an HKY model with gamma
distributed rate variation among sites and a strict global clock.</p>
  </li>
  <li>
    <p>Here, we run an MCMC on this model, using data from 10 genes in 23
mammalian species.</p>
  </li>
</ul>

<p>Scripts are all placed in
<em>$tutorials/RB_GeneConcatenation_Tutorial/RevBayes_scripts/$</em>.</p>

<ol>
  <li>
    <p>Open RevBayes</p>
  </li>
  <li>
    <p>Let’s load all 10 gene alignments.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># read in each data matrix together which will create a vector of objects
data = readDiscreteCharacterData("data/merged.nex")

# Now we get some useful variables from the data. We need these later on.
num_loci = data.size()
# get the number of species
n_species &lt;- data[1].ntaxa()
# get the taxon information (e.g. the taxon names)
taxa &lt;- data[1].taxa()
n_branches &lt;- 2 * n_species - 1 # number of branches in a rooted tree

# We set our move index
mi = 0
</code></pre></div>    </div>
  </li>
  <li>
    <p>We specified a constant-rate birth-death process as our prior on the
species tree. The birth-death process has a speciation and
extinction rate as its parameters. We will use here a transformation
and specify priors on the speciation rate and relative extinction
rate. Additionally, we calibrate the tree by assuming that the crown
age of primates is around 75 MYA. Thus, we specify a normal
distribution with mean 75 and standard deviation 2.5 as the prior on
the root age. Since the root age can only be a positive real number
we truncate the normal distribution at 0.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Specify a prior on the diversification and turnover rate
speciation ~ dnGamma(2,2)
relativeExtinction ~ dnBeta(1,1)

# Now transform the diversification and turnover rates into speciation and extinction rates
extinction := speciation * relativeExtinction

# Specify a prior on the root age (our informed guess is about ~75 mya)
# Note that we use a truncated normal distribution because the root age must be positive
root ~ dnNormal(mean=75,sd=2.5,min=0.0, max=Inf)

sampling_fraction &lt;- 23 / 450 # we sampled 23 out of the ~ 450 primate species

# create some moves that change the stochastic variables
# Moves are sliding and scaling proposals
moves[++mvi] = mvSlide(diversification,delta=1,tune=true,weight=2)
moves[++mvi] = mvSlide(relativeExtinction,delta=1,tune=true,weight=2)
moves[++mvi] = mvScale(diversification,lambda=1,tune=true,weight=2)
moves[++mvi] = mvScale(relativeExtinction,lambda=1,tune=true,weight=2)
moves[++mvi] = mvSlide(root,delta=1,tune=true,weight=0.2)


# construct a variable for the tree drawn from a birth-death process
psi ~ dnBDP(lambda=speciation, mu=extinction, rootAge=root, rho=sampling_fraction, taxa=taxa )

moves[++mvi] = mvNarrow(psi, weight=5.0)
moves[++mvi] = mvNNI(psi, weight=1.0)
moves[++mvi] = mvFNPR(psi, weight=3.0)
moves[++mvi] = mvGPR(psi, weight=3.0)
moves[++mvi] = mvSubtreeScale(psi, weight=3.0)
moves[++mvi] = mvNodeTimeSlideUniform(psi, weight=15.0)
</code></pre></div>    </div>
  </li>
  <li>
    <p>Now that we have a species tree, which we assume is shared exactly
for all genes. That is, we assume each gene evolves under exactly
the same tree, and thus each gene tree is equivalent to the species
tree. Nevertheless, we assume that each gene evolves at a different
rate and with its own substitution model parameters. Here we will
assume for simplicity that every gene evolves under a global strict
clock but has its own independent clock rate. We assume that the
logarithm of the clock rate is uniformly distribution, thus we
specify in effect a log-uniform prior distribution. This prior
assumption means that we put the same prior probability on values of
each magnitude, e.g., values between 0.0001 and 0.001 have the same
prior probability as values between 10 and 100.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for ( i in 1:num_loci ) { 
   log_clock_rate[i] ~ dnUniform(-8,4)
   clock_rate[i] := 10^log_clock_rate[i]
       
   moves[++mvi] = mvSlide(log_clock_rate[i], weight=1.0)
}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Next we need our model for the substitution process. Hence, we just
need to define the substitution matrix. We use a single HKY matrix
that will apply to all sites per gene. Additionally, we assume that
sites evolve according to one of four possible rates, where each
rate corresponds to a quantile from a gamma distribution.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for ( i in 1:num_loci ) {

    #### specify the HKY substitution model applied uniformly to all sites of a gene
    kappa[i] ~ dnLognormal(0,1)
    moves[++mvi] = mvScale(kappa[i],weight=1)

    pi_prior[i] &lt;- v(1,1,1,1) 
    pi[i] ~ dnDirichlet(pi_prior[i])
    moves[++mvi] = mvSimplexElementScale(pi[i],weight=2)


    #### create a deterministic variable for the rate matrix
    Q[i] := fnHKY(kappa[i],pi[i]) 

    #### create the rates to model the gamma distributed rate variation among sites.
    alpha_prior[i] &lt;- 0.05
    alpha[i] ~ dnExponential( alpha_prior[i] )
    gamma_rates[i] := fnDiscretizeGamma( alpha[i], alpha[i], 4, false )

    # add moves for the stationary frequencies, exchangeability rates and the shape parameter
    moves[++mvi] = mvScale(alpha[i],weight=2)

}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Finally, we can create our distribution for the character evolution.
We will use the common ‘PhyloCTMC‘ distribution, which is a
continuous time Markov process along a phylogenetic tree. We create
a ‘seq‘ variable and attach/clamp each gene to one of the
‘seq‘ variables.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for ( i in 1:num_loci ) { 
    # the sequence evolution model
    seq[i] ~ dnPhyloCTMC(tree=psi, Q=Q[i], branchRates=clock_rate[i], siteRates=gamma_rates[i], type="DNA")

    # attach the data
    seq[i].clamp(data[i])
}
</code></pre></div>    </div>
  </li>
  <li>
    <p>Now we have defined all the bricks of the model, and create our
model object from it.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># We get a handle on our model.
# We can use any node of our model as a handle, here we choose to use the topology.
mymodel = model(psi)
</code></pre></div>    </div>
  </li>
  <li>
    <p>Finally, we need to perform inference under the model, using
the data.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Monitors to check the progression of the program
monitors[1] = mnScreen(printgen=100, root)
monitors[2] = mnModel(filename="output/primates_concatenation_root_calibration",printgen=10, separator = TAB)
monitors[3] = mnFile(filename="output/primates_concatenation_root_calibration",printgen=10, separator = TAB, psi)

# Here we use a plain MCMC. You could also set nruns=2 for a replicated analysis
# or use mcmcmc with heated chains.
mymcmc = mcmc(mymodel, monitors, moves)

# This should be sufficient to obtain enough MCMC samples
mymcmc.burnin(generations=3000,tuningInterval=100)
mymcmc.run(generations=10000)
</code></pre></div>    </div>
  </li>
  <li>
    <p>Now we can perform some post-run analyses.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Now, we will analyze the tree output.
# Let us start by reading in the tree trace
treetrace = readTreeTrace("output/primates_concatenation_root_calibration", treetype="clock")
# and get the summary of the tree trace
treetrace.summarize()

mapTree(treetrace,"output/primates_concatenation_root_calibration")
</code></pre></div>    </div>
  </li>
</ol>


<ol class="bibliography"><li><span id="Leache2011">Leaché A.D., Rannala B. 2011. The accuracy of species tree estimation under simulation: a comparison of methods. Systematic Biology. 60:126–137.</span>

<a href="https://doi.org/10.1093/sysbio/syq073">10.1093/sysbio/syq073</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>

      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
