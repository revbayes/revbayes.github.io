################################################################################
#
# BiSSE analysis of the influence of diet on the diversification
# rates of extant and extinct canids
#
# author: Bruno do Rosario Petrucci
#
################################################################################

###
# reading the data

# read the phylogenetic tree
observed_phylogeny <- readTrees("data/canidae_tree.nex")[1]
# this includes 94 canid species, with 3/36 extant species, and 89 extinct species
# representing all three canid subfamilies: caninae, borophaginae, and hesperocyoninae

# read the character data
data <- readCharacterData("data/canidae_diet.nex")
# this includes diet data for the same 94 species, with 0 representing
# hypercarnivory, and 1 representing meso- or hypocarnivory

###
# set up useful variables and model objects

# number of states
num_states <- 2

# and root age
root <- observed_phylogeny.rootAge()

# vectors for moves and monitors
moves    = VectorMoves()
monitors = VectorMonitors()
seed(3)

###
# create parameters for the diversification and serial sampling rates

# loop through number of states, setting speciation, extinction, and fossil sampling rate for each
for (i in 1:num_states) {

  # loguniform prior on speciation
  speciation[i] ~ dnLoguniform( 1E-6, 1E2)
  moves.append( mvSlice(speciation[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )

  # and on extinction
  extinction[i] ~ dnLoguniform( 1E-6, 1E2)
  moves.append( mvSlice(extinction[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )

  # exponential prior on fossil sampling
  fossil_sampling[i] ~ dnExp(5)
  moves.append( mvSlice(fossil_sampling[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )

  # set a variable to monitor diversification rates
  diversification[i] := speciation[i] - extinction[i]
}

### 
# set up the transition rate matrix

# set transition rate prior mean - expecting ~10 character transitions throughout the tree
rate_pr := observed_phylogeny.treeLength() / 10

# loop through number of transition rates (3 * 2 = 6 in this case)
for ( i in 1:(num_states * (num_states - 1)) ) {
    
    # set it to an exponential prior
    q[i] ~ dnExp(rate_pr)
    moves.append( mvSlice(q[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )
}

# make the rate matrix Q
rate_matrix := fnFreeK( q, rescaled = false)

###
# set up last variables

# set root state frequency prior mean
root_frequencies ~ dnDirichlet( rep(1, num_states) )

# move on pi
moves.append( mvDirichletSimplex(root_frequencies, weight = 2) )
# a Dirichlet prior means we expect both states to be equally likely to
# be the root state--we could modify this based on our prior knowledge about
# canid diet evolution, but it's good to see if the data has the signal instead

# sampling at present--we know we have 4/36 extant species
extant_sampling <- 4 / 36

###
# make the final distribution and clamp it

# use dnCDBDP to build timetree distribution under MuSSE
timetree ~ dnCDBDP( rootAge           = root,
                    lambda            = speciation,
                    mu                = extinction,
                    psi               = fossil_sampling,
                    Q                 = rate_matrix,
                    pi                = root_frequencies,
                    rho               = extant_sampling)

# clamp observed tree and character data
timetree.clamp( observed_phylogeny )

timetree.clampCharData( data )

###
# final adjustments

# create model object
mymodel = model(timetree)

# add a monitor for the log
monitors.append( mnModel(filename="output/canidae_diet_bisse.log", printgen = 1000) )

# ancestral states monitor to check ancestral state estimation
monitors.append( mnJointConditionalAncestralState(tree            = timetree, 
                                                  cdbdp           = timetree, 
                                                  type            = "Standard", 
                                                  withStartStates = false,
                                                  printgen        = 100, 
                                                  filename        = "output/canidae_diet_anc_states.log") )

# and screen monitor
monitors.append( mnScreen(printgen = 10000) )

###
# run the analysis

# create mcmc object
mymcmc = mcmc(mymodel, monitors, moves)

if ( fileExists("output/canidae_diet_bisse.state") ) {

  mymcmc.initializeFromCheckpoint("output/canidae_diet_bisse.state")

}

# run MCMC
stopping_rules[1] = srMinESS(250, file = "output/canidae_diet_bisse.log", freq = 10000)

mymcmc.run(rules = stopping_rules, checkpointInterval = 1000, checkpointFile = "output/canidae_diet_bisse.state")

###
# summarize ancestral states

# read ancestral states file
anc_states = readAncestralStateTrace("output/canidae_diet_anc_states.log")

# get ancestral state tree
anc_tree = ancestralStateTree(tree                         = observed_phylogeny,
                              ancestral_state_trace_vector = anc_states,
                              include_start_states         = false,
                              file                         = "output/canidae_diet_anc_states_results.tree",
                              burnin                       = 0.1,
                              summary_statistic            = "MAP",
                              site                         = 1)

# quit
q()
