################################################################################
#
# BiSSE analysis of the influence of diet on the diversification
# rates of extant and extinct canids
#
# author: Bruno do Rosario Petrucci
#
################################################################################

###
# reading the data

# read the phylogenetic tree
tree <- readTrees("data/canidae_tree.nex")[1]
# this includes 94 canid species, with 3/36 extant species, and 89 extinct species
# representing all three canid subfamilies: caninae, borophaginae, and hesperocyoninae

# read the character data
data <- readCharacterData("data/canidae_diet.nex")
# this includes diet data for the same 94 species, with 0 representing
# hypercarnivory, and 1 representing meso- or hypocarnivory

###
# set up useful variables and model objects

# number of states
num_states <- 2

# number of hidden states
num_hidden <- 2

# total number of rates
num_rates <- num_states * num_hidden

# and root age
root_age <- tree.rootAge()

# vectors for moves and monitors
moves    = VectorMoves()
monitors = VectorMonitors()

# expand data to include the hidden characters
data_exp <- data.expandCharacters( num_hidden )

###
# create parameters for the diversification and serial sampling rates

# loop through number of rates, setting speciation, extinction, and fossil sampling rate for each
for (i in 1:num_rates) {

  # loguniform prior on speciation
  lambda[i] ~ dnLoguniform( 1E-6, 1E2)
  moves.append( mvSlice(lambda[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )

  # and on extinction
  mu[i] ~ dnLoguniform( 1E-6, 1E2)
  moves.append( mvSlice(mu[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )

  # exponential prior on fossil sampling
  psi[i] ~ dnExp(5)
  moves.append( mvSlice(psi[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )

  # set a variable to monitor diversification rates
  diversification[i] := lambda[i] - mu[i]
}

### 
# set up the transition rate matrix

# set transition rate prior mean - expecting ~10 character transitions throughout the tree
rate_pr := tree.treeLength() / 10

# loop through number of transition rates (3 * 2 = 6 in this case)
# we set hidden and observed rates separately
for ( i in 1:(num_states * (num_states - 1)) ) {
    
    # set observed rate to an exponential prior
    q_obs[i] ~ dnExp(rate_pr)
    moves.append( mvSlice(q_obs[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )

    # same for hidden rates
    q_hidden[i] ~ dnExp(rate_pr)
    moves.append( mvSlice(q_hidden[i], window = 0.1, weight = 1.0, search_method = "stepping_out") )
}

# make the rate matrix Q
Q := fnHiddenStateRateMatrix(q_obs, q_hidden, rescaled = false)

###
# set up last variables

# set root state frequency prior mean
pi ~ dnDirichlet( rep(1, num_rates) )

# move on pi
moves.append( mvDirichletSimplex(pi, weight = 2) )
# a Dirichlet prior means we expect both states to be equally likely to
# be the root state--we could modify this based on our prior knowledge about
# canid diet evolution, but it's good to see if the data has the signal instead

# sampling at present--we know we have 4/36 extant species
rho <- 4 / 36

###
# make the final distribution and clamp it

# use dnCDBDP to build timetree distribution under MuSSE
timetree ~ dnCDBDP( rootAge           = root_age,
                    lambda            = lambda,
                    mu                = mu,
                    psi               = psi,
                    Q                 = Q,
                    pi                = pi,
                    rho               = rho)

# clamp observed tree and character data
timetree.clamp( tree )

timetree.clampCharData( data_exp )

###
# final adjustments

# create model object
mymodel = model(timetree)

# add a monitor for the log
monitors.append( mnModel(filename="output/canidae_diet_hisse.log", printgen = 1000) )

# ancestral states monitor to check ancestral state estimation
monitors.append( mnJointConditionalAncestralState(tree            = timetree, 
                                                  cdbdp           = timetree, 
                                                  type            = "NaturalNumbers", 
                                                  withStartStates = false,
                                                  printgen        = 100, 
                                                  filename        = "output/canidae_diet_anc_states_hisse.log") )

# and screen monitor
monitors.append( mnScreen(printgen = 10000) )

###
# run the analysis

# create mcmc object
mymcmc = mcmc(mymodel, monitors, moves)

if ( fileExists("output/canidae_diet_hisse.state") ) {

  mymcmc.initializeFromCheckpoint("output/canidae_diet_hisse.state")

}

# run MCMC
stopping_rules[1] = srMinESS(250, file = "output/canidae_diet_hisse.log", freq = 10000)

mymcmc.run(rules = stopping_rules, checkpointInterval = 1000, checkpointFile = "output/canidae_diet_hisse.state")

###
# summarize ancestral states

# read ancestral states file
anc_states = readAncestralStateTrace("output/canidae_diet_anc_states_hisse.log")

# get ancestral state tree
anc_tree = ancestralStateTree(tree                         = tree,
                              ancestral_state_trace_vector = anc_states,
                              include_start_states         = false,
                              file                         = "output/canidae_diet_anc_states_hisse_results.tree",
                              burnin                       = 0.1,
                              summary_statistic            = "MAP",
                              site                         = 1)

# quit
q()
