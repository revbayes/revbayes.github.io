################################################################################
#
# MuSSE analysis of the influence of diet on the diversification
# rates of extant and extinct canids
#
# author: Bruno do Rosario Petrucci
#
################################################################################

loadPlugin("TensorPhylo", "/Users/petrucci/Documents/research/programs/tensorphylo/build/installer/lib")

###
# reading the data

# read the phylogenetic tree
tree <- readTrees("data/canidae_tree_jitter.nex")[1]
# this includes 94 canid species, with 3/36 extant species, and 89 extinct species
# representing all three canid subfamilies: caninae, borophaginae, and hesperocyoninae

# read the character data
data <- readCharacterData("data/canidae_diet.nex")
# this includes diet data for the same 94 species, with 0 representing
# hypercarnivory, 1 mesocarnivory, and 2 hypocarnivory

###
# set up useful variables and model objects

# number of states
num_states <- 3

# taxa
taxa <- tree.taxa()

# and root age
root_age <- tree.rootAge()

# vectors for moves and monitors
moves    = VectorMoves()
monitors = VectorMonitors()

###
# create parameters for the diversification and serial sampling rates

# loop through number of states, setting speciation, extinction, and fossil sampling rate for each
for (i in 1:num_states) {

  # loguniform prior on speciation
  lambda[i] ~ dnLoguniform( 1E-6, 1E2)
  moves.append( mvScale(lambda[i], weight = 3.0) )

  # and on extinction
  mu[i] ~ dnLoguniform( 1E-6, 1E2)
  moves.append( mvScale(mu[i], weight = 3.0) )

  # exponential prior on fossil sampling
  psi[i] ~ dnExp(5)
  moves.append( mvScale(psi[i], weight = 3.0) )

  # set a variable to monitor diversification rates
  diversification[i] := lambda[i] - mu[i]
}

### 
# set up the transition rate matrix

# set transition rate prior mean - expecting ~10 character transitions throughout the tree
rate_pr := tree.treeLength() / 10

# loop through number of transition rates (3 * 2 = 6 in this case)
for ( i in 1:(num_states * (num_states - 1)) ) {
    
    # set it to an exponential prior
    q[i] ~ dnExp(rate_pr)
    moves.append( mvScale(q[i], weight = 3.0) )
}
# note that the order these are assigned are first by the 
# origin state, then target state
# so q[1] is q_01, q[2] is q_02, q[3] is q_10, etc.

# make the rate matrix Q
Q := fnFreeK( q, rescaled = false)

###
# set up last variables

# set root state frequency 
pi ~ dnDirichlet( rep(1, num_states) )
moves.append( mvDirichletSimplex(pi, weight = 2) )
# a Dirichlet prior means we expect both states to be equally likely to
# be the root state--we could modify this based on our prior knowledge about
# canid diet evolution, but it's good to see if the data has the signal instead

# sampling at present--we know we have 3/36 extant species
rho <- 3 / 36

###
# make the final distribution and clamp it

# use dnCDBDP to build timetree distribution under MuSSE
timetree ~ dnGLHBDSP( rootAge           = root_age,
                      lambda            = lambda,
                      mu                = mu,
                      phi               = psi,
                      eta               = Q,
                      pi                = pi,
                      rho               = rho,
                      taxa              = taxa,
                      nStates           = num_states)

# clamp observed tree and character data
timetree.clamp( tree )
timetree.clampCharData( data )

###
# final adjustments

# create model object
mymodel = model(timetree)

# add a monitor for the log
monitors.append( mnModel(filename="output_tp/canidae_diet_musse.log", printgen = 1000) )

# ancestral states monitor to check ancestral state estimation
monitors.append( mnJointConditionalAncestralState(tree            = timetree, 
                                                  cdbdp           = timetree, 
                                                  type            = "Standard", 
                                                  withStartStates = false,
                                                  printgen        = 100, 
                                                  filename        = "output_tp/canidae_diet_anc_states.log") )

# and screen monitor
monitors.append( mnScreen(printgen = 10000) )

###
# run the analysis

# create mcmc object
mymcmc = mcmc(mymodel, monitors, moves)

if ( fileExists("output_tp/canidae_diet_musse.state") ) {
  mymcmc.initializeFromCheckpoint("output_tp/canidae_diet_musse.state")
}

# run MCMC
stopping_rules[1] = srMinESS(250, file = "output_tp/canidae_diet_musse.log", freq = 10000)
mymcmc.run(rules = stopping_rules, checkpointInterval = 1000, checkpointFile = "output_tp/canidae_diet_musse.state")

###
# summarize ancestral states

# read ancestral states file
anc_states = readAncestralStateTrace("output_tp/canidae_diet_anc_states.log")

# get ancestral state tree
anc_tree = ancestralStateTree(tree                         = tree,
                              ancestral_state_trace_vector = anc_states,
                              include_start_states         = false,
                              file                         = "output_tp/canidae_diet_anc_states_results.tree",
                              burnin                       = 0.1,
                              summary_statistic            = "MAP",
                              site                         = 1)

# quit
q()
