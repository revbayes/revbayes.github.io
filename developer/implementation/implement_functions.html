<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Implementing a function</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Implementing a function</h1>
	
	<h4 class="authors"></h4>
  <h5>Last modified on April 30, 2024</h5>
</div>

<p>There are two main classes of functions in RevBayes: regular functions and member functions.  For our example, we will be implement a regular function. First we need to add two files to the RevBayes source code, <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosineFunction.cpp</code> and <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosineFunction.h</code>. These will go within <code class="language-plaintext highlighter-rouge">revbayes/src/revlanguage/functions/math</code> since we are adding a function and it is a mathematical function. Second, we need to register the function by modifying <code class="language-plaintext highlighter-rouge">revbayes/src/revlanguage/workspace/RbRegister_Func.cpp</code>.</p>

<h2 class="subsection" id="revlanguage-header-file">RevLanguage Header file</h2>

<p>The file <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosine.h</code> should look like the following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#ifndef Func_hyperbolicCosine_h
#define Func_hyperbolicCosine_h
</span>
<span class="cp">#include</span> <span class="cpf">"Real.h"</span><span class="cp">
#include</span> <span class="cpf">"RlTypedFunction.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">RevLanguage</span> <span class="p">{</span>
    
    <span class="cm">/**
     * The RevLanguage wrapper of the hyperbolic Cosine function (sinh()).
     *
     * The RevLanguage wrapper of the hyperbolic function function connects
     * the variables/parameters of the function and creates the internal HyperbolicCosineFunction object.
     * Please read the HyperbolicCosineFunction.h for more info.
     *
     *
     * @copyright Copyright 2024-
     * @author The RevBayes Development Core Team (&lt;your-name&gt;)
     * @since 2024-04-26, version 1.0
     *
     */</span>
    <span class="k">class</span> <span class="nc">Func_hyperbolicCosine</span> <span class="o">:</span>  <span class="k">public</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="p">{</span>
        
    <span class="nl">public:</span>
        <span class="c1">// Basic utility functions</span>
        <span class="n">Func_hyperbolicCosine</span><span class="o">*</span>                         <span class="n">clone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                          <span class="c1">//!&lt; Clone the object</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>                       <span class="n">getClassType</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                                         <span class="c1">//!&lt; Get Rev type</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span>                          <span class="n">getClassTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                                     <span class="c1">//!&lt; Get class type spec</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                     <span class="n">getFunctionName</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                <span class="c1">//!&lt; Get the primary name of the function in Rev</span>
        <span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span>                                 <span class="n">getTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                    <span class="c1">//!&lt; Get the type spec of the instance</span>
        
        <span class="c1">// Function functions you have to override</span>
        <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span>            <span class="n">createFunction</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                 <span class="c1">//!&lt; Create internal function object</span>
        <span class="k">const</span> <span class="n">ArgumentRules</span><span class="o">&amp;</span>                            <span class="n">getArgumentRules</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                               <span class="c1">//!&lt; Get argument rules</span>
        
    <span class="p">};</span>
    
<span class="p">}</span>


<span class="cp">#endif </span><span class="cm">/* Func_hyperbolicCosine_h */</span><span class="cp">
</span>
</code></pre></div></div>

<h2 class="subsection" id="revlanguage-implementation-file">RevLanguage Implementation file</h2>

<p>And the <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosine.cpp</code> should look like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Func_hyperbolicCosine.h"</span><span class="cp">
#include</span> <span class="cpf">"Probability.h"</span><span class="cp">
#include</span> <span class="cpf">"Real.h"</span><span class="cp">
#include</span> <span class="cpf">"RlDeterministicNode.h"</span><span class="cp">
#include</span> <span class="cpf">"TypedDagNode.h"</span><span class="cp">
#include</span> <span class="cpf">"GenericFunction.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">RevLanguage</span><span class="p">;</span>

<span class="kt">double</span><span class="o">*</span> <span class="nf">hyperbolicCosine</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**
 * The clone function is a convenience function to create proper copies of inherited objected.
 * E.g. a.clone() will create a clone of the correct type even if 'a' is of derived type 'b'.
 *
 * \return A new copy of the function.
 */</span>
<span class="n">Func_hyperbolicCosine</span><span class="o">*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">clone</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Func_hyperbolicCosine</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
<span class="p">}</span>


<span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">createFunction</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Real</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getVariable</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">generic_function_ptr</span><span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">hyperbolicCosine</span><span class="p">,</span> <span class="n">x</span> <span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Get argument rules */</span>
<span class="k">const</span> <span class="n">ArgumentRules</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getArgumentRules</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">ArgumentRules</span> <span class="n">argumentRules</span> <span class="o">=</span> <span class="n">ArgumentRules</span><span class="p">();</span>
    <span class="k">static</span> <span class="kt">bool</span>          <span class="n">rules_set</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">rules_set</span> <span class="p">)</span>
    <span class="p">{</span>
        
        <span class="n">argumentRules</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">ArgumentRule</span><span class="p">(</span> <span class="s">"x"</span><span class="p">,</span> <span class="n">Real</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">(),</span> <span class="s">"The value."</span><span class="p">,</span> <span class="n">ArgumentRule</span><span class="o">::</span><span class="n">BY_CONSTANT_REFERENCE</span><span class="p">,</span> <span class="n">ArgumentRule</span><span class="o">::</span><span class="n">ANY</span> <span class="p">)</span> <span class="p">);</span>
        
        <span class="n">rules_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">argumentRules</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getClassType</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rev_type</span> <span class="o">=</span> <span class="s">"Func_hyperbolicCosine"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">rev_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get class type spec describing type of object */</span>
<span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">TypeSpec</span> <span class="n">rev_type_spec</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="p">(</span> <span class="n">getClassType</span><span class="p">(),</span> <span class="k">new</span> <span class="n">TypeSpec</span><span class="p">(</span> <span class="n">Function</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
    
    <span class="k">return</span> <span class="n">rev_type_spec</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get the primary Rev name for this function.
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getFunctionName</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create a name variable that is the same for all instance of this class</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">f_name</span> <span class="o">=</span> <span class="s">"cosh"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">f_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getTypeSpec</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">TypeSpec</span> <span class="n">type_spec</span> <span class="o">=</span> <span class="n">getClassTypeSpec</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">type_spec</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">RevBayesCore::generic_function_ptr&lt; ResultType &gt;(CppFunction, arg1, ...)</code> in <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosine::createFunction( )</code> automatically constructs a <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> from the C++ function so that we do not have to.</p>

<p>If <code class="language-plaintext highlighter-rouge">CppFunction</code> is has multiple type signatures, as is the case with functions like <code class="language-plaintext highlighter-rouge">sqrt( )</code>, <code class="language-plaintext highlighter-rouge">generic_function_ptr&lt; &gt;</code> will not work.
In such cases, we can solve this problem by writing a wrapper function with a single type signature.
For example,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Specialize sqrt to only work on doubles
double mysqrt(double x)
{
   return sqrt(x);
}
</code></pre></div></div>

<h2 class="subsection" id="registering-the-new-function">Registering the new function</h2>

<p>In order to make the new function available for use within the Rev language, we first need to register it.
To do this,</p>
<ol>
  <li>Go to the <code class="language-plaintext highlighter-rouge">src/revlanguage/workspace/</code> directory.</li>
  <li>Open the file <code class="language-plaintext highlighter-rouge">RbRegister_Func.cpp</code> file in your editor.</li>
  <li>Scroll down until you find the <code class="language-plaintext highlighter-rouge">#include</code> commands for math functions.</li>
  <li><strong>Add the line <code class="language-plaintext highlighter-rouge">#include "Func_hyperbolicCosine.h"</code> in the correct alphabetical order for that group.</strong></li>
  <li>Scroll down in that file until you find the section of the code that adds math functions.</li>
  <li><strong>Add the line <code class="language-plaintext highlighter-rouge">addFunction( new Func_hyperbolicCosine() );</code></strong></li>
</ol>

<h1 class="section" id="functions-with-caching-and-optimized-recalculation">Functions with caching and optimized recalculation</h1>

<p>The above method should be prefered for implementing new functions in RevBayes unless the function needs to save intermediate results and use them during recalculation.
For example, if our function computes <code class="language-plaintext highlighter-rouge">x*(y+z)</code>, then if only <code class="language-plaintext highlighter-rouge">x</code> has changed, we could save the old value of <code class="language-plaintext highlighter-rouge">y+z</code> and re-use it instead of computing <code class="language-plaintext highlighter-rouge">y+z</code> from scratch.  (In this case, <code class="language-plaintext highlighter-rouge">y+z</code> is not expensive enough to be worth saving, but is just a simple illustration of an intermediate result.)</p>

<p>In such cases we will also need to write a <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code>.
A <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> serves a different role than a <code class="language-plaintext highlighter-rouge">RevLanguage::Function</code>.
A <code class="language-plaintext highlighter-rouge">RevLanguage::Function</code> interprets the function arguments and connects them to the <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code>, which performs the actual calculation and holds the result.
If we write our own <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code>, then we can use the <code class="language-plaintext highlighter-rouge">update()</code> method to intelligently recalculate the value,
and we can add data memembers to save intermediate results;</p>

<p>Here will illustrate how to write a simple <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> using the hyperbolic cosine example.
Our example does’t actually save any intermediate results, it just illustrates how a <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> works.
It is therefore equivalent to the <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> that is automatically generated by <code class="language-plaintext highlighter-rouge">generic_function_ptr</code>.</p>

<h2 class="subsection" id="revbayescore-header-file">RevBayesCore Header file</h2>

<p>First, we will write our new header file. Within our header file, we need to <code class="language-plaintext highlighter-rouge">#include</code> a few other RevBayes header files, including <code class="language-plaintext highlighter-rouge">TypedDagNode.h</code> since our typed function deals with nodes of DAGs. Note that the directory structure of <code class="language-plaintext highlighter-rouge">core</code> is similar to that of the <code class="language-plaintext highlighter-rouge">revlanguage</code>.  The file <code class="language-plaintext highlighter-rouge">src/core/functions/math/HyperbolicCosineFunction.h</code> will be:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef HyperbolicCosineFunction_h 
#define HyperbolicCosineFunction_h
</span>
<span class="cp">#include</span> <span class="cpf">"TypedFunction.h"</span><span class="cp">
#include</span> <span class="cpf">"TypedDagNode.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">RevBayesCore</span> <span class="p">{</span>
    <span class="cm">/**
     * \brief Hyperbolic Cosine of a real number.
     *
     * Compute the hyperbolic cosine of a real number x. (cosh(x) = (exp(x) + exp(-x))/2).
     *
     * \copyright (c) Copyright 2009-2018 (GPL version 3)
     * \author &lt;your-name&gt;
     * \since Version 1.0, 2015-01-31
     *
     */</span>
    <span class="k">class</span> <span class="nc">HyperbolicCosineFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>

        <span class="nl">public:</span>
                                          <span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span> 

            <span class="n">HyperbolicCosineFunction</span><span class="o">*</span>     <span class="n">clone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; creates a clone</span>
            <span class="kt">void</span>                          <span class="n">update</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>      <span class="c1">//!&lt; recomputes the value</span>

        <span class="nl">protected:</span>
            <span class="kt">void</span>                          <span class="n">swapParameterInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">oldP</span><span class="p">,</span> <span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">newP</span><span class="p">);</span> <span class="c1">//!&lt; Implementation of swapping parameters</span>

        <span class="nl">private:</span>
            <span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">;</span>

    <span class="p">};</span>
<span class="p">}</span>


<span class="cp">#endif
</span></code></pre></div></div>
<p>The first part of this file should be the standard header that goes in all the files giving a brief description about what that file is as well as information about the copyright and the author of that file.</p>

<h2 class="subsection" id="revbayescore-implementation-file">RevBayesCore Implementation file</h2>

<p>Next, after including the necessary header files, we have to ensure that our new function is included within the <code class="language-plaintext highlighter-rouge">RevBayesCore</code> namespace.
Here we are implementing our hyperbolic cosine function as its own class that is derived from the typed function class. This class stores the hyperbolic cosine of a value that is held in a DAG node. We have also defined a clone method which can create a clone of our class, and an update method which will update the value of our Hyperbolic Cosine class whenever the value of the DAG node changes.</p>

<p>The file <code class="language-plaintext highlighter-rouge">src/core/functions/math/HyperbolicCosineFunction.cpp</code> will look like:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"HyperbolicCosineFunction.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">RevBayesCore</span><span class="p">;</span>

<span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="nf">double</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">),</span>
<span class="n">x</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">addParameter</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
<span class="p">}</span>


<span class="n">HyperbolicCosineFunction</span><span class="o">*</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">clone</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">swapParameterInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">oldP</span><span class="p">,</span> <span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">newP</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">oldP</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">newP</span> <span class="p">);</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="kt">void</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get the current value of x</span>
    <span class="kt">double</span> <span class="n">xValue</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">getValue</span><span class="p">();</span>

    <span class="c1">// compute the function result</span>
    <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">xValue</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xValue</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

    <span class="c1">// update the stored value</span>
    <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>        

<span class="p">}</span>
</code></pre></div></div>

<h2 id="alternate-implemention-for-createfunction">Alternate implemention for <code class="language-plaintext highlighter-rouge">createFunction</code></h2>

<p>In order to use the new <code class="language-plaintext highlighter-rouge">RevBayesCore::HyperbolicCosineFunction</code> class, we need to modify the <code class="language-plaintext highlighter-rouge">RevLanguage::Func_hyperbolicCosine</code> class to use it instead of <code class="language-plaintext highlighter-rouge">generic_function_ptr( )</code>.  To do this,</p>

<ol>
  <li>Open <code class="language-plaintext highlighter-rouge">src/revlanguage/functions/math/Func_hyperbolicCosine.cpp</code> in your editor.</li>
  <li><strong>Add an <code class="language-plaintext highlighter-rouge">#include</code> statement to make the <code class="language-plaintext highlighter-rouge">RevBayesCore::HyperbolicCosineFunction</code> class visible</strong></li>
  <li><strong>Modify the definition of <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosine::createFunction()</code></strong> as follows:</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="cp">#include</span> <span class="cpf">"HyperbolicCosineFunction.h"</span><span class="cp">
</span><span class="p">...</span>
         
<span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">createFunction</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Real</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getVariable</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="p">(</span> <span class="n">x</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol class="bibliography"></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "default highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "default highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
