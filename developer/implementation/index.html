<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Implementing functions, distributions, and moves</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
        <li><class="header-search">
  <form class="header-search-form" action="/search.html" method="get">
    <input type="text" id="search-box-nav" placeholder="Search..." name="query" style="border-color:black;background-color:white;height:32px;">
    <button type="submit" style="color:black; border-color:black;width:32px;height:32px;padding-top:4px">
        <img src="https://revbayes.github.io/assets/img/search.png" height="22px" width="28px"/>
    </button>
  </form>
</div>

</li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <!-- adds margin to main content -->
      <div class="container" style="padding-left:20px padding-right:20px;">
          <div class="titlebar">
	<h1 class="maintitle">Implementing functions, distributions, and moves</h1>
	
	<h4 class="authors"></h4>
  <h5>Last modified on August 15, 2018</h5>
</div>


<div class="sidebar no-print" style="width: 100%;">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
</blockquote>

</div>

<p class="section maintitle" id="implement_functions">Implementing a function</p>
<p>There are two main classes of functions in RevBayes: regular functions and member functions.  For our example, we will be implement a regular function. First we need to add two files to the RevBayes source code, <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosineFunction.cpp</code> and <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosineFunction.h</code>. These will go within <code class="language-plaintext highlighter-rouge">revbayes/src/revlanguage/functions/math</code> since we are adding a function and it is a mathematical function. Second, we need to register the function by modifying <code class="language-plaintext highlighter-rouge">revbayes/src/revlanguage/workspace/RbRegister_Func.cpp</code>.</p>

<h2 class="subsection" id="revlanguage-header-file">RevLanguage Header file</h2>

<p>The file <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosine.h</code> should look like the following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#ifndef Func_hyperbolicCosine_h
#define Func_hyperbolicCosine_h
</span>
<span class="cp">#include</span> <span class="cpf">"Real.h"</span><span class="cp">
#include</span> <span class="cpf">"RlTypedFunction.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">RevLanguage</span> <span class="p">{</span>
    
    <span class="cm">/**
     * The RevLanguage wrapper of the hyperbolic Cosine function (sinh()).
     *
     * The RevLanguage wrapper of the hyperbolic function function connects
     * the variables/parameters of the function and creates the internal HyperbolicCosineFunction object.
     * Please read the HyperbolicCosineFunction.h for more info.
     *
     *
     * @copyright Copyright 2024-
     * @author The RevBayes Development Core Team (&lt;your-name&gt;)
     * @since 2024-04-26, version 1.0
     *
     */</span>
    <span class="k">class</span> <span class="nc">Func_hyperbolicCosine</span> <span class="o">:</span>  <span class="k">public</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="p">{</span>
        
    <span class="nl">public:</span>
        <span class="c1">// Basic utility functions</span>
        <span class="n">Func_hyperbolicCosine</span><span class="o">*</span>                         <span class="n">clone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                          <span class="c1">//!&lt; Clone the object</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>                       <span class="n">getClassType</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                                         <span class="c1">//!&lt; Get Rev type</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span>                          <span class="n">getClassTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                                     <span class="c1">//!&lt; Get class type spec</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                     <span class="n">getFunctionName</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                <span class="c1">//!&lt; Get the primary name of the function in Rev</span>
        <span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span>                                 <span class="n">getTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                    <span class="c1">//!&lt; Get the type spec of the instance</span>
        
        <span class="c1">// Function functions you have to override</span>
        <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span>            <span class="n">createFunction</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                 <span class="c1">//!&lt; Create internal function object</span>
        <span class="k">const</span> <span class="n">ArgumentRules</span><span class="o">&amp;</span>                            <span class="n">getArgumentRules</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                               <span class="c1">//!&lt; Get argument rules</span>
        
    <span class="p">};</span>
    
<span class="p">}</span>


<span class="cp">#endif </span><span class="cm">/* Func_hyperbolicCosine_h */</span><span class="cp">
</span>
</code></pre></div></div>

<h2 class="subsection" id="revlanguage-implementation-file">RevLanguage Implementation file</h2>

<p>And the <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosine.cpp</code> should look like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Func_hyperbolicCosine.h"</span><span class="cp">
#include</span> <span class="cpf">"Probability.h"</span><span class="cp">
#include</span> <span class="cpf">"Real.h"</span><span class="cp">
#include</span> <span class="cpf">"RlDeterministicNode.h"</span><span class="cp">
#include</span> <span class="cpf">"TypedDagNode.h"</span><span class="cp">
#include</span> <span class="cpf">"GenericFunction.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">RevLanguage</span><span class="p">;</span>

<span class="kt">double</span><span class="o">*</span> <span class="nf">hyperbolicCosine</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**
 * The clone function is a convenience function to create proper copies of inherited objected.
 * E.g. a.clone() will create a clone of the correct type even if 'a' is of derived type 'b'.
 *
 * \return A new copy of the function.
 */</span>
<span class="n">Func_hyperbolicCosine</span><span class="o">*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">clone</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Func_hyperbolicCosine</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
<span class="p">}</span>


<span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">createFunction</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Real</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getVariable</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">generic_function_ptr</span><span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">hyperbolicCosine</span><span class="p">,</span> <span class="n">x</span> <span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Get argument rules */</span>
<span class="k">const</span> <span class="n">ArgumentRules</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getArgumentRules</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">ArgumentRules</span> <span class="n">argumentRules</span> <span class="o">=</span> <span class="n">ArgumentRules</span><span class="p">();</span>
    <span class="k">static</span> <span class="kt">bool</span>          <span class="n">rules_set</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">rules_set</span> <span class="p">)</span>
    <span class="p">{</span>
        
        <span class="n">argumentRules</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">ArgumentRule</span><span class="p">(</span> <span class="s">"x"</span><span class="p">,</span> <span class="n">Real</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">(),</span> <span class="s">"The value."</span><span class="p">,</span> <span class="n">ArgumentRule</span><span class="o">::</span><span class="n">BY_CONSTANT_REFERENCE</span><span class="p">,</span> <span class="n">ArgumentRule</span><span class="o">::</span><span class="n">ANY</span> <span class="p">)</span> <span class="p">);</span>
        
        <span class="n">rules_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">argumentRules</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getClassType</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rev_type</span> <span class="o">=</span> <span class="s">"Func_hyperbolicCosine"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">rev_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get class type spec describing type of object */</span>
<span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">TypeSpec</span> <span class="n">rev_type_spec</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="p">(</span> <span class="n">getClassType</span><span class="p">(),</span> <span class="k">new</span> <span class="n">TypeSpec</span><span class="p">(</span> <span class="n">Function</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
    
    <span class="k">return</span> <span class="n">rev_type_spec</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get the primary Rev name for this function.
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getFunctionName</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create a name variable that is the same for all instance of this class</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">f_name</span> <span class="o">=</span> <span class="s">"cosh"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">f_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getTypeSpec</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">TypeSpec</span> <span class="n">type_spec</span> <span class="o">=</span> <span class="n">getClassTypeSpec</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">type_spec</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">RevBayesCore::generic_function_ptr&lt; ResultType &gt;(CppFunction, arg1, ...)</code> in <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosine::createFunction( )</code> automatically constructs a <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> from the C++ function so that we do not have to.</p>

<p>If <code class="language-plaintext highlighter-rouge">CppFunction</code> is has multiple type signatures, as is the case with functions like <code class="language-plaintext highlighter-rouge">sqrt( )</code>, <code class="language-plaintext highlighter-rouge">generic_function_ptr&lt; &gt;</code> will not work.
In such cases, we can solve this problem by writing a wrapper function with a single type signature.
For example,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Specialize sqrt to only work on doubles
double mysqrt(double x)
{
   return sqrt(x);
}
</code></pre></div></div>

<h2 class="subsection" id="registering-the-new-function">Registering the new function</h2>

<p>In order to make the new function available for use within the Rev language, we first need to register it.
To do this,</p>
<ol>
  <li>Go to the <code class="language-plaintext highlighter-rouge">src/revlanguage/workspace/</code> directory.</li>
  <li>Open the file <code class="language-plaintext highlighter-rouge">RbRegister_Func.cpp</code> file in your editor.</li>
  <li>Scroll down until you find the <code class="language-plaintext highlighter-rouge">#include</code> commands for math functions.</li>
  <li><strong>Add the line <code class="language-plaintext highlighter-rouge">#include "Func_hyperbolicCosine.h"</code> in the correct alphabetical order for that group.</strong></li>
  <li>Scroll down in that file until you find the section of the code that adds math functions.</li>
  <li><strong>Add the line <code class="language-plaintext highlighter-rouge">addFunction( new Func_hyperbolicCosine() );</code></strong></li>
</ol>

<h1 class="section" id="functions-with-caching-and-optimized-recalculation">Functions with caching and optimized recalculation</h1>

<p>The above method should be prefered for implementing new functions in RevBayes unless the function needs to save intermediate results and use them during recalculation.
For example, if our function computes <code class="language-plaintext highlighter-rouge">x*(y+z)</code>, then if only <code class="language-plaintext highlighter-rouge">x</code> has changed, we could save the old value of <code class="language-plaintext highlighter-rouge">y+z</code> and re-use it instead of computing <code class="language-plaintext highlighter-rouge">y+z</code> from scratch.  (In this case, <code class="language-plaintext highlighter-rouge">y+z</code> is not expensive enough to be worth saving, but is just a simple illustration of an intermediate result.)</p>

<p>In such cases we will also need to write a <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code>.
A <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> serves a different role than a <code class="language-plaintext highlighter-rouge">RevLanguage::Function</code>.
A <code class="language-plaintext highlighter-rouge">RevLanguage::Function</code> interprets the function arguments and connects them to the <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code>, which performs the actual calculation and holds the result.
If we write our own <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code>, then we can use the <code class="language-plaintext highlighter-rouge">update()</code> method to intelligently recalculate the value,
and we can add data memembers to save intermediate results;</p>

<p>Here will illustrate how to write a simple <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> using the hyperbolic cosine example.
Our example does’t actually save any intermediate results, it just illustrates how a <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> works.
It is therefore equivalent to the <code class="language-plaintext highlighter-rouge">RevBayesCore::Function</code> that is automatically generated by <code class="language-plaintext highlighter-rouge">generic_function_ptr</code>.</p>

<h2 class="subsection" id="revbayescore-header-file">RevBayesCore Header file</h2>

<p>First, we will write our new header file. Within our header file, we need to <code class="language-plaintext highlighter-rouge">#include</code> a few other RevBayes header files, including <code class="language-plaintext highlighter-rouge">TypedDagNode.h</code> since our typed function deals with nodes of DAGs. Note that the directory structure of <code class="language-plaintext highlighter-rouge">core</code> is similar to that of the <code class="language-plaintext highlighter-rouge">revlanguage</code>.  The file <code class="language-plaintext highlighter-rouge">src/core/functions/math/HyperbolicCosineFunction.h</code> will be:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef HyperbolicCosineFunction_h 
#define HyperbolicCosineFunction_h
</span>
<span class="cp">#include</span> <span class="cpf">"TypedFunction.h"</span><span class="cp">
#include</span> <span class="cpf">"TypedDagNode.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">RevBayesCore</span> <span class="p">{</span>
    <span class="cm">/**
     * \brief Hyperbolic Cosine of a real number.
     *
     * Compute the hyperbolic cosine of a real number x. (cosh(x) = (exp(x) + exp(-x))/2).
     *
     * \copyright (c) Copyright 2009-2018 (GPL version 3)
     * \author &lt;your-name&gt;
     * \since Version 1.0, 2015-01-31
     *
     */</span>
    <span class="k">class</span> <span class="nc">HyperbolicCosineFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>

        <span class="nl">public:</span>
                                          <span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span> 

            <span class="n">HyperbolicCosineFunction</span><span class="o">*</span>     <span class="n">clone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; creates a clone</span>
            <span class="kt">void</span>                          <span class="n">update</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>      <span class="c1">//!&lt; recomputes the value</span>

        <span class="nl">protected:</span>
            <span class="kt">void</span>                          <span class="n">swapParameterInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">oldP</span><span class="p">,</span> <span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">newP</span><span class="p">);</span> <span class="c1">//!&lt; Implementation of swapping parameters</span>

        <span class="nl">private:</span>
            <span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">;</span>

    <span class="p">};</span>
<span class="p">}</span>


<span class="cp">#endif
</span></code></pre></div></div>
<p>The first part of this file should be the standard header that goes in all the files giving a brief description about what that file is as well as information about the copyright and the author of that file.</p>

<h2 class="subsection" id="revbayescore-implementation-file">RevBayesCore Implementation file</h2>

<p>Next, after including the necessary header files, we have to ensure that our new function is included within the <code class="language-plaintext highlighter-rouge">RevBayesCore</code> namespace.
Here we are implementing our hyperbolic cosine function as its own class that is derived from the typed function class. This class stores the hyperbolic cosine of a value that is held in a DAG node. We have also defined a clone method which can create a clone of our class, and an update method which will update the value of our Hyperbolic Cosine class whenever the value of the DAG node changes.</p>

<p>The file <code class="language-plaintext highlighter-rouge">src/core/functions/math/HyperbolicCosineFunction.cpp</code> will look like:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"HyperbolicCosineFunction.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">RevBayesCore</span><span class="p">;</span>

<span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="nf">double</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">),</span>
<span class="n">x</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">addParameter</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
<span class="p">}</span>


<span class="n">HyperbolicCosineFunction</span><span class="o">*</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">clone</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">swapParameterInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">oldP</span><span class="p">,</span> <span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">newP</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">oldP</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">newP</span> <span class="p">);</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="kt">void</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get the current value of x</span>
    <span class="kt">double</span> <span class="n">xValue</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">getValue</span><span class="p">();</span>

    <span class="c1">// compute the function result</span>
    <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">xValue</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">xValue</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

    <span class="c1">// update the stored value</span>
    <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>        

<span class="p">}</span>
</code></pre></div></div>

<h2 id="alternate-implemention-for-createfunction">Alternate implemention for <code class="language-plaintext highlighter-rouge">createFunction</code></h2>

<p>In order to use the new <code class="language-plaintext highlighter-rouge">RevBayesCore::HyperbolicCosineFunction</code> class, we need to modify the <code class="language-plaintext highlighter-rouge">RevLanguage::Func_hyperbolicCosine</code> class to use it instead of <code class="language-plaintext highlighter-rouge">generic_function_ptr( )</code>.  To do this,</p>

<ol>
  <li>Open <code class="language-plaintext highlighter-rouge">src/revlanguage/functions/math/Func_hyperbolicCosine.cpp</code> in your editor.</li>
  <li><strong>Add an <code class="language-plaintext highlighter-rouge">#include</code> statement to make the <code class="language-plaintext highlighter-rouge">RevBayesCore::HyperbolicCosineFunction</code> class visible</strong></li>
  <li><strong>Modify the definition of <code class="language-plaintext highlighter-rouge">Func_hyperbolicCosine::createFunction()</code></strong> as follows:</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="cp">#include</span> <span class="cpf">"HyperbolicCosineFunction.h"</span><span class="cp">
</span><span class="p">...</span>
         
<span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">createFunction</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Real</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getVariable</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="p">(</span> <span class="n">x</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="section maintitle" id="implement_distributions">Implementing a distribution</p>
<h2 id="general-info-before-getting-started">General info before getting started</h2>

<ul>
  <li>
    <p>Within the RevBayes <strong>core</strong> directory, there are subdirectories for different categories of distributions. 
All mathematical distributions that have been implemented exist in <code class="language-plaintext highlighter-rouge">core/distributions/math</code>.</p>
  </li>
  <li>
    <p>Note that when implementing a new distribution, you will need to create <code class="language-plaintext highlighter-rouge">.cpp</code> and <code class="language-plaintext highlighter-rouge">.h</code> files in both the <strong>revlanguage</strong> directory and the <strong>core</strong> directory. (For a refresher on the difference between these two directories, refer to the <a href="/developer/architecture/">Getting familiar with the code</a> section of this Developer’s guide).
The overall naming format remains the same for every distribution in RevBayes. In the Beta Binomial Distribution example provided below, I specify what naming convention to use when creating each file.</p>
  </li>
  <li>
    <p>It is often helpful to look at/borrow code from existing RevBayes distributions for general help on syntax and organization.</p>
  </li>
</ul>

<p>For the language side, one of the most important things is the create distribution function (it converts user-arguments into calculations). Also, the getParameterRules function is important (to get the degrees of freedom &amp; other things). It is often helpful to look at the code of existing distributions for general help on syntax &amp; organization.</p>

<ul>
  <li>
    <p>Within every new distribution, you will need to include some functions. For example, each new distribution must have: the get class type, name, and help functions. You may not need to implement these from scratch (if they’re dictated by the parent class &amp; are already present), but you will need to implement other functions within your distribution (e.g. cdf, rv, quantile).</p>
  </li>
  <li>
    <p>Distributions have a prefix <code class="language-plaintext highlighter-rouge">DN</code> (dag node), and all moves have a prefix <code class="language-plaintext highlighter-rouge">MV</code>. RevBayes takes the name within &amp; creates the <code class="language-plaintext highlighter-rouge">DN</code> automatically, so be aware of this. For a refresher on DAG nodes, refer to <a href="/developer/architecture/">Getting familiar with the code</a>.</p>
  </li>
</ul>

<p>In the following steps, we’ll implement the <strong>Beta Binomial Distribution</strong> as an example, for syntax purposes.</p>

<h2 id="steps">Steps</h2>

<ol>
  <li>
    <p>Create new .cpp &amp; .h files in <code class="language-plaintext highlighter-rouge">revlanguage/distributions/math/</code>, named <code class="language-plaintext highlighter-rouge">Dist_betabinomial.cpp</code> and <code class="language-plaintext highlighter-rouge">Dist_betaBinomial.h</code>. 
<strong>Note:</strong> all files in this directory will follow this naming format: <code class="language-plaintext highlighter-rouge">Dist_&lt;nameofdistribution&gt;.[cpp|h]</code>.</p>

    <p>To populate these files, look at existing examples of similar distributions for specific info on what to include &amp; on proper syntax.  For example, for the Beta Binomial distribution, I checked the existing Binomial Distribution code for guidance.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//add code here</span>
</code></pre></div>    </div>
  </li>
  <li>Test
    <ol>
      <li>
        <p>Create new <code class="language-plaintext highlighter-rouge">.cpp</code> &amp; <code class="language-plaintext highlighter-rouge">.h</code> files in <code class="language-plaintext highlighter-rouge">core/distributions/math/</code>, named <code class="language-plaintext highlighter-rouge">BetaBinomialDistribution.cpp</code> and <code class="language-plaintext highlighter-rouge">BetaBinomialDistribution.h</code>.</p>

        <p><strong>Note:</strong> This is the object oriented wrapper code that references the functions hard-coded in the next step. All files in this directory will follow this naming format: <code class="language-plaintext highlighter-rouge">&lt;NameOfDistribution&gt;Distribution.[cpp|h]</code>.</p>
      </li>
      <li>
        <p>Create new <code class="language-plaintext highlighter-rouge">.cpp</code> and <code class="language-plaintext highlighter-rouge">.h</code> files in <code class="language-plaintext highlighter-rouge">core/math/Distributions/</code>, named <code class="language-plaintext highlighter-rouge">DistributionBetaBinomial.cpp</code> and <code class="language-plaintext highlighter-rouge">DistributionBetaBinomial.h</code>.</p>

        <p>These are the raw procedural functions in the RevBayes namespace (e.g. pdf, cdf, quantile); they are not derived functions. <code class="language-plaintext highlighter-rouge">RbStatistics</code> is a namespace. To populate these files, look at existing examples of similar distributions to get an idea of what functions to include, what variables are needed, and the proper syntax.</p>

        <p><strong>Note:</strong> This is the most time-consuming step in the entire process of implementing a new distribution. All files in this directory will follow this naming format: <code class="language-plaintext highlighter-rouge">Distribution&lt;NameOfDistribution&gt;.[cpp|h]</code></p>
      </li>
    </ol>
  </li>
  <li>
    <p>Navigate to <code class="language-plaintext highlighter-rouge">revlanguage/workspace/RbRegister_Dist.cpp</code></p>

    <p><strong>Every</strong> new implementation must be registered in RevBayes. All register files are located in the <code class="language-plaintext highlighter-rouge">revlanguage/workspace</code> directory, and there are different files for the different types of implementations (<code class="language-plaintext highlighter-rouge">RbRegister_Func.cpp</code> is for registering functions; <code class="language-plaintext highlighter-rouge">RbRegister_Move</code> is for registering moves; etc.).  We are implementing a distribution, so we will edit the <code class="language-plaintext highlighter-rouge">RbRegister_Dist.cpp</code> file.</p>
  </li>
  <li>
    <p>You need to have an include statement at the top of the <code class="language-plaintext highlighter-rouge">RbRegister</code> script, to effectively add your distribution to the RevBayes language. You also need to add code to the bottom of this file, and give it a type and a <em>new</em> constructor. Generally, you can look within the file for an idea of proper syntax to use.</p>

    <p>For the Beta Binomial distribution, we navigate to the section in the file with the header ‘Distributions’ and then look for the sub-header dealing with ‘math distributions’. Then, add the following line of code:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"Dist_betaBinomial.h"</span><span class="cp">
</span></code></pre></div>    </div>

    <p>This step registers the header file for the beta binomial distribution, effectively adding it to RevBayes.</p>

    <p>Next, navigate to the section of the file that initializes the global workspace. This section defines the workspace class, which houses info on all distributions. Then, add the following line of code:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AddDistribution</span><span class="o">&lt;</span> <span class="n">Natural</span>		<span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="nf">Dist_betaBinomial</span><span class="p">());</span>
</code></pre></div>    </div>

    <p>This adds the distribution to the workspace. Without this step, the beta binomial distribution will not be added to the <code class="language-plaintext highlighter-rouge">revlanguage</code>.</p>

    <p><strong>Note:</strong> Depending on the kind of distribution, you may need to change <code class="language-plaintext highlighter-rouge">Natural</code> to a different type (e.g. <code class="language-plaintext highlighter-rouge">Probability</code>, <code class="language-plaintext highlighter-rouge">Real</code>, <code class="language-plaintext highlighter-rouge">RealPos</code>, etc.).</p>

    <p>After registering your distribution, you are ready to test your code.</p>
  </li>
  <li>
    <p>Before pushing your changes, you should ensure your code is working properly.</p>

    <p>There are multiple ways to do this. As a best practice, you should first compile it to ensure there are no errors. Once it compiles with no problems, you can test in various ways (e.g. run each individual function within the new Beta Binomial distribution in R, then run the Binomial distribution with a Beta prior in Rev and see if the output matches). For more information, see the developer tutorials on <a href="../validation/">validation</a> and testing. (TODO)</p>

    <p>After ensuring your code runs properly, you are ready to add it to the git repo. We recommend reading through the <a href="/developer/git-flow.html">RevBayes Git Workflow</a> section of the Developer’s guide before pushing.</p>
  </li>
</ol>

<p class="section maintitle" id="implement_moves">Implementing a Metropolis-Hastings Move</p>
<h2 id="general-info-before-getting-started">General info before getting started</h2>

<p>The steps to implementing a new move vary slightly, depending on the move’s type (e.g., Metropolis-Hastings versus Gibbs). For the purpose of this guide, we will focus on a Metropolis-Hastings move.</p>

<p>In general, the fastest and easiest way to get help is to find the most similar move already implemented in RevBayes and use it as a guide. Remember that, as with implementing a new distribution or function, you’ll need to add relevant code to both the core of RevBayes and the language. Also remember that you’ll need to work out the math appropriate for your move (e.g., the Hastings ratio) ahead of time.</p>

<h2 id="steps">Steps</h2>

<ol>
  <li>
    <p><em>Orienting within the repository</em> - For the <strong>core</strong>, navigate in the repository to <code class="language-plaintext highlighter-rouge">src/core/moves</code>. For a Metropolis-Hastings move, we’ll then go into the <code class="language-plaintext highlighter-rouge">proposal</code> directory. In this directory, you can find several templates for generic proposal classes, as well as subdirectories containing moves for specific parameter types. To keep things easy, we’ll focus on a single scalar parameter, so we’ll navigate one step further into the <code class="language-plaintext highlighter-rouge">scalar</code> directory. For the <strong>language</strong>, navigate to <code class="language-plaintext highlighter-rouge">src/revlanguage/moves</code>. For this example, as we did in the core, we’ll focus on a move for a scalar parameter, so we’ll then open <code class="language-plaintext highlighter-rouge">scalar</code>. To <strong>register</strong> our new move after it’s implemented, we’ll also need to update the file <code class="language-plaintext highlighter-rouge">src/revlanguage/workspace/RbRegister_Move.cpp</code>.</p>
  </li>
  <li>
    <p><em>Creating new files for the core</em> - As an example, we’ll implement a new move that draws a random value from a Gamma distribution and proposes a new scalar by multiplying the current value by the draw from the Gamma. This move will be called a “Gamma Scaling move”. Since this move is similar to an existing scaling move, we can start by copying the file <code class="language-plaintext highlighter-rouge">ScaleProposal.h</code> and naming the new copy <code class="language-plaintext highlighter-rouge">GammaScaleProposal.h</code>. As a reminder, we’re working in the directory <code class="language-plaintext highlighter-rouge">src/core/moves/proposal/scalar/</code>.</p>

    <p>Once the new <strong>header file</strong> is created and named, we can update the content to match our new move. The simplest changes involve renaming things to match the new move (e.g., updating the preprocessor macro from <code class="language-plaintext highlighter-rouge">ScaleProposal_H</code> to <code class="language-plaintext highlighter-rouge">GammaScaleProposal_H</code>, or changing the name of object references and constructor from <code class="language-plaintext highlighter-rouge">ScaleProposal</code> to <code class="language-plaintext highlighter-rouge">GammaScaleProposal</code>). The comments at the top of the header file that describe how the move works should also be updated, but these changes will obviously be specific to the move being implemented.</p>

    <p>Next, we’ll need to create a <strong>new .cpp file</strong> containing the implementation of our new move. As with the header, it’s easiest to copy and rename an existing file, so we’ll use <code class="language-plaintext highlighter-rouge">ScaleProposal.cpp</code> as our template, copy it, and rename to <code class="language-plaintext highlighter-rouge">GammaScaleProposal.cpp</code>. As with the header file, most of the necessary changes involve updating the names of variables and function names. If the move requires access to other math functions, additional header files may need to be included at the top. Explore <code class="language-plaintext highlighter-rouge">src/core/math</code> as needed to find the necessary functions or distributions. In this case, we will need access to methods associated with the Gamma distribution, so we will add <code class="language-plaintext highlighter-rouge">#include "DistributionGamma.h"</code>. For our example, the number and type of variables used by our move are the same as our template based on the Scale move, so we don’t need to modify the constructor or variable initialization, other than updating the constructor name. Similarly for this example, we don’t need to alter the code in the <code class="language-plaintext highlighter-rouge">::cleanProposal</code>, <code class="language-plaintext highlighter-rouge">::clone</code>, <code class="language-plaintext highlighter-rouge">::prepareProposal</code>, <code class="language-plaintext highlighter-rouge">::printParameterSummary</code>, <code class="language-plaintext highlighter-rouge">::undoProposal</code>, <code class="language-plaintext highlighter-rouge">::swapNodeInternal</code>, and <code class="language-plaintext highlighter-rouge">::tune</code> methods as these are common to our template and new moves (and will be identical to many of the scalar moves), but we do need to update the class names associated with the methods (i.e., <code class="language-plaintext highlighter-rouge">ScaleMove::</code> -&gt; <code class="language-plaintext highlighter-rouge">GammaScaleMove::</code>). For the <code class="language-plaintext highlighter-rouge">::getProposalName</code> method, we need to update the string in the method that provides a descriptive name for the move - <code class="language-plaintext highlighter-rouge">name = "Gamma Scaling"</code>. The bulk of the necessary changes for the new move will come in the <code class="language-plaintext highlighter-rouge">::propose</code> method and the help description above the method. For this example, the new <code class="language-plaintext highlighter-rouge">::propose</code> method looks like this:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Perform the proposal.
 *
 * A gamma scaling proposal draws a random number from a gamma distribution u ~ Gamma(lambda,1) and scales the current vale by u
 * lambda is the tuning parameter of the proposal which influences the size of the proposals by changing the shape of the Gamma.
 *
 * \return The hastings ratio.
 */</span>
<span class="kt">double</span> <span class="n">GammaScaleProposal</span><span class="o">::</span><span class="n">propose</span><span class="p">(</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">val</span> <span class="p">)</span>
<span class="p">{</span>
    
    <span class="c1">// Get random number generator</span>
    <span class="n">RandomNumberGenerator</span><span class="o">*</span> <span class="n">rng</span>     <span class="o">=</span> <span class="n">GLOBAL_RNG</span><span class="p">;</span>
    
    <span class="c1">// copy value</span>
    <span class="n">storedValue</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    
    <span class="c1">// Generate new value (no reflection, so we simply abort later if we propose value here outside of support)</span>
    <span class="kt">double</span> <span class="n">u</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">rv</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="n">rng</span><span class="p">);</span>
    <span class="n">val</span> <span class="o">*=</span> <span class="n">u</span><span class="p">;</span>
    
    <span class="c1">// compute the Hastings ratio</span>
    <span class="kt">double</span> <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// compute the Hastings ratio</span>
        <span class="kt">double</span> <span class="n">forward</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">lnPdf</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">backward</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">lnPdf</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">u</span><span class="p">));</span>
        
        <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="n">backward</span> <span class="o">-</span> <span class="n">forward</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>    <span class="c1">// The -log(u) term is the Jacobian</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">RbException</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="n">RbConstants</span><span class="o">::</span><span class="n">Double</span><span class="o">::</span><span class="n">neginf</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ln_hastings_ratio</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>In this case, the Hastings ratio involves the probability density of the forward move (the scaling factor <em>u</em>), the density of the corresponding backward move (the scaling factor $\frac{1}{u}$), and the solution to the Jacobian ($-\frac{1}{u}$).</p>
  </li>
  <li>
    <p><em>Creating new files for the rev language</em> - After implementing the detailed machinery to perform the new move in the RevBayes core, you need to modify a few files associated with the Rev language to make it available to users. As a reminder, the first set of these files is found in <code class="language-plaintext highlighter-rouge">src/revlanguage/moves</code>. For our example, we will be focusing specifically on a move for a scalar value, so navigate to the <code class="language-plaintext highlighter-rouge">scalar</code> subdirectory. As with the files in the core, we will copy and rename a header (.h) and implementation (.cpp) file from the Scale move. In this case, our new header file will be called <code class="language-plaintext highlighter-rouge">Move_GammaScale.h</code> and our new implementation file will be called <code class="language-plaintext highlighter-rouge">Move_GammaScale.cpp</code>. In the <strong>header file</strong>, simply update the names of the preprocessor macro, the class, and the objects. Also remember to update the help comments near the top of the file.</p>

    <p>In the new <strong>.cpp file</strong>, begin by updating the names of the header files included at the top. Note that we include, and will need to update, the names of both the header for the core <code class="language-plaintext highlighter-rouge">GammaScaleProposal.h</code> and the workspace <code class="language-plaintext highlighter-rouge">Move_GammaScale.h</code>. Most of the rest of the changes in this file involve updating the names of classes and objects associated with this move, but we also need to update the string specifying the type in the <code class="language-plaintext highlighter-rouge">::getClassType</code> method and specifying the constructor name in the <code class="language-plaintext highlighter-rouge">::getMoveName</code> method. Pay special attention to the rules specified in <code class="language-plaintext highlighter-rouge">::getParameterRules</code> and make sure they satisfy the constraints required by the new move. Update these rules as needed, using existing rules from other moves as templates.</p>

    <p>For our particular example, we also need to make one additional change. Because we’ve only updated the <code class="language-plaintext highlighter-rouge">ScaleProposal</code>, and not the <code class="language-plaintext highlighter-rouge">ScaleProposalContinuous</code>, we need to remove the part of the code in this move that could call <code class="language-plaintext highlighter-rouge">ScaleProposalContinuous</code>. The <code class="language-plaintext highlighter-rouge">::constructInternalObject</code> method now looks like this (compare to the corresponding method from <code class="language-plaintext highlighter-rouge">Move_Scale.cpp</code>):</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Move_GammaScale</span><span class="o">::</span><span class="n">constructInternalObject</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// we free the memory first</span>
    <span class="k">delete</span> <span class="n">value</span><span class="p">;</span>
    
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">Proposal</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="c1">// now allocate a new sliding move</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">lambda</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">w</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">weight</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Probability</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">tuneTarget</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">StochasticNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">RevBayesCore</span><span class="o">::</span><span class="n">StochasticNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">tmp</span> <span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">GammaScaleProposal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">t</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RlBoolean</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">tune</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    
    <span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">MetropolisHastingsMove</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
    
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>Updating the Rev language register</em> - The last step in implementing our new move is to make sure that it’s registered in the Rev language. To do this, we will need to update the file <code class="language-plaintext highlighter-rouge">RbRegister_Move.cpp</code> in <code class="language-plaintext highlighter-rouge">src/revlanguage/workspace</code>. In this file, we’ll need to include the header for our new move <code class="language-plaintext highlighter-rouge">#include "Move_GammaScale.h"</code> in the section corresponding to moves on real values. We’ll also need to add the constructor to the workspace by updating the <code class="language-plaintext highlighter-rouge">::initializeMoveGlobalWorkspace</code> method to include <code class="language-plaintext highlighter-rouge">addTypeWithConstructor( new Move_GammaScale() );</code>, again in the section corresponding to moves on real values.</p>
  </li>
  <li>
    <p><em>Testing the performance of the new move</em> - If properly implemented, a new move can be validated by running an MCMC analysis where the clamped data are ignored and one tries to sample only the prior. This can be done in RevBayes by calling <code class="language-plaintext highlighter-rouge">model.ignoreAllData()</code> to mark the data as ignored. The recommended strategy is to implement the simplest possible model that uses a variable of the type appropriate for the new move, and assigning that variable an easily validated prior (e.g., a uniform). Run the analysis with only the new move operating on that variable and then plot the variable’s marginal distribution to make sure it matches the prior.</p>
  </li>
</ol>


<ol class="bibliography"></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>
      </div>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "default highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "default highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
