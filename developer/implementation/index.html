<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="http://localhost:4000/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Implementing functions, distributions, and moves</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/software">Software</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="https://revbayes.github.io/revscripter/">RevScripter</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Implementing functions, distributions, and moves</h1>
	
	<h4 class="authors"></h4>
  <h5>Last modified on August 15, 2018</h5>
</div>


<div class="sidebar no-print" style="width: 100%;">
<blockquote class="overview" id="overview">
  <h2>Overview</h2>
  
</blockquote>

</div>

<p class="section maintitle" id="implement_functions">Implementing a function</p>
<p>There are two main classes of functions in RevBayes: member functions and typed functions. Member functions are functions used inside of deterministic nodes and allow access to member methods of a member object. Typed functions are either values within directed acyclic graph (DAG) nodes (i.e. random variables of some distribution), or are associated with a deterministic node. All deterministic nodes hold a function, the value of these deterministic nodes are returned by a call to that function. This has the advantage of simply modifying the value instead of creating a new object.</p>

<p>For our example implementation we will be implementing a typed function. We will begin with a simple example of implementing a mathematical function, the hyperbolic cosine function. First we need to add two files to the RevBayes source code, a <code class="highlighter-rouge">HyperbolicCosineFunction.cpp</code> and a <code class="highlighter-rouge">HyperbolicCosineFunction.h</code>. These will go within <code class="highlighter-rouge">revbayes/src/core/functions/math</code> since we are adding a function and it is a mathematical function.</p>

<p>First, we will write our header file. Within our header file, we need to <code class="highlighter-rouge">include</code> a few other RevBayes header files, including <code class="highlighter-rouge">ContinousFunction.h</code> since hyperbolic cosine is a continuous function, and <code class="highlighter-rouge">TypedDagNode.h</code> since our typed function deals with nodes of DAGs.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef HyperbolicCosineFunction_h 
#define HyperbolicCosineFunction_h
</span>
<span class="cp">#include "ContinuousFunction.h"
#include "TypedDagNode.h"
#include &lt;cmath&gt;
</span>
<span class="k">namespace</span> <span class="n">RevBayesCore</span> <span class="p">{</span>
    <span class="cm">/**
     * \brief Hyperbolic Cosine of a real number.
     *
     * Compute the hyperbolic cosine of a real number x. (cosh(x) = (exp(x) + exp(-x))/2).
     *
     * \copyright (c) Copyright 2009-2018 (GPL version 3)
     * \author &lt;your-name&gt;
     * \since Version 1.0, 2015-01-31
     *
     */</span>
    <span class="k">class</span> <span class="nc">HyperbolicCosineFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ContinuousFunction</span> <span class="p">{</span>

        <span class="k">public</span><span class="o">:</span>
                                          <span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span> 

            <span class="n">HyperbolicCosineFunction</span><span class="o">*</span>     <span class="n">clone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; creates a clone
</span>            <span class="kt">void</span>                          <span class="n">update</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>      <span class="c1">//!&lt; recomputes the value
</span>
        <span class="k">protected</span><span class="o">:</span>
            <span class="kt">void</span>                          <span class="n">swapParameterInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">oldP</span><span class="p">,</span> <span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">newP</span><span class="p">);</span> <span class="c1">//!&lt; Implementation of swapping parameters
</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">;</span>

    <span class="p">};</span>
<span class="p">}</span>


<span class="cp">#endif
</span></code></pre></div></div>
<p>The first part of this file should be the standard header that goes in all the files giving a brief description about what that file is as well as information about the copyright and the author of that file.
Next, after including the necessary header files, we have to ensure that our new function is included within the <code class="highlighter-rouge">RevBayesCore</code> namespace.
Here we are implementing our hyperbolic cosine function as its own class that is derived from the continuous function class that is derived from the typed function class. This class stores the hyperbolic cosine of a value that is held in a DAG node. We have also defined a clone method which can create a clone of our class, and an update method which will update the value of our Hyperbolic Cosine class whenever the value of the DAG node changes. Now we will move on to the <code class="highlighter-rouge">HyperbolicCosineFunction.cpp</code> file.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "HyperbolicCosineFunction.h"
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">RevBayesCore</span><span class="p">;</span>

<span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">ContinuousFunction</span><span class="p">(</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">),</span>
<span class="n">x</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">addParameter</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
<span class="p">}</span>


<span class="n">HyperbolicCosineFunction</span><span class="o">*</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">clone</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">swapParameterInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">oldP</span><span class="p">,</span> <span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">newP</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">oldP</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">newP</span> <span class="p">);</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="kt">void</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    
    <span class="c1">// recompute and set the internal value
</span>    <span class="kt">double</span> <span class="n">myValue</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">getValue</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">myValue</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">myValue</span><span class="p">);</span>
    <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">x1</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Now all we need to do is add the hyperbolic cosine function to the <code class="highlighter-rouge">revlanguage</code> side of things so that when we are using <code class="highlighter-rouge">Rev</code> we can use our function. First we need to add <code class="highlighter-rouge">Func_hyperbolicCosine.cpp</code> and <code class="highlighter-rouge">Func_hyperbolicCosine.h</code> to <code class="highlighter-rouge">/src/revlanguage/functions/math/</code>. Note that the directory structure of <code class="highlighter-rouge">revlanguage</code> is similar to that of the <code class="highlighter-rouge">core</code>. The Revlanguage side serves as a wrapper of the function that we just wrote in the <code class="highlighter-rouge">core</code>.</p>

<p>The <code class="highlighter-rouge">Func_hyperbolicCosine.h</code> should look like the following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#ifndef Func_hyperbolicCosine_h
#define Func_hyperbolicCosine_h
</span>
<span class="cp">#include "Real.h"
#include "RlTypedFunction.h"
</span>
<span class="cp">#include &lt;string&gt;
</span>
<span class="k">namespace</span> <span class="n">RevLanguage</span> <span class="p">{</span>
    
    <span class="cm">/**
     * The RevLanguage wrapper of the hyperbolic Cosine function (sinh()).
     *
     * The RevLanguage wrapper of the hyperbolic function function connects
     * the variables/parameters of the function and creates the internal HyperbolicCosineFunction object.
     * Please read the HyperbolicCosineFunction.h for more info.
     *
     *
     * @copyright Copyright 2009-
     * @author The RevBayes Development Core Team (&lt;your-name&gt;)
     * @since 2016-09-26, version 1.0
     *
     */</span>
    <span class="k">class</span> <span class="nc">Func_hyperbolicCosine</span> <span class="o">:</span>  <span class="k">public</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="p">{</span>
        
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Func_hyperbolicCosine</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
        
        <span class="c1">// Basic utility functions
</span>        <span class="n">Func_hyperbolicCosine</span><span class="o">*</span>                         <span class="n">clone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                          <span class="c1">//!&lt; Clone the object
</span>        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>                       <span class="n">getClassType</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                                         <span class="c1">//!&lt; Get Rev type
</span>        <span class="k">static</span> <span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span>                          <span class="n">getClassTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                                     <span class="c1">//!&lt; Get class type spec
</span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                     <span class="n">getFunctionName</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                <span class="c1">//!&lt; Get the primary name of the function in Rev
</span>        <span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span>                                 <span class="n">getTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                    <span class="c1">//!&lt; Get the type spec of the instance
</span>        
        <span class="c1">// Function functions you have to override
</span>        <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span>            <span class="n">createFunction</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                 <span class="c1">//!&lt; Create internal function object
</span>        <span class="k">const</span> <span class="n">ArgumentRules</span><span class="o">&amp;</span>                            <span class="n">getArgumentRules</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                               <span class="c1">//!&lt; Get argument rules
</span>        
    <span class="p">};</span>
    
<span class="p">}</span>


<span class="cp">#endif </span><span class="cm">/* Func_hyperbolicCosine_h */</span><span class="cp">
</span>
</code></pre></div></div>

<p>And the <code class="highlighter-rouge">Func_hyperbolicCosine.cpp</code> should look like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "Func_hyperbolicCosine.h"
#include "HyperbolicCosineFunction.h"
#include "Probability.h"
#include "Real.h"
#include "RlDeterministicNode.h"
#include "TypedDagNode.h"
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">RevLanguage</span><span class="p">;</span>

<span class="cm">/** default constructor */</span>
<span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">Func_hyperbolicCosine</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="o">:</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    
<span class="p">}</span>


<span class="cm">/**
 * The clone function is a convenience function to create proper copies of inherited objected.
 * E.g. a.clone() will create a clone of the correct type even if 'a' is of derived type 'b'.
 *
 * \return A new copy of the process.
 */</span>
<span class="n">Func_hyperbolicCosine</span><span class="o">*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">clone</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="k">return</span> <span class="k">new</span> <span class="n">Func_hyperbolicCosine</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
<span class="p">}</span>


<span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">createFunction</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Real</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getVariable</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="p">(</span> <span class="n">x</span> <span class="p">);</span>
    
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Get argument rules */</span>
<span class="k">const</span> <span class="n">ArgumentRules</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getArgumentRules</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="k">static</span> <span class="n">ArgumentRules</span> <span class="n">argumentRules</span> <span class="o">=</span> <span class="n">ArgumentRules</span><span class="p">();</span>
    <span class="k">static</span> <span class="kt">bool</span>          <span class="n">rules_set</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">rules_set</span> <span class="p">)</span>
    <span class="p">{</span>
        
        <span class="n">argumentRules</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">ArgumentRule</span><span class="p">(</span> <span class="s">"x"</span><span class="p">,</span> <span class="n">Real</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">(),</span> <span class="s">"The value."</span><span class="p">,</span> <span class="n">ArgumentRule</span><span class="o">::</span><span class="n">BY_CONSTANT_REFERENCE</span><span class="p">,</span> <span class="n">ArgumentRule</span><span class="o">::</span><span class="n">ANY</span> <span class="p">)</span> <span class="p">);</span>
        
        <span class="n">rules_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">argumentRules</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getClassType</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rev_type</span> <span class="o">=</span> <span class="s">"Func_hyperbolicCosine"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">rev_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get class type spec describing type of object */</span>
<span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">static</span> <span class="n">TypeSpec</span> <span class="n">rev_type_spec</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="p">(</span> <span class="n">getClassType</span><span class="p">(),</span> <span class="k">new</span> <span class="n">TypeSpec</span><span class="p">(</span> <span class="n">Function</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
    
    <span class="k">return</span> <span class="n">rev_type_spec</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get the primary Rev name for this function.
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getFunctionName</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create a name variable that is the same for all instance of this class
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">f_name</span> <span class="o">=</span> <span class="s">"cosh"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">f_name</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getTypeSpec</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="k">static</span> <span class="n">TypeSpec</span> <span class="n">type_spec</span> <span class="o">=</span> <span class="n">getClassTypeSpec</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">type_spec</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, we need to include the hyperbolic cosine function in the <code class="highlighter-rouge">RbRegister_Func.cpp</code> file located in the <code class="highlighter-rouge">/revlanguage/workspace/</code> directory. To do this go to the <code class="highlighter-rouge">RbRegister_Func.cpp</code> file and locate the math functions and type <code class="highlighter-rouge">#include Func_hyperbolicCosine.h</code> in the correct alphabetical order for that group. Now scroll down in that file until you find the math functions and add the line <code class="highlighter-rouge">addFunction( new Func_hyperbolicCosine());</code></p>

<p class="section maintitle" id="implement_distributions">Implementing a distribution</p>
<h2 id="general-info-before-getting-started">General info before getting started</h2>

<ul>
  <li>
    <p>Within the RevBayes <strong>core</strong> directory, there are subdirectories for different categories of distributions. 
All mathematical distributions that have been implemented exist in <code class="highlighter-rouge">core/distributions/math</code>.</p>
  </li>
  <li>
    <p>Note that when implementing a new distribution, you will need to create <code class="highlighter-rouge">.cpp</code> and <code class="highlighter-rouge">.h</code> files in both the <strong>revlanguage</strong> directory and the <strong>core</strong> directory. (For a refresher on the difference between these two directories, refer to the <a href="/developer/architecture/">Getting familiar with the code</a> section of this Developer’s guide).
The overall naming format remains the same for every distribution in RevBayes. In the Beta Binomial Distribution example provided below, I specify what naming convention to use when creating each file.</p>
  </li>
  <li>
    <p>It is often helpful to look at/borrow code from existing RevBayes distributions for general help on syntax and organization.</p>
  </li>
</ul>

<p>For the language side, one of the most important things is the create distribution function (it converts user-arguments into calculations). Also, the getParameterRules function is important (to get the degrees of freedom &amp; other things). It is often helpful to look at the code of existing distributions for general help on syntax &amp; organization.</p>

<ul>
  <li>
    <p>Within every new distribution, you will need to include some functions. For example, each new distribution must have: the get class type, name, and help functions. You may not need to implement these from scratch (if they’re dictated by the parent class &amp; are already present), but you will need to implement other functions within your distribution (e.g. cdf, rv, quantile).</p>
  </li>
  <li>
    <p>Distributions have a prefix <code class="highlighter-rouge">DN</code> (dag node), and all moves have a prefix <code class="highlighter-rouge">MV</code>. RevBayes takes the name within &amp; creates the <code class="highlighter-rouge">DN</code> automatically, so be aware of this. For a refresher on DAG nodes, refer to <a href="/developer/architecture/">Getting familiar with the code</a>.</p>
  </li>
</ul>

<p>In the following steps, we’ll implement the <strong>Beta Binomial Distribution</strong> as an example, for syntax purposes.</p>

<h2 id="steps">Steps</h2>

<ol>
  <li>
    <p>Create new .cpp &amp; .h files in <code class="highlighter-rouge">revlanguage/distributions/math/</code>, named <code class="highlighter-rouge">Dist_betabinomial.cpp</code> and <code class="highlighter-rouge">Dist_betaBinomial.h</code>. 
<strong>Note:</strong> all files in this directory will follow this naming format: <code class="highlighter-rouge">Dist_&lt;nameofdistribution&gt;.[cpp|h]</code>.</p>

    <p>To populate these files, look at existing examples of similar distributions for specific info on what to include &amp; on proper syntax.  For example, for the Beta Binomial distribution, I checked the existing Binomial Distribution code for guidance.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//add code here
</span></code></pre></div>    </div>
  </li>
  <li>Test
    <ol>
      <li>
        <p>Create new <code class="highlighter-rouge">.cpp</code> &amp; <code class="highlighter-rouge">.h</code> files in <code class="highlighter-rouge">core/distributions/math/</code>, named <code class="highlighter-rouge">BetaBinomialDistribution.cpp</code> and <code class="highlighter-rouge">BetaBinomialDistribution.h</code>.</p>

        <p><strong>Note:</strong> This is the object oriented wrapper code that references the functions hard-coded in the next step. All files in this directory will follow this naming format: <code class="highlighter-rouge">&lt;NameOfDistribution&gt;Distribution.[cpp|h]</code>.</p>
      </li>
      <li>
        <p>Create new <code class="highlighter-rouge">.cpp</code> and <code class="highlighter-rouge">.h</code> files in <code class="highlighter-rouge">core/math/Distributions/</code>, named <code class="highlighter-rouge">DistributionBetaBinomial.cpp</code> and <code class="highlighter-rouge">DistributionBetaBinomial.h</code>.</p>

        <p>These are the raw procedural functions in the RevBayes namespace (e.g. pdf, cdf, quantile); they are not derived functions. <code class="highlighter-rouge">RbStatistics</code> is a namespace. To populate these files, look at existing examples of similar distributions to get an idea of what functions to include, what variables are needed, and the proper syntax.</p>

        <p><strong>Note:</strong> This is the most time-consuming step in the entire process of implementing a new distribution. All files in this directory will follow this naming format: <code class="highlighter-rouge">Distribution&lt;NameOfDistribution&gt;.[cpp|h]</code></p>
      </li>
    </ol>
  </li>
  <li>
    <p>Navigate to <code class="highlighter-rouge">revlanguage/workspace/RbRegister_Dist.cpp</code></p>

    <p><strong>Every</strong> new implementation must be registered in RevBayes. All register files are located in the <code class="highlighter-rouge">revlanguage/workspace</code> directory, and there are different files for the different types of implementations (<code class="highlighter-rouge">RbRegister_Func.cpp</code> is for registering functions; <code class="highlighter-rouge">RbRegister_Move</code> is for registering moves; etc.).  We are implementing a distribution, so we will edit the <code class="highlighter-rouge">RbRegister_Dist.cpp</code> file.</p>
  </li>
  <li>
    <p>You need to have an include statement at the top of the <code class="highlighter-rouge">RbRegister</code> script, to effectively add your distribution to the RevBayes language. You also need to add code to the bottom of this file, and give it a type and a <em>new</em> constructor. Generally, you can look within the file for an idea of proper syntax to use.</p>

    <p>For the Beta Binomial distribution, we navigate to the section in the file with the header ‘Distributions’ and then look for the sub-header dealing with ‘math distributions’. Then, add the following line of code:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "Dist_betaBinomial.h"
</span></code></pre></div>    </div>

    <p>This step registers the header file for the beta binomial distribution, effectively adding it to RevBayes.</p>

    <p>Next, navigate to the section of the file that initializes the global workspace. This section defines the workspace class, which houses info on all distributions. Then, add the following line of code:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AddDistribution</span><span class="o">&lt;</span> <span class="n">Natural</span>		<span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="n">Dist_betaBinomial</span><span class="p">());</span>
</code></pre></div>    </div>

    <p>This adds the distribution to the workspace. Without this step, the beta binomial distribution will not be added to the <code class="highlighter-rouge">revlanguage</code>.</p>

    <p><strong>Note:</strong> Depending on the kind of distribution, you may need to change <code class="highlighter-rouge">Natural</code> to a different type (e.g. <code class="highlighter-rouge">Probability</code>, <code class="highlighter-rouge">Real</code>, <code class="highlighter-rouge">RealPos</code>, etc.).</p>

    <p>After registering your distribution, you are ready to test your code.</p>
  </li>
  <li>
    <p>Before pushing your changes, you should ensure your code is working properly.</p>

    <p>There are multiple ways to do this. As a best practice, you should first compile it to ensure there are no errors. Once it compiles with no problems, you can test in various ways (e.g. run each individual function within the new Beta Binomial distribution in R, then run the Binomial distribution with a Beta prior in Rev and see if the output matches). For more information, see the developer tutorials on <a href="../validation/">validation</a> and testing. (TODO)</p>

    <p>After ensuring your code runs properly, you are ready to add it to the git repo. We recommend reading through the <a href="/developer/git-flow.html">Git Workflow Best Practices</a> section of the Developer’s guide before pushing.</p>
  </li>
</ol>

<p class="section maintitle" id="implement_moves">Implementing a Metropolis-Hastings Move</p>
<h2 id="general-info-before-getting-started">General info before getting started</h2>

<p>The steps to implementing a new move vary slightly, depending on the move’s type (e.g., Metropolis-Hastings versus Gibbs). For the purpose of this guide, we will focus on a Metropolis-Hastings move.</p>

<p>In general, the fastest and easiest way to get help is to find the most similar move already implemented in RevBayes and use it as a guide. Remember that, as with implementing a new distribution or function, you’ll need to add relevant code to both the core of RevBayes and the language. Also remember that you’ll need to work out the math appropriate for your move (e.g., the Hastings ratio) ahead of time.</p>

<h2 id="steps">Steps</h2>

<ol>
  <li>
    <p><em>Orienting within the repository</em> - For the <strong>core</strong>, navigate in the repository to <code class="highlighter-rouge">src/core/moves</code>. For a Metropolis-Hastings move, we’ll then go into the <code class="highlighter-rouge">proposal</code> directory. In this directory, you can find several templates for generic proposal classes, as well as subdirectories containing moves for specific parameter types. To keep things easy, we’ll focus on a single scalar parameter, so we’ll navigate one step further into the <code class="highlighter-rouge">scalar</code> directory. For the <strong>language</strong>, navigate to <code class="highlighter-rouge">src/revlanguage/moves</code>. For this example, as we did in the core, we’ll focus on a move for a scalar parameter, so we’ll then open <code class="highlighter-rouge">scalar</code>. To <strong>register</strong> our new move after it’s implemented, we’ll also need to update the file <code class="highlighter-rouge">src/revlanguage/workspace/RbRegister_Move.cpp</code>.</p>
  </li>
  <li>
    <p><em>Creating new files for the core</em> - As an example, we’ll implement a new move that draws a random value from a Gamma distribution and proposes a new scalar by multiplying the current value by the draw from the Gamma. This move will be called a “Gamma Scaling move”. Since this move is similar to an existing scaling move, we can start by copying the file <code class="highlighter-rouge">ScaleProposal.h</code> and naming the new copy <code class="highlighter-rouge">GammaScaleProposal.h</code>. As a reminder, we’re working in the directory <code class="highlighter-rouge">src/core/moves/proposal/scalar/</code>.</p>

    <p>Once the new <strong>header file</strong> is created and named, we can update the content to match our new move. The simplest changes involve renaming things to match the new move (e.g., updating the preprocessor macro from <code class="highlighter-rouge">ScaleProposal_H</code> to <code class="highlighter-rouge">GammaScaleProposal_H</code>, or changing the name of object references and constructor from <code class="highlighter-rouge">ScaleProposal</code> to <code class="highlighter-rouge">GammaScaleProposal</code>). The comments at the top of the header file that describe how the move works should also be updated, but these changes will obviously be specific to the move being implemented.</p>

    <p>Next, we’ll need to create a <strong>new .cpp file</strong> containing the implementation of our new move. As with the header, it’s easiest to copy and rename an existing file, so we’ll use <code class="highlighter-rouge">ScaleProposal.cpp</code> as our template, copy it, and rename to <code class="highlighter-rouge">GammaScaleProposal.cpp</code>. As with the header file, most of the necessary changes involve updating the names of variables and function names. If the move requires access to other math functions, additional header files may need to be included at the top. Explore <code class="highlighter-rouge">src/core/math</code> as needed to find the necessary functions or distributions. In this case, we will need access to methods associated with the Gamma distribution, so we will add <code class="highlighter-rouge">#include "DistributionGamma.h"</code>. For our example, the number and type of variables used by our move are the same as our template based on the Scale move, so we don’t need to modify the constructor or variable initialization, other than updating the constructor name. Similarly for this example, we don’t need to alter the code in the <code class="highlighter-rouge">::cleanProposal</code>, <code class="highlighter-rouge">::clone</code>, <code class="highlighter-rouge">::prepareProposal</code>, <code class="highlighter-rouge">::printParameterSummary</code>, <code class="highlighter-rouge">::undoProposal</code>, <code class="highlighter-rouge">::swapNodeInternal</code>, and <code class="highlighter-rouge">::tune</code> methods as these are common to our template and new moves (and will be identical to many of the scalar moves), but we do need to update the class names associated with the methods (i.e., <code class="highlighter-rouge">ScaleMove::</code> -&gt; <code class="highlighter-rouge">GammaScaleMove::</code>). For the <code class="highlighter-rouge">::getProposalName</code> method, we need to update the string in the method that provides a descriptive name for the move - <code class="highlighter-rouge">name = "Gamma Scaling"</code>. The bulk of the necessary changes for the new move will come in the <code class="highlighter-rouge">::propose</code> method and the help description above the method. For this example, the new <code class="highlighter-rouge">::propose</code> method looks like this:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Perform the proposal.
 *
 * A gamma scaling proposal draws a random number from a gamma distribution u ~ Gamma(lambda,1) and scales the current vale by u
 * lambda is the tuning parameter of the proposal which influences the size of the proposals by changing the shape of the Gamma.
 *
 * \return The hastings ratio.
 */</span>
<span class="kt">double</span> <span class="n">GammaScaleProposal</span><span class="o">::</span><span class="n">propose</span><span class="p">(</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">val</span> <span class="p">)</span>
<span class="p">{</span>
    
    <span class="c1">// Get random number generator
</span>    <span class="n">RandomNumberGenerator</span><span class="o">*</span> <span class="n">rng</span>     <span class="o">=</span> <span class="n">GLOBAL_RNG</span><span class="p">;</span>
    
    <span class="c1">// copy value
</span>    <span class="n">storedValue</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    
    <span class="c1">// Generate new value (no reflection, so we simply abort later if we propose value here outside of support)
</span>    <span class="kt">double</span> <span class="n">u</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">rv</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="n">rng</span><span class="p">);</span>
    <span class="n">val</span> <span class="o">*=</span> <span class="n">u</span><span class="p">;</span>
    
    <span class="c1">// compute the Hastings ratio
</span>    <span class="kt">double</span> <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// compute the Hastings ratio
</span>        <span class="kt">double</span> <span class="n">forward</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">lnPdf</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">backward</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">lnPdf</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">u</span><span class="p">));</span>
        
        <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="n">backward</span> <span class="o">-</span> <span class="n">forward</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>    <span class="c1">// The -log(u) term is the Jacobian
</span>    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">RbException</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="n">RbConstants</span><span class="o">::</span><span class="n">Double</span><span class="o">::</span><span class="n">neginf</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ln_hastings_ratio</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>In this case, the Hastings ratio involves the probability density of the forward move (the scaling factor <em>u</em>), the density of the corresponding backward move (the scaling factor $\frac{1}{u}$), and the solution to the Jacobian ($-\frac{1}{u}$).</p>
  </li>
  <li>
    <p><em>Creating new files for the rev language</em> - After implementing the detailed machinery to perform the new move in the RevBayes core, you need to modify a few files associated with the Rev language to make it available to users. As a reminder, the first set of these files is found in <code class="highlighter-rouge">src/revlanguage/moves</code>. For our example, we will be focusing specifically on a move for a scalar value, so navigate to the <code class="highlighter-rouge">scalar</code> subdirectory. As with the files in the core, we will copy and rename a header (.h) and implementation (.cpp) file from the Scale move. In this case, our new header file will be called <code class="highlighter-rouge">Move_GammaScale.h</code> and our new implementation file will be called <code class="highlighter-rouge">Move_GammaScale.cpp</code>. In the <strong>header file</strong>, simply update the names of the preprocessor macro, the class, and the objects. Also remember to update the help comments near the top of the file.</p>

    <p>In the new <strong>.cpp file</strong>, begin by updating the names of the header files included at the top. Note that we include, and will need to update, the names of both the header for the core <code class="highlighter-rouge">GammaScaleProposal.h</code> and the workspace <code class="highlighter-rouge">Move_GammaScale.h</code>. Most of the rest of the changes in this file involve updating the names of classes and objects associated with this move, but we also need to update the string specifying the type in the <code class="highlighter-rouge">::getClassType</code> method and specifying the constructor name in the <code class="highlighter-rouge">::getMoveName</code> method. Pay special attention to the rules specified in <code class="highlighter-rouge">::getParameterRules</code> and make sure they satisfy the constraints required by the new move. Update these rules as needed, using existing rules from other moves as templates.</p>

    <p>For our particular example, we also need to make one additional change. Because we’ve only updated the <code class="highlighter-rouge">ScaleProposal</code>, and not the <code class="highlighter-rouge">ScaleProposalContinuous</code>, we need to remove the part of the code in this move that could call <code class="highlighter-rouge">ScaleProposalContinuous</code>. The <code class="highlighter-rouge">::constructInternalObject</code> method now looks like this (compare to the corresponding method from <code class="highlighter-rouge">Move_Scale.cpp</code>):</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Move_GammaScale</span><span class="o">::</span><span class="n">constructInternalObject</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// we free the memory first
</span>    <span class="k">delete</span> <span class="n">value</span><span class="p">;</span>
    
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">Proposal</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="c1">// now allocate a new sliding move
</span>    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">lambda</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">w</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">weight</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Probability</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">tuneTarget</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">StochasticNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">RevBayesCore</span><span class="o">::</span><span class="n">StochasticNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">tmp</span> <span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">GammaScaleProposal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">t</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RlBoolean</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">tune</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    
    <span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">MetropolisHastingsMove</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
    
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>Updating the Rev language register</em> - The last step in implementing our new move is to make sure that it’s registered in the Rev language. To do this, we will need to update the file <code class="highlighter-rouge">RbRegister_Move.cpp</code> in <code class="highlighter-rouge">src/revlanguage/workspace</code>. In this file, we’ll need to include the header for our new move <code class="highlighter-rouge">#include "Move_GammaScale.h"</code> in the section corresponding to moves on real values. We’ll also need to add the constructor to the workspace by updating the <code class="highlighter-rouge">::initializeMoveGlobalWorkspace</code> method to include <code class="highlighter-rouge">addTypeWithConstructor( new Move_GammaScale() );</code>, again in the section corresponding to moves on real values.</p>
  </li>
  <li>
    <p><em>Testing the performance of the new move</em> - If properly implemented, a new move can be validated by running an MCMC analysis where the data are ignored and one tries to sample only the prior. This can be done in RevBayes by adding the <code class="highlighter-rouge">underPrior=TRUE</code> option as an argument to the <code class="highlighter-rouge">.run()</code> method of an <code class="highlighter-rouge">mcmc</code> object. The recommended strategy is to implement the simplest possible model that uses a variable of the type appropriate for the new move, and assigning that variable an easily validated prior (e.g., a uniform). Run the analysis with only the new move operating on that variable and then plot the variable’s marginal distribution to make sure it matches the prior.</p>
  </li>
</ol>

<p class="section maintitle" id="implement_help">Implementing a help entry</p>
<h2 id="adding-basic-help-sections">Adding basic help sections</h2>

<p>For each new function, distrubution or move you add in RevBayes you should always create a corresponding help entry.</p>

<p>As an example we will look at the documentation associated with the normal distributon function.
The functions used to generate the help entry are in the <code class="highlighter-rouge">Dist_norm.cpp</code> and <code class="highlighter-rouge">Dist_norm.h</code> files in the directory <code class="highlighter-rouge">/revlanguage/distributions/math</code>.</p>

<p>The basic help fields and assocaited functions are listed in the table below and are output to screen in the same order.</p>

<figure id="help_sections" class="table"><table>
  <thead>
    <tr>
      <th>Help section</th>
      <th>Association RevBayes function</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Title</td>
      <td><code class="highlighter-rouge">getHelpTitle</code></td>
    </tr>
    <tr>
      <td>Aliases</td>
      <td><code class="highlighter-rouge">getDistributionFunctionAliases</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="highlighter-rouge">getFunctionNameAliases</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code class="highlighter-rouge">getMoveAliases</code></td>
    </tr>
    <tr>
      <td>Description</td>
      <td><code class="highlighter-rouge">getHelpDescription</code></td>
    </tr>
    <tr>
      <td>Constructor</td>
      <td>(autogenerated)</td>
    </tr>
    <tr>
      <td>Return Type</td>
      <td>(autogenerated; only Functions, Distributions)</td>
    </tr>
    <tr>
      <td>Details</td>
      <td><code class="highlighter-rouge">getHelpDetails</code></td>
    </tr>
    <tr>
      <td>Example</td>
      <td><code class="highlighter-rouge">getHelpExample</code></td>
    </tr>
    <tr>
      <td>Methods</td>
      <td>(autogenerated)</td>
    </tr>
    <tr>
      <td>Authors</td>
      <td><code class="highlighter-rouge">getHelpAuthor</code></td>
    </tr>
    <tr>
      <td>References</td>
      <td><code class="highlighter-rouge">getHelpReferences</code></td>
    </tr>
    <tr>
      <td>See Also</td>
      <td><code class="highlighter-rouge">getHelpSeeAlso</code></td>
    </tr>
  </tbody>
</table>

<figcaption class="table">Help fields and associatd functions</figcaption>
</figure>

<p>Note the <em>Constructor</em>, <em>Return Type</em> and <em>Methods</em> fields are generated automatically. All the other fields must be populated manually.</p>

<p>The help functions are <em>protected functions</em> included in the header file <code class="highlighter-rouge">Dist_norm.h</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">protected:</span>
    
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>                        <span class="n">getHelpAuthor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">//!&lt; Get the author(s) of this function
</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                     <span class="n">getHelpDescription</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">//!&lt; Get the description for this function
</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                     <span class="n">getHelpDetails</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; Get the more detailed description of the function
</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                     <span class="n">getHelpExample</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; Get an executable and instructive example
</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RevBayesCore</span><span class="o">::</span><span class="n">RbHelpReference</span><span class="o">&gt;</span>      <span class="n">getHelpReferences</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; Get some references/citations for this function
</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>                        <span class="n">getHelpSeeAlso</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; Get suggested other functions
</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                     <span class="n">getHelpTitle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; Get the title of this help entry
</span></code></pre></div></div>
<p>The information for the helps fields should be filled out in the source file <code class="highlighter-rouge">Dist_norm.cpp</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Get the author(s) of this function so they can receive credit (and blame) for it.
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Dist_norm</span><span class="o">::</span><span class="n">getHelpAuthor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create a vector of authors for this function
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authors</span><span class="p">;</span>
    <span class="n">authors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">"Sebastian Hoehna"</span> <span class="p">);</span>

    <span class="k">return</span> <span class="n">authors</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get the (brief) description for this function
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Dist_norm</span><span class="o">::</span><span class="n">getHelpDescription</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// return the description
</span>    <span class="k">return</span> <span class="s">"Normal (gaussian) distribution with mean equal to ‘mean’ and standard deviation equal to ‘sd’."</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get the more detailed description of the function
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Dist_norm</span><span class="o">::</span><span class="n">getHelpDetails</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="c1">// create a details variable
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">details</span><span class="p">;</span>
    <span class="n">details</span> <span class="o">+=</span> <span class="s">"The normal distribution has density:</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">details</span> <span class="o">+=</span> <span class="s">"f(x) = 1/(sqrt(2 pi) sigma) e^-((x - mu)^2/(2 sigma^2))</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">details</span> <span class="o">+=</span> <span class="s">"where mu is the mean of the distribution and sigma the standard deviation."</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">details</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get an executable and instructive example.
 * These example should help the users to show how this function works but
 * are also used to test if this function still works.
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Dist_norm</span><span class="o">::</span><span class="n">getHelpExample</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create an example as a single string variable.
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">example</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>

    <span class="n">example</span> <span class="o">+=</span> <span class="s">"# we simulate some observations</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">example</span> <span class="o">+=</span> <span class="s">"x &lt;- rnorm(n=10,mean=5,sd=10)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">example</span> <span class="o">+=</span> <span class="s">"# let's see what the minimum is (you could do the max too)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">example</span> <span class="o">+=</span> <span class="s">"min(x)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">example</span> <span class="o">+=</span> <span class="s">"# let's also see what the mean and the variance are</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">example</span> <span class="o">+=</span> <span class="s">"mean(x)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">example</span> <span class="o">+=</span> <span class="s">"var(x)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">example</span> <span class="o">+=</span> <span class="s">"sd(x)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">example</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get some references/citations for this function
 *
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RevBayesCore</span><span class="o">::</span><span class="n">RbHelpReference</span><span class="o">&gt;</span> <span class="n">Dist_norm</span><span class="o">::</span><span class="n">getHelpReferences</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create an entry for each reference
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RevBayesCore</span><span class="o">::</span><span class="n">RbHelpReference</span><span class="o">&gt;</span> <span class="n">references</span><span class="p">;</span>


    <span class="k">return</span> <span class="n">references</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get the names of similar and suggested other functions
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Dist_norm</span><span class="o">::</span><span class="n">getHelpSeeAlso</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create an entry for each suggested function
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">see_also</span><span class="p">;</span>
    <span class="n">see_also</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">"dnLognormal"</span> <span class="p">);</span>


    <span class="k">return</span> <span class="n">see_also</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get the title of this help entry
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Dist_norm</span><span class="o">::</span><span class="n">getHelpTitle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create a title variable
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span> <span class="o">=</span> <span class="s">"Normal Distribution"</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">title</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once you recompile RevBayes, be careful to double check the screen output!</p>


<ol class="bibliography"></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "default highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "default highlighter-rouge";
//   }
//   
// });
</script>

<script src="/assets/js/base.js"></script>

<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

  </body>
</html>
