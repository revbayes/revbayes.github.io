<!doctype html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/img/favicon.png" >
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />
    <title>RevBayes: Implementing a Metropolis-Hastings Move</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="/" class="pull-left">
        
        <img class="navbar-logo" src="/assets/img/aquabayes-desaturated.png" alt="RevBayes Home" />
        
      </a>

      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar" align="right"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/download">Download</a></li>
        <li><a href="/tutorials/">Tutorials</a></li>
        <li><a href="/documentation/">Documentation</a></li>
        <li><a href="/interfaces">Interfaces</a></li>
        <li><a href="/workshops/">Workshops</a></li>
        <li><a href="/jobs/">Jobs</a></li>
        <li><a href="/developer/">Developer</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="titlebar">
	<h1 class="maintitle">Implementing a Metropolis-Hastings Move</h1>
	
	<h4 class="authors"></h4>
  <h5>Last modified on December 13, 2024</h5>
</div>

<h2 id="general-info-before-getting-started">General info before getting started</h2>

<p>The steps to implementing a new move vary slightly, depending on the move’s type (e.g., Metropolis-Hastings versus Gibbs). For the purpose of this guide, we will focus on a Metropolis-Hastings move.</p>

<p>In general, the fastest and easiest way to get help is to find the most similar move already implemented in RevBayes and use it as a guide. Remember that, as with implementing a new distribution or function, you’ll need to add relevant code to both the core of RevBayes and the language. Also remember that you’ll need to work out the math appropriate for your move (e.g., the Hastings ratio) ahead of time.</p>

<h2 id="steps">Steps</h2>

<ol>
  <li>
    <p><em>Orienting within the repository</em> - For the <strong>core</strong>, navigate in the repository to <code class="language-plaintext highlighter-rouge">src/core/moves</code>. For a Metropolis-Hastings move, we’ll then go into the <code class="language-plaintext highlighter-rouge">proposal</code> directory. In this directory, you can find several templates for generic proposal classes, as well as subdirectories containing moves for specific parameter types. To keep things easy, we’ll focus on a single scalar parameter, so we’ll navigate one step further into the <code class="language-plaintext highlighter-rouge">scalar</code> directory. For the <strong>language</strong>, navigate to <code class="language-plaintext highlighter-rouge">src/revlanguage/moves</code>. For this example, as we did in the core, we’ll focus on a move for a scalar parameter, so we’ll then open <code class="language-plaintext highlighter-rouge">scalar</code>. To <strong>register</strong> our new move after it’s implemented, we’ll also need to update the file <code class="language-plaintext highlighter-rouge">src/revlanguage/workspace/RbRegister_Move.cpp</code>.</p>
  </li>
  <li>
    <p><em>Creating new files for the core</em> - As an example, we’ll implement a new move that draws a random value from a Gamma distribution and proposes a new scalar by multiplying the current value by the draw from the Gamma. This move will be called a “Gamma Scaling move”. Since this move is similar to an existing scaling move, we can start by copying the file <code class="language-plaintext highlighter-rouge">ScaleProposal.h</code> and naming the new copy <code class="language-plaintext highlighter-rouge">GammaScaleProposal.h</code>. As a reminder, we’re working in the directory <code class="language-plaintext highlighter-rouge">src/core/moves/proposal/scalar/</code>.</p>

    <p>Once the new <strong>header file</strong> is created and named, we can update the content to match our new move. The simplest changes involve renaming things to match the new move (e.g., updating the preprocessor macro from <code class="language-plaintext highlighter-rouge">ScaleProposal_H</code> to <code class="language-plaintext highlighter-rouge">GammaScaleProposal_H</code>, or changing the name of object references and constructor from <code class="language-plaintext highlighter-rouge">ScaleProposal</code> to <code class="language-plaintext highlighter-rouge">GammaScaleProposal</code>). The comments at the top of the header file that describe how the move works should also be updated, but these changes will obviously be specific to the move being implemented.</p>

    <p>Next, we’ll need to create a <strong>new .cpp file</strong> containing the implementation of our new move. As with the header, it’s easiest to copy and rename an existing file, so we’ll use <code class="language-plaintext highlighter-rouge">ScaleProposal.cpp</code> as our template, copy it, and rename to <code class="language-plaintext highlighter-rouge">GammaScaleProposal.cpp</code>. As with the header file, most of the necessary changes involve updating the names of variables and function names. If the move requires access to other math functions, additional header files may need to be included at the top. Explore <code class="language-plaintext highlighter-rouge">src/core/math</code> as needed to find the necessary functions or distributions. In this case, we will need access to methods associated with the Gamma distribution, so we will add <code class="language-plaintext highlighter-rouge">#include "DistributionGamma.h"</code>. For our example, the number and type of variables used by our move are the same as our template based on the Scale move, so we don’t need to modify the constructor or variable initialization, other than updating the constructor name. Similarly for this example, we don’t need to alter the code in the <code class="language-plaintext highlighter-rouge">::cleanProposal</code>, <code class="language-plaintext highlighter-rouge">::clone</code>, <code class="language-plaintext highlighter-rouge">::prepareProposal</code>, <code class="language-plaintext highlighter-rouge">::printParameterSummary</code>, <code class="language-plaintext highlighter-rouge">::undoProposal</code>, <code class="language-plaintext highlighter-rouge">::swapNodeInternal</code>, and <code class="language-plaintext highlighter-rouge">::tune</code> methods as these are common to our template and new moves (and will be identical to many of the scalar moves), but we do need to update the class names associated with the methods (i.e., <code class="language-plaintext highlighter-rouge">ScaleMove::</code> -&gt; <code class="language-plaintext highlighter-rouge">GammaScaleMove::</code>). For the <code class="language-plaintext highlighter-rouge">::getProposalName</code> method, we need to update the string in the method that provides a descriptive name for the move - <code class="language-plaintext highlighter-rouge">name = "Gamma Scaling"</code>. The bulk of the necessary changes for the new move will come in the <code class="language-plaintext highlighter-rouge">::propose</code> method and the help description above the method. For this example, the new <code class="language-plaintext highlighter-rouge">::propose</code> method looks like this:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Perform the proposal.
 *
 * A gamma scaling proposal draws a random number from a gamma distribution u ~ Gamma(lambda,1) and scales the current vale by u
 * lambda is the tuning parameter of the proposal which influences the size of the proposals by changing the shape of the Gamma.
 *
 * \return The hastings ratio.
 */</span>
<span class="kt">double</span> <span class="n">GammaScaleProposal</span><span class="o">::</span><span class="n">propose</span><span class="p">(</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">val</span> <span class="p">)</span>
<span class="p">{</span>
    
    <span class="c1">// Get random number generator</span>
    <span class="n">RandomNumberGenerator</span><span class="o">*</span> <span class="n">rng</span>     <span class="o">=</span> <span class="n">GLOBAL_RNG</span><span class="p">;</span>
    
    <span class="c1">// copy value</span>
    <span class="n">storedValue</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    
    <span class="c1">// Generate new value (no reflection, so we simply abort later if we propose value here outside of support)</span>
    <span class="kt">double</span> <span class="n">u</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">rv</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="n">rng</span><span class="p">);</span>
    <span class="n">val</span> <span class="o">*=</span> <span class="n">u</span><span class="p">;</span>
    
    <span class="c1">// compute the Hastings ratio</span>
    <span class="kt">double</span> <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// compute the Hastings ratio</span>
        <span class="kt">double</span> <span class="n">forward</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">lnPdf</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">backward</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">lnPdf</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">u</span><span class="p">));</span>
        
        <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="n">backward</span> <span class="o">-</span> <span class="n">forward</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>    <span class="c1">// The -log(u) term is the Jacobian</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">RbException</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="n">RbConstants</span><span class="o">::</span><span class="n">Double</span><span class="o">::</span><span class="n">neginf</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ln_hastings_ratio</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>In this case, the Hastings ratio involves the probability density of the forward move (the scaling factor <em>u</em>), the density of the corresponding backward move (the scaling factor $\frac{1}{u}$), and the solution to the Jacobian ($-\frac{1}{u}$).</p>
  </li>
  <li>
    <p><em>Creating new files for the rev language</em> - After implementing the detailed machinery to perform the new move in the RevBayes core, you need to modify a few files associated with the Rev language to make it available to users. As a reminder, the first set of these files is found in <code class="language-plaintext highlighter-rouge">src/revlanguage/moves</code>. For our example, we will be focusing specifically on a move for a scalar value, so navigate to the <code class="language-plaintext highlighter-rouge">scalar</code> subdirectory. As with the files in the core, we will copy and rename a header (.h) and implementation (.cpp) file from the Scale move. In this case, our new header file will be called <code class="language-plaintext highlighter-rouge">Move_GammaScale.h</code> and our new implementation file will be called <code class="language-plaintext highlighter-rouge">Move_GammaScale.cpp</code>. In the <strong>header file</strong>, simply update the names of the preprocessor macro, the class, and the objects. Also remember to update the help comments near the top of the file.</p>

    <p>In the new <strong>.cpp file</strong>, begin by updating the names of the header files included at the top. Note that we include, and will need to update, the names of both the header for the core <code class="language-plaintext highlighter-rouge">GammaScaleProposal.h</code> and the workspace <code class="language-plaintext highlighter-rouge">Move_GammaScale.h</code>. Most of the rest of the changes in this file involve updating the names of classes and objects associated with this move, but we also need to update the string specifying the type in the <code class="language-plaintext highlighter-rouge">::getClassType</code> method and specifying the constructor name in the <code class="language-plaintext highlighter-rouge">::getMoveName</code> method. Pay special attention to the rules specified in <code class="language-plaintext highlighter-rouge">::getParameterRules</code> and make sure they satisfy the constraints required by the new move. Update these rules as needed, using existing rules from other moves as templates.</p>

    <p>For our particular example, we also need to make one additional change. Because we’ve only updated the <code class="language-plaintext highlighter-rouge">ScaleProposal</code>, and not the <code class="language-plaintext highlighter-rouge">ScaleProposalContinuous</code>, we need to remove the part of the code in this move that could call <code class="language-plaintext highlighter-rouge">ScaleProposalContinuous</code>. The <code class="language-plaintext highlighter-rouge">::constructInternalObject</code> method now looks like this (compare to the corresponding method from <code class="language-plaintext highlighter-rouge">Move_Scale.cpp</code>):</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Move_GammaScale</span><span class="o">::</span><span class="n">constructInternalObject</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// we free the memory first</span>
    <span class="k">delete</span> <span class="n">value</span><span class="p">;</span>
    
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">Proposal</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="c1">// now allocate a new sliding move</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">lambda</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">w</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">weight</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Probability</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">tuneTarget</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RealPos</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">StochasticNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">RevBayesCore</span><span class="o">::</span><span class="n">StochasticNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">tmp</span> <span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">GammaScaleProposal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">t</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RlBoolean</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">tune</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getValue</span><span class="p">();</span>
    
    <span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">MetropolisHastingsMove</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
    
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>Updating the Rev language register</em> - The last step in implementing our new move is to make sure that it’s registered in the Rev language. To do this, we will need to update the file <code class="language-plaintext highlighter-rouge">RbRegister_Move.cpp</code> in <code class="language-plaintext highlighter-rouge">src/revlanguage/workspace</code>. In this file, we’ll need to include the header for our new move <code class="language-plaintext highlighter-rouge">#include "Move_GammaScale.h"</code> in the section corresponding to moves on real values. We’ll also need to add the constructor to the workspace by updating the <code class="language-plaintext highlighter-rouge">::initializeMoveGlobalWorkspace</code> method to include <code class="language-plaintext highlighter-rouge">addTypeWithConstructor( new Move_GammaScale() );</code>, again in the section corresponding to moves on real values.</p>
  </li>
  <li>
    <p><em>Testing the performance of the new move</em> - If properly implemented, a new move can be validated by running an MCMC analysis where the clamped data are ignored and one tries to sample only the prior. This can be done in RevBayes by calling <code class="language-plaintext highlighter-rouge">model.ignoreAllData()</code> to mark the data as ignored. The recommended strategy is to implement the simplest possible model that uses a variable of the type appropriate for the new move, and assigning that variable an easily validated prior (e.g., a uniform). Run the analysis with only the new move operating on that variable and then plot the variable’s marginal distribution to make sure it matches the prior.</p>
  </li>
</ol>

<ol class="bibliography"></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2 class='references'>References</h2><hr class='references'>"+elem_ol.outerHTML
	}
}
</script>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/license">License</a> | <a href="/citation">Citation</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users Forum</a>
    </div>
  </div>
  <br>
  </div>
</footer>

    </div>
    <script src="/assets/js/vendor/jquery.min.js"></script>
<script src="/assets/js/vendor/FileSaver.min.js"></script>
<script src="/assets/js/vendor/jszip.min.js"></script>
<script src="/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "default highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "default highlighter-rouge";
//   }
//   
// });
</script>
<script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
    });
    MathJax.Hub.Queue(function () {
      $(".aside").each(function() {
          $("div .MathJax", this).hide();
      });
    });
</script>
<script src="/assets/js/base.js"></script>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0Y03X9Q2TJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0Y03X9Q2TJ');
</script>

  </body>
</html>
