- name: 'UPGMA'
  return_type: 'TimeTree'
  usage: 'UPGMA(AbstractHomologousDiscreteCharacterData<any> x)'
  arguments:
    - label: 'x'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'VectorMonitors'
  return_type: 'Monitor[]'
  usage: 'VectorMonitors()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'VectorMoves'
  return_type: 'Move[]'
  usage: 'VectorMoves()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: '[]'
  return_type: 'Integer'
  usage: '[](Integer[]<any> v, Natural<any> index)'
  arguments:
    - label: 'v'
      description: 'The vector.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Integer[]'
      default:
      options:
    - label: 'index'
      description: 'The index.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: '_RateGenerator[]2SiteMixtureModel[]'
  return_type: 'SiteMixtureModel[]'
  usage: '_RateGenerator[]2SiteMixtureModel[](RateGenerator[]<any> matrices)'
  arguments:
    - label: 'matrices'
      description: 'The matrix to convert.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: '_RateMatrix2SiteMixtureModel'
  return_type: 'SiteMixtureModel'
  usage: '_RateMatrix2SiteMixtureModel(RateMatrix<any> matrix)'
  arguments:
    - label: 'matrix'
      description: 'The matrix to convert.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'abs'
  return_type: 'RealPos'
  usage: 'abs(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'A (possibly negative) number.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title: 'Absolute value of a number'
  aliases:
  description: 'The ''abs'' function returns the absolute value of a number.'
  details:
  example: |
    # compute the absolute value of a real number
    number <- -3.0
    absoluteValueOfTheNumber <- abs(number)
    if (number + absoluteValueOfTheNumber != 0.0) {
        print("Problem when computing an absolute value.")
    } else {
        print("Correct computation of an absolute value.")
    }
  authors:
  see_also:
    - 'ceil'
    - 'floor'
    - 'round'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'ancestralStateTree'
  return_type: 'Tree'
  usage: 'ancestralStateTree(Tree<any> tree, AncestralStateTrace[]<any> ancestral_state_trace_vector, TraceTree<any> tree_trace, Bool<any> include_start_states, String<any> file, Probability|Integer<any> burnin, String<any> summary_statistic {valid options: "MAP"|"mean"}, String<any> reconstruction {valid options: "conditional"|"joint"|"marginal"}, Integer<any> site, Bool<any> verbose, Natural<any> nStates)'
  arguments:
    - label: 'tree'
      description: 'The input tree to summarize ancestral states over.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Tree'
      default:
      options:
    - label: 'ancestral_state_trace_vector'
      description: 'A vector of ancestral state traces.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AncestralStateTrace[]'
      default:
      options:
    - label: 'tree_trace'
      description: 'A trace of tree samples.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'TraceTree'
      default: 'NULL'
      options:
    - label: 'include_start_states'
      description: 'Annotate start states as well as end states for each branch. Only applicable for cladogenetic processes.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'file'
      description: 'The name of the file to store the annotated tree.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'burnin'
      description: 'The fraction/number of samples to discard as burnin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.25'
      options:
    - label: 'summary_statistic'
      description: 'The statistic used to summarize ancestral states. ''MAP'' displays the 3 states with highest posterior probabilities. ''mean'' displays the mean value and 95% CI.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'MAP'
      options:
        - 'MAP'
        - 'mean'
    - label: 'reconstruction'
      description: '''joint'' and ''conditional'' should only be used to summarize ancestral states sampled from the joint distribution. ''marginal'' can be used for states sampled from the joint or marginal distribution.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'marginal'
      options:
        - 'conditional'
        - 'joint'
        - 'marginal'
    - label: 'site'
      description: 'The character site to be summarized.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default: '1'
      options:
    - label: 'verbose'
      description: 'Printing verbose output'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'nStates'
      description: 'The number of states for which we compute the posterior probability. By default it will be the best three.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '3'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'annotateTree'
  return_type: 'Tree'
  usage: 'annotateTree(Tree<any> tree, TraceTree|TraceTree[]<any> trace, String<any> file, Bool<any> ages, Bool<any> ccAges, Bool<any> ccp, Bool<any> conditionalAges, Probability<any> hpd, Bool<any> mean, Bool<any> sampledAncestors)'
  arguments:
    - label: 'tree'
      description: 'The input tree which will be annotated.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Tree'
      default:
      options:
    - label: 'trace'
      description: 'The sample trace.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'TraceTree'
      default:
      options:
    - label: 'file'
      description: 'The name of the file where to store the tree.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'ages'
      description: 'Annotate node ages?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'ccAges'
      description: 'Annotate conditional clade ages?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'ccp'
      description: 'Annotate conditional clade probabilities?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'conditionalAges'
      description: 'Annotate node ages conditional on the input topology?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'hpd'
      description: 'The probability mass of the highest posterior density node age interval.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.95'
      options:
    - label: 'mean'
      description: 'Annotate node ages using the mean age instead of the median?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'sampledAncestors'
      description: 'Annotate sampled ancestor probs?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'append'
  return_type: 'Integer[]'
  usage: 'append(Integer[]<any> v, Integer<any> x)'
  arguments:
    - label: 'v'
      description: 'The vector that we append.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'Integer[]'
      default:
      options:
    - label: 'x'
      description: 'The value that we append.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'Integer'
      default:
      options:
  title: 'Append a value'
  aliases:
  description: '''append'' adds an element to a vector.'
  details: '''append'' creates a new vector that is the original vector plus the extra element.'
  example: |
    a <- 1:3
    b <- 4
    c := append(a,b)
  authors:
  see_also: 'rep'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'branchScoreDistance'
  return_type: 'RealPos'
  usage: 'branchScoreDistance(Tree<any> tree1, Tree<any> tree2)'
  arguments:
    - label: 'tree1'
      description: 'The first tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'tree2'
      description: 'The second tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'ceil'
  return_type: 'Integer'
  usage: 'ceil(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title: 'Ceiling value of a number'
  aliases:
  description: 'The ''ceil'' function maps the value of a number to the smallest following integer.'
  details:
  example: |
    # compute the ceiling of a real number
    number <- 3.4
    ceiled_number <- ceil(number)
    if (ceiled_number != 4.0) {
        print("Problem when computing a ceiled value.")
    } else {
        print("Correct computation of a ceiled value.")
    }
  authors:
  see_also:
    - 'abs'
    - 'floor'
    - 'round'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'characterMapTree'
  return_type: 'Tree'
  usage: 'characterMapTree(Tree<any> tree, AncestralStateTrace[]<any> ancestral_state_trace_vector, TraceTree<any> tree_trace, String<any> character_file, String<any> posterior_file, String<any> shift_prob_file, Probability|Integer<any> burnin, String<any> reconstruction {valid options: "conditional"|"joint"|"marginal"}, Integer<any> num_time_slices, Bool<any> verbose)'
  arguments:
    - label: 'tree'
      description: 'The input tree to summarize the character history over.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Tree'
      default:
      options:
    - label: 'ancestral_state_trace_vector'
      description: 'A vector of ancestral state traces.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AncestralStateTrace[]'
      default:
      options:
    - label: 'tree_trace'
      description: 'A trace of tree samples.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'TraceTree'
      default: 'NULL'
      options:
    - label: 'character_file'
      description: 'The name of the file to store the tree annotated with the MAP character history.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'posterior_file'
      description: 'The name of the file to store the tree annotated with the posterior probabilities for the MAP character history.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'shift_prob_file'
      description: 'The name of the file to store the tree annotated with the shift probabilities of the character.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'NULL'
      options:
    - label: 'burnin'
      description: 'The fraction/number of samples to discard as burnin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.25'
      options:
    - label: 'reconstruction'
      description: '''joint'' and ''conditional'' should only be used to summarize character maps sampled from the joint distribution. ''marginal'' can be used for character maps sampled from the joint or marginal distribution.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'marginal'
      options:
        - 'conditional'
        - 'joint'
        - 'marginal'
    - label: 'num_time_slices'
      description: 'The number of time slices to discretize the character history. Should be the same as used for the numeric ODE.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default: '500'
      options:
    - label: 'verbose'
      description: 'Printing verbose output'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'checkNodeOrderConstraints'
  return_type: 'Bool'
  usage: 'checkNodeOrderConstraints(TimeTree<any> tree, RlRelativeNodeAgeConstraints<any> constraints)'
  arguments:
    - label: 'tree'
      description: 'The tree which is used to compute the MRCA.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'constraints'
      description: 'The constraints on relative node ages that need to be tested on the tree.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RlRelativeNodeAgeConstraints'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'choose'
  return_type: 'Natural'
  usage: 'choose(Natural<any> n, Natural<any> k)'
  arguments:
    - label: 'n'
      description: 'Number of total elements.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'k'
      description: 'Number of chosen elements.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description: 'Rev function to calculate the binomial coefficients.'
  details:
  example: |
    n <- 5
    k <- 2
    x := choose(n, k)
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'clear'
  return_type: 'void'
  usage: 'clear(RevObject ...)'
  arguments:
    - label:
      description: 'Variables to remove.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RevObject'
      default:
      options:
  title: 'Clear the current workspace'
  aliases:
  description: 'Clear (e.g., remove) variables and functions from the workspace.'
  details: 'The clear function removes either a given variable or all variables from the workspace. Clearing the workspace is very useful between analysis if you do not want to have old connections between variables hanging around.'
  example: |
    ls()   # check what is in the workspace
    a <- 1
    b := exp(a)
    ls()   # check what is in the workspace
    clear()
    ls()   # check what is in the workspace
    a <- 1
    b := exp(a)
    ls()   # check what is in the workspace
    clear( b )
    ls()   # check what is in the workspace
  authors:
  see_also: 'exists'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'combineCharacter'
  return_type: 'AbstractHomologousDiscreteCharacterData'
  usage: 'combineCharacter(AbstractHomologousDiscreteCharacterData<any> a, AbstractHomologousDiscreteCharacterData<any> b)'
  arguments:
    - label: 'a'
      description: 'First character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'b'
      description: 'Second character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
  title: 'Concatenate character matrices'
  aliases:
  description: 'Creates a new data matrix by concatentating the provided data matrices (by order).'
  details:
  example: |
    # read in character data for locus_1
    locus_1 = readContinuousCharacterData("locus_1.nex")
    # read in character data for locus_2
    locus_2 = readContinuousCharacterData("locus_2.nex")
    # create concated locus for 1+2 (union of taxa)
    locus_1_and_2 = concatenate( locus_1, locus_2 )
  authors:
  see_also:
  type_spec:
    - 'Procedure'
    - 'Function'
    - 'RevObject'
  references:
- name: 'computeWeightedNodeOrderConstraintsScore'
  return_type: 'Real'
  usage: 'computeWeightedNodeOrderConstraintsScore(TimeTree<any> tree, RlRelativeNodeAgeWeightedConstraints<any> constraints, RealPos<any> beta)'
  arguments:
    - label: 'tree'
      description: 'The tree which is used to compute the MRCA.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'constraints'
      description: 'The constraints on relative node ages that are needed to compute the score of the tree.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RlRelativeNodeAgeWeightedConstraints'
      default:
      options:
    - label: 'beta'
      description: 'The beta weight for the constraints.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'concatenate'
  return_type: 'AbstractHomologousDiscreteCharacterData'
  usage: 'concatenate(AbstractHomologousDiscreteCharacterData<any> a, AbstractHomologousDiscreteCharacterData<any> b, AbstractHomologousDiscreteCharacterData ..., String<any> merge {valid options: "union"|"intersection"})'
  arguments:
    - label: 'a'
      description: 'First character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'b'
      description: 'Second character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label:
      description: 'Additional character data objects.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'merge'
      description: 'How to merge differing taxa'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'Taxa must match'
      options:
        - 'union'
        - 'intersection'
  title: 'Concatenate character matrices'
  aliases:
  description: 'Creates a new data matrix by concatentating the provided data matrices (by order).'
  details:
  example: |
    # read in character data for locus_1
    locus_1 = readDiscreteCharacterData("locus_1.nex")
    # read in character data for locus_2
    locus_2 = readDiscreteCharacterData("locus_2.nex")
    # create concated locus for 1+2 (union of taxa)
    locus_1_and_2 = concatenate( locus_1, locus_2 )
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'consensusTree'
  return_type: 'Tree'
  usage: 'consensusTree(TraceTree|TraceTree[]<any> trace, Probability<any> cutoff, String<any> file, Probability<any> hpd, Bool<any> mean, Bool<any> sampledAncestors, Bool<any> positiveBranchLengths)'
  arguments:
    - label: 'trace'
      description: 'The samples of trees from the posterior.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'TraceTree'
      default:
      options:
    - label: 'cutoff'
      description: 'The minimum threshold for clade probabilities.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.5'
      options:
    - label: 'file'
      description: 'The name of the file for storing the tree.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'hpd'
      description: 'The probability mass of the highest posterior density node age interval.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.95'
      options:
    - label: 'mean'
      description: 'Annotate node ages using the mean age instead of the median?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'sampledAncestors'
      description: 'Annotate sampled ancestor probs?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'positiveBranchLengths'
      description: 'Force negative branch lengths to be short but positive?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
    - 'conTree'
    - 'sumt'
  description: 'Calculates the majority-rule consensus topology from a trace of trees and summarizes branch lengths.'
  details:
  example: |
    # Read in tree trace
    tree_trace = readTreeTrace("output/my.trees", burnin=0.25)
    
    # Generate the majority-rule consensus tree
    map_tree = consensusTree(trace=tree_trace, cutoff=0.5, file="consensus.tree")
  authors:
  see_also:
    - 'mapTree'
    - 'mccTree'
    - 'treeTrace'
    - 'readTreeTrace'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'convertCountFileToNaturalNumbers'
  return_type: 'NULL'
  usage: 'convertCountFileToNaturalNumbers(String<any> count file, Natural<any> number of individuals, String<any> output file)'
  arguments:
    - label: 'count file'
      description: 'A count file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'number of individuals'
      description: 'The number of (virtual or effective) individuals.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
    - label: 'output file'
      description: 'A NaturalNumbers-type file, where each number corresponds to a PoMo state.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'convertFastaFileToNaturalNumbers'
  return_type: 'NULL'
  usage: 'convertFastaFileToNaturalNumbers(String<any> fasta file, String[]<any> taxa, String[]<any> alleles, Natural<any> number of individuals, String<any> output file)'
  arguments:
    - label: 'fasta file'
      description: 'A fasta file: sequence names must all start with one of the taxa names; this how they are assigned to each taxa. E.g., >taxa1plusotherinfo, >taxa1_plusotherinfo or just >taxa1.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'taxa'
      description: 'A string vector listing the the taxa names.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String[]'
      default:
      options:
    - label: 'alleles'
      description: 'A string vector listing the alleles.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String[]'
      default:
      options:
    - label: 'number of individuals'
      description: 'The number of (virtual or effective) individuals.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
    - label: 'output file'
      description: 'A NaturalNumbers-type file, where each number corresponds to a PoMo state.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'convertToPhylowood'
  return_type: 'Tree'
  usage: 'convertToPhylowood(String<any> statefile, String<any> treefile, String<any> geofile, String<any> outfile, Probability<any> burnin, String<any> chartype {valid options: "NaturalNumbers"|"Standard"}, String<any> bgtype {valid options: "Range"|"Area"})'
  arguments:
    - label: 'statefile'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'treefile'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'geofile'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'outfile'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'burnin'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.25'
      options:
    - label: 'chartype'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'NaturalNumbers'
      options:
        - 'NaturalNumbers'
        - 'Standard'
    - label: 'bgtype'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'Area'
      options:
        - 'Range'
        - 'Area'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'cos'
  return_type: 'Real'
  usage: 'cos(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The argument in radians.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'd_add'
  return_type: 'Real'
  usage: 'd_add(RealPos<any> x, Distribution__RealPos|Distribution__Probability<any> baseDistribution, RealPos<any> delta, Bool<any> log)'
  arguments:
    - label: 'x'
      description: 'The observed value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__RealPos'
      default:
      options:
    - label: 'delta'
      description: 'The amount added to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'log'
      description: 'Log-transformed probability?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'd_mul'
  return_type: 'Real'
  usage: 'd_mul(Probability<any> x, Distribution__Probability<any> baseDistribution, Probability<any> lambda, Bool<any> log)'
  arguments:
    - label: 'x'
      description: 'The observed value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Probability'
      default:
      options:
    - label: 'lambda'
      description: 'The amount muled to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
    - label: 'log'
      description: 'Log-transformed probability?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'd_sub'
  return_type: 'Real'
  usage: 'd_sub(Real<any> x, Distribution__Real|Distribution__RealPos|Distribution__Probability<any> firstDistribution, Real<any> second, Bool<any> log)'
  arguments:
    - label: 'x'
      description: 'The observed value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'firstDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Real'
      default:
      options:
    - label: 'second'
      description: 'The amount sub1ed to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'log'
      description: 'Log-transformed probability?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'dexponential'
  return_type: 'Real'
  usage: 'dexponential(RealPos<any> x, RealPos<any> lambda, RealPos<any> offset, Bool<any> log)'
  arguments:
    - label: 'x'
      description: 'The observed value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'lambda'
      description: 'The rate parameter ( rate = 1/mean ).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '1'
      options:
    - label: 'offset'
      description: 'The offset of the distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'log'
      description: 'Log-transformed probability?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases: 'dexp'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'diagonalMatrix'
  return_type: 'MatrixRealSymmetric'
  usage: 'diagonalMatrix(Natural<any> n)'
  arguments:
    - label: 'n'
      description: 'The number of rows/columns (dimension).'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description: 'Building a identity/diagonal matrix with ''n'' columns and rows.'
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'dinvlogit'
  return_type: 'Real'
  usage: 'dinvlogit(Probability<any> x, Distribution__Real|Distribution__RealPos|Distribution__Probability<any> baseDistribution, Bool<any> log)'
  arguments:
    - label: 'x'
      description: 'The observed value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Real'
      default:
      options:
    - label: 'log'
      description: 'Log-transformed probability?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'dlogit'
  return_type: 'Real'
  usage: 'dlogit(Real<any> x, Distribution__Probability<any> baseDistribution, Bool<any> log)'
  arguments:
    - label: 'x'
      description: 'The observed value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Probability'
      default:
      options:
    - label: 'log'
      description: 'Log-transformed probability?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'dscale'
  return_type: 'Real'
  usage: 'dscale(Probability<any> x, Distribution__Probability<any> baseDistribution, Probability<any> lambda, Bool<any> log)'
  arguments:
    - label: 'x'
      description: 'The observed value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Probability'
      default:
      options:
    - label: 'lambda'
      description: 'The amount muled to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
    - label: 'log'
      description: 'Log-transformed probability?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'dshift'
  return_type: 'Real'
  usage: 'dshift(RealPos<any> x, Distribution__RealPos|Distribution__Probability<any> baseDistribution, RealPos<any> delta, Bool<any> log)'
  arguments:
    - label: 'x'
      description: 'The observed value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__RealPos'
      default:
      options:
    - label: 'delta'
      description: 'The amount added to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'log'
      description: 'Log-transformed probability?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'exists'
  return_type: 'Bool'
  usage: 'exists(String<any> name)'
  arguments:
    - label: 'name'
      description: 'The name of the variable we wish to check for existence.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title: 'Check whether a variable exists'
  aliases:
  description: 'Determines whether the RevBayes workspace contains a variable named ''name'''
  details: '''exists'' returns ''true'' if the workspace contains a variable whose name matches the String ''name'' and ''false'' otherwise. One use of ''exists'' is to add Move and Monitor objects conditional on the variable ''x'' existing. The function ''ls'' provides a summary for all variable names that ''exists'' would evaluate as ''true''.'
  example: |
    ## Correct usage: does "x" exist?
    x <- 1.0
    exists("x")
    
    ## Incorrect usage: does "1.0" exist?
    exists(x)
  authors:
  see_also: 'clear'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'exp'
  return_type: 'RealPos'
  usage: 'exp(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'A number.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title: 'Exponential of a number'
  aliases:
  description: 'Maps the value of a number x to e^x, where e is the number such that ln(e) = 1.'
  details:
  example: |
    # checking that ln(e) = 1
    x <- exp(1)
    ln_of_x <- ln(x)
    if (ln_of_ex != 1) {
            print("Problem when computing an exponential value.")
    } else {
            print("Correct computation of an exponential value.")
    }
  authors:
  see_also: 'ln'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fileExists'
  return_type: 'Bool'
  usage: 'fileExists(String<any> file)'
  arguments:
    - label: 'file'
      description: 'The file to check.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'floor'
  return_type: 'Integer'
  usage: 'floor(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title: 'The floor function.'
  aliases:
  description: 'Rounds a number down to the nearest integer.'
  details: |
    The floor function takes as input a real number x, and gives as output the
    greatest integer less than or equal to x.
  example: |
    x <- 2.4
    floor(x) # returns 2
    
    y <- -2.4
    floor(y) # returns -3
  authors:
  see_also: 'trunc'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnAdjacentRateModifier'
  return_type: 'CharacterHistoryRateModifier'
  usage: 'fnAdjacentRateModifier(Real<any> gainFactor, Real<any> lossFactor, Natural<any> width, RealPos[][]|Real[][]|MatrixRealSymmetric|MatrixReal<any> matrix, Natural<any> numStates, Natural<any> numChars)'
  arguments:
    - label: 'gainFactor'
      description: 'Multiplicative factor (r'' = r * e^{ n_1 * f }) for characters in context set'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'lossFactor'
      description: 'Multiplicative factor (r'' = r * e^{ n_0 * f }) for characters in context set'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'width'
      description: 'Width of context-dependence window'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'matrix'
      description: 'Weighted character adjacency matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default: 'NULL'
      options:
    - label: 'numStates'
      description: 'Number of states'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'numChars'
      description: 'Number of characters'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnAverageDistanceMatrix'
  return_type: 'AverageDistanceMatrix'
  usage: 'fnAverageDistanceMatrix(DistanceMatrix[]<any> distanceMatrices, RealPos[]<any> weights)'
  arguments:
    - label: 'distanceMatrices'
      description: 'The vector of distance matrices.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'DistanceMatrix[]'
      default:
      options:
    - label: 'weights'
      description: 'The vector of weights.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default: 'NULL'
      options:
  title:
  aliases: 'avgDistanceMatrix'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<AverageDistanceMatrix>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnBetaBrokenStick'
  return_type: 'Simplex'
  usage: 'fnBetaBrokenStick(RealPos<any> alpha, RealPos<any> beta, Natural<any> numCats)'
  arguments:
    - label: 'alpha'
      description: 'The alpha parameter of the beta distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'beta'
      description: 'The beta parameter of the beta distribution'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numCats'
      description: 'The number of categories.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnBinaryMutationCoalescentRateMatrix'
  return_type: 'RateMatrix'
  usage: 'fnBinaryMutationCoalescentRateMatrix(Natural<any> n, RealPos<any> mu, RealPos<any> Ne)'
  arguments:
    - label: 'n'
      description: 'The number of samples.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'mu'
      description: 'The mutation rate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'Ne'
      description: 'The effective population size.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnBiogeoDE'
  return_type: 'RateGeneratorSequence'
  usage: 'fnBiogeoDE(RateGenerator<any> gainLossRates, CharacterHistoryRateModifier<any> geoRateMod, Simplex<any> root_frequencies, Natural<any> numAreas, Bool<any> forbidExtinction)'
  arguments:
    - label: 'gainLossRates'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator'
      default:
      options:
    - label: 'geoRateMod'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'CharacterHistoryRateModifier'
      default: 'NULL'
      options:
    - label: 'root_frequencies'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: '[ 0.500, 0.500 ]'
      options:
    - label: 'numAreas'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'forbidExtinction'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnBiogeographyCladoEventsBD'
  return_type: 'CladogeneticSpeciationRateMatrix'
  usage: 'fnBiogeographyCladoEventsBD(RealPos[]<any> speciation_rates, RealPos[]<constant> within_region_features, RealPos[][]<constant> between_region_features, RealPos[]<any> rate_multipliers, Natural<any> max_range_size, Natural<any> max_subrange_split_size, Bool<any> normalize_split_score)'
  arguments:
    - label: 'speciation_rates'
      description: 'The vector of speciation rates (1: within-region, 2: between-region).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'within_region_features'
      description: 'The within-region feature vector.'
      dag_type: '<constant>'
      pass_by: 'value'
      value_type: 'RealPos[]'
      default: 'NULL'
      options:
    - label: 'between_region_features'
      description: 'The between-region feature matrix.'
      dag_type: '<constant>'
      pass_by: 'value'
      value_type: 'RealPos[][]'
      default: 'NULL'
      options:
    - label: 'rate_multipliers'
      description: 'The rate multipliers for hidden rate classes.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default: 'NULL'
      options:
    - label: 'max_range_size'
      description: 'The maximum range size.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '0'
      options:
    - label: 'max_subrange_split_size'
      description: 'The maximum size of a daughter subrange following a between-region speciation event.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '0'
      options:
    - label: 'normalize_split_score'
      description: 'Normalize the split scores to have geometric mean of 1?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnBiogeographyRateMatrix'
  return_type: 'RateMatrix'
  usage: 'fnBiogeographyRateMatrix(RealPos[][]<any> dispersalRates, RealPos[]<any> extirpationRates, Natural<any> maxRangeSize)'
  arguments:
    - label: 'dispersalRates'
      description: 'Matrix of dispersal rates between areas.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'extirpationRates'
      description: 'Matrix of extirpation rates.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'maxRangeSize'
      description: 'Maximum range size.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '0'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnBlosum62'
  return_type: 'RateGenerator'
  usage: 'fnBlosum62()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnChromosomes'
  return_type: 'RateMatrix'
  usage: 'fnChromosomes(Natural<any> maxChromosomes, RealPos<any> gamma, RealPos<any> delta, RealPos<any> rho, RealPos<any> eta, Real<any> gamma_l, Real<any> delta_l)'
  arguments:
    - label: 'maxChromosomes'
      description: 'Maximum number of chromosomes.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'gamma'
      description: 'Rate of gain of a single chromosome.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'delta'
      description: 'Rate of loss of a single chromosome.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'rho'
      description: 'Rate of polyploidization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'eta'
      description: 'Rate of demi-polyploidization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'gamma_l'
      description: 'Rate modifier for chromosome gains.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'delta_l'
      description: 'Rate modifier for chromosome losses.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnChromosomesCladoEventsBD'
  return_type: 'CladogeneticSpeciationRateMatrix'
  usage: 'fnChromosomesCladoEventsBD(RealPos[]<any> speciation_rates, RealPos[]<any> rate_multipliers, Natural<any> max_chromosomes)'
  arguments:
    - label: 'speciation_rates'
      description: 'The speciation rates for different cladogenetic event types.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'rate_multipliers'
      description: 'The rate multipliers for hidden rate classes.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default: 'NULL'
      options:
    - label: 'max_chromosomes'
      description: 'The maximum number of chromosomes.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnChromosomesCladoProbs'
  return_type: 'CladogeneticProbabilityMatrix'
  usage: 'fnChromosomesCladoProbs(Simplex<any> eventProbs, Natural<any> maxChromosomes)'
  arguments:
    - label: 'eventProbs'
      description: 'The probabilities of the different event types.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'maxChromosomes'
      description: 'The maximum number of chromosomes.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnChromosomesPloidy'
  return_type: 'RateMatrix'
  usage: 'fnChromosomesPloidy(Natural<any> maxChromosomes, RealPos<any> gamma_d, RealPos<any> delta_d, RealPos<any> rho_d, RealPos<any> eta_d, Real<any> gamma_dl, Real<any> delta_dl, RealPos<any> gamma_p, RealPos<any> delta_p, RealPos<any> rho_p, RealPos<any> eta_p, Real<any> gamma_pl, Real<any> delta_pl, Real<any> beta)'
  arguments:
    - label: 'maxChromosomes'
      description: 'Maximum number of chromosomes.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'gamma_d'
      description: 'Diploid rate of gain of a single chromosome.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'delta_d'
      description: 'Diploid rate of loss of a single chromosome.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'rho_d'
      description: 'Diploid rate of polyploidization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'eta_d'
      description: 'Disploid rate of demi-polyploidization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'gamma_dl'
      description: 'Diploid rate modifier for chromosome gains.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'delta_dl'
      description: 'Diploid rate modifier for chromosome losses.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'gamma_p'
      description: 'Polyploid rate of gain of a single chromosome.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'delta_p'
      description: 'Polyploid rate of loss of a single chromosome.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'rho_p'
      description: 'Polyploid rate of polyploidization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'eta_p'
      description: 'Polyploid rate of demi-polyploidization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'gamma_pl'
      description: 'Polyploid rate modifier for chromosome gains.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'delta_pl'
      description: 'Polyploid rate modifier for chromosome losses.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'beta'
      description: 'Rate of rediploidization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnChromosomesPloidyCladoEventsBD'
  return_type: 'CladogeneticSpeciationRateMatrix'
  usage: 'fnChromosomesPloidyCladoEventsBD(RealPos[]<any> speciation_rates, Natural<any> max_chromosomes)'
  arguments:
    - label: 'speciation_rates'
      description: 'The speciation rates for different cladogenetic event types.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'max_chromosomes'
      description: 'The maximum number of chromosomes.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnChronoToPhylo'
  return_type: 'BranchLengthTree'
  usage: 'fnChronoToPhylo(TimeTree<any> tree, RealPos[]<any> rates)'
  arguments:
    - label: 'tree'
      description: 'The tree variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'rates'
      description: 'The branch rates we use to multiply/rescale the branches with.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnCladeSpecificHierarchicalBranchRate'
  return_type: 'RealPos[]'
  usage: 'fnCladeSpecificHierarchicalBranchRate(TimeTree<any> tree, Clade[]<any> clades, RealPos[]<any> baseRates, RealPos[]<any> cladeRates)'
  arguments:
    - label: 'tree'
      description: 'The tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'clades'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Clade[]'
      default:
      options:
    - label: 'baseRates'
      description: 'The branch rates without clade multipliers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'cladeRates'
      description: 'The rate multipliers for the clades.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnCladogeneticProbabilityMatrix'
  return_type: 'CladogeneticProbabilityMatrix'
  usage: 'fnCladogeneticProbabilityMatrix(Integer[][]<any> cladogenetic_events, RealPos[]<any> probabilities, Natural<any> num_states)'
  arguments:
    - label: 'cladogenetic_events'
      description: 'A vector of cladogenetic event types. Each type is in the form [ancestral_state, daughter1_state, daughter2_state].'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Integer[][]'
      default:
      options:
    - label: 'probabilities'
      description: 'The probabilities that correspond to the different cladogenetic event types.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'num_states'
      description: 'The number of states.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnCladogeneticSpeciationRateMatrix'
  return_type: 'CladogeneticSpeciationRateMatrix'
  usage: 'fnCladogeneticSpeciationRateMatrix(Integer[][]<any> cladogenetic_events, RealPos[]<any> speciation_rates, Natural<any> num_states)'
  arguments:
    - label: 'cladogenetic_events'
      description: 'A vector of cladogenetic event types. Each type is in the form [ancestral_state, daughter1_state, daughter2_state].'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Integer[][]'
      default:
      options:
    - label: 'speciation_rates'
      description: 'The speciation rates that correspond to the different cladogenetic event types.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'num_states'
      description: 'The number of states.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnCoala'
  return_type: 'Real[]'
  usage: 'fnCoala(Real[]<any> coordinates, MatrixReal<any> corAnalysis, RealPos[]<any> weights)'
  arguments:
    - label: 'coordinates'
      description: 'A vector of coordinates.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'corAnalysis'
      description: 'A correspondence analysis object.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'MatrixReal'
      default:
      options:
    - label: 'weights'
      description: 'A vector of weight for the coordinates.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'A branch-heterogeneous model of protein evolution for efficient inference of ancestral sequences. Groussin M, Boussau B, Gouy M. Syst Biol. 2013 Jul;62(4):523-38.'
      doi: '10.1093/sysbio/syt016'
      url: 'https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3676677/'
- name: 'fnCodon'
  return_type: 'RateMatrix'
  usage: 'fnCodon(RealPos<any> omega, Simplex<any> codonFrequencies)'
  arguments:
    - label: 'omega'
      description: 'The dN / dS rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'codonFrequencies'
      description: 'The stationary frequencies.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnCodonGY94'
  return_type: 'RateMatrix'
  usage: 'fnCodonGY94(RealPos<any> omega, RealPos<any> kappa, Simplex<any> codonFrequencies)'
  arguments:
    - label: 'omega'
      description: 'The dN / dS rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'kappa'
      description: 'The transition-transversion rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'codonFrequencies'
      description: 'The stationary frequencies of the codons.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The Goldman-Yang (1994) codon rate matrix'
  aliases:
  description: |
    The Goldman-Yang (1994) codon model.
    
    A rate matrix on the 61 non-stop codons (in the standard genetic code).
    
    Rates between codons with more than one nucleotide change are equal to 0.
    
    In this model the rate Q(i,j) from i -> j is proportional to the frequency of codon j.
    This means that the rate of change between low-frequency codons is lower than the rate
    between high-frequency codons, even when the nucleotide change involved is the same.
    In other words, the rate of change from nucleotide n1 -> n2 depends on its neighboring
    nucleotides.  This differs from the Muse-Gaut (1994) model, and is perhaps less realistic.
    
    Unlike the Muse-Gaut (1994) model, the Goldman-Yang (1994) model can allow all the codon
    frequencies to vary independently.
  details:
  example: |
    kappa ~ dnLognormal(0,1)
    omega ~ dnUniform(0,1)
    pi61 ~ dnDirichlet( rep(2.0, 61) )
    Q1 := fnCodonGY94( kappa, omega, pi61 )
    
    pi1 ~ dnDirichlet( rep(2.0, 4) )
    Q2 := fnCodonGY94( kappa, omega, fnF1x4(pi1) )
    
    pi2 ~ dnDirichlet( rep(2.0, 4) )
    pi3 ~ dnDirichlet( rep(2.0, 4) )
    Q3 := fnCodonGY94( kappa, omega, fnF3x4(pi1, pi2, pi3) )
  authors:
  see_also: 'fnF1x4, fnF3x4, fnCodonMG94, fnCodonMG94K'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Goldman, N. and Z. Yang (1994). A codon-based model of nucleotide substitution for protein-coding DNA sequences. Mol. Biol. Evol. (1994) 11 (5):725-736'
      doi: 'https://doi.org/10.1093/oxfordjournals.molbev.a040153'
      url:
- name: 'fnCodonHKY'
  return_type: 'RateMatrix'
  usage: 'fnCodonHKY(RealPos<any> omega, RealPos<any> kappa, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'omega'
      description: 'The dN / dS rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'kappa'
      description: 'The transition-transversion rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnCodonMG94'
  return_type: 'RateMatrix'
  usage: 'fnCodonMG94(RealPos<any> omega, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'omega'
      description: 'The dN / dS rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the nucleotides.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The Muse-Gaut (1994) codon rate matrix'
  aliases:
  description: |
    The Muse-Gaut (1994) codon model.
    
    A rate matrix on the 61 non-stop codons (in the standard genetic code).
    
    Rates between codons with more than one nucleotide change are equal to 0.
    
    In this model the rate Q(i,j) from i -> j is proportional to the frequency of
    nucleotide in codon j that changed.  This differs from the Goldman-Yang (1994) model,
    where Q(i,j) is proportional to the frequency of the entire codon j.
    
    Unlike the Goldman-Yang (1994) model, the Muse-Gaut (1994) model does not allow all the codon
    frequencies to vary independently.
  details:
  example: |
    omega ~ dnUniform(0,1)
    pi ~ dnDirichlet( rep(2.0, 4) )
    Q1 := fnCodonMG94( omega, pi )
    
    Q2 := fndNdS( omega, fnX3( fnF81(pi) ) ) # MG94 = F81 + X3 + dNdS
  authors:
  see_also: 'fnCodonMG94, fnCodonMG94K'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Muse, S. and B. Gaut (1994) A likelihood approach for comparing synonymous and nonsynonymous nucleotide substitution rates, with application to the chloroplast genome. Mol. Biol. Evol. (1994) 11 (5):715-724'
      doi: 'https://doi.org/10.1093/oxfordjournals.molbev.a040152'
      url:
- name: 'fnCodonMG94K'
  return_type: 'RateMatrix'
  usage: 'fnCodonMG94K(RealPos<any> kappa, RealPos<any> omega, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'kappa'
      description: 'The transition-transversion rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'omega'
      description: 'The dN / dS rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the nucleotides.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The Muse-Gaut (1994) codon rate matrix + K.'
  aliases:
  description: |
    The Muse-Gaut (1994) codon model, extended with a transition/transversion rate ratio.
    
    A rate matrix on the 61 non-stop codons (in the standard genetic code).
    
    Rates between codons with more than one nucleotide change are equal to 0.
    
    In this model the rate Q(i,j) from i -> j is proportional to the frequency of
    nucleotide in codon j that changed.  This differs from the Goldman-Yang (1994) model,
    where Q(i,j) is proportional to the frequency of the entire codon j.
    
    This version is an extension of the fnCodonMG94 model to add a transition/transversion
    rate ratio.  This makes it more comparable to the Goldman-Yang (1994) model.
    
    Unlike the Goldman-Yang (1994) model, the Muse-Gaut (1994) model does not allow all the codon
    frequencies to vary independently.
  details:
  example: |
    kappa ~ dnLognormal(0,1)
    omega ~ dnUniform(0,1)
    pi ~ dnDirichlet( rep(2.0, 4) )
    Q1 := fnCodonMG94K( kappa, omega, pi )
    
    Q2 := fndNdS( omega, fnX3( fnHKY( kappa, pi) ) ) # MG94K = HKY + X3 + dNdS
  authors:
  see_also: 'fnCodonGY94, fnCodonMG94K'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Muse, S. and B. Gaut (1994) A likelihood approach for comparing synonymous and nonsynonymous nucleotide substitution rates, with application to the chloroplast genome. Mol. Biol. Evol. (1994) 11 (5):715-724'
      doi: 'https://doi.org/10.1093/oxfordjournals.molbev.a040152'
      url:
- name: 'fnCollapseSA'
  return_type: 'Tree'
  usage: 'fnCollapseSA(Tree<any> tree)'
  arguments:
    - label: 'tree'
      description: 'The tree variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnCovarion'
  return_type: 'RateMatrix'
  usage: 'fnCovarion(RateGenerator[]<any> RateMatrices, RealPos[]<any> RateScalars, RealPos[][]<any> SwitchRates, Bool<any> rescaled)'
  arguments:
    - label: 'RateMatrices'
      description: 'Rate matrices for the characters per state.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator[]'
      default:
      options:
    - label: 'RateScalars'
      description: 'Rate multipliers per state.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'SwitchRates'
      description: 'Rates between state.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'rescaled'
      description: 'Should the matrix be normalized?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title: 'The Covarion model rate matrix.'
  aliases:
  description: |
    The `fnCovarion` function defines a covarion model rate matrix for character evolution.
    The resulting rate matrix incorporates rate heterogeneity where the characters/sites are allowed to move between rate categories with a switching rate.
  details: 'The covarion model allows for variation in evolutionary rates across sites over time, accommodating shifts in character state evolution.'
  example: |
    # define number of rate categories
    num_cats = 2
    
    # define rate scalars
    rate_scalars <- [ 0, 1.0 ]
    
    # obtain substitution model rate matrix for rescaling
    for ( i in 1:num_cats ) {
      Q_sub[i] := fnJC( 4 )
    }
    
    # define switching rate
    switching_rate = 0.1
    
    for ( i in 1:num_cats ) {
      for ( j in 1:num_cats ) {
        if ( i == j ) {
          switch_rates[i][j] := 0
        } else {
          switch_rates[i][j] := switching_rate
        }
      }
    }
    
    # finally construct the covarion rate matrix
    Q_Cov := fnCovarion(RateMatrices = Q_sub, RateScalars = rate_scalars, SwitchRates = switch_rates, rescaled = FALSE)
  authors:
  see_also:
    - 'fnJC'
    - ''
    - 'fnF81'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Fitch, W. M., & Markowitz, E. (1970). An improved method for determining codon variability in a gene and its application to the rate of fixation of mutations in evolution. _Biochemical genetics_, 4, 579-593.'
      doi: '10.1007/BF00486096'
      url: 'https://doi.org/10.1007/BF00486096'
    - citation: 'Tuffley, C., & Steel, M. (1998). Modeling the covarion hypothesis of nucleotide substitution. _Mathematical biosciences_, 147(1), 63-91.'
      doi: '10.1016/S0025-5564(97)00081-3'
      url: 'https://doi.org/10.1016/S0025-5564(97)00081-3'
- name: 'fnCovarionRateMatrix'
  return_type: 'RateGenerator'
  usage: 'fnCovarionRateMatrix(RateGenerator[]<any> Q, RateMatrix<any> switch_rates, RealPos[]<any> clock_rates, Bool<any> rescaled)'
  arguments:
    - label: 'Q'
      description: 'The rate matrix classes'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator[]'
      default:
      options:
    - label: 'switch_rates'
      description: 'The class-switching rate matrix'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
    - label: 'clock_rates'
      description: 'The rate multipliers per class'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'rescaled'
      description: 'Should the matrix be normalized?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnCpRev'
  return_type: 'RateGenerator'
  usage: 'fnCpRev()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDECCladoProbs'
  return_type: 'CladogeneticProbabilityMatrix'
  usage: 'fnDECCladoProbs(Simplex<any> eventProbs, Natural<any> numCharacters, Natural<any> maxRangeSize, String<any> probType {valid options: "pattern"|"class"}, Bool<any> widespreadAllopatry, String[]<any> eventTypes, RealPos[][]<constant> connectivityGraph, RealPos[][]<constant> vicarianceGraph)'
  arguments:
    - label: 'eventProbs'
      description: 'The probabilities of the different event types.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'numCharacters'
      description: 'The number of characters.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
    - label: 'maxRangeSize'
      description: 'The maximum range size.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '0'
      options:
    - label: 'probType'
      description: 'Assign event weights over classes of patterns or over specific patterns'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'pattern'
      options:
        - 'pattern'
        - 'class'
    - label: 'widespreadAllopatry'
      description: 'Allopatry may result in both daughter ranges being larger than size 1.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'eventTypes'
      description: 'Vector of cladogenetic event types.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String[]'
      default:
      options:
    - label: 'connectivityGraph'
      description: 'Connectivity graph of allowed ranges.'
      dag_type: '<constant>'
      pass_by: 'value'
      value_type: 'RealPos[][]'
      default: '[ ]'
      options:
    - label: 'vicarianceGraph'
      description: 'Graph to model vicariance events.'
      dag_type: '<constant>'
      pass_by: 'value'
      value_type: 'RealPos[][]'
      default: '[ ]'
      options:
  title:
  aliases: 'fnCladoProbs'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDECRateMatrix'
  return_type: 'RateMatrix'
  usage: 'fnDECRateMatrix(RealPos[][]<any> dispersalRates, RealPos[][]<any> extirpationRates, Simplex<any> rangeSize, String<any> nullRange {valid options: "CondSurv"|"Exclude"|"Include"}, Natural<any> maxRangeSize)'
  arguments:
    - label: 'dispersalRates'
      description: 'Matrix of dispersal rates between areas.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'extirpationRates'
      description: 'Matrix of extirpation rates.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'rangeSize'
      description: 'Relative proportions of range sizes.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: '[ ]'
      options:
    - label: 'nullRange'
      description: 'How should DEC handle the null range?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'CondSurv'
      options:
        - 'CondSurv'
        - 'Exclude'
        - 'Include'
    - label: 'maxRangeSize'
      description: 'Maximum range size.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '0'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDECRates'
  return_type: 'RealPos[]'
  usage: 'fnDECRates(RealPos[][]<any> dispersalRates, RealPos[]<any> extinctionRates, Natural<any> maxRangeSize)'
  arguments:
    - label: 'dispersalRates'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'extinctionRates'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'maxRangeSize'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '2147483647'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDECRoot'
  return_type: 'Simplex'
  usage: 'fnDECRoot(RealPos[]<any> rootFreqs, Simplex<any> rangeSize)'
  arguments:
    - label: 'rootFreqs'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'rangeSize'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Simplex'
      default: 'NULL'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDayhoff'
  return_type: 'RateGenerator'
  usage: 'fnDayhoff()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDecompVarCovar'
  return_type: 'MatrixRealSymmetric'
  usage: 'fnDecompVarCovar(RealPos[]<any> standardDeviations, MatrixReal<any> correlationCoefficients)'
  arguments:
    - label: 'standardDeviations'
      description: 'A vector of standard deviations.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'correlationCoefficients'
      description: 'A matrix of correlation coefficients.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'MatrixReal'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDiscretizeBeta'
  return_type: 'Probability[]'
  usage: 'fnDiscretizeBeta(RealPos<any> alpha, RealPos<any> beta, Natural<any> numCats, Bool<any> median)'
  arguments:
    - label: 'alpha'
      description: 'The alpha parameter of the beta distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'beta'
      description: 'The beta parameter of the beta distribution'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numCats'
      description: 'The number of categories.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
    - label: 'median'
      description: 'Should we use the median or mean?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title: 'Disctetize a beta distribution'
  aliases:
  description: 'Select representative values from `num_cats` discrete subdivisions of a beta distribution.'
  details: |
    
    A beta distribution is defined by two shape parameters, alpha and beta.
    
    Where a parameter or prior is defined based on the beta distribution, it may be more tractable to evaluate likelihoods at a fixed number of points from the distribution.  These representative points can be computed using `dnDiscretizeBeta`.
    
    In practice, these values are computed as follows:
    
    Let _n_ be the number of categories.
    If `median = TRUE`, the quantile function is performed at the midpoint of each category.  Call this vector _q_.
    _q_ is then normalized by dividing against its sum, so its elements sum to one; then multiplied by a factor _n_ * _alpha) / (_alpha_ + _beta_).
    
    The computation to obtain the mean for each category, when `median = FALSE`, is more complex, making use of the incomplete beta function (Majumder & Bhattacharjee 1973).
    
    A real-world use case is available in Wright et al. (2016), with discussion of the properties of the beta distribution. Corresponding tutorials are available at https://www.palass.org/sites/default/files/media/publications/newsletters/number_106/number_106_0.pdf and https://revbayes.github.io/tutorials/morph_tree/V2.html.
  example: |
    # Values to represent four quadrants of a symmetric beta distribution
    categories := fnDiscretizeBeta(0.2, 0.2, 4)
    print(categories)
  authors:
  see_also: 'A translation of `fnDiscretizeBeta` into R is available at https://gist.github.com/ms609/883632d10d4d80ea5391cee9c47071fc.'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Majumder KL, Bhattacharjee GP (1973). Algorithm AS 63: The incomplete beta integral. Applied Statistics, 22(3):409--411.'
      doi: '10.2307/2346797'
      url: 'https://www.jstor.org/stable/2346797'
    - citation: 'Wright AM, Lloyd GT, Hillis DM (2016). Modeling character change heterogeneity in phylogenetic analyses of morphology through the use of priors. Systematic Biology, 65(4):602--611.'
      doi: '10.1093/sysbio/syv122'
      url: 'https://doi.org/10.1093/sysbio/syv122'
- name: 'fnDiscretizeBetaQuadrature'
  return_type: 'MatrixRealPos'
  usage: 'fnDiscretizeBetaQuadrature(RealPos<any> alpha, RealPos<any> beta, Integer<any> numCats)'
  arguments:
    - label: 'alpha'
      description: 'The alpha parameter of the beta distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'beta'
      description: 'The beta parameter of the beta distribution'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numCats'
      description: 'The number of categories.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDiscretizeDistribution'
  return_type: 'Real[]'
  usage: 'fnDiscretizeDistribution(ContinuousDistribution<any> G0, Integer<any> num_cats)'
  arguments:
    - label: 'G0'
      description: 'The distribution to discretize.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'ContinuousDistribution'
      default:
      options:
    - label: 'num_cats'
      description: 'The number of categories into which this distribution should be discretized.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
  title: 'Discretize a Continuous Distribution'
  aliases:
  description: '`fnDiscretizeDistribution` transforms a continuous probability distribution into a discrete one by dividing it into a specified number of categories.'
  details: |
    This function takes as two arguments: a continuous probability distribution and a specified number of categories (`num_cats`).
    It then yields a sequence of median values that approximate the distribution, assuming that each bin represents an equal probability mass.
  example: |
    # Using a Normal distribution to discretize it into 5 categories
    discrete_values := fnDiscretizeDistribution( dnNormal( 0.0, 1.0 ), 5 )
    
    # print the discretized values to the screen
    discrete_values
  authors:
  see_also:
    - 'fnDiscretizeGamma'
    - ''
    - 'fnDiscretizeBeta'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDiscretizeGamma'
  return_type: 'RealPos[]'
  usage: 'fnDiscretizeGamma(RealPos<any> shape, RealPos<any> rate, Integer<any> numCats, Bool<any> median)'
  arguments:
    - label: 'shape'
      description: 'The shape parameter of the gamma distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'rate'
      description: 'The rate parameter (rate = 1/scale) of the gamma distribution'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numCats'
      description: 'The number of categories.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
    - label: 'median'
      description: 'Should we use the median or mean?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title: 'Discretize a Gamma distribution'
  aliases:
  description: '`fnDiscretizeGamma` approximates a continuous gamma distribution by dividing it into a specified number of discrete categories (quantiles), using either the mean or the median of each interval.'
  details: |
    This function takes a gamma distribution parameterized by `shape` and `rate`, along with a specified number of categories (`numCats`).
    It then discretizes the distribution into `numCats` bins yielding a sequence of values, assuming that each bin represents an equal probability mass.
    The representative values for each category can be chosen based on either the mean or the median of the interval.
  example: |
    # to obtain the mean of the quantiles
    alpha = 0.5
    
    discrete_values := fnDiscretizeGamma( shape = alpha, rate = alpha, numCats = 4, median = FALSE )
  authors:
  see_also:
    - 'fnDiscretizeDistribution'
    - ''
    - 'fnDiscretizeBeta'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Yang, Z (1994). Maximum likelihood phylogenetic estimation from DNA sequences with variable rates over sites: Approximate methods. Journal of Molecular Evolution, 39:306--314.'
      doi: '10.1007/BF00160154 usl: https://doi.org/10.1007/BF00160154'
      url:
- name: 'fnDiscretizeGammaFromBetaQuantiles'
  return_type: 'RealPos[]'
  usage: 'fnDiscretizeGammaFromBetaQuantiles(RealPos<any> alpha, RealPos<any> beta, RealPos<any> shape, RealPos<any> rate, Integer<any> numCats, Bool<any> median)'
  arguments:
    - label: 'alpha'
      description: 'The alpha parameter of the beta distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'beta'
      description: 'The beta parameter of the beta distribution'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'shape'
      description: 'The shape parameter of the gamma distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'rate'
      description: 'The rate parameter (rate = 1/scale) of the gamma distribution'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numCats'
      description: 'The number of categories.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
    - label: 'median'
      description: 'Should we use the median or mean?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDiscretizeGammaQuadrature'
  return_type: 'MatrixRealPos'
  usage: 'fnDiscretizeGammaQuadrature(RealPos<any> shape, RealPos<any> rate, Integer<any> numCats)'
  arguments:
    - label: 'shape'
      description: 'The shape parameter of the Gamma distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'rate'
      description: 'The rate parameter (rate = 1/scale) of the Gamma distribution'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numCats'
      description: 'The number of categories.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDiscretizeLognormalQuadrature'
  return_type: 'MatrixRealPos'
  usage: 'fnDiscretizeLognormalQuadrature(Real<any> mean, RealPos<any> sd, Integer<any> numCats)'
  arguments:
    - label: 'mean'
      description: 'The mean (in log-space) of the Lognormal distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'sd'
      description: 'The standard deviation (in log-space) of the Lognormal distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numCats'
      description: 'The number of categories.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDistanceRateModifier'
  return_type: 'CharacterHistoryRateModifier'
  usage: 'fnDistanceRateModifier(RealPos[][]<any> distances, Real<any> distancePower, Bool<any> useDistances, Bool<any> useAvailable)'
  arguments:
    - label: 'distances'
      description: 'Matrix of distances'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'distancePower'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '1e-05'
      options:
    - label: 'useDistances'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'useAvailable'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDppConcFromMean'
  return_type: 'RealPos'
  usage: 'fnDppConcFromMean(RealPos<any> numCats, Natural<any> numElements)'
  arguments:
    - label: 'numCats'
      description: 'Number of Categories of the DPP.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numElements'
      description: 'Total number of elements.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnDppMeanFromConc'
  return_type: 'RealPos'
  usage: 'fnDppMeanFromConc(RealPos<any> concentration, RealPos<any> numElements)'
  arguments:
    - label: 'concentration'
      description: 'The concentration parameter of the DPP.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RealPos'
      default:
      options:
    - label: 'numElements'
      description: 'The number of elements of the DPP.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnEarlyBurst'
  return_type: 'RealPos[]'
  usage: 'fnEarlyBurst(TimeTree<any> tree, RealPos<any> sigma, RealPos<any> lambda)'
  arguments:
    - label: 'tree'
      description: 'The tree which will be re-scaled.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'sigma'
      description: 'The rate of drift.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'lambda'
      description: 'The rate of change through time.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnEpoch'
  return_type: 'RateGenerator'
  usage: 'fnEpoch(RateGenerator[]<any> Q, RealPos[]<any> times, RealPos[]<any> rates)'
  arguments:
    - label: 'Q'
      description: 'The per epoch rate matrices'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator[]'
      default:
      options:
    - label: 'times'
      description: 'The times of the epochs.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'rates'
      description: 'The rate multipliers per epoch.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnEpochCladoProbs'
  return_type: 'CladogeneticProbabilityMatrix'
  usage: 'fnEpochCladoProbs(CladogeneticProbabilityMatrix[]<any> cladogeneticProbabilities, RealPos[]<any> times)'
  arguments:
    - label: 'cladogeneticProbabilities'
      description: 'The cladogenetic event probability functions.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'CladogeneticProbabilityMatrix[]'
      default:
      options:
    - label: 'times'
      description: 'The vector of epoch end ages.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnExtantTree'
  return_type: 'TimeTree'
  usage: 'fnExtantTree(TimeTree<any> tree)'
  arguments:
    - label: 'tree'
      description: 'The tree variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnF1x4'
  return_type: 'Simplex'
  usage: 'fnF1x4(Simplex<any> baseFrequencies)'
  arguments:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the nucleotides.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The F1x4 codon frequency model'
  aliases:
  description: |
    This treats codon frequencies as a product of independent nucleotide frequencies.
    
    Since stop codons are removed from the codon alphabet, frequencies are renormalized
    so that the frequencies of non-stop codons sum to 1.0.
  details:
  example: |
    kappa ~ dnLognormal(0,1)
    omega ~ dnUniform(0,1)
    pi ~ dnDirichlet( v(2.0, 2.0, 2.0, 2.0) )
    Q := fnCodonGY94( kappa, omega, fnF1x4(pi) )
  authors:
  see_also: 'fnGY94, fnF3x4'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnF2x4'
  return_type: 'Simplex'
  usage: 'fnF2x4(Simplex<any> baseFrequencies1, Simplex<any> baseFrequencies2)'
  arguments:
    - label: 'baseFrequencies1'
      description: 'The stationary frequencies of the 1st nucleotide.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'baseFrequencies2'
      description: 'The stationary frequencies of the 2nd nucleotide.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The F2x4 doublet frequency model'
  aliases:
  description: 'This treats doublet frequencies as a product of independent nucleotide frequencies.'
  details:
  example: |
    # An RNA stem model with independent base frequencies (from fnF2x4),
    # and simultaneous 2-nucleotide changes allows.
    nuc_pi ~ dnDirichlet( v(2.0, 2.0, 2.0, 2.0) )
    rna_stem_er ~ dnDirichlet( rep(1.0, 16*15/2) )
    rna_stem_pi := fnF2x4(nuc_pi, nuc_pi)
    Q := fnGTR(rna_stem_er, rna_stem_pi)
  authors:
  see_also: 'fnX2'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnF3x4'
  return_type: 'Simplex'
  usage: 'fnF3x4(Simplex<any> baseFrequencies1, Simplex<any> baseFrequencies2, Simplex<any> baseFrequencies3)'
  arguments:
    - label: 'baseFrequencies1'
      description: 'The stationary frequencies of the 1st nucleotide.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'baseFrequencies2'
      description: 'The stationary frequencies of the 2nd nucleotide.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'baseFrequencies3'
      description: 'The stationary frequencies of the 3rd nucleotide.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The F3x4 codon frequency model'
  aliases:
  description: |
    This treats codon frequencies as a product of independent nucleotide frequencies.
    
    Since stop codons are removed from the codon alphabet, frequencies are renormalized
    so that the frequencies of non-stop codons sum to 1.0.
  details:
  example: |
    kappa ~ dnLognormal(0,1)
    omega ~ dnUniform(0,1)
    pi1 ~ dnDirichlet( v(2.0, 2.0, 2.0, 2.0) )
    pi2 ~ dnDirichlet( v(2.0, 2.0, 2.0, 2.0) )
    pi3 ~ dnDirichlet( v(2.0, 2.0, 2.0, 2.0) )
    Q := fnCodonGY94( kappa, omega, fnF3x4(pi1, pi2, pi3) )
  authors:
  see_also: 'fnGY94, fnF1x4'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnF81'
  return_type: 'RateMatrix'
  usage: 'fnF81(Simplex<any> baseFrequencies)'
  arguments:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The Felsenstein (1981) rate matrix'
  aliases:
  description: 'DNA evolution model proposed in Felsenstein (1981).'
  details: |
    In this model, states are allowed to have different stationary frequencies, and exchangeability rates between states are equal. Its only argument, baseFrequencies, codes for said stationary frequencies. While this is usually used for DNA (and therefore has four states), the function can take any number of states, and therefore be used for many other applications (such as aminoacid or morphological evolution).
    
    The F81 rate matrix elements will be of the form:
        Q[i, j] = c * baseFrequencies[j]
    
    where c is a constant needed to normalize the average rate to 1
  example: |
    # stationary base frequencies
    baseFrequencies ~ dnDirichlet(v(1,1,1,1))
    
    # create an F81 rate matrix
    Q := fnF81(baseFrequencies)
  authors:
  see_also:
    - 'fnJC'
    - 'fnK80'
    - 'fnK81'
    - 'fnT92'
    - 'fnHKY'
    - 'fnTrN'
    - 'fnGTR'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Felsenstein J (1981). Evolutionary trees from DNA sequences: a maximum likelihood approach. Journal of Molecular Evolution, 17:368--376.'
      doi: '10.1007/BF01734359'
      url: 'https://link.springer.com/article/10.1007/BF01734359'
- name: 'fnFMutSel'
  return_type: 'RateMatrix'
  usage: 'fnFMutSel(RateMatrix<any> submodel, Real[]<any> fitnesses, RealPos<any> omega)'
  arguments:
    - label: 'submodel'
      description: 'Nucleotide mutation rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
    - label: 'fitnesses'
      description: 'Scaled selection coefficients 2Ns for 61 codons.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'omega'
      description: 'The dN / dS rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'The FMutSel model'
  aliases:
  description: |
    Constructs a rate matrix from 61 scaled selection coefficients w[i] and
    a 4x4 nucleotide mutation rate matrix mu(i,j).  In the original paper
    the nucleotide mutation rate matrix is a GTR rate matrix.
    
    The FMutSel0 model differs from FMutSel by constraining all codons for
    the same amino acid to have the same scaled selection coefficient.
    
    The function fnMutSel differs from fnFMutSel by taking a codon mutation
    rate matrix.
    
    A substitution from allele i -> j can be decomposed into
     (1) all individuals initially have state i
     (2) a single individual mutates from i -> j, at rate mu(i,j)
     (3) the allele j goes to fixation
    
    Then the substitution rate Q is then given by
      Q(i,j) = mu(i,j) * Pr(j goes to fixation | i was fixed previously).
    
    The probability of fixation is determined by scaled selection coefficients:
      F[i] = 2*N*s[i]
    and the initial frequency 1/N of allele j.
  details:
  example: |
    er ~ dnDirichlet( v(1,1,1,1,1,1) )
    nuc_pi ~ dnDirichlet( rep(2.0, 4) )
    F ~ dnIID(61, dnNormal(0,1))
    omega ~ dnUniform(0,1)
    # The FMutSel model from Yang and Nielsen (2008)
    Q1 := fnFMutSel(fnGTR(er, nuc_pi), F, omega)
    
    # The same -- fMutSel = GTR(er,nuc_pi) + X3 + MutSel(F) + dNdS(omega)
    Q2 := fndNdS(fnMutSel(F, fnX3(fnGTR(er, nuc_pi))), omega)
  authors:
  see_also: 'fnCodonGY94, fnCodonMG94, fnFMutSel0, fnMutSel'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Yang, Z. and R. Nielsen. Mutation-Selection Models of Codon Substitution and Their Use to Estimate Selective Strengths on Codon Usage.  Mol. Biol. Evol. (2008) 25(3):568--579'
      doi: 'https://doi.org/10.1093/molbev/msm284'
      url:
- name: 'fnFMutSel0'
  return_type: 'RateMatrix'
  usage: 'fnFMutSel0(RateMatrix<any> submodel, Real[]<any> fitnesses, RealPos<any> omega)'
  arguments:
    - label: 'submodel'
      description: 'Nucleotide mutation rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
    - label: 'fitnesses'
      description: 'Scaled selection coefficients 2Ns for 20 amino acids.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'omega'
      description: 'The dN / dS rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'The FMutSel0 model'
  aliases:
  description: |
    Constructs a rate matrix from 61 scaled selection coefficients w[i] and
    a 4x4 nucleotide mutation rate matrix mu(i,j).  In the original paper
    the nucleotide mutation rate matrix is a GTR rate matrix.
    
    The FMutSel0 model is a restriction of the FMutSel model that constrains
    all codons for the same amino acid to have the same scaled selection
    coefficient.
    
    The function fnMutSelAA differs from fnFMutSel0 by taking a codon mutation
    rate matrix.
    
    A substitution from allele i -> j can be decomposed into
     (1) all individuals initially have state i
     (2) a single individual mutates from i -> j, at rate mu(i,j)
     (3) the allele j goes to fixation
    
    Then the substitution rate Q is then given by
      Q(i,j) = mu(i,j) * Pr(j goes to fixation | i was fixed previously).
    
    The probability of fixation is determined by scaled selection coefficients:
      F[i] = 2*N*s[i]
    and the initial frequency 1/N of allele j.
  details:
  example: |
    er ~ dnDirichlet( v(1,1,1,1,1,1) )
    nuc_pi ~ dnDirichlet( rep(2.0, 4) )
    F ~ dnIID(20, dnNormal(0,1))
    omega ~ dnUniform(0,1)
    # The FMutSel0 model from Yang and Nielsen (2008)
    Q1 := fnFMutSel0(fnGTR(er, nuc_pi), F, omega)
    
    # The same -- fMutSel0 = GTR(er,nuc_pi) + X3 + MutSel(F) + dNdS(omega)
    Q2 := fndNdS( fnMutSelAA( fnX3( fnGTR(er, nuc_pi)), F), omega)
  authors:
  see_also: 'fnCodonGY94, fnCodonMG94, fnFMutSel0, fnMutSel'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Yang, Z. and R. Nielsen. Mutation-Selection Models of Codon Substitution and Their Use to Estimate Selective Strengths on Codon Usage.  Mol. Biol. Evol. (2008) 25(3):568--579'
      doi: 'https://doi.org/10.1093/molbev/msm284'
      url:
- name: 'fnFeatureInformedRates'
  return_type: 'RealPos[][]'
  usage: 'fnFeatureInformedRates(Integer[][][]<any> categoricalFeatures, Real[][][]<any> quantitativeFeatures, Real[]<any> sigma, Real[]<any> phi, RealPos<any> null_rate)'
  arguments:
    - label: 'categoricalFeatures'
      description: 'Vector of layers for categorical regional features.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Integer[][][]'
      default:
      options:
    - label: 'quantitativeFeatures'
      description: 'Vector of layers for quantitative regional features.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[][][]'
      default:
      options:
    - label: 'sigma'
      description: 'Vector of effect parameters for each categorical feature layer.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of effect parameters for each quantitative feature layer.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'null_rate'
      description: 'The rate assigned when a feature equals the null value (e.g. nan).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnFlowT2Populations'
  return_type: 'RateMatrix'
  usage: 'fnFlowT2Populations(Real[]<any> nu, Real[]<any> mu, Real[]<any> lambda, Real[]<any> sigma)'
  arguments:
    - label: 'nu'
      description: 'The population sizes: nu=(nu_1,nu_2).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'mu'
      description: 'The mutation rates: mu=(mu_A,mu_a).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'lambda'
      description: 'The allele flow rates: lambda=(lambda_12,lambda_21).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'sigma'
      description: 'The selection coefficients: sigma=(sigma_A,sigma_a).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnFreeBinary'
  return_type: 'RateMatrix'
  usage: 'fnFreeBinary(Real[]<any> transition_rates, Bool<any> rescaled)'
  arguments:
    - label: 'transition_rates'
      description: 'The transition rates between the two states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'rescaled'
      description: 'Should the matrix be normalized?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title: 'Free Binary transition rate matrix'
  aliases:
  description: 'Constructs a transition rate matrix between two states.'
  details: |
    This function enables the user to define the non-normalized off-diagonal elements of the matrix while also providing the option to normalize the matrix. Normalization ensures that the mean instantaneous rate equals 1. For example, a branch of length 1 in a non-clock tree corresponds to an expected 1 substitution per character.
     
     It takes in two arguments: 
        (1) transition_rates (tr) - A vector of real numbers of length 2 that represents the rate of transition between states.
        (2) rescaled - A boolean value that indicates whether or not the matrix should be normalized. Takes on TRUE by default.
    
    0 and 1 represent our 2 states:
    Q = [[-q_{01}, q_{01}],[q_{10}, -q_{10}]]
    
    When len(transition_rates) = 1, the single element will get recycled.
    When len(transition_rates) > 2, everything after the first two elements in the vector will be ignored.
  example: |
    # Under the ERM model
    rate_pr := phylogeny.treeLength() / 10
    mu ~ dnExp(rate_pr)
    
    moves.append( mvScale(mu, lambda=1, weight=2.0) )
    
    rate := rep(mu, 2)
    
    Q := fnFreeBinary(rate, rescaled=false)
  authors:
  see_also: 'fnFreeK'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnFreeK'
  return_type: 'RateMatrix'
  usage: 'fnFreeK(RealPos[][]|RealPos[]<any> transition_rates, Bool<any> rescaled, String<any> matrixExponentialMethod {valid options: "scalingAndSquaring"|"scalingAndSquaringPade"|"scalingAndSquaringTaylor"|"uniformization"|"eigen"})'
  arguments:
    - label: 'transition_rates'
      description: 'Transition rates between states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'rescaled'
      description: 'Should the matrix be normalized?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'matrixExponentialMethod'
      description: 'The method used to compute the matrix exponential.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'eigen'
      options:
        - 'scalingAndSquaring'
        - 'scalingAndSquaringPade'
        - 'scalingAndSquaringTaylor'
        - 'uniformization'
        - 'eigen'
  title: 'Free K Rate Matrix'
  aliases:
  description: 'This function generates and returns a free rates matrix.'
  details: |
    This function accepts both a vector or a matrix of non-negative, real numbers in the 
    first argument to automatically generate a rate matrix with corresponding substitution 
    rates, returning a rate matrix object. The function will fill rates in the matrix from
    left to right as provided in the first argument, skipping the diagonal when using a vector
    as input. For this reason, using a vector of lengths 2 to 5 will create a 2-by-2 rate
    matrix but a vector of length 6 will create a 3-by-3 rate matrix as fnFreeK will have 
    enough values to fill the matrix. Using a matrix in fnFreeK will create a rate matrix object with
    rates assigned using their respective position in the provided matrix.
    Users can specify if matrix should be normalized in the second argument using a boolean 
    variable (default TRUE). Lastly users can specify what matrix exponential method to
    use (default eigen) with a string. Possible options include:
    scalingAndSquaring
    scalingAndSquaringPade
    scalingAndSquaringTaylor
    uniformization
    eigen
  example: |
    # Define vector to pass, this will create a 2-by-2 matrix
    x <- v(0.5, 0,5)
    # Use fnFreeK to create rate matrix
    # Note the second argument is true in this case so rates will be normalized
    fnFreeK(x)
    [ [ -1.0000, 1.0000 ] ,
      [ 1.0000, -1.0000 ] ]
    
    # Case where rates are not normalized
    x <- v(0.5, 0.5)
    fnFreeK(x, false)
    [ [ -0.5000, 0.5000 ] ,
      [ 0.5000, -0.5000 ] ]
    
    # Define matrix for 3-by-3 rate matrix object
    x <- v([0, .6, .4], [.2, 0, .4], [.3, .3, 0])
    # Create rate matrix object
    fnFreeK(x)
    [ [ -1.0000, 0.6000, 0.4000 ] ,
      [ 0.2000, -0.6000, 0.4000 ] ,
      [ 0.3000, 0.3000, -0.6000 ] ]
  authors:
  see_also:
    - 'RateMatrix'
    - 'fnFreeBinary'
    - 'fnFreeSymmetricRateMatrix'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnFreeSymmetricRateMatrix'
  return_type: 'RateMatrix'
  usage: 'fnFreeSymmetricRateMatrix(RealPos[]<any> transition_rates, Bool<any> rescaled, String<any> matrixExponentialMethod {valid options: "scalingAndSquaring"|"scalingAndSquaringPade"|"scalingAndSquaringTaylor"|"uniformization"|"eigen"})'
  arguments:
    - label: 'transition_rates'
      description: 'The transition rates between states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'rescaled'
      description: 'Should the matrix be normalized?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'matrixExponentialMethod'
      description: 'The method used to compute the matrix exponential.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'scalingAndSquaring'
      options:
        - 'scalingAndSquaring'
        - 'scalingAndSquaringPade'
        - 'scalingAndSquaringTaylor'
        - 'uniformization'
        - 'eigen'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnGTR'
  return_type: 'RateMatrix'
  usage: 'fnGTR(Simplex<any> exchangeRates, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'exchangeRates'
      description: 'The exchangeability rates between states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The General Time-Reversible rate matrix'
  aliases:
  description: 'DNA evolution model proposed in Tavare (1986).'
  details: |
    In this model, states are allowed to have different stationary frequencies, and exchangeability rates between states are allowed to be different. Its first argument, exchangeRates, codes for the transition rates between states (as in other models, transition rates are assumed to be symmetric). Its second argument, baseFrequencies, codes for the stationary frequencies of these states. Note that for n states, exchangeRates should have length n*(n-1)/2, and baseFrequencies should have length n. While this is usually used for DNA (and therefore has four states), the function can take any number of states, and therefore be used for many other applications (such as aminoacid or morphological evolution).
    
    The general time-reversible rate matrix elements will be of the form:
         Q[i, j] = c * exchangeRates[i, j] * baseFrequencies[j]
    
    where c is a constant needed to normalize the average rate to 1.
  example: |
    # exchange rates
    er ~ dnDirichlet( v(1,1,1,1,1,1) )
    
    # base frequencies
    pi ~ dnDirichlet( v(1,1,1,1) )
    
    # create a GTR rate matrix
    Q := fnGTR(er,pi)
  authors:
  see_also:
    - 'fnJC'
    - 'fnK80'
    - 'fnK81'
    - 'fnT92'
    - 'fnHKY'
    - 'fnTrN'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Tavare, S (1986). "Some Probabilistic and Statistical Problems in the Analysis of DNA Sequences".  Lectures on Mathematics in the Life Sciences. 17:57-86'
      doi:
      url: 'http://www.damtp.cam.ac.uk/user/st321/CV_&_Publications_files/STpapers-pdf/T86.pdf'
- name: 'fnGammaASRV'
  return_type: 'SiteMixtureModel'
  usage: 'fnGammaASRV(SiteMixtureModel<any> submodel, RealPos<any> alpha, Integer<any> n, Bool<any> median)'
  arguments:
    - label: 'submodel'
      description: 'Sub-model.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'SiteMixtureModel'
      default:
      options:
    - label: 'alpha'
      description: 'The alpha parameter of the gamma distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'n'
      description: 'The number of bins to approximate the gamma distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Integer'
      default: '4'
      options:
    - label: 'median'
      description: 'Should we use the median (or the mean)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title: 'fnGammaASRV'
  aliases:
  description: 'Add Gamma-distributed across-site rate variation (ASRV) to a site model.'
  details: |
    Each site evolves according to the specified site model, but at an unknown rate
    that is Gamma distributed. If the site model parameter is a mixture model with
    m components, this function will return a mixture with m*n components.
    
    The continuous Gamma distribution is approximated with a mixture distribution
    over n discrete rates, each with probability 1/n.  The Gamma distribution is
    constrained to have a mean of 1, so as not to change the  branch lengths.
    It therefore has only a single parameter alpha -- the shape parameter.
            - As alpha approaches infinity, all rates across sites become equal (rate variation goes to 0).
            - If alpha = 1, then the rate is exponentially distributed.  Rate variation is substantial.
            - As alpha approaches zero, many sites have rate 0, and many sites have a high rate.
    
    RateMatrix and RateGenerator site model parameters will automatically be converted to a
    SiteMixtureModel with a single component.
  example: |
    # fnGammaASRV( ) constructs a mixture model that represents both the underlying
    #   rate matrix and Gamma-distributed rate variation.
    for (i in 1:10) { taxa[i] = taxon("T"+i) }
    psi ~ dnBDP(lambda=1, rootAge=1, taxa=taxa)
    alpha ~ dnExp(1/10)
    er ~ dnDirichlet( [1,1,1,1,1,1] )
    pi ~ dnDirichlet( [1,1,1,1] )
    M := fnGammaASRV( fnGTR(er, pi), alpha, 4)
    seq ~ dnPhyloCTMC(psi, M, type="DNA",nSites=10)
    
    # As an alternative approach, models can be built up iteratively using pipes.
    M := fnGTR(er,pi) |> fnGammaASRV(alpha, 4)
    
    M := fnGTR(er,pi) |> fnGammaASRV(alpha, 4) |> fnInvASRV(p_inv)  # This has 5 (4+1) components - faster.
    M := fnGTR(er,pi) |> fnInvASRV(p_inv) |> fnGammaASRV(alpha, 4)  # This has 8 (2*4) components - slower.
    
    # The site model parameter can be a mixture model
    weights ~ dnDirichlet([1,1])
    pi1 ~ dnDirichlet( [1,1,1,1,1,1 ] )
    pi2 ~ dnDirichlet( [1,1,1,1,1,1 ] )
    M := fnMixtureASRV([fnGTR(er,pi1),fnGTR(er,pi2)],weights) |> fnGammaASRV(alpha) |> fnInvASRV(p_inv)
  authors:
  see_also:
    - 'fnUnitMixture'
    - 'fnInvASRV'
    - 'fnScale'
    - 'fnMixtureASRV'
    - 'fnDiscretizeGamma'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Yang, Z. (1994) Maximum likelihood phylogenetic estimation from DNA sequences with variable rates over sites: approximate methods'
      doi: 'https://doi.org/10.1007/BF00160154'
      url:
- name: 'fnGeographicalDistance'
  return_type: 'RealPos'
  usage: 'fnGeographicalDistance(Real<any> lat1, Real<any> lon1, Real<any> lat2, Real<any> lon2)'
  arguments:
    - label: 'lat1'
      description: 'The latitude for the first coordinate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'lon1'
      description: 'The longitude for the first coordinate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'lat2'
      description: 'The latitude for the second coordinate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'lon2'
      description: 'The longitude for the second coordinate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnHKY'
  return_type: 'RateMatrix'
  usage: 'fnHKY(RealPos<any> kappa, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'kappa'
      description: 'The transition-transversion rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title: 'The Hasegawa-Kishino-Yano (1985) nucleotide rate matrix'
  aliases:
  description: 'DNA evolution model proposed in Hasegawa, Kishino, and Yano (1985).'
  details: |
    In this model, nucleotides have different stationary frequencies, and transition and transversion rates are allowed to be different. Its first parameter, kappa, codes for the ratio between the rate of transitions and transversions. Its second parameter, baseFrequencies, codes for the frequencies of each nucleotide.
    
    The HKY rate matrix elements will be of the form:
        Q[i, j] = c * kappa * baseFrequencies[j], if i<->j is a transition 
                = c * baseFrequencies[j], if i<->j is a transversion
    
    where c is a constant needed to normalize the average rate to 1.
  example: |
    # the ratio between rates of transitions and transversions
    kappa ~ dnLognormal(0,1)
    
    # the base frequencies
    pi ~ dnDirichlet( v(1,1,1,1) )
    
    # create an HKY rate matrix
    Q := fnHKY(kappa,pi)
  authors:
  see_also:
    - 'fnJC'
    - 'fnK80'
    - 'fnK81'
    - 'fnF81'
    - 'fnT92'
    - 'fnTrN'
    - 'fnGTR'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Hasegawa, M. et al. (1985). "Dating of the human-ape splitting by a molecular clock of mitochondrial DNA". Journal of molecular evolution. 22(2):160-174.'
      doi: 'https://doi.org/10.1007/BF02101694'
      url: 'https://link.springer.com/article/10.1007%2FBF02101694'
- name: 'fnHiddenStateRateMatrix'
  return_type: 'RateMatrix'
  usage: 'fnHiddenStateRateMatrix(RealPos[][]|RealPos[]|RateGenerator<any> observered_transition_rates, RealPos[][]|RealPos[]|RateGenerator<any> hidden_transition_rates, Bool<any> rescaled)'
  arguments:
    - label: 'observered_transition_rates'
      description: 'Transition rates between observed states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'hidden_transition_rates'
      description: 'Transition rates between hidden states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'rescaled'
      description: 'Should the matrix be normalized?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnHostSwitchRateModifier'
  return_type: 'CharacterHistoryRateModifier'
  usage: 'fnHostSwitchRateModifier(Tree<any> tree, RealPos[]<any> gainScale)'
  arguments:
    - label: 'tree'
      description: 'Host phylogeny that influences host switch rates.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'gainScale'
      description: 'Scales phylogenetic distance depending on gain type.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnInferAncestralPopSize'
  return_type: 'MatrixReal'
  usage: 'fnInferAncestralPopSize(RealPos<any> rootAge, RealPos|RealPos[]<any> lambda, RealPos|RealPos[]<any> mu, RealPos|RealPos[]<any> psi, RealPos|RealPos[]<any> omega, Probability<any> rho, Probability<any> removalPr, Natural<any> maxHiddenLin, String<any> condition {valid options: "survival"|"survival2"}, Real[]<any> occurrence_ages, Real[]<any> time_points, TimeTree<any> timeTree, RealPos[]<any> timeline, Bool<any> verbose)'
  arguments:
    - label: 'rootAge/originAge'
      description: 'Start age of the process.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'lambda'
      description: 'Speciation/birth rate(s).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'mu'
      description: 'Extinction/death rate(s).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'psi'
      description: 'Serial sampling rate(s).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'omega'
      description: 'Occurrence sampling rate(s).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
    - label: 'rho'
      description: 'Sampling probability at present time.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default: '1'
      options:
    - label: 'removalPr'
      description: 'Probabilit(y|ies) of death upon sampling (treatment).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default: '0'
      options:
    - label: 'maxHiddenLin'
      description: 'Maximum number of hidden lineages (algorithm accuracy).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default: '30'
      options:
    - label: 'condition'
      description: 'Condition of the process on the survival of either 1 (survival) or 2 lineages (survival2) to the present.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'none'
      options:
        - 'survival'
        - 'survival2'
    - label: 'occurrence_ages'
      description: 'Vector of occurrence ages.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'time_points'
      description: 'Time points at which we compute the density.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'timeTree'
      description: 'Tree for which ancestral pop. size has to be computed.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'TimeTree'
      default: 'NULL'
      options:
    - label: 'timeline'
      description: 'Rate interval change times of the piecewise constant process.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default: 'NULL'
      options:
    - label: 'verbose'
      description: 'If true displays warnings and information messages.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnInfiniteSites'
  return_type: 'RateMatrix'
  usage: 'fnInfiniteSites(Natural<any> num_states)'
  arguments:
    - label: 'num_states'
      description: 'The number of states.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '2'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnInvASRV'
  return_type: 'SiteMixtureModel'
  usage: 'fnInvASRV(SiteMixtureModel<any> submodel, RealPos<any> pInv)'
  arguments:
    - label: 'submodel'
      description: 'Sub-rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'SiteMixtureModel'
      default:
      options:
    - label: 'pInv'
      description: 'The fraction of invariable sites.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'fnInvASRV'
  aliases:
  description: 'Add an invariable-sites component to a site model.'
  details: |
    This model specifies that some fraction pInv of sites are invariable.
    If the site model parameter is a mixture model with m components, this function will return a model with
    m+1 components.
  example: |
    # fnInvASRV( ) creates a mixture model by adding invariant sites to an underlying site model.
    for (i in 1:10) { taxa[i] = taxon("T"+i) }
    psi ~ dnBDP(lambda=1, rootAge=1, taxa=taxa)
    p_inv ~ dnUniform(0,1)
    M := fnInvASRV( fnJC(4), p_inv)
    seq ~ dnPhyloCTMC(psi, M, type="DNA", nSites=10)
    
    # As an alternative approach, models can be built up iteratively using pipes.
    M := fnJC(4) |> fnInv(p_inv)
    
    M := fnJC(4) |> fnGammaASRV(alpha, 4) |> fnInvASRV(p_inv)  # This has 5 (4+1) components - faster.
    M := fnJC(4) |> fnInvASRV(p_inv) |> fnGammaASRV(alpha, 4)  # This has 8 (4*2) components - slower.
    
    # Not recommended -- illustration only.  3 components.
    M := fnJC(4) |> fnInv(p1) |> fnInv(p2) # Fraction of invariable sites is p2 + (1-p2)*p1
  authors:
  see_also:
    - 'fnUnitMixture'
    - 'fnGammaASRV'
    - 'fnMixtureASRV'
    - 'fnScale'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnJC'
  return_type: 'RateMatrix'
  usage: 'fnJC(Natural<any> num_states)'
  arguments:
    - label: 'num_states'
      description: 'The number of state or state space.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title: 'fnJC'
  aliases:
  description: 'Jukes Cantor rate matrix'
  details: |
    Rate matrix with n states in which each state has an equal probability to change 
    to any other state. The rate of transition from one state to another is equal to 
    n / n-1.
  example: |
    # Rate Matrix for DNA
    q := fnJC(4)
    # Rate Matrix for Amino Acids
    q := fnJC(20)
    # Binary Character Matrix
    q := fnJC(2)
  authors:
  see_also:
    - 'fnGTR'
    - 'fnF81'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Jukes TH, Cantor CR (1969). Evolution of Protein Molecules. New York: Academic Press. pp. 21--132.'
      doi:
      url:
- name: 'fnJones'
  return_type: 'RateGenerator'
  usage: 'fnJones()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnK80'
  return_type: 'RateMatrix'
  usage: 'fnK80(RealPos<any> kappa)'
  arguments:
    - label: 'kappa'
      description: 'The transition/transversion rate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'The Kimura (1980) nucleotide rate matrix'
  aliases: 'fnKimura80'
  description: 'DNA evolution model proposed in Kimura (1980).'
  details: |
    In this model, all nucleotides have an equal stationary frequency, and transition and transversion rates are allowed to be different. Its only parameter, kappa, codes for the ratio between the rate of transitions and transversions.
    
    The K80 rate matrix elements will be of the form:
        Q[i, j] = c * kappa, if i<->j is a transition
                = c, if i<->j is a transversion
    
    where c is a constant needed to normalize the average rate to 1.
  example: |
    # the ratio between rates of transitions and transversions
    kappa ~ dnExp(0.5)
    
    # create a K80 rate matrix
    Q := fnK80(kappa)
  authors:
  see_also:
    - 'fnJC'
    - 'fnF81'
    - 'fnK81'
    - 'fnT92'
    - 'fnHKY'
    - 'fnGTR'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Kimura M (1980). A simple method for estimating evolutionary rates of base substitutions through comparative studies of nucleotide sequences. Journal of Molecular Evolution, 16:111--20.'
      doi: '10.1007/BF01731581'
      url: 'https://link.springer.com/article/10.1007/BF01731581'
- name: 'fnK81'
  return_type: 'RateMatrix'
  usage: 'fnK81(RealPos<any> kappa1, RealPos<any> kappa2, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'kappa1'
      description: 'The transversion rate from purine to pyrimidine.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'kappa2'
      description: 'The transversion rate from pyrimidine to purine.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: '[ 0.250, 0.250, 0.250, 0.250 ]'
      options:
  title:
  aliases: 'fnKimura81'
  description: 'DNA evolution model proposed in Kimura (1981).'
  details: |
    In this model, transition and transversion rates are allowed to be different, and transversion rates for A <-> C, G <-> T and A <-> T, C <-> G transversions are different as well. The first argument, kappa1, defines the ratio between the rate of transitions and the rate of A <-> C, G <-> T transversions. The second argument, kappa2, defines the ratio between the rate of A <-> T, C <-> G transversions and the rate of A <-> C, G <-> T transversions. The third argument, baseFrequencies, defines the stationary frequencies of nucleotide bases. Note that the original Kimura (1981) model assumed equal base frequencies, so this function is more general (if ran without a baseFrequencies argument, however, this is equivalent to K81, since the default is all frequencies equal). 
    
    The K81 rate matrix elements will be of the form:
        Q[i, j] = c, if i<->j is an A<->C/G<->T transversion
                = c * kappa1, if i<->j is a transition
                = c * kappa2, if i<->j is an A<->T/C<->G transversion
    
    where c is a constant needed to normalize the average rate to 1. If using the baseFrequencies parameter, those elements are multiplied by baseFrequencies[j].
  example: |
    # the ratio between rates of transitions and A<->C/G<->T transversions
    kappa1 ~ dnExp(0.5)
    
    # the ratio between rates of A<->T/C<->G and A<->C/G<->T transversions
    kappa2 ~ dnExp(0.5)
    
    # create a K81 rate matrix
    Q := fnK81(kappa1, kappa2)
    
    # base frequencies
    baseFrequencies ~ dnDirichlet(v(1,1,1,1))
    
    # K81 rate matrix with non-equal base frequencies
    Q := fnK81(kappa1, kappa2, baseFrequencies)
  authors:
  see_also:
    - 'fnJC'
    - 'fnK80'
    - 'fnF80'
    - 'fnT92'
    - 'fnHKY'
    - 'fnTrN'
    - 'fnGTR'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Kimura M (1981). Estimation of evolutionary distances between homologous nucleotide sequences. Proceedings of the National Academy of Sciences of the United States of America, 78(1):454--458.'
      doi: '10.1073/pnas.78.1.454'
      url: 'https://www.pnas.org/doi/abs/10.1073/pnas.78.1.454'
- name: 'fnLG'
  return_type: 'RateMatrix'
  usage: 'fnLG(Simplex<any> aaFrequencies)'
  arguments:
    - label: 'aaFrequencies'
      description: 'The stationary frequencies of the states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: '[ 0.079, 0.056, 0.042, 0.053, 0.013, 0.041, 0.072, 0.057, 0.022, 0.062, 0.099, 0.065, 0.023, 0.042, 0.044, 0.061, 0.053, 0.012, 0.034, 0.069 ]'
      options:
  title: 'LG (Le and Gascuel) Amino Acid Substitution Rate Matrix'
  aliases:
  description: 'Generates a rate matrix based on the Le and Gascuel (LG) substitution model for amino acid evolution.'
  details: 'The LG model is an empirical model of amino acid replacement derived from large-scale protein alignments. It refines substitution rate estimation by explicitly considering site-specific rate variation.'
  example: |
    # LG model with estimated frequencies
    pi ~ dnDirichlet( rep(1,20) )
    Q := fnLG(pi)
    
    # LG model with fixed frequencies
    Q2 <- fnLG()
  authors:
  see_also:
    - 'fnDayhoff'
    - 'fnJones'
    - 'fnWAG'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Le SQ, Gascuel O (2008). An improved general amino acid replacement matrix. Molecular Biology and Evolution, 25(7):1307-1320.'
      doi: '10.1093/molbev/msn067'
      url: 'https://academic.oup.com/mbe/article/25/7/1307/1041491'
- name: 'fnLnProbability'
  return_type: 'Real'
  usage: 'fnLnProbability(Real<stochastic> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<stochastic>'
      pass_by: 'reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnMinBLTimeScaling'
  return_type: 'TimeTree'
  usage: 'fnMinBLTimeScaling(Tree<any> unscaledTree, Taxon[]<any> taxa, RealPos<any> minBL)'
  arguments:
    - label: 'unscaledTree'
      description: 'The tree to be scaled.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'taxa'
      description: 'The vector of taxa; has to match the tips of the tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Taxon[]'
      default:
      options:
    - label: 'minBL'
      description: 'Minimum branch length to use for time scaling.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description: |
    Time-scales an undated tree based on a vector of tip ages using the minimum
    branch length ("MBL") approach (Laurin 2004; Bapst 2014).
  details: |
    The age of each internal node is based on the age of the oldest tip descended
    from it. However, if t0 is the oldest tip descended from a given node (denoted
    x) and also the oldest tip descended from that node's parent (denoted y), then
    setting t(x) = t(y) = t(t0) would produce zero-length branches y->x and x->t0.
    We avoid this by requiring every branch to be no shorter than some user-supplied
    constant. This has the effect of shifting node ages deeper into the past.
    
    Conceptually, the undated tree would usually correspond either to a bare
    topology (a tree without branch lengths) or a tree with branch lengths in units
    of expected change; in practice, both `BranchLengthTree` and `TimeTree` arguments
    are accepted. In this implementation of the MBL approach, both terminal and
    internal branches are required to be greater than or equal to the specified
    minimum. If there is uncertainty associated with the age of a given tip,
    the midpoint of the uncertainty range is used for time-scaling.
    
    The algorithm is not stochastic (i.e., it always returns the same time-scaled
    tree for a given input), and is primarily intended to generate a plausible
    starting tree for MCMC analyses.
  example: |
    # Read in an undated tree
    undated_tree <- readTrees("undated.nex")[1]
    
    # Read tip age data from a file
    taxa <- readTaxonData("tipages.tsv")
    
    # Time-scale using a minimum branch length of 3 Myr
    dated_tree <- fnMinBLTimeScaling(undated_tree, taxa, 3.0)
    
    print(undated_tree) # The original tree remains unchanged
    print(dated_tree)   # A new, dated tree has been returned
  authors:
  see_also: 'simStartingTree'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Bapst DW (2014). Assessing the effect of time-scaling methods on phylogeny-based analyses in the fossil record. Paleobiology, 40(3):331-351.'
      doi: '10.1666/13033'
      url:
    - citation: 'Laurin M (2004). The evolution of body size, Cope''s rule and the origin of amniotes. Systematic Biology, 53(4):594-622.'
      doi: '10.1080/10635150490445706'
      url:
- name: 'fnMixtureASRV'
  return_type: 'SiteMixtureModel'
  usage: 'fnMixtureASRV(SiteMixtureModel[]<any> models, Simplex<any> fractions)'
  arguments:
    - label: 'models'
      description: 'The mixture models to mix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'SiteMixtureModel[]'
      default:
      options:
    - label: 'fractions'
      description: 'The probability of each model.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: 'NULL'
      options:
  title: 'fnMixtureASRV'
  aliases:
  description: 'Constructs a mixture model from a collection of site models.'
  details: |
    Each site will evolve according to one of the input site models, which may also
    be mixture models.  The probability that each site follows a particular site model
    is specified by the fractions parameter.
    
    The number of components in the resulting mixture model is the sum of the number
    of components of the input mixture models.
    
    If the fractions parameter is missing, then each of the given models is given equal
    weight.
  example: |
    # Two components with different frequencies
    for (i in 1:10) { taxa[i] = taxon("T"+i) }
    psi ~ dnBDP(lambda=1, rootAge=1, taxa=taxa)
    pi1 ~ dnDirichlet([1,1,1,1])
    pi2 ~ dnDirichlet([1,1,1,1])
    weights ~ dnDirichlet([1,1])
    M := fnMixtureASRV([fnF81(pi1),fnF81(pi2)],weights)
    seq ~ dnPhyloCTMC(psi, M, type="DNA", nSites=10)
    
    # A weight of 1/2 on each model because the weights are missing.
    M := fnMixtureASRV([fnF81(pi1),fnF81(pi2)])
    
    # Adding rate variation to the frequency-variation model.
    M := fnMixtureASRV([fnF81(pi1),fnF81(pi2)],weights) |> fnGammaASRV(alpha) |> fnInvASRV(p_inv)
  authors:
  see_also:
    - 'fnUnitMixture'
    - 'fnGammaASRV'
    - 'fnInvASRV'
    - 'fnScale'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnMixtureCladoProbs'
  return_type: 'CladogeneticProbabilityMatrix'
  usage: 'fnMixtureCladoProbs(CladogeneticProbabilityMatrix[]<any> cladogeneticProbabilities, Simplex<any> mixtureWeights)'
  arguments:
    - label: 'cladogeneticProbabilities'
      description: 'The cladogenetic event probability functions.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'CladogeneticProbabilityMatrix[]'
      default:
      options:
    - label: 'mixtureWeights'
      description: 'The mixture probabilities.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnMtMam'
  return_type: 'RateGenerator'
  usage: 'fnMtMam()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnMtRev'
  return_type: 'RateGenerator'
  usage: 'fnMtRev()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnMutSel'
  return_type: 'RateMatrix'
  usage: 'fnMutSel(RateMatrix<any> submodel, Real[]<any> fitnesses)'
  arguments:
    - label: 'submodel'
      description: 'Mutation rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
    - label: 'fitnesses'
      description: 'Fitnesses.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Add mutation-selection balance to a rate matrix.'
  aliases:
  description: |
    Constructs a rate matrix from scaled selection coefficients w[i] and
    mutation rate matrix mu(i,j).
    
    fnMutSel takes 61 scaled selection coefficients, one for each codon.
    This differs from fnMutSelAA, which takes 20 scaled selection coefficients,
    one for each amino acid.
    
    A substitution from allele i -> j can be decomposed into
     (1) all individuals initially have state i
     (2) a single individual mutates from i -> j, at rate mu(i,j)
     (3) the allele j goes to fixation
    
    Then the substitution rate Q is then given by
      Q(i,j) = mu(i,j) * Pr(j goes to fixation | i was fixed previously).
    
    The probability of fixation is determined by scaled selection coefficients:
      F[i] = 2*N*s[i]
    and the initial frequency 1/N of allele j.
  details:
  example: |
    er ~ dnDirichlet( v(1,1,1,1,1,1) )
    nuc_pi ~ dnDirichlet( rep(2.0, 4) )
    F ~ dnIID(61, dnNormal(0,1))
    Q := fnMutSel(fnX3(fnGTR(er, nuc_pi) ), F)       # GTR + X3 + MutSel
    
    # A mutation-selection balance model on RNA, with GTR mutation.
    F2 ~ dnIID(16, dnNormal(0,1))
    Q2 := fnMutSel(fnX2(fnGTR(er,nuc_pi) ), F2)      # GTR + X2 + MutSel
  authors:
  see_also: 'fnCodonGY94, fnCodonMG94, fnMutSelAA, fnFMutSel, fndNdS'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Yang, Z. and R. Nielsen. Mutation-Selection Models of Codon Substitution and Their Use to Estimate Selective Strengths on Codon Usage.  Mol. Biol. Evol. (2008) 25(3):568--579'
      doi: 'https://doi.org/10.1093/molbev/msm284'
      url:
- name: 'fnMutSelAA'
  return_type: 'RateMatrix'
  usage: 'fnMutSelAA(RateMatrix<any> submodel, Real[]<any> fitnesses)'
  arguments:
    - label: 'submodel'
      description: 'Codon rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
    - label: 'fitnesses'
      description: 'Amino acid fitnesses.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Add mutation-selection balance to a rate matrix -- fitnesses on amino acids'
  aliases:
  description: |
    Constructs a rate matrix from scaled selection coefficients w[i] and
    mutation rate matrix mu(i,j).
    
    fnMutSelAA takes 20 scaled selection coefficients, one for each amino acid.
    This differs from fnMutSel, which takes 61 scaled selection coefficients,
    one for each codon.  fnMutSelAA assumes that codons for the same amino acid
    have the same fitness.
    
    A substitution from allele i -> j can be decomposed into
     (1) all individuals initially have state i
     (2) a single individual mutates from i -> j, at rate mu(i,j)
     (3) the allele j goes to fixation
    
    Then the substitution rate Q is then given by
      Q(i,j) = mu(i,j) * Pr(j goes to fixation | i was fixed previously).
    
    The probability of fixation is determined by scaled selection coefficients:
      F[i] = 2*N*s[i]
    and the initial frequency 1/N of allele j.
  details:
  example: |
    er ~ dnDirichlet( v(1,1,1,1,1,1) )
    nuc_pi ~ dnDirichlet( rep(2.0, 4) )
    F ~ dnIID(20, dnNormal(0,1))
    Q := fnMutSelAA(fnX3(fnGTR(er, nuc_pi)), F)
  authors:
  see_also: 'fnCodonGY94, fnCodonMG94, fnX3, fndNdS, fnMutSel'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Yang, Z. and R. Nielsen. Mutation-Selection Models of Codon Substitution and Their Use to Estimate Selective Strengths on Codon Usage.  Mol. Biol. Evol. (2008) 25(3):568--579'
      doi: 'https://doi.org/10.1093/molbev/msm284'
      url:
- name: 'fnNormalizedQuantile'
  return_type: 'Real[]'
  usage: 'fnNormalizedQuantile(Distribution__Real<any> contDistribution, Integer<any> numCategories)'
  arguments:
    - label: 'contDistribution'
      description: 'The distribution which we discretize.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Real'
      default:
      options:
    - label: 'numCategories'
      description: 'How many discrete categories?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Integer'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnNumUniqueInVector'
  return_type: 'Natural'
  usage: 'fnNumUniqueInVector(Real[]<any> vector)'
  arguments:
    - label: 'vector'
      description: 'The vector of values.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnOrderedRateMatrix'
  return_type: 'RateMatrix'
  usage: 'fnOrderedRateMatrix(Natural<any> maxState, RealPos<any> lambda, RealPos<any> mu, Bool<any> allowZeroState, Bool<any> rescaled, String<any> matrixExponentialMethod {valid options: "scalingAndSquaring"|"scalingAndSquaringPade"|"scalingAndSquaringTaylor"|"uniformization"|"eigen"})'
  arguments:
    - label: 'maxState'
      description: 'The maximum state for this rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'lambda'
      description: 'The rate of gain.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '1'
      options:
    - label: 'mu'
      description: 'The rate of loss.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '1'
      options:
    - label: 'allowZeroState'
      description: 'Can the character go into state 0.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'rescaled'
      description: 'Should the matrix be normalized?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'matrixExponentialMethod'
      description: 'The method used to compute the matrix exponential.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'eigen'
      options:
        - 'scalingAndSquaring'
        - 'scalingAndSquaringPade'
        - 'scalingAndSquaringTaylor'
        - 'uniformization'
        - 'eigen'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPD'
  return_type: 'RealPos'
  usage: 'fnPD(Tree<any> tree, Clade<any> sample, Bool<any> includeRoot, RealPos[]<any> weights)'
  arguments:
    - label: 'tree'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'sample'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Clade'
      default:
      options:
    - label: 'includeRoot'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'weights'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RealPos[]'
      default: '[ ]'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<RealPos>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPartialToCorr'
  return_type: 'MatrixRealSymmetric'
  usage: 'fnPartialToCorr(MatrixReal<any> partialCorrelations)'
  arguments:
    - label: 'partialCorrelations'
      description: 'A matrix of partial correlation coefficients.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'MatrixReal'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPattersonsD'
  return_type: 'Real'
  usage: 'fnPattersonsD(String<any> p1, String<any> p2, String<any> p3, String<any> outgroup, AbstractHomologousDiscreteCharacterData<any> data)'
  arguments:
    - label: 'p1'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'p2'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'p3'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'outgroup'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'data'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<Real>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPhylogeneticIndependentContrasts'
  return_type: 'Real[]'
  usage: 'fnPhylogeneticIndependentContrasts(TimeTree<any> tree, ContinuousCharacterData<any> data, Natural<any> site, Bool<any> normalized)'
  arguments:
    - label: 'tree'
      description: 'The tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'data'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'ContinuousCharacterData'
      default:
      options:
    - label: 'site'
      description: 'The site for which we compute the contrasts.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'normalized'
      description: 'If we should normalize the contrasts by their standard deviations.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default:
      options:
  title:
  aliases: 'fnPIC'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPhylogeneticIndependentContrastsMultiSample'
  return_type: 'Real[]'
  usage: 'fnPhylogeneticIndependentContrastsMultiSample(TimeTree<any> tree, ContinuousCharacterData<any> data, Natural<any> site, Taxon[]<any> taxa, Bool<any> normalized)'
  arguments:
    - label: 'tree'
      description: 'The tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'data'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'ContinuousCharacterData'
      default:
      options:
    - label: 'site'
      description: 'The site for which we compute the contrasts.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'taxa'
      description: 'The vector of taxa which have species and individual names.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Taxon[]'
      default:
      options:
    - label: 'normalized'
      description: 'If we should normalize the contrasts by their standard deviations.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default:
      options:
  title:
  aliases: 'fnPIC'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPoMo'
  return_type: 'RateMatrix'
  usage: 'fnPoMo(RateGenerator<any> mutationRates, Real[]<any> fitness, Natural<any> virtualNe)'
  arguments:
    - label: 'mutationRates'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator'
      default:
      options:
    - label: 'fitness'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'virtualNe'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPoMo2N'
  return_type: 'RateMatrix'
  usage: 'fnPoMo2N(Natural<any> N, RealPos[]<any> mu, RealPos[]<any> phi)'
  arguments:
    - label: 'N'
      description: 'Number of individuals'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'mu'
      description: 'Vector of mutation rates: mu=(mu_a0a1,mu_a1a0)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_0,phi_1)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPoMo4N'
  return_type: 'RateMatrix'
  usage: 'fnPoMo4N(Natural<any> N, RealPos[]<any> mu, RealPos[]<any> phi)'
  arguments:
    - label: 'N'
      description: 'Number of individuals'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'mu'
      description: 'Vector of mutation rates: mu=(mu_a0a1,mu_a1a0,mu_a0a2,mu_a2a0...)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_0,phi_1,phi_2,phi_3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPoMoKN'
  return_type: 'RateMatrix'
  usage: 'fnPoMoKN(Natural<any> K, Natural<any> N, RealPos[]<any> mu, RealPos[]<any> phi)'
  arguments:
    - label: 'K'
      description: 'Number of alleles'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'N'
      description: 'Number of individuals'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'mu'
      description: 'Vector of mutation rates: mu=(mu_a0a1,mu_a1a0,mu_a0a2,mu_a2a0,...)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_0,phi_1,...,phi_ak)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnPruneTree'
  return_type: 'Tree'
  usage: 'fnPruneTree(Tree<any> tree, Taxon[]|String[]<any> prune, Bool<any> pruneFossils)'
  arguments:
    - label: 'tree'
      description: 'The tree variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'prune/retain'
      description: 'Taxon set to prune/retain in the tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Taxon[]'
      default:
      options:
    - label: 'pruneFossils'
      description: 'Prune all fossils from tree?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnRangeEvolutionRateModifier'
  return_type: 'CharacterHistoryRateModifier'
  usage: 'fnRangeEvolutionRateModifier(Real<any> gainFactor, Real<any> lossFactor, Real[][]<any> matrix, Natural<any> numChars)'
  arguments:
    - label: 'gainFactor'
      description: 'Multiplicative factor (r'' = r * e^{ n_1 * f }) for characters in context set'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'lossFactor'
      description: 'Multiplicative factor (r'' = r * e^{ n_0 * f }) for characters in context set'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'matrix'
      description: 'Weighted character adjacency matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[][]'
      default: 'NULL'
      options:
    - label: 'numChars'
      description: 'Number of characters'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnRateGeneratorSequence'
  return_type: 'RateGeneratorSequence'
  usage: 'fnRateGeneratorSequence(RateGenerator<any> Q, Natural<any> numChars, CharacterHistoryRateModifier[]<any> rateModifiers)'
  arguments:
    - label: 'Q'
      description: 'The per-character rate generator.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator'
      default:
      options:
    - label: 'numChars'
      description: 'The number of characters.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'rateModifiers'
      description: 'The sequence-wide context-dependent rate modifiers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'CharacterHistoryRateModifier[]'
      default: 'NULL'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMo'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMo(Simplex<any> baseFrequencies, Real[]<any> exchangeRates, Natural<any> virtualNe)'
  arguments:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the 4 DNA states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'exchangeRates'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'virtualNe'
      description: 'The virtual population size'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMo2N'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMo2N(Natural<any> N, Simplex<any> pi, RealPos<any> rho, RealPos[]<any> phi)'
  arguments:
    - label: 'N'
      description: 'Number of individuals'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'pi'
      description: 'Vector of allele frequencies: pi=(pi_a0,pi_a1)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'rho'
      description: 'Vector of exchangeabilities: rho=(rho_a0a1)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_0,phi_1)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMo4N'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMo4N(Natural<any> N, Simplex<any> pi, RealPos[]<any> rho, RealPos[]<any> phi)'
  arguments:
    - label: 'N'
      description: 'Number of individuals'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'pi'
      description: 'Vector of allele frequencies: pi=(pi_a0,pi_a1,pi_a2,pi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'rho'
      description: 'Vector of exchangeabilitie: : rho=(rho_a0a1,rho_a0a2,rho_a0a3,rho_a1a2,rho_a1a3,rho_a2a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_a0,phi_a1,phi_a2,phi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMoBalance4N'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMoBalance4N(Natural<any> N, Simplex<any> pi, RealPos[]<any> rho, Real[]<any> phi, RealPos[]<any> beta, Natural[]<any> B)'
  arguments:
    - label: 'N'
      description: 'Population size'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'pi'
      description: 'Vector of allele frequencies: pi=(pi_a0,pi_a1,pi_a2,pi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'rho'
      description: 'Vector of exchangeabilities: rho=(rho_a0a1,rho_a0a2,rho_a0a3,rho_a1a2,rho_a1a3,rho_a2a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_a0,phi_a1,phi_a2,phi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'beta'
      description: 'Vector of balancing selection coefficients: beta=(beta_a0a1,beta_a0a2,beta_a0a3,beta_a1a2,beta_a1a3,beta_a2a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'B'
      description: 'Vector of preferred frequencies: B=(B_a0a1,B_a0a2,B_a0a3,B_a1a2,B_a1a3,B_a2a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMoKN'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMoKN(Natural<any> K, Natural<any> N, Simplex<any> pi, RealPos[]<any> rho, RealPos[]<any> phi)'
  arguments:
    - label: 'K'
      description: 'Number of alleles'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'N'
      description: 'Number of individuals'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'pi'
      description: 'Vector of allele frequencies_ pi=(pi_a0,pi_a1,...,pi_ak)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'rho'
      description: 'Vector of exchangeabilities: rho=(rho_a0a1,rho_a0a2,...,rho_a0ak,rho_a1a2,...)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_0,phi_1,...,phi_ak)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMoNeutralM4N'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMoNeutralM4N(Natural<any> N, Natural<any> M, Simplex<any> pi, RealPos[]<any> rho)'
  arguments:
    - label: 'N'
      description: 'Population size'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'M'
      description: 'Virtual population size'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'pi'
      description: 'Vector of allele frequencies: pi=(pi_a0,pi_a1,pi_a2,pi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'rho'
      description: 'Vector of exchangeabilities: rho=(rho_a0a1,rho_a0a2,rho_a0a3,rho_a1a2,rho_a1a3,rho_a2a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMoThree4'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMoThree4(Simplex<any> pi, RealPos[]<any> rho, RealPos[]<any> phi)'
  arguments:
    - label: 'pi'
      description: 'Vector of allele frequencies: pi=(pi_a0,pi_a1,pi_a2,pi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'rho'
      description: 'Vector of exchangeabilities: rho=(rho_a0a1,rho_a0a2,rho_a0a3,rho_a1a2,rho_a1a3,rho_a2a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_a0,phi_a1,phi_a2,phi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMoThree4N'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMoThree4N(Natural<any> N, Simplex<any> pi, RealPos[]<any> rho, RealPos[]<any> phi)'
  arguments:
    - label: 'N'
      description: 'Population size'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'pi'
      description: 'Vector of allele frequencies: pi=(pi_a0,pi_a1,pi_a2,pi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'rho'
      description: 'Vector of exchangeabilities: rho=(rho_a0a1,rho_a0a2,rho_a0a3,rho_a1a2,rho_a1a3,rho_a2a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'phi'
      description: 'Vector of fitness coefficients: phi=(phi_a0,phi_a1,phi_a2,phi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnReversiblePoMoTwo4N'
  return_type: 'RateMatrix'
  usage: 'fnReversiblePoMoTwo4N(Natural<any> N, Simplex<any> pi, RealPos[]<any> rho)'
  arguments:
    - label: 'N'
      description: 'Population size'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'pi'
      description: 'Vector of allele frequencies: pi=(pi_a0,pi_a1,pi_a2,pi_a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'rho'
      description: 'Vector of exchangeabilities: rho=(rho_a0a1,rho_a0a2,rho_a0a3,rho_a1a2,rho_a1a3,rho_a2a3)'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnRtRev'
  return_type: 'RateGenerator'
  usage: 'fnRtRev()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnSampledCladogenesisRootFrequencies'
  return_type: 'Simplex'
  usage: 'fnSampledCladogenesisRootFrequencies(RateGenerator<any> Q, MatrixReal<deterministic> cladogeneticProbabilities, TimeTree<stochastic> tree, RealPos<any> clock)'
  arguments:
    - label: 'Q'
      description: 'The anagenetic event rate matrix'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator'
      default:
      options:
    - label: 'cladogeneticProbabilities'
      description: 'The cladogenetic event probabilities'
      dag_type: '<deterministic>'
      pass_by: 'const reference'
      value_type: 'MatrixReal'
      default:
      options:
    - label: 'tree'
      description: 'The time-tree variable containtain the sampled speciation events'
      dag_type: '<stochastic>'
      pass_by: 'reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'clock'
      description: 'The anagenetic clock rate'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '1'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnScale'
  return_type: 'SiteMixtureModel'
  usage: 'fnScale(SiteMixtureModel<any> model, RealPos<any> rate)'
  arguments:
    - label: 'model'
      description: 'The mixture model to scale.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'SiteMixtureModel'
      default:
      options:
    - label: 'rate'
      description: 'The factor by which to scale the speed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'fnScale'
  aliases:
  description: 'Scale a vector of SiteMixtureModels'
  details: |
    This function has two forms.  The first form takes a SiteMixtureModel `model` and scales it by
    a rate `rate`.  This form returns SiteMixtureModel.
    
    The second form takes SiteMixtureModel[] `models` and RealPos[] `rates`, and scales `models[i]`
    by `rates[i]`.  This form returns SiteMixtureModel[].
    
    As a shortcut, if the second argument `rates` is a vector but the first element `model` is not,
    then the first argument will be automatically replaced with a vector of SiteMixtureModels of the
    same length as `rates`, where each element is identical to `model`.
  example: |
    Q = fnJC(4)                    # The rate of Q is 1
    
    # Operating on SiteMixtureModel
    Q2 = fnScale(Q,2)              # The rate of Q2 is 2
    
    # Operating on SiteMixtureModel[]
    Qs = fnScale([Q,Q],[1,2])      # Qs[1] and Qs[2] have rates 1 and 2
    Qs = fnScale(Q,    [1,2])      # An abbreviation for the above.
    
    # We can build up models iteratively using pipes
    Qs = Q |> fnScale([1,2])       # A shorter abbreviation.
    
    # A JC+LogNormal[4] ASRV model
    site_rates := dnLognormal(0,lsigma) |> fnDiscretizeDistribution(4)
    MM := fnJC(4) |> fnScale(site_rates) |> fnMixtureASRV()
    M := fnScale(MM, 1/MM.rate())
    
    # A FreeRates[5] ASRV model
    rates ~ dnDirichlet( [1,1,1,1,1] )
    weights ~ dnDirichlet( [2,2,2,2,2] )
    MM := fnJC(4) |> fnScale(rates) |> fnMixtureASRV(weights)
    M := fnScale(MM, 1/MM.rate())
  authors:
  see_also:
    - 'fnUnitMixture'
    - 'fnInvASRV'
    - 'fnMixtureASRV'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnSegregatingSites'
  return_type: 'Natural'
  usage: 'fnSegregatingSites(AbstractHomologousDiscreteCharacterData<any> data, Bool<any> excludeAmbiguous)'
  arguments:
    - label: 'data'
      description: 'The alignment for which to compute the number of segregating sites.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'excludeAmbiguous'
      description: 'Should we exclude ambiguous or missing characters?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<Natural>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnShiftEvents'
  return_type: 'OrderedEvents<RealPos>'
  usage: 'fnShiftEvents(RealPos<any> initialValue, OrderedEvents<RealPos><any> shiftEvents)'
  arguments:
    - label: 'initialValue'
      description: 'The intitial values.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'shiftEvents'
      description: 'The  shift events.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'OrderedEvents<RealPos>'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnShortestDistance'
  return_type: 'RealPos[][]'
  usage: 'fnShortestDistance(Natural[][]<any> adjacencies, RealPos[][]<any> distances)'
  arguments:
    - label: 'adjacencies'
      description: 'The adjaceny matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural[][]'
      default:
      options:
    - label: 'distances'
      description: 'The distance matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default: 'NULL'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnSiteRateModifier'
  return_type: 'CharacterHistoryRateModifier'
  usage: 'fnSiteRateModifier(RealPos[][]<any> rateMultipliers, Natural[][]<any> eventClasses, Natural[]<any> siteClasses)'
  arguments:
    - label: 'rateMultipliers'
      description: 'Multiplies character i by rate-multiplier r_i.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'eventClasses'
      description: 'Assigns event classes to rate matrix events.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural[][]'
      default:
      options:
    - label: 'siteClasses'
      description: 'Assigns classes to the sites.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnSmoothTimeLine'
  return_type: 'RealPos[]'
  usage: 'fnSmoothTimeLine(Real<any> maxTime, RealPos[]<any> times, RealPos[]<any> values)'
  arguments:
    - label: 'maxTime'
      description: 'The maximum time after which we smoothen the timelime out.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'times'
      description: 'The times at which the values change.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'values'
      description: 'The values for each time bin.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title: 'Create a smooth timeline'
  aliases:
  description: 'Function to create a smooth timeline where all values after a maximum time are constant, i.e., equal to the previous interval, to avoid crazy looking plots from the prior.'
  details: 'Thus function takes a vector of values and a matching vector of times and a maximum time. Then, it constructs a smooth timeline by using all values before the maximum, and replacing all values after the maximum with the last value before the maximum. Thus, the timeline is smooth after the maximum.'
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnStateCountRateModifier'
  return_type: 'CharacterHistoryRateModifier'
  usage: 'fnStateCountRateModifier(Real[]<any> stateFactors, Natural<any> numChars)'
  arguments:
    - label: 'stateFactors'
      description: 'Power penalty (bonus) for n-1 states'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'numChars'
      description: 'Number of characters'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnStirling'
  return_type: 'Real'
  usage: 'fnStirling(String<any> kind {valid options: "first"|"lnFirst"|"second"}, Natural<any> n, Natural<any> k)'
  arguments:
    - label: 'kind'
      description: 'The type of the stirling number to compute.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'first'
      options:
        - 'first'
        - 'lnFirst'
        - 'second'
    - label: 'n'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
    - label: 'k'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnStitchTree'
  return_type: 'Tree'
  usage: 'fnStitchTree(Tree<any> backboneTree, TimeTree[]<any> patchClades, Taxon[][]<any> patchTaxa)'
  arguments:
    - label: 'backboneTree'
      description: 'The backbone tree variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'patchClades'
      description: 'The patch clade variables.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree[]'
      default:
      options:
    - label: 'patchTaxa'
      description: 'The taxa per patch clade to be stitched on to the backbone tree. Shares order with patchClades.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Taxon[][]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnT92'
  return_type: 'RateMatrix'
  usage: 'fnT92(RealPos<any> kappa, Probability<any> gc)'
  arguments:
    - label: 'kappa'
      description: 'The transition-tranversion rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'gc'
      description: 'The frequency of GC.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
  title: 'The Tamura (1992) nucleotide rate matrix'
  aliases:
  description: 'DNA evolution model proposed in Tamura (1992).'
  details: |
    In this model, A and T have an equal stationary frequency, with G and C frequencies distinct, and transition and transversion rates are allowed to be different. Its first parameter, kappa, codes for the ratio between the rate of transitions and transversions. Its second parameter, gc, codes for the compound frequency of G and C nucleotides.
    
    The T92 rate matrix elements will be of the form:
        Q[i, j] = c * kappa * gc / 2, if i<->j is a transition and j is C or G
                = c * gc / 2, if i<->j is a transversion and j is C or G
                = c * kappa * (1 - gc) / 2, if i<->j is a transition and j is A or T
                = c * (1 - gc) / 2, if i<->j is a transversion and j is A or T
    
    where c is a constant needed to normalize the average rate to 1.
  example: |
    # the ratio between rates of transitions and transversions
    kappa ~ dnExp(0.5)
    
    # the frequency of G and C nucleotides
    gc ~ dnUnif(0, 1)
    
    # create a T92 rate matrix
    Q := fnT92(kappa, gc)
  authors:
  see_also:
    - 'fnJC'
    - 'fnF81'
    - 'fnK80'
    - 'fnK81'
    - 'fnHKY'
    - 'fnTrN'
    - 'fnGTR'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Tamura K (1992). "Estimation of the number of nucleotide substitutions when there are strong transition-transversion and G+C-content biases". Molecular Biology and Evolution. 9:678--87.'
      doi: 'https://doi.org/10.1093/oxfordjournals.molbev.a040752'
      url: 'https://academic.oup.com/mbe/article/9/4/678/1254082'
- name: 'fnTIM'
  return_type: 'RateMatrix'
  usage: 'fnTIM(Simplex<any> exchangeRates, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'exchangeRates'
      description: 'The exchangeability rates between states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnTVM'
  return_type: 'RateMatrix'
  usage: 'fnTVM(Simplex<any> exchangeRates, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'exchangeRates'
      description: 'The exchangeability rates between states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnTajimasD'
  return_type: 'Real'
  usage: 'fnTajimasD(AbstractHomologousDiscreteCharacterData<any> data, Bool<any> excludeAmbiguous)'
  arguments:
    - label: 'data'
      description: 'The character data matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'excludeAmbiguous'
      description: 'Should we exclude ambiguous or amissing characters?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<Real>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnTajimasPi'
  return_type: 'RealPos'
  usage: 'fnTajimasPi(AbstractHomologousDiscreteCharacterData<any> data, Bool<any> perSite, Bool<any> excludeAmbiguous)'
  arguments:
    - label: 'data'
      description: 'The character data matrix for which to compute the summary.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'perSite'
      description: 'Is the statistic normalized per site?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'excludeAmbiguous'
      description: 'Should we exclude ambiguous or missing characters?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<RealPos>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnTrN'
  return_type: 'RateMatrix'
  usage: 'fnTrN(RealPos<any> kappa1, RealPos<any> kappa2, Simplex<any> baseFrequencies)'
  arguments:
    - label: 'kappa1'
      description: 'The first transition rate (A<->G).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'kappa2'
      description: 'The second transition rate (C<->T).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'baseFrequencies'
      description: 'The stationary frequencies of the states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: '[ 0.250, 0.250, 0.250, 0.250 ]'
      options:
  title: 'The Tamura-Nei (1993) nucleotide rate matrix'
  aliases: 'fnTamuraNei'
  description: 'DNA evolution model proposed in Tamura & Nei (1993).'
  details: |
    In this model, nucleotide base frequencies are different, and the two transition rates (A <-> G and C<->T) can be different to each other, and to the transversion rate. The first argument, kappa1, defines the ratio between the rate of A <-> G (i.e. purine) transitions to transversions. The second argument, kappa2, defines the ratio between the rate of C <-> T (i.e. pyrimidine) transitions to transversions. The third argument, baseFrequencies, defines the stationary frequencies of nucleotide bases. 
    
    The TrN rate matrix elements are of the form:
        Q[i, j] = c * kappa1 * baseFrequencies[j], if i<->j is A<->G
                = c * kappa2 * baseFrequencies[j], if i<->j is C<->T
                = c * baseFrequencies[j], otherwise
    
    where c is a constant needed to normalize the average rate to 1
  example: |
    # A <-> G transition rate
    kappaAG ~ dnLognormal(0,1)
    
    # C <-> T transition rate
    kappaCT ~ dnLognormal(0,1)
    
    # nucleotide base frequencies
    pi ~ dnDirichlet( v(1,1,1,1) )
    
    # create a TrN rate matrix
    Q := fnTrN(kappaAG, kappaCT, ,pi)
  authors:
  see_also:
    - 'fnJC'
    - 'fnK80'
    - 'fnK81'
    - 'fnT92'
    - 'fnHKY'
    - 'fnGTR'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Tamura, K. and M. Nei (1993). "Estimation of the number of nucleotide substitutions in the control region of mitochondrial DNA in humans and chimpanzees". Molecular biology and evolution. 10(3):512-526.'
      doi: 'https://doi.org/10.1093/oxfordjournals.molbev.a040023'
      url: 'https://academic.oup.com/mbe/article/10/3/512/1016366'
- name: 'fnTreeAssembly'
  return_type: 'Tree'
  usage: 'fnTreeAssembly(Tree<any> topology, RealPos[]<any> brlens)'
  arguments:
    - label: 'topology'
      description: 'The tree topology variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'brlens'
      description: 'The vector of branch lengths.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
  title:
  aliases: 'treeAssembly'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnTreePairwiseDistances'
  return_type: 'DistanceMatrix'
  usage: 'fnTreePairwiseDistances(Tree<any> tree)'
  arguments:
    - label: 'tree'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<Tree>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnTreePairwiseNodalDistances'
  return_type: 'DistanceMatrix'
  usage: 'fnTreePairwiseNodalDistances(Tree<any> tree)'
  arguments:
    - label: 'tree'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<Tree>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnTreeScale'
  return_type: 'TimeTree'
  usage: 'fnTreeScale(RealPos<any> scale, TimeTree<any> tree, RealPos|RealPos[]<any> tipAges)'
  arguments:
    - label: 'scale'
      description: 'The multiplicator by which to scale the tree,'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'tree'
      description: 'The tree which will be re-scaled.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'tipAges'
      description: 'A vector of ages for the tips.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnUnitMixture'
  return_type: 'SiteMixtureModel'
  usage: 'fnUnitMixture(RateGenerator<any> model, Simplex<any> rootFrequencies, RealPos<any> rate)'
  arguments:
    - label: 'model'
      description: 'The mixture models to mix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator'
      default:
      options:
    - label: 'rootFrequencies'
      description: 'State frequencies at the root.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: 'NULL'
      options:
    - label: 'rate'
      description: 'Scale by model by this rate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '1'
      options:
  title: 'fnUnitMixture'
  aliases:
  description: 'Create a SiteMixtureModel from a RateMatrix or RateGenerator'
  details: |
    This function creates a SiteMixtureModel with one component by specifying the
    rate and root frequencies for a RateGenerator.  The rate defaults to 1, leaving
    the underlying model unchanged.
    
    If the site model parameter is a RateMatrix, the root frequencies default to the
    equilibrium frequencies of the RateMatrix.  However, a RateGenerator might not have
    equilibrium frequencies, in which case the root frequencies must be specified explicitly.
    
    In many cases it is not necessary to explicitly call fnUnitMixture(), RevBayes can
    automatically convert a RateMatrix to a SiteMixtureModel.
  example: |
    M := fnUnitMixture( fnJC(4) )
    M := fnJC(4) |> fnUnitMixture()  # nested functions can be expressed using pipes.
    
    # Explicit conversion to SiteMixtureModel
    M := fnGTR(er,pi) |> fnUnitMixture() |> fnGammaASRV(alpha) |> fnInvASRV(p_inv)
    # Implicit conversion to SiteMixtureModel
    M := fnGTR(er,pi) |> fnGammaASRV(alpha) |> fnInvASRV(p_inv)
    
    # Specifying the root frequencies
    M := fnDECRateMatrix(dr,er,"Include") |> fnUnitMixture(rootFrequencies=simplex(rep(1,n_states)))
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnUpperTriangle'
  return_type: 'RealPos[]'
  usage: 'fnUpperTriangle(MatrixReal<any> matrix)'
  arguments:
    - label: 'matrix'
      description: 'A matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'MatrixReal'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnVT'
  return_type: 'RateGenerator'
  usage: 'fnVT()'
  arguments:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnVarCovar'
  return_type: 'MatrixRealSymmetric'
  usage: 'fnVarCovar(RealPos[]<any> standardDeviations, Real[]<any> correlationCoefficients)'
  arguments:
    - label: 'standardDeviations'
      description: 'The vector of standard deviations.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'correlationCoefficients'
      description: 'The correlation coefficients.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnWAG'
  return_type: 'RateMatrix'
  usage: 'fnWAG(Simplex<any> aaFrequencies)'
  arguments:
    - label: 'aaFrequencies'
      description: 'The stationary frequencies of the states.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: '[ 0.087, 0.044, 0.039, 0.057, 0.019, 0.037, 0.058, 0.083, 0.024, 0.048, 0.086, 0.062, 0.020, 0.038, 0.046, 0.070, 0.061, 0.014, 0.035, 0.071 ]'
      options:
  title: 'WAG (Whelan and Goldman) Amino Acid Substitution Rate Matrix'
  aliases:
  description: 'Generates a rate matrix based on the Whelan and Goldman (WAG) substitution model for amino acid evolution.'
  details: 'The WAG model is an empirical model of amino acid replacement derived using an approximate maximum-likelihood method from 3,905 sequences across 182 protein families. It outperforms previous models like Dayhoff and JTT in terms of accuracy and likelihood for phylogenetic analysis, aiming to provide better evolutionary tree estimates and applications in sequence alignment, database searches, and protein structure prediction.'
  example: |
    # WAG model with estimated frequencies
    pi ~ dnDirichlet( rep(1,20) )
    Q := fnWAG(pi)
    
    # WAG model with fixed frequencies
    Q2 <- fnWAG()
  authors:
  see_also:
    - 'fnDayhoff'
    - 'fnJones'
    - 'fnLG'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Whelan S, Goldman N (2001). A general empirical model of protein evolution derived from multiple protein families using a maximum-likelihood approach. Molecular Biology and Evolution, 18(5):691-699.'
      doi: '10.1093/oxfordjournals.molbev.a003851'
      url: 'https://academic.oup.com/mbe/article/18/5/691/1018653'
- name: 'fnWattersonsTheta'
  return_type: 'RealPos'
  usage: 'fnWattersonsTheta(AbstractHomologousDiscreteCharacterData<any> data, Bool<any> perSite, Bool<any> excludeAmbiguous)'
  arguments:
    - label: 'data'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'perSite'
      description: 'Should we normalize per site?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'excludeAmbiguous'
      description: 'Should we exclude ambiguous or missing characters?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function<RealPos>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnX2'
  return_type: 'RateMatrix'
  usage: 'fnX2(RateMatrix<any> submodel)'
  arguments:
    - label: 'submodel'
      description: 'Nucleotide rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
  title: 'Construct a doublet (16x16) rate matrix from a nucleotide rate matrix.'
  aliases:
  description: |
    Constructs a double rate matrix on the 16 nucleotide pairs.
    
    Rates of change from nucleotide i -> j at each doublet position are given by the
    nucleotide rate matrix.  The rate of 2 simultaneous changes is 0.
    
    The X3 function can be used to constructor rate matrices on doublets in a
    modular fashion.
  details:
  example: |
    
    kappa ~ dnLognormal(0,1)
    nuc_pi ~ dnDirichlet( rep(2.0, 4) )
    # Mutation rate matrix on RNA stems
    Q1 := fnX2( fnHKY(kappa, nuc_pi) )
    F ~ dnIID(16, dnNormal(0,1))
    # Add selection to the rate matrix
    Q2 := fnMutSel(Q1, F)
  authors:
  see_also: 'fnX3'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fnX3'
  return_type: 'RateMatrix'
  usage: 'fnX3(RateMatrix<any> submodel)'
  arguments:
    - label: 'submodel'
      description: 'Nucleotide rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
  title: 'Construct a codon rate matrix from a nucleotide rate matrix.'
  aliases:
  description: |
    Constructs a rate matrix on the 61 non-stop codons (in the standard genetic code).
    
    Rates of change from nucleotide i -> j at each codon position are given by the
    nucleotide rate matrix.  The rate of 2 or 3 simultaneous changes is 0.
    
    The X3 function can be used to construct other rate matrices in a modular fashion.
    For example:
      (i)  MG94  = F81 + X3 + dNdS
      (ii) MG94K = HKY85 + X3 + dNdS
  details:
  example: |
    
    kappa ~ dnLognormal(0,1)
    omega ~ dnUniform(0,1)
    nuc_pi ~ dnDirichlet( rep(2.0, 4) )
    Q1 := fnCodonMG94K( kappa, omega, nuc_pi )
    # This is the same.
    Q2 := fndNdS(fnX3(fnHKY(kappa, nuc_pi)), omega)          # HKY + X3 + dNdS, or HKY*3 + dNdS
    
    er ~ dnDirichlet( v(1,1,1,1,1,1) )
    Q3 := fnX3(fnGTR(er, nuc_pi))      # GTR + X3, or GTR*3
  authors:
  see_also: 'fnCodonGY94, fnCodonMG94K, fndNdS'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Redelings, BD (2021). BAli-Phy version 3: Model-based co-estimation of Alignment and Phylogeny. Bioinformatics (2021) 37(10):3032--3034.'
      doi: 'https://doi.org/10.1093/bioinformatics/btab129'
      url:
- name: 'fnassembleContinuousMRF'
  return_type: 'RealPos[]'
  usage: 'fnassembleContinuousMRF(Real<any> initialValue, Real[]<any> increments, Real<any> beta, Real[]<any> predictors, Bool<any> initialValueIsLogScale, Natural<any> order)'
  arguments:
    - label: 'initialValue'
      description: 'The first value in the MRF.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'increments'
      description: 'The increments of the process, assumed to be on the log-scale.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'beta'
      description: 'The correlation coefficient for the predictor variables.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default: '0'
      options:
    - label: 'predictors'
      description: 'The predictor variables, assumed to be.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default: 'NULL'
      options:
    - label: 'initialValueIsLogScale'
      description: 'Is valueInitial on the log-scale, like the increments?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default:
      options:
    - label: 'order'
      description: 'The order of the MRF (1 or 2).'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'fndNdS'
  return_type: 'RateMatrix'
  usage: 'fndNdS(RateMatrix<any> submodel, RealPos<any> omega)'
  arguments:
    - label: 'submodel'
      description: 'Singlet (i.e. nucleotide) rate matrix.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateMatrix'
      default:
      options:
    - label: 'omega'
      description: 'The dN / dS rate ratio.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'Add a dN/dS factor to a codon rate matrix.'
  aliases:
  description: |
    Constructs a rate matrix on the 61 non-stop codons (in the standard genetic code).
    
       Q(i,j) = Q'(i,j) * omega if aa(i) != aa(j)
                        * 1     if aa(i) == aa(j)
    
    where aa(i) gives the amino acid for codon i in the standard genetic code, and
    Q'(i,j) is the input rate matrix on codons.
    
    The dNdS function can be used to construct other rate matrices in a modular fashion.
    For example:
      (i)  MG94  = F81 + X3 + dNdS
      (ii) MG94K = HKY85 + X3 + dNdS
  details:
  example: |
    
    kappa ~ dnLognormal(0,1)
    omega ~ dnUniform(0,1)
    nuc_pi ~ dnDirichlet( rep(2.0, 4) )
    Q1 := fnCodonMG94K( kappa, omega, nuc_pi )
    # This is the same.
    Q2 := fndNdS(fnX3(fnHKY(kappa, nuc_pi)), omega)        # HKY + X3 + dNdS,
                                                           #   or HKY*3 + dNdS
    
    er ~ dnDirichlet( v(1,1,1,1,1,1) )
    Q3 := fndNdS(fnX3(fnGTR(er, nuc_pi)), omega)         # GTR + X3 + dNdS
  authors:
  see_also: 'fnCodonGY94, fnCodonMG94K, fnX3, fnMutSel'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Redelings, BD (2021). BAli-Phy version 3: Model-based co-estimation of Alignment and Phylogeny. Bioinformatics (2021) 37(10):3032--3034.'
      doi: 'https://doi.org/10.1093/bioinformatics/btab129'
      url:
- name: 'formatDiscreteCharacterData'
  return_type: 'NULL'
  usage: 'formatDiscreteCharacterData(AbstractHomologousDiscreteCharacterData<any> data, String<any> format {valid options: "DEC"|"GeoSSE"}, Natural<any> numStates)'
  arguments:
    - label: 'data'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'format'
      description: 'The data format.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'DEC'
      options:
        - 'DEC'
        - 'GeoSSE'
    - label: 'numStates'
      description: 'The number of states (format=="DEC" or "GeoSSE" only).'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '0'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'gamma'
  return_type: 'RealPos'
  usage: 'gamma(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'geometricMean'
  return_type: 'Real'
  usage: 'geometricMean(Real[]<any> x)'
  arguments:
    - label: 'x'
      description: 'A vector of numbers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'getOption'
  return_type: 'void'
  usage: 'getOption(String<any> key)'
  arguments:
    - label: 'key'
      description: 'The key-identifier for the option.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title: 'Get a global RevBayes option'
  aliases:
  description: 'Get a global option for RevBayes.'
  details: 'Runtime options are used to personalize RevBayes and are stored on the local machine. See `setOption` for the list of available keys and their associated values.'
  example: |
    # compute the absolute value of a real number
    getOption("linewidth")
    
    # let us set the linewidth to a new value
    setOption("linewidth", 200)
    
    # now let's check what the value is
    getOption("linewidth")
  authors:
  see_also: 'setOption'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'getwd'
  return_type: 'String'
  usage: 'getwd()'
  arguments:
  title: 'Get and print the working directory'
  aliases:
  description: 'Get the current working directory which RevBayes uses.'
  details:
  example: |
    # get the current working directory
    getwd()
    
    # let us set a new working directory
    setwd("~/Desktop")
    
    # check the working directory again
    getwd()
  authors:
  see_also: 'setwd'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'help'
  return_type: 'void'
  usage: 'help(String<any> topic)'
  arguments:
    - label: 'topic'
      description: 'Retrieve help for a specific topic.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'String'
      default:
      options:
  title: 'Get help with RevBayes'
  aliases:
  description: 'Provides general or specific help.'
  details:
  example: |
    # get general help
    help()
    # get specific help
    help("dnNormal")
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'ifelse'
  return_type: 'Natural'
  usage: 'ifelse(Bool<any> condition, Natural<any> a, Natural<any> b)'
  arguments:
    - label: 'condition'
      description: 'A variable representing the condition of the if-else statement.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default:
      options:
    - label: 'a'
      description: 'The value if the statement is true.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'b'
      description: 'The value if the statement is false.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title: 'If-else statement as a function'
  aliases:
  description: 'If the expression is true, then the function returns the first value, otherwise the second value.'
  details: 'The ifelse function is important when the value of a variable should deterministically change during an analysis depending on other variables. Standard if-else statements are not dynamically re-evaluated.'
  example: |
    a <- 1
    b := ifelse( a == 1, 10, -10 )
    b
    
    a <- 2
    b
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'int'
  return_type: 'Integer'
  usage: 'int(String<any> x)'
  arguments:
    - label: 'x'
      description: 'The string value to convert.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Procedure'
    - 'Function'
    - 'RevObject'
  references:
- name: 'license'
  return_type: 'void'
  usage: 'license()'
  arguments:
  title: 'Copyright license of RevBayes'
  aliases:
  description: 'Print the copyright license of RevBayes.'
  details:
  example: 'license()'
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'listFiles'
  return_type: 'String[]'
  usage: 'listFiles(String<any> path, Bool<any> allFiles, Bool<any> recursive, Bool<any> includeDirs)'
  arguments:
    - label: 'path'
      description: 'The path in which to list files.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: '.'
      options:
    - label: 'allFiles'
      description: 'Should special files be returned.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'recursive'
      description: 'Should we search directories recursively.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'includeDirs'
      description: 'Should we re return directory names in recursive search.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'listOptions'
  return_type: 'void'
  usage: 'listOptions()'
  arguments:
  title: 'List global RevBayes options'
  aliases:
  description: 'List all global options for RevBayes.'
  details: 'Options are used to personalize RevBayes and are stored on the local machine. Currently this is rather experimental.'
  example:
  authors:
  see_also:
    - 'setOption'
    - 'getOption'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'ln'
  return_type: 'Real'
  usage: 'ln(RealPos<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'Natural log function'
  aliases:
  description: 'Returns the natural log of a (positive) value.'
  details:
  example: |
    # create a stochastic node with an exponential distribution
    x ~ dnExponential(1)
    
    # create a determinstic node that takes the natural log of x
    y := ln(x)
    
    # print the values for x and y
    x # x has the stochastic value of 2.940149
    y # y has the determined value of 1.07846
  authors:
  see_also: 'log'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'loadPlugin'
  return_type: 'void'
  usage: 'loadPlugin(String<any> name, String<any> path)'
  arguments:
    - label: 'name'
      description: 'Name of the plugin (e.g., TensorPhylo).'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'path'
      description: 'Relative or absolute path of the plugin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'log'
  return_type: 'Real'
  usage: 'log(RealPos<any> x, RealPos<any> base)'
  arguments:
    - label: 'x'
      description: 'A positive number.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'base'
      description: 'The base of the logarithm.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'logistic'
  return_type: 'Probability'
  usage: 'logistic(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title: 'The logistic function'
  aliases: 'invlogit'
  description: 'Compute the logistic function'
  details: |
    The function is defined as
    
            logistic(x) = 1/(1 + exp(-x))
    
                        = exp(x)/(1 + exp(x))
    
    This function takes a real number to a probability.
    It is the inverse of the logit function.
  example: |
    x ~ dnNormal(0,1)
    p := logistic(x)
  authors:
  see_also: 'logit'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'logit'
  return_type: 'Real'
  usage: 'logit(Probability<any> x)'
  arguments:
    - label: 'x'
      description: 'A positive number.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'ls'
  return_type: 'void'
  usage: 'ls(Bool<any> all, String<any> filter {valid options: "all"|"utility"|"math"|"distribution"|"function"|"datatype"|"move"|"monitor"|"analysis"|"file"|"summary"|"uncategorized"})'
  arguments:
    - label: 'all'
      description: 'Should we print all variables and functions including provided ones by RevBayes?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'filter'
      description: 'List objects for the provided type.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'all'
      options:
        - 'all'
        - 'utility'
        - 'math'
        - 'distribution'
        - 'function'
        - 'datatype'
        - 'move'
        - 'monitor'
        - 'analysis'
        - 'file'
        - 'summary'
        - 'uncategorized'
  title: 'List workspace content'
  aliases:
  description: 'Show the content of the workspace.'
  details: 'The list functions shows all the variables in the current workspace. You can also see all the functions available if you use ls(all=TRUE)'
  example: |
    # now we have an empty workspace
    ls()
    # next wee add a variable
    a <- 1
    # and we can see it
    ls()
  authors:
  see_also:
    - 'clear'
    - 'exists'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'mapTree'
  return_type: 'Tree'
  usage: 'mapTree(TraceTree|TraceTree[]<any> trace, String<any> file, Bool<any> ccAges, Bool<any> ccp, Bool<any> conditionalAges, Probability<any> hpd, Bool<any> mean, Bool<any> sampledAncestors, Bool<any> positiveBranchLengths)'
  arguments:
    - label: 'trace'
      description: 'The samples of trees from the posterior.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'TraceTree'
      default:
      options:
    - label: 'file'
      description: 'The name of the file where to store the tree.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'ccAges'
      description: 'Annotate conditional clade ages?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'ccp'
      description: 'Annotate conditional clade probabilities?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'conditionalAges'
      description: 'Annotate node ages conditional on the topology?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'hpd'
      description: 'The probability mass of the highest posterior density node age interval.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.95'
      options:
    - label: 'mean'
      description: 'Annotate node ages using the mean age instead of the median?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'sampledAncestors'
      description: 'Annotate sampled ancestor probs?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'positiveBranchLengths'
      description: 'Force negative branch lengths to be short but positive?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description: 'Finds the maximum a posteriori (MAP) topology from a trace of trees and summarizes branch lengths.'
  details:
  example: |
    # Read in tree trace
    tree_trace = readTreeTrace("output/my.trees", burnin=0.25)
    
    # Generate the MAP tree
    map_tree = mapTree(trace=tree_trace, file="map.tree")
  authors:
  see_also:
    - 'consensusTree'
    - 'mccTree'
    - 'treeTrace'
    - 'readTreeTrace'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'matrix'
  return_type: 'MatrixReal'
  usage: 'matrix(Real[][]<any> x)'
  arguments:
    - label: 'x'
      description: 'x'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[][]'
      default:
      options:
  title: 'Matrix'
  aliases:
  description: 'Create matrix object.'
  details: 'This function creates a matrix object from a vector of vectors.'
  example: |
    # create set of real numbers to convert to matrix
    x <- [[1, 1], [1, 1]]
    # convert x to matrix object
    y <- matrix(x)
  authors:
  see_also: 'MatrixReal'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'max'
  return_type: 'Real'
  usage: 'max(Real[]|MatrixReal<any> x)'
  arguments:
    - label: 'x'
      description: 'A vector/matrix of numbers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Maximum of a set of numbers'
  aliases:
  description: 'Finds the maximum of a vector of numbers.'
  details:
  example: |
    a = v(1,2,3,4,5)
    max(a)
    # this will print 5
  authors:
  see_also: '`min`'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'maxdiff'
  return_type: 'Tree'
  usage: 'maxdiff(TraceTree[]<any> traces)'
  arguments:
    - label: 'traces'
      description: 'The samples of trees from the posterior.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'TraceTree[]'
      default:
      options:
  title:
  aliases:
  description: 'Finds the maximum difference in clade probabilities between two posterior samples.'
  details:
  example: |
    # Read in tree trace
    tree_trace = readTreeTrace("output/my.trees", burnin=0.25, nruns=2)
    
    # Compute the maxdiff statistic
    maxdiff = maxdiff(traces=tree_trace)
  authors:
  see_also: 'readTreeTrace'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'maximumTree'
  return_type: 'TimeTree'
  usage: 'maximumTree(TimeTree[]<any> geneTrees)'
  arguments:
    - label: 'geneTrees'
      description: 'The vector of trees from which to pick the maximum.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree[]'
      default:
      options:
  title: 'Maximum tree function to build a species tree.'
  aliases:
  description: 'Builds the maximum species tree given several ultrametric gene trees.'
  details: 'The maximum species tree is a consistent estimate of the species tree under the multispecies coalescent model, if the gene trees are correct and the effective population size constant along the species tree.'
  example: |
    # We simulate a species tree and gene trees and reconstruct a species tree using maximum tree:
    # Let's simulate a species tree with 10 taxa, 5 gene trees, 1 alleles per species:
    n_species <- 10
    n_genes <- 5
    n_alleles <- 2
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a constant effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescent(speciesTree=spTree, Ne=popSize, taxa=taxa[g])
    }
    
    # Let's compute the maximum tree:
    recTree <- maximumTree(geneTrees)
    print(recTree)
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Edwards SV, Liu L, Pearl DK (2007). High-resolution species trees without concatenation. Proceedings of the National Academy of Sciences of the USA, 104(14):5936-5941.'
      doi: '10.1073/pnas.0607004104'
      url: 'http://www.pnas.org/content/104/14/5936.full'
    - citation: 'Liu L, Yu L, Pearl DK (2010). Maximum tree: a consistent estimator of the species tree. Journal of Mathematical Biology, 60(1):95-106.'
      doi: '10.1007/s00285-009-0260-0'
      url: 'https://link.springer.com/article/10.1007%2Fs00285-009-0260-0'
- name: 'mccTree'
  return_type: 'Tree'
  usage: 'mccTree(TraceTree|TraceTree[]<any> trace, String<any> file, Bool<any> ccAges, Bool<any> ccp, Bool<any> conditionalAges, Probability<any> hpd, Bool<any> mean, Bool<any> sampledAncestors, Bool<any> positiveBranchLengths)'
  arguments:
    - label: 'trace'
      description: 'The samples of trees from the posterior.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'TraceTree'
      default:
      options:
    - label: 'file'
      description: 'The name of the file where to store the tree.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'ccAges'
      description: 'Annotate conditional clade ages?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'ccp'
      description: 'Annotate conditional clade probabilities?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'conditionalAges'
      description: 'Annotate node ages conditional on the topology?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'hpd'
      description: 'The probability mass of the highest posterior density node age interval.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.95'
      options:
    - label: 'mean'
      description: 'Annotate node ages using the mean age instead of the median?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'sampledAncestors'
      description: 'Annotate sampled ancestor probs?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'positiveBranchLengths'
      description: 'Force negative branch lengths to be short but positive?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description: 'Finds the maximum clade credibility (MCC) topology from a trace of trees and summarizes branch lengths.'
  details:
  example: |
    # Read in tree trace
    tree_trace = readTreeTrace("output/my.trees", burnin=0.25)
    
    # Generate the MCC tree
    map_tree = mccTree(trace=tree_trace, file="mcc.tree")
  authors:
  see_also:
    - 'consensusTree'
    - 'mapTree'
    - 'treeTrace'
    - 'readTreeTrace'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'mean'
  return_type: 'Real'
  usage: 'mean(Real[]<any> x)'
  arguments:
    - label: 'x'
      description: 'A vector of numbers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Mean of a vector of numbers'
  aliases:
  description: 'Finds the arithmetic mean of a vector of numbers.'
  details: 'The numbers of the vector are summed and divided by the vector length.'
  example: |
    g = v(2,3,5,6,7)
    mean(g)
    # 4.6
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'median'
  return_type: 'Real'
  usage: 'median(Real[]<any> x)'
  arguments:
    - label: 'x'
      description: 'A vector of numbers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Median of a set of numbers'
  aliases:
  description: 'Finds the median of a sorted vector of numbers.'
  details: |
    The vector is sorted when `median` is used finding the
    number of the sorted values with an equal amount of numbers that
    are greater than or less than that value. If the length of the vector is even, there will be no such value. In that case, the two are averaged automatically.
  example: |
    a = v(5,3,2,6,8)
    median(a)
    # 5 is the result
    b = v(1,1,2,3,5,8)
    median(b)
    # 2.5 is the result
  authors:
  see_also: '`mean`'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'min'
  return_type: 'Real'
  usage: 'min(Real[]|MatrixReal<any> x)'
  arguments:
    - label: 'x'
      description: 'A vector of values.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Minimum of a set of numbers'
  aliases:
  description: 'Finds the minimum of a vector of numbers.'
  details:
  example: |
    a = v(0,1,1,2,3,5,8,13)
    min(a)
    # will print 0
  authors:
  see_also: '`max`'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'module'
  return_type: 'void'
  usage: 'module(String<any> file, String<any> namespace, RevObject ...)'
  arguments:
    - label: 'file'
      description: 'Relative or absolute name of module file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'namespace'
      description: 'Namespace used to rescue variables from overwriting.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'NULL'
      options:
    - label:
      description: 'Additinal variables passed into the module.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RevObject'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'mrcaIndex'
  return_type: 'Natural'
  usage: 'mrcaIndex(TimeTree<any> tree, Clade<any> clade)'
  arguments:
    - label: 'tree'
      description: 'The tree which is used to compute the MRCA.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'clade'
      description: 'The clade for which the MRCA is searched.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Clade'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'nodeAgeByID'
  return_type: 'RealPos'
  usage: 'nodeAgeByID(TimeTree<any> tree, Natural<any> nodeID, Bool<any> stemAge)'
  arguments:
    - label: 'tree'
      description: 'The tree variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'nodeID'
      description: 'The node index.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
    - label: 'stemAge'
      description: 'Do we want the stem age or crown age?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'normalize'
  return_type: 'RealPos[]'
  usage: 'normalize(RealPos[]<any> x, RealPos<any> sum)'
  arguments:
    - label: 'x'
      description: 'The vector of numbers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default:
      options:
    - label: 'sum'
      description: 'The sum the vector will have after normalization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '1'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'pomoRF'
  return_type: 'Simplex'
  usage: 'pomoRF(Simplex<any> root_base_frequencies, Real<any> root_polymorphism_proportion, RateGenerator<any> mutation_rate_matrix, Natural<any> virtualNe)'
  arguments:
    - label: 'root_base_frequencies'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default:
      options:
    - label: 'root_polymorphism_proportion'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'mutation_rate_matrix'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RateGenerator'
      default:
      options:
    - label: 'virtualNe'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'pomoState4Convert'
  return_type: 'AbstractHomologousDiscreteCharacterData'
  usage: 'pomoState4Convert(AbstractHomologousDiscreteCharacterData<any> aln, Natural<any> virtualNe, Taxon[]<any> taxa)'
  arguments:
    - label: 'aln'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'virtualNe'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
    - label: 'taxa'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Taxon[]'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'posteriorPredictiveProbability'
  return_type: 'Simplex'
  usage: 'posteriorPredictiveProbability(Real[]<any> v, Real<any> x)'
  arguments:
    - label: 'v'
      description: 'The simulated statistics.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'x'
      description: 'The opbserved value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'power'
  return_type: 'RealPos'
  usage: 'power(Real<any> base, Real<any> exponent)'
  arguments:
    - label: 'base'
      description: 'The base.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'exponent'
      description: 'The exponent.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title: 'power'
  aliases:
  description: 'The function raises any real number to a power.'
  details: 'This function accepts two arguments: one real number (the base) and a second real number (the exponenent).'
  example: |
    # Raise 2 to the 3rd power
        x<-2
        power(x, 3)
  authors:
  see_also: 'log'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'printSeed'
  return_type: 'NULL'
  usage: 'printSeed()'
  arguments:
  title: 'Print the random number generator seed'
  aliases:
  description: 'Print the seed of the random number generator.'
  details:
  example: |
    printSeed()
    
    # Set the seed to a new value
    seed(12345)
    # Now print the seed again
    printSeed()
  authors:
  see_also: 'seed'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'profile'
  return_type: 'NULL'
  usage: 'profile(String<any> command {valid options: "start"|"stop"|"reportTotalTime"|"reportPerCallAvgTime"}, String<any> event)'
  arguments:
    - label: 'command'
      description: 'The command to apply (start, stop, reportTotalTime or reportPerCallAvgTime).'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'start'
      options:
        - 'start'
        - 'stop'
        - 'reportTotalTime'
        - 'reportPerCallAvgTime'
    - label: 'event'
      description: 'The name of the event to track.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'quantile'
  return_type: 'Real'
  usage: 'quantile(Real[]<any> x, Probability<any> k)'
  arguments:
    - label: 'x'
      description: 'A vector of numbers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'k'
      description: 'The kth quantile of vector x.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'quit'
  return_type: 'void'
  usage: 'quit()'
  arguments:
  title: 'Quit RevBayes'
  aliases: 'q'
  description: 'Terminates the currently running instance of RevBayes.'
  details:
  example: |
    # if you really want to quit
    q()
    # you can always start again later ...
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'r_add'
  return_type: 'RealPos[]'
  usage: 'r_add(Natural<any> n, Distribution__RealPos|Distribution__Probability<any> baseDistribution, RealPos<any> delta)'
  arguments:
    - label: 'n'
      description: 'Number of random values to draw.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__RealPos'
      default:
      options:
    - label: 'delta'
      description: 'The amount added to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'r_mul'
  return_type: 'Probability[]'
  usage: 'r_mul(Natural<any> n, Distribution__Probability<any> baseDistribution, Probability<any> lambda)'
  arguments:
    - label: 'n'
      description: 'Number of random values to draw.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Probability'
      default:
      options:
    - label: 'lambda'
      description: 'The amount muled to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'r_sub'
  return_type: 'Real[]'
  usage: 'r_sub(Natural<any> n, Distribution__Real|Distribution__RealPos|Distribution__Probability<any> firstDistribution, Real<any> second)'
  arguments:
    - label: 'n'
      description: 'Number of random values to draw.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'firstDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Real'
      default:
      options:
    - label: 'second'
      description: 'The amount sub1ed to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'range'
  return_type: 'Integer[]'
  usage: 'range(Integer<any> first, Integer<any> last)'
  arguments:
    - label: 'first'
      description: 'Lower value.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
    - label: 'last'
      description: 'Upper value.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
  title: 'A range of consecutive integer numbers'
  aliases:
  description: 'Create a sequence of number in the given range (interval).'
  details: 'This function is a simplified version of the sequence function ''seq''. The range function creates a sequence of integer numbers with a step size of 1.'
  example: |
    range(1,20)
    range(20,-20)
    
    # this function is actually the same as the ':'
    20:-20
  authors:
  see_also:
    - 'seq'
    - 'rep'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readAncestralStateTrace'
  return_type: 'AncestralStateTrace[]'
  usage: 'readAncestralStateTrace(String<any> file, String<any> separator)'
  arguments:
    - label: 'file'
      description: 'The name of the file which holds the ancestral state trace.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The separater/delimiter between columns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readAncestralStateTreeTrace'
  return_type: 'TraceTree'
  usage: 'readAncestralStateTreeTrace(String<any> file, String<any> treetype {valid options: "clock"|"non-clock"}, String<any> separator, Probability|Integer<any> burnin)'
  arguments:
    - label: 'file'
      description: 'The name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'treetype'
      description: 'The type of tree.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'clock'
      options:
        - 'clock'
        - 'non-clock'
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'burnin'
      description: 'The fraction/number of samples to discard as burnin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.25'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readAtlas'
  return_type: 'RlAtlas'
  usage: 'readAtlas(String<any> file)'
  arguments:
    - label: 'file'
      description: 'The name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readBranchLengthTrees'
  return_type: 'BranchLengthTree[]'
  usage: 'readBranchLengthTrees(String<any> file)'
  arguments:
    - label: 'file'
      description: 'The name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readCharacterData'
  return_type: 'AbstractHomologousDiscreteCharacterData[]'
  usage: 'readCharacterData(String<any> file, Bool<any> alwaysReturnAsVector)'
  arguments:
    - label: 'file'
      description: 'File or directory names where to find the character data.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'alwaysReturnAsVector'
      description: 'Should the value be returned as a vector even it is only a single matrix?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readContinuousCharacterData'
  return_type: 'ContinuousCharacterData[]'
  usage: 'readContinuousCharacterData(String<any> file, Bool<any> alwaysReturnAsVector)'
  arguments:
    - label: 'file'
      description: 'The name of the file or directory for the character data matrices.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'alwaysReturnAsVector'
      description: 'Should we return this object as a vector even if it is just a single matrix?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readDelimitedCharacterData'
  return_type: 'NaturalNumbers'
  usage: 'readDelimitedCharacterData(String<any> file, String<any> type {valid options: "NaturalNumbers"|"Bitset"|"Standard"|"Continuous"|"Taxa"}, String<any> stateLabels, String<any> separator, Bool<any> header)'
  arguments:
    - label: 'file'
      description: 'The name of the file to read in.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'type'
      description: 'The type of data.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'NaturalNumbers'
      options:
        - 'NaturalNumbers'
        - 'Bitset'
        - 'Standard'
        - 'Continuous'
        - 'Taxa'
    - label: 'stateLabels'
      description: 'The state labels (for standard states) or max number for NaturalNumbers.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'header'
      description: 'Does this file have a header line?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases: 'readCharacterDataDelimited'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readDelimitedDataFile'
  return_type: 'RevObject[][]'
  usage: 'readDelimitedDataFile(String<any> file, Bool<any> header, String<any> separator, Bool<any> rownames)'
  arguments:
    - label: 'file'
      description: 'The name of the file to read.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'header'
      description: 'Skip first line?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'rownames'
      description: 'Skip first column?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
    - 'readTable'
    - 'readDataDelimitedFile'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readDiscreteCharacterData'
  return_type: 'AbstractHomologousDiscreteCharacterData[]'
  usage: 'readDiscreteCharacterData(String<any> file, Bool<any> alwaysReturnAsVector)'
  arguments:
    - label: 'file'
      description: 'The name of the file or directory from which to read in the character data matrix.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'alwaysReturnAsVector'
      description: 'Should we always return the character data matrix as a vector of matrices even if there is only one?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readDistanceMatrix'
  return_type: 'DistanceMatrix'
  usage: 'readDistanceMatrix(String<any> file, String<any> separator)'
  arguments:
    - label: 'file'
      description: 'Relative or absolute name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readMatrix'
  return_type: 'MatrixReal'
  usage: 'readMatrix(String<any> file, String<any> separator)'
  arguments:
    - label: 'file'
      description: 'The name of the file to read.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readPoMoCountFile'
  return_type: 'AbstractHomologousDiscreteCharacterData'
  usage: 'readPoMoCountFile(String<any> file, Natural<any> virtualPopulationSize, Natural<any> numStates)'
  arguments:
    - label: 'file'
      description: 'Relative or absolute name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'virtualPopulationSize'
      description:
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
    - label: 'numStates'
      description: 'The number of states (e.g. 4 for A,C,G and T).'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '4'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readRegionalFeatures'
  return_type: 'RevObject[][]'
  usage: 'readRegionalFeatures(String<any> filename, String<any> delimiter, Bool<any> header, String<any> nonexistent_region_token)'
  arguments:
    - label: 'filename'
      description: 'A data table that contains the regional feature information.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'delimiter'
      description: 'The delimiter between columns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: ','
      options:
    - label: 'header'
      description: 'Do the summary file and the data files have headers?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'nonexistent_region_token'
      description: 'What string token represents a non-existent region (for null rate assignments)?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'NA'
      options:
  title:
  aliases: 'readTable'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readRelativeNodeAgeConstraints'
  return_type: 'RlRelativeNodeAgeConstraints'
  usage: 'readRelativeNodeAgeConstraints(String<any> file, String<any> separator)'
  arguments:
    - label: 'file'
      description: 'Relative or absolute name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readRelativeNodeAgeWeightedConstraints'
  return_type: 'RlRelativeNodeAgeWeightedConstraints'
  usage: 'readRelativeNodeAgeWeightedConstraints(String<any> file, String<any> separator, Real<any> threshold)'
  arguments:
    - label: 'file'
      description: 'Relative or absolute name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'threshold'
      description: 'weight threshold below which constraints are ignored.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readStochasticVariableTrace'
  return_type: 'ModelTrace[]'
  usage: 'readStochasticVariableTrace(String<any> file, String<any> separator, Probability|Integer<any> burnin)'
  arguments:
    - label: 'file'
      description: 'The name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'burnin'
      description: 'The fraction/number of samples to discard as burnin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.25'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readTaxonData'
  return_type: 'Taxon[]'
  usage: 'readTaxonData(String<any> filename, String<any> separator)'
  arguments:
    - label: 'filename'
      description: 'Relative or absolute file name.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readTrace'
  return_type: 'Trace[]'
  usage: 'readTrace(String<any> file, String<any> separator, Probability|Integer<any> burnin, Natural<any> thinning, Natural<any> nruns)'
  arguments:
    - label: 'file'
      description: 'Name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'burnin'
      description: 'The fraction/number of samples to discard as burnin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.25'
      options:
    - label: 'thinning'
      description: 'The frequency of samples to read, i.e., we will only used every n-th sample where n is defined by this argument.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'nruns'
      description: 'The number of trace files with the same basename (i.e. the number of filenames with pattern <file>_run_<n>.log)'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
  title: 'Read an MCMC log file.'
  aliases:
  description: |
    Reads parameter values from a log file, usually produced as the output of an
    MCMC or MCMCMC run.
  details: |
    Either a file name or a directory must be provided as argument. If a folder is
    provided, all the files that contain trees in that directory are read in
    the same object.
    
    When reading individual log files, field is delimited by `separator`. We drop
    the first `burnin` iterations if `burnin` is an integer greater than or equal
    to 1, or the fraction `burnin` of iterations if `burnin` is a real number
    smaller than 1. Then we keep every `n`th entry if the `thinning` is `n`.
    
    `trace = readTrace(..., nruns = 1)` returns a `Trace[]` object.
    `trace = readTrace(..., nruns > 1)` returns a `Trace[][]` object, in which
    `trace[n]` corresponds to the trace of run `n`.
  example: |
    # read in a single log file as a vector of traces
    traces = readTrace("out.log", burnin=0.5)
    
    # read in two log files called 'out_run_1.log', 'out_run_2.log'
    traces = readTrace("out.log", burnin=0.5, nruns=2)
  authors:
  see_also:
    - 'readAncestralStateTrace'
    - 'readTreeTrace'
    - 'Trace'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readTreeTrace'
  return_type: 'TraceTree'
  usage: 'readTreeTrace(String|String[]<any> file, String<any> treetype {valid options: "clock"|"non-clock"}, Bool<any> unroot_nonclock, Clade<any> outgroup, String<any> separator, Integer|Probability<any> burnin, Natural<any> thinning, Natural<any> offset, Bool<any> nexus, Natural<any> nruns)'
  arguments:
    - label: 'file'
      description: 'The name of the tree trace file(s), or directories containing them.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'treetype'
      description: 'The type of trees.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'clock'
      options:
        - 'clock'
        - 'non-clock'
    - label: 'unroot_nonclock'
      description: 'Remove a degree-2 root node and set the tree unrooted, if treetype is non-clock.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'outgroup'
      description: 'The clade (consisting of one or more taxa) used as an outgroup.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Clade'
      default: 'NULL'
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'burnin'
      description: 'The fraction/number of samples to discard as burnin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default: '0.25'
      options:
    - label: 'thinning'
      description: 'The frequency of samples to read, i.e., we will only used every n-th sample where n is defined by this argument.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'offset'
      description: 'The offset of the first sample to read, i.e., how many samples should we skip before we take the first sample.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '0'
      options:
    - label: 'nexus'
      description: 'Whether the file to read is in NEXUS format.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'nruns'
      description: 'The number of trace files with the same basename (i.e. the number of filenames with pattern <file>_run_<n>.trees)'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
  title: 'Function to read in a tree trace, usually produced as the output of an MCMC.'
  aliases:
  description: |
    Reads trees (Nexus or Newick accepted) from a file or folder containing a set
    of trees and saves them in one object.
  details: |
    Either a file name or a directory must be provided as argument. If a folder is
    provided, all the files that contain trees in that directory are read in
    the same object.
    
    `tree_trace = readTreeTrace(..., nruns = 1)` returns a `TraceTree` object.
    `tree_trace = readTreeTrace(..., nruns > 1)` returns a `TraceTree[]` object,
    in which `tree_trace[n]` corresponds to the trace of run `n`.
    
    The resulting `TraceTree` object stores every `thinning`th sample from a file,
    starting at the sample numbered `offset + 1`.
  example: |
    # read a tree trace
    tree_trace = readTreeTrace("my_filename.tree", treetype="clock", burnin=0.5)
    
    # make a summary maximum clade credibility (MCC) tree
    mcc_tree = mccTree(trace=tree_trace, file="mcc.tree")
  authors:
  see_also:
    - 'readAncestralStateTrace'
    - 'readTrace'
    - 'readTrees'
    - 'TraceTree'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readTrees'
  return_type: 'TimeTree[]'
  usage: 'readTrees(String<any> file, String<any> text, String<any> treetype {valid options: "clock"|"non-clock"}, Bool<any> unroot_nonclock)'
  arguments:
    - label: 'file'
      description: 'The name of the file containing the trees.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'text'
      description: 'A string containing one or several newick trees, separated by end of lines.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'treetype'
      description: 'The type of trees.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'clock'
      options:
        - 'clock'
        - 'non-clock'
    - label: 'unroot_nonclock'
      description: 'Remove a degree-2 root node and set the tree unrooted, if treetype is non-clock.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title: 'Function to read in trees.'
  aliases:
  description: 'Reads trees from a file containing trees (Nexus, Phylip or Newick accepted), or from a string containing Newick representations of trees.'
  details: 'Either a file name (with the file argument) or a string (with the text argument) must be provided as argument. If both are provided, trees will be read from both sources.'
  example: |
    trees=readTrees(text="(a,(b,c));\n(d:0.1,(e:0.1,f:0.1):0.1);")
    print(trees)
  authors:
  see_also:
    - 'write'
    - 'readBranchLengthTrees'
    - 'readCharacterData'
    - 'readCharacterDataDelimited'
    - 'readContinuousCharacterData'
    - 'readDiscreteCharacterData'
    - 'readDataDelimitedFile'
    - 'readCharacterData'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'readVCF'
  return_type: 'AbstractHomologousDiscreteCharacterData'
  usage: 'readVCF(String<any> file, String<any> type {valid options: "DNA"|"binary"})'
  arguments:
    - label: 'file'
      description: 'Relative or absolute name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'type'
      description: 'The type of data to be constructed.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'binary'
      options:
        - 'DNA'
        - 'binary'
  title: 'Read VCF'
  aliases:
  description: 'Read VCF file into RevBayes'
  details: |
    readVCF reads in a file that is in Variant Call Format (VCF), accepting two
    arguments. The first argument specifies the relative or absolute 
    file path to desired VCF file. The second specifies type of data
    to be constructed (default binary). This function
    only allows for 0, 1, and . characters in the VCF file.
  example: 'x <- readVCF("path/to/VCF/file", "binary")'
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation:
      doi:
      url:
- name: 'rep'
  return_type: 'Integer[]'
  usage: 'rep(Integer<any> x, Natural<any> n)'
  arguments:
    - label: 'x'
      description: 'The value that we replicate.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'Integer'
      default:
      options:
    - label: 'n'
      description: 'How often we replicate the value.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title: 'Replicate a value'
  aliases: 'replicate'
  description: '''rep'' creates a vector of ''n'' copies of the value ''x''.'
  details: '''rep'' creates a vector of ''n'' elements, each with value ''x'', preserving the type of ''x'' in the returned vector.'
  example: 'rep(0.1, 3)'
  authors:
  see_also:
    - 'simplex'
    - 'v'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'reverse'
  return_type: 'Integer[]'
  usage: 'reverse(Integer[]<any> v)'
  arguments:
    - label: 'v'
      description: 'The vector that we want to reverse.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'Integer[]'
      default:
      options:
  title: 'Reverse function'
  aliases: 'rev'
  description: 'Reverses the order of the elements in a vector.'
  details:
  example: |
    x = v(1,2,3,4)
    reverse(x)
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'rexponential'
  return_type: 'RealPos[]'
  usage: 'rexponential(Natural<any> n, RealPos<any> lambda, RealPos<any> offset)'
  arguments:
    - label: 'n'
      description: 'Number of random values to draw.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'lambda'
      description: 'The rate parameter ( rate = 1/mean ).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '1'
      options:
    - label: 'offset'
      description: 'The offset of the distribution.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default: '0'
      options:
  title:
  aliases: 'rexp'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'rinvlogit'
  return_type: 'Probability[]'
  usage: 'rinvlogit(Natural<any> n, Distribution__Real|Distribution__RealPos|Distribution__Probability<any> baseDistribution)'
  arguments:
    - label: 'n'
      description: 'Number of random values to draw.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'rlogit'
  return_type: 'Real[]'
  usage: 'rlogit(Natural<any> n, Distribution__Probability<any> baseDistribution)'
  arguments:
    - label: 'n'
      description: 'Number of random values to draw.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Probability'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'rootedTripletDist'
  return_type: 'RootedTripletDistribution'
  usage: 'rootedTripletDist(Tree<any> geneTrees, String[]<any> speciesNames, Bool<any> keepBranchLengths)'
  arguments:
    - label: 'geneTrees'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'speciesNames'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'String[]'
      default:
      options:
    - label: 'keepBranchLengths'
      description:
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'round'
  return_type: 'Integer'
  usage: 'round(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'rscale'
  return_type: 'Probability[]'
  usage: 'rscale(Natural<any> n, Distribution__Probability<any> baseDistribution, Probability<any> lambda)'
  arguments:
    - label: 'n'
      description: 'Number of random values to draw.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__Probability'
      default:
      options:
    - label: 'lambda'
      description: 'The amount muled to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'rshift'
  return_type: 'RealPos[]'
  usage: 'rshift(Natural<any> n, Distribution__RealPos|Distribution__Probability<any> baseDistribution, RealPos<any> delta)'
  arguments:
    - label: 'n'
      description: 'Number of random values to draw.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default: '1'
      options:
    - label: 'baseDistribution'
      description: 'The distribution to be transformed.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Distribution__RealPos'
      default:
      options:
    - label: 'delta'
      description: 'The amount added to base random variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'seed'
  return_type: 'NULL'
  usage: 'seed(Natural<any> x)'
  arguments:
    - label: 'x'
      description: 'The number used to seed the random number generator.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Natural'
      default:
      options:
  title: 'Seed set function'
  aliases:
  description: 'Sets the random number generator seed given a natural number.'
  details:
  example: |
    # pick some definitely random number
    seed(80797980)
    a <- rUniform(1,0.6,1.2)
    a
    seed(80797980)
    a <- rUniform(1,0.6,1.2)
    a # this will be the same as above!
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'seq'
  return_type: 'Integer[]'
  usage: 'seq(Integer<any> from, Integer<any> to, Integer<any> by)'
  arguments:
    - label: 'from'
      description: 'The first value of the sequence.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
    - label: 'to'
      description: 'The last value of the sequence.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
    - label: 'by'
      description: 'The step-size between value.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Integer'
      default:
      options:
  title: 'Create a sequence values'
  aliases:
  description: 'Create a sequence of values separate by a given step-size.'
  details: 'The ''seq'' function create a sequence of values, starting with the initial value and then adding the step-size to it until the value reaches the ''to''-value.'
  example: 'seq(-0.5, 10.5, 2)'
  authors:
  see_also: 'rep'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'setOption'
  return_type: 'void'
  usage: 'setOption(String<any> key, String<any> value, Bool<any> save)'
  arguments:
    - label: 'key'
      description: 'The key-identifier for which to set a new value.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'value'
      description: 'The new value.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'save'
      description: 'Save option to file'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title: 'Set a global RevBayes option'
  aliases:
  description: 'Set a global option for RevBayes.'
  details: |
    Runtime options are used to personalize RevBayes and are stored on the local machine.
    The currently available keys and their associated values are as follows:
    
        lineWidth=<integer>          Screen width when printing (in characters).
    
            DEFAULT: 160
    
        outputPrecision=<integer>    How many significant digits to print for the values of model graph nodes.
    
            DEFAULT: 7
    
        printNodeIndex=<TRUE,FALSE>  Print the node indices of a tree as annotations?
    
            DEFAULT: TRUE
    
        useScaling=<TRUE,FALSE>      Should the partial likelihoods in continuous-time Markov chain (CTMC) models be scaled
                                     to avoid underflow?
            DEFAULT: TRUE
    
        scalingDensity=<integer>     If so, scale CTMC likelihoods every n-th node (min = 1).
    
            DEFAULT: 1
    
        tolerance=<numeric>          Tolerance for comparing doubles.
    
            DEFAULT: 10e-10
    
        debugMCMC=<0,1>              How much work to perform to check MCMC?
    
            0: MCMC run without checks.
            1: MCMC run with additional checks at extra CPU time cost.
    
            DEFAULT: 0
    
        logMCMC=<0,1,2,3,4>          How much logging to perform when checking MCMC? NOTE: This option serves for debugging and
                                     should be considered experimental. The exact meaning of individual values may be subject
                                     to frequent changes.
    
            0: No information on individual moves written out.
            1 or higher: Writes out the generation, within-generation position, and name for each move.
            2 or higher: Also writes out posterior, likelihood, prior, and Hastings ratios, and if log likelihood = -Inf or NaN,
                         writes out why this is the case.
            3 or higher: Writes out each changed probability density and the name of the corresponding model graph node.
            4: Writes out additional details about the mvSlice move (if present).
    
            DEFAULT: 0
  example: |
    # compute the absolute value of a real number
    getOption("linewidth")
    
    # let us set the linewidth to a new value
    setOption("linewidth", 200)
    
    # now let's check what the value is
    getOption("linewidth")
  authors:
  see_also: 'getOption'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'setwd'
  return_type: 'void'
  usage: 'setwd(String<any> wd)'
  arguments:
    - label: 'wd'
      description: 'The new working directory.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title: 'Set and print the working directory'
  aliases:
  description: 'Set the current working directory which RevBayes uses.'
  details:
  example: |
    # get the current working directory
    getwd()
    
    # let us set a new working directory
    setwd("~/Desktop")
    
    # check the working directory again
    getwd()
  authors:
  see_also: 'getwd'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'sigmoid'
  return_type: 'RealPos'
  usage: 'sigmoid(Real<any> x, RealPos<any> min, RealPos<any> max, Real<any> mid, Real<any> slope)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'min'
      description: 'The minimum value of the sigmoid function.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'max'
      description: 'The maximum value of the sigmoid function.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'mid'
      description: 'The middle of the sigmoid function.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
    - label: 'slope'
      description: 'The slope of the sigmoid function.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'simCompleteTree'
  return_type: 'TimeTree'
  usage: 'simCompleteTree(Taxon[]<any> taxa, RealPos<any> rootAge, RealPos<any> lambda, RealPos<any> mu)'
  arguments:
    - label: 'taxa'
      description: 'The taxon names used for initialization.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Taxon[]'
      default:
      options:
    - label: 'rootAge'
      description: 'The root age.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'lambda'
      description: 'The speciation rate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'mu'
      description: 'The extinction rate.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'simForwardBirthDeath'
  return_type: 'TimeTree'
  usage: 'simForwardBirthDeath(RealPos[]<any> timeline, RealPos[][]|RealPos[]|RealPos<any> lambda, RealPos[][]|RealPos[]|RealPos<any> mu, RealPos[][]|RealPos[]|RealPos<any> phi, Probability[][]|Probability[]|Probability<any> r, Probability[][]|Probability[]|Probability<any> Lambda, Probability[][]|Probability[]|Probability<any> Mu, Probability[][]|Probability[]|Probability<any> Phi, Probability[][]|Probability[]|Probability<any> R, Simplex<any> rootCategory, RealPos<any> time, String<any> condition {valid options: "time"|"root"|"survival"}, Natural<any> maxNumLineages, Bool<any> completeTree)'
  arguments:
    - label: 'timeline'
      description: 'The endpoints of the time intervals (episodes). You should include 0 at the end. We use ages before the present.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[]'
      default: '[ 0.000 ]'
      options:
    - label: 'lambda'
      description: 'The speciation rates for each interval.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default:
      options:
    - label: 'mu'
      description: 'The extinction rates for each interval.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default: '0'
      options:
    - label: 'phi'
      description: 'The sampling rates for each interval.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos[][]'
      default: '0'
      options:
    - label: 'r'
      description: 'The extinction probability when rate-sampling happens for each interval.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability[][]'
      default: '0'
      options:
    - label: 'Lambda'
      description: 'The burst probability at the end of each interval (first value is ignored).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability[][]'
      default: '0'
      options:
    - label: 'Mu'
      description: 'The (mass) extinction probability at the end of each interval (first value is ignored).'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability[][]'
      default: '0'
      options:
    - label: 'Phi'
      description: 'The sampling probability at the end of each interval.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability[][]'
      default: '0'
      options:
    - label: 'R'
      description: 'The extinction probability when event-sampling happens for each interval (first value is ignored). If NULL, r is used instead.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Probability[][]'
      default: 'NULL'
      options:
    - label: 'rootCategory'
      description: 'The probabilities of the categories for the root.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Simplex'
      default: '[ 1.000 ]'
      options:
    - label: 'time'
      description: 'The time/age before the present.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
    - label: 'condition'
      description: 'What outcome should we condition on?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'root'
      options:
        - 'time'
        - 'root'
        - 'survival'
    - label: 'maxNumLineages'
      description: 'The maximum number of lineages allowed by the simulator. Simulations that reach this size will be aborted and re-started.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default: '100000'
      options:
    - label: 'completeTree'
      description: 'Should the tree include all lineages, even those that went extinct?'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'simStartingTree'
  return_type: 'TimeTree'
  usage: 'simStartingTree(Taxon[]<any> taxa, Clade[]<any> constraints)'
  arguments:
    - label: 'taxa'
      description: 'The taxa used for initialization.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Taxon[]'
      default:
      options:
    - label: 'constraints'
      description: 'The topological constraints.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Clade[]'
      default: '[ ]'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'simTree'
  return_type: 'TimeTree'
  usage: 'simTree(Natural<any> num_taxa, String<any> type {valid options: "balanced"|"caterpillar"})'
  arguments:
    - label: 'num_taxa'
      description: 'How many taxa this tree has.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Natural'
      default:
      options:
    - label: 'type'
      description: 'The type of the shape of the topology.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'balanced'
      options:
        - 'balanced'
        - 'caterpillar'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'sin'
  return_type: 'Real'
  usage: 'sin(RealPos<any> x)'
  arguments:
    - label: 'x'
      description: 'A number.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'Apply the sine function to an angular input `x` in radians.'
  aliases:
  description: |
    `sin` calculates the trigonometric ratio of the length of the side opposite the angle and length of the hypotenuse. 
    
    sin(x) = opposite/hypotenuse.
  details:
  example: |
    pi <- 3.1415926536
    sin(pi/2) # = 1
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'sinh'
  return_type: 'Real'
  usage: 'sinh(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title: 'Hyperbolic Sine Function'
  aliases:
  description: 'Returns the hyperbolic sine of a real number.'
  details: |
    The function takes a hyperbolic angle `x` as its only argument, and returns
    sinh(x) = (exp(x) - exp(-x))/2.
  example: 'sinh(1)'
  authors:
  see_also:
    - 'cosh'
    - 'tanh'
    - 'exp'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'sort'
  return_type: 'Real[]'
  usage: 'sort(Real[]<any> x, Bool<any> ascending)'
  arguments:
    - label: 'x'
      description: 'The vector to be sorted.'
      dag_type: '<any>'
      pass_by: 'reference'
      value_type: 'Real[]'
      default:
      options:
    - label: 'ascending'
      description: 'Sort in ascending order?.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title: 'Sort function'
  aliases:
  description: 'Function for sorting the members of a vector in either ascending or descending order.'
  details: 'The vector to be sorted can be of any numeric type. Ascending or descending is specified via the `ascending` argument'
  example: |
    nums = v(1,3,5,7,2,4,6,8)
    sort(nums)
    # this will result in 1,2,3,4,5,6,7,8
    sort(nums, ascending = FALSE)
    # this will result in 8,7,6,5,4,3,2,1
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'source'
  return_type: 'void'
  usage: 'source(String<any> file, Bool<any> echo.on, Bool<any> continue)'
  arguments:
    - label: 'file'
      description: 'The name of the file to read-in.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'echo.on'
      description: 'Should we print the commands from the file on the screen?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'continue'
      description: 'Should we continue executing after an error?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title: 'Function for sourcing a Rev file'
  aliases:
  description: 'This function takes a Rev filename as an argument and runs that Rev script.'
  details:
  example: |
    # set the file name
    fn = "rb_tutorial.Rev"
    # the source function will run the Rev code in the file fn
    source(fn)
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'sqrt'
  return_type: 'RealPos'
  usage: 'sqrt(RealPos<any> x)'
  arguments:
    - label: 'x'
      description: 'A number.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RealPos'
      default:
      options:
  title: 'Square root of a number'
  aliases:
  description: 'Takes the square root of some positive number `x`.'
  details:
  example: |
    # compute the square root of a real number
    x <- 3.0
    root <- sqrt(x)
    if ( abs(root*root - x) > 1.0e-15) {
        print("Problem computing the square root.")
    } else {
        print("Correct computation of the square root.")
    }
  authors:
  see_also: '`power`'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'stdev'
  return_type: 'Real'
  usage: 'stdev(Real[]<any> x)'
  arguments:
    - label: 'x'
      description: 'The vector of samples.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Standard Deviation'
  aliases:
  description: 'Finds the standard deviation of a vector of real numbers.'
  details: |
    Accepts one argument, a vector of real numbers, and returns the standard deviation
    as a real number.
  example: |
    x <- v(4, 3, 2, 1)
    s := stdev(x)
  authors:
  see_also:
    - 'v'
    - 'Real'
    - 'mean'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'structure'
  return_type: 'void'
  usage: 'structure(RevObject<any> x, Bool<any> verbose)'
  arguments:
    - label: 'x'
      description: 'The variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RevObject'
      default:
      options:
    - label: 'verbose'
      description: 'Do you want all the information?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title: 'The structure of a variable'
  aliases: 'str'
  description: 'Shows all the information about a given variable.'
  details:
  example: |
    # create a variable
    a <- 1
    b := exp(a)
    # now create a deterministic variable which will be a child of 'b'
    c := ln(b)
    # now create a constant variable which will not be a child of 'b'
    d <- ln(b)
    
    str(b)
  authors:
  see_also: 'type'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'sum'
  return_type: 'Real'
  usage: 'sum(Real[]<any> x)'
  arguments:
    - label: 'x'
      description: 'A vector of numbers.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Sum function'
  aliases:
  description: 'Sums all members of a vector of type `Real`, `RealPos`, `Integer`, or `Natural`'
  details:
  example: |
    a = v(1,2,3,4,5,6,7,8)
    sum(a)
    # returns 36
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'summarizeCharacterMaps'
  return_type: 'Tree'
  usage: 'summarizeCharacterMaps(Tree<any> tree, AncestralStateTrace[]<any> character_map_trace_vector, TraceTree<any> tree_trace, String<any> file, Probability|Integer<any> burnin, String<any> separator, Bool<any> verbose, Bool<any> use_simmap_default)'
  arguments:
    - label: 'tree'
      description: 'The input tree to summarize ancestral states over.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Tree'
      default: 'NULL'
      options:
    - label: 'character_map_trace_vector'
      description: 'A vector of stochastic character map traces.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AncestralStateTrace[]'
      default:
      options:
    - label: 'tree_trace'
      description: 'A trace of tree samples.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'TraceTree'
      default: 'NULL'
      options:
    - label: 'file'
      description: 'The name of the file to store the summarized character histories.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'burnin'
      description: 'The fraction/number of samples to discard as burnin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.25'
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'verbose'
      description: 'Printing verbose output'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
    - label: 'use_simmap_default'
      description: 'Was the default SIMMAP/phytools event ordering (i.e., young/left -> old/right) used with mnStochasticCharacterMap()? True by default.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'TRUE'
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'symmetricDifference'
  return_type: 'RealPos'
  usage: 'symmetricDifference(Tree<any> tree1, Tree<any> tree2)'
  arguments:
    - label: 'tree1'
      description: 'The first tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
    - label: 'tree2'
      description: 'The second tree.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Tree'
      default:
      options:
  title:
  aliases: 'symDiff'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'system'
  return_type: 'void'
  usage: 'system(String<any> command)'
  arguments:
    - label: 'command'
      description: 'The system command to execute.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title: 'Execute a system command.'
  aliases:
  description: 'Run a system command.'
  details: 'This function will delegate the command to the system. In that way, the function works as an interface to the shell.'
  example: |
    # We can execute any command just as if you are using a terminal
    system("ls")
    system("pwd")
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'tanh'
  return_type: 'Real'
  usage: 'tanh(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'time'
  return_type: 'NULL'
  usage: 'time(String<any> option {valid options: "year"|"day"|"seconds"|"milliseconds"|"nanoseconds"|"fromBeginning"})'
  arguments:
    - label: 'option'
      description: 'The format of the time.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: 'fromBeginning'
      options:
        - 'year'
        - 'day'
        - 'seconds'
        - 'milliseconds'
        - 'nanoseconds'
        - 'fromBeginning'
  title: 'Get the time information'
  aliases:
  description: 'Get the current system time.'
  details: |
    
    "year" reports the current year (e.g. 2000).
    
    "day" returns the index of the day in the year (e.g. Jan 1 = 1; Feb 1 = 32).
    
    "(milli/nano)seconds" returns the number of (milli/nano)seconds that have elapsed since midnight.
    
    "fromBeginning", the default, returns the number of milliseconds that have elapsed since 1400-Jan-01 00:00:00, the earliest representable date in the boost library's implementation of the Gregorian date system.
  example: |
    time()
    
    # Wait a little bit
    sum = 0
    for (i in 1:10000) sum += i
    # Now print the time again
    time()
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'tmrca'
  return_type: 'RealPos'
  usage: 'tmrca(TimeTree<any> tree, Clade<any> clade, Bool<any> stemAge)'
  arguments:
    - label: 'tree'
      description: 'The tree variable.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'TimeTree'
      default:
      options:
    - label: 'clade'
      description: 'The clade.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Clade'
      default:
      options:
    - label: 'stemAge'
      description: 'Do we want the stem age or crown age?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title: 'Find the time to the most recent common ancestor'
  aliases:
  description: 'Finds the most recent common ancestor (TMRCA) of a clade of taxa on a tree.'
  details:
  example: |
    # let's make up some taxa
    taxa = v("horse", "whale", "unicorn", "narwhal")
    # convert these to the taxon datatype
    for(i in 1:4) { taxa[i] = taxon(taxa[i]) }
    # simulate a tree
    tau ~ dnUniformTimeTree(rootAge=1, taxa=taxa)
    # we also need a molecular substitution model
    molecular_model := fnJC(4)
    # together these form a continuous time Markov chain over the tree
    full_model ~ dnPhyloCTMC(tree=tau, Q=molecular_model, nSites = 100, type="DNA")
    # need to make a clade
    horned_animals <- clade(taxa[3], taxa[4])
    tmrca(tau, horned_animals)
  authors:
  see_also: '`clade`'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'treeTrace'
  return_type: 'TraceTree'
  usage: 'treeTrace(TimeTree[]|BranchLengthTree[]|Tree[]<any> trees, Probability|Integer<any> burnin)'
  arguments:
    - label: 'trees'
      description: 'Vector of trees.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'TimeTree[]'
      default:
      options:
    - label: 'burnin'
      description: 'The fraction/number of samples to discard as burnin.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Probability'
      default: '0.25'
      options:
  title:
  aliases:
  description: 'Creates a tree trace object from a vector of trees.'
  details:
  example: |
    # Read in a vector of trees
    trees = readTrees("trees.nex")
    
    # Create a tree trace
    tree_trace = treeTrace(trees, burnin=0.25)
    
    # Create a distribution of trees from the tree trace
    tree ~ dnEmpiricalTree(tree_trace)
    
    # Add an MCMC move
    moves[1] = mvEmpiricalTree(tree)
  authors:
  see_also:
    - 'mvEmpiricalTree'
    - 'treeTrace'
    - 'readTreeTrace'
    - 'readTrees'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'trunc'
  return_type: 'Integer'
  usage: 'trunc(Real<any> x)'
  arguments:
    - label: 'x'
      description: 'The value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real'
      default:
      options:
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'type'
  return_type: 'String'
  usage: 'type(RevObject<any> x, Bool<any> verbose)'
  arguments:
    - label: 'x'
      description: 'A variable.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RevObject'
      default:
      options:
    - label: 'verbose'
      description: 'Show parent classes.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
  title: 'The value type of a variable'
  aliases:
  description: 'The value type of a variable.'
  details:
  example: |
    a <- 2
    type(a)
    
    b <- 2.0
    type(b)
  authors:
  see_also: 'structure'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'v'
  return_type: 'Integer[]'
  usage: 'v(Integer<any> , Integer ...)'
  arguments:
    - label:
      description: 'First value.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Integer'
      default:
      options:
    - label:
      description: 'More values ...'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Integer'
      default:
      options:
  title: 'Create a vector'
  aliases:
  description: '''v'' creates a vector of the elements ''...'''
  details: '''v'' creates a vector of the elements ''...'', which are objects of a common base type. Vector elements may themselves be vectors.'
  example: |
    # create a vector, Natural[]
    x <- v(1,2,3)
    x <- x + 1
    x
    
    y <- v(2,4,6)
    # create a vector of Natural[][]
    z <- v(x,y)
    z
    z[0]
  authors:
  see_also:
    - 'simplex'
    - 'rep'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'var'
  return_type: 'RealPos'
  usage: 'var(Real[]<any> x)'
  arguments:
    - label: 'x'
      description: 'A vector of values.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[]'
      default:
      options:
  title: 'Variance'
  aliases:
  description: 'Calculate variance of a vector of real numbers'
  details: |
    This function accepts a vector of real numbers and returns the variance.
    This a measure of how the data points deviate from the mean which is calculated
    as follows:
    
    s^2 = (1 / (n - 1)) * \sum (x[i] - \bar{x})^2
    
    which is essentially:
    (sum of squared differences from the mean) / (n - 1)
  example: |
    # Define vector to calculate variance
    x <- v(1, 2, 3, 4)
    # or
    x <- [1, 2, 3, 4]
    # Calculate variance
    var(x)
  authors:
  see_also:
    - 'mean'
    - 'stdev'
    - 'median'
  type_spec:
    - 'Function<RealPos>'
    - 'Function'
    - 'RevObject'
  references:
- name: 'vectorFlatten'
  return_type: 'Real[]'
  usage: 'vectorFlatten(Real[][]<any> x)'
  arguments:
    - label: 'x'
      description: 'A vector of a vector.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'Real[][]'
      default:
      options:
  title: 'Vector Flatten'
  aliases:
  description: 'Flatten a vector to one dimension.'
  details: |
    This function accepts a two-dimensional vector as an argument and flattens it
    to one dimension.
  example: |
    # Define Vector
    x <- v([1, 2], [3, 4])
    # Flatten
    x_flat <- vectorFlatten(x)
    x_flat
    [1, 2, 3, 4]
  authors:
  see_also:
    - 'v'
    - 'RealPos'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'write'
  return_type: 'NULL'
  usage: 'write(RevObject<any> , RevObject ..., String<any> filename, Bool<any> append, String<any> separator)'
  arguments:
    - label:
      description: 'A variable to write.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'RevObject'
      default:
      options:
    - label:
      description: 'Additional variables to write.'
      dag_type: '<any>'
      pass_by: 'const reference'
      value_type: 'RevObject'
      default:
      options:
    - label: 'filename'
      description: 'Writing to this file, or to the screen if name is empty.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'append'
      description: 'Append or overwrite existing file?'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'Bool'
      default: 'FALSE'
      options:
    - label: 'separator'
      description: 'How to separate values between variables.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default: ''
      options:
  title: 'Write RevObject to file'
  aliases: 'print'
  description: 'This function write values in a RevObject to a file specified by the user.'
  details: |
    This function accepts multiple RevObjects in the first arguments to be written to a file.
    After this, users can specify the filename with a string which can include the directory path
    to where the file should be made. Users can also specify whether to append or overwrite the file
    using a boolean operator (default is false). Lastly, a seperator can be specified using a string
    for specifying how to separate values in the RevObject (default is "").
  example: |
    
    # define RevObject to write
        x <- matrix([[1, 1],[1, 1]])
    # write to CSV file
        write(x, "/path/to/file/filename.csv", false, ",")
  authors:
  see_also:
    - 'writeDelimitedCharacterData'
    - 'writeFasta'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'writeDelimitedCharacterData'
  return_type: 'NULL'
  usage: 'writeDelimitedCharacterData(String<any> filename, AbstractHomologousDiscreteCharacterData|ContinuousCharacterData<any> data, String<any> separator)'
  arguments:
    - label: 'filename'
      description: 'The name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'data'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
    - label: 'separator/delimiter'
      description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
  title:
  aliases: 'writeCharacterDataDelimited'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'writeFasta'
  return_type: 'NULL'
  usage: 'writeFasta(String<any> filename, AbstractHomologousDiscreteCharacterData<any> data)'
  arguments:
    - label: 'filename'
      description: 'The name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'data'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
  title: 'FASTA file writing function'
  aliases:
  description: |
    This function writes out a FASTA formatted file given 
    data of class `AbstractHomologousDiscreteCharacterData`.
    Filename is specified using the `filename` argument.
  details:
  example: |
    # let's make up some taxa
    taxa = v("horse", "whale", "unicorn", "narwhal")
    
    # convert these to the taxon datatype
    for(i in 1:4) { taxa[i] = taxon(taxa[i]) }
    
    # simulate a tree
    tau ~ dnUniformTimeTree(rootAge=1, taxa=taxa)
    
    # we also need a molecular substitution model
    molecular_model := fnJC(4)
    
    # together these form a continuous time Markov chain over the tree
    full_model ~ dnPhyloCTMC(tree=tau, Q=molecular_model, nSites = 100, type="DNA")
    
    # this will print a FASTA file with a simulated molecular matrix
    # to the working directory
    writeFasta(filename="test.fasta", full_model)
  authors:
  see_also:
    - 'writeCharacterDataDelimited'
    - 'writeNexus'
    - 'writePhylip'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Pearson, William R., and David J. Lipman. "Improved tools for biological sequence comparison." Proceedings of the National Academy of Sciences 85.8 (1988): 2444-2448.'
      doi:
      url:
    - citation:
      doi:
      url: 'https://www.pnas.org/content/85/8/2444.short'
    - citation:
      doi: 'https://doi.org/10.1073/pnas.85.8.2444'
      url:
- name: 'writeNexus'
  return_type: 'NULL'
  usage: 'writeNexus(String<any> filename, AbstractHomologousDiscreteCharacterData|ContinuousCharacterData|Tree|Tree[]|TimeTree[]|BranchLengthTree[]<any> data)'
  arguments:
    - label: 'filename'
      description: 'The name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'data'
      description: 'The character data matrix to print.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
  title: 'Nexus file writer'
  aliases:
  description: 'Function for writing a Nexus file.'
  details: |
    The first argument is the filename to write to; this must be a string.
    The second argument is a data object that could be a morphological matrix,
    a molecular alignment, or a tree.
  example: |
    # let's make up some taxa
    taxa = v("horse", "whale", "unicorn", "narwhal")
    
    # simulate a tree
    tau ~ dnUniformTimeTree(rootAge=1, taxa=taxa)
    
    # we also need a molecular substitution model
    molecular_model := fnJC(4)
    
    # together these form a continuous time Markov chain over the tree
    full_model ~ dnPhyloCTMC(tree=tau, Q=molecular_model, nSites = 100, type="DNA")
    
    # this will print a Nexus file with a simulated molecular matrix
    # to the working directory
    writeNexus(filename="test.nex", full_model)
  authors:
  see_also:
    - 'writeCharacterDataDelimited'
    - 'writeFasta'
    - 'writeNexus'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
    - citation: 'Maddison DR, Swofford DL, Maddison WP (1997). Nexus: An extensible file format for systematic information. Systematic Biology, 46(4):590--621.'
      doi: '10.1093/sysbio/46.4.590'
      url: 'https://academic.oup.com/sysbio/article/46/4/590/1629695'
- name: 'writePhylip'
  return_type: 'NULL'
  usage: 'writePhylip(String<any> filename, AbstractHomologousDiscreteCharacterData<any> data)'
  arguments:
    - label: 'filename'
      description: 'The name of the file.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'String'
      default:
      options:
    - label: 'data'
      description: 'The character data object.'
      dag_type: '<any>'
      pass_by: 'value'
      value_type: 'AbstractHomologousDiscreteCharacterData'
      default:
      options:
  title: 'Phylip file writing function'
  aliases:
  description: |
    This function writes out a phylip formatted file given
    data of class `AbstractHomologousDiscreteCharacterData`.
    Filename is specified using the `filename` argument.
  details:
  example: |
    # let's make up some taxa
    taxa = v("horse", "whale", "unicorn", "narwhal")
    
    # convert these to the taxon datatype
    for(i in 1:4) { taxa[i] = taxon(taxa[i]) }
    
    # simulate a tree
    tau ~ dnUniformTimeTree(rootAge=1, taxa=taxa)
    
    # we also need a molecular substitution model
    molecular_model := fnJC(4)
    
    # together these form a continuous time Markov chain over the tree
    full_model ~ dnPhyloCTMC(tree=tau, Q=molecular_model, nSites = 100, type="DNA")
    
    # this will print a Phylip file with a simulated molecular matrix
    # to the working directory
    writePhylip(filename="test.phy", full_model)
  authors:
  see_also:
    - 'writeCharacterDataDelimited'
    - 'writeFasta'
    - 'writeNexus'
  type_spec:
    - 'Function'
    - 'RevObject'
  references:
- name: 'AbstractDiscreteTaxonData'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'ModelObject'
    - 'RevObject'
  constructor:
  methods:
    - name: '[]'
      return_type: 'DiscreteCharacter'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'nchar'
      return_type: 'Natural'
      usage: 'nchar()'
      arguments:
  references:
- name: 'AbstractHomologousDiscreteCharacterData'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'ModelObject'
    - 'RevObject'
  constructor:
  methods:
    - name: '[]'
      return_type: 'AbstractDiscreteTaxonData'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'addMissingTaxa'
      return_type: 'void'
      usage: 'addMissingTaxa(String|Taxon|String[]|Taxon[]<any> taxon)'
      arguments:
        - label: 'taxon'
          description: 'The name(s) of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'applyMissingSitesMask'
      return_type: 'void'
      usage: 'applyMissingSitesMask(AbstractHomologousDiscreteCharacterData<any> ref)'
      arguments:
        - label: 'ref'
          description: 'The reference dataset/alignment which we use for applying the mask of missing sites.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
    - name: 'chartype'
      return_type: 'String'
      usage: 'chartype()'
      arguments:
    - name: 'computeMultinomialProfileLikelihood'
      return_type: 'Real'
      usage: 'computeMultinomialProfileLikelihood()'
      arguments:
    - name: 'computeSiteFrequencySpectrum'
      return_type: 'Natural[]'
      usage: 'computeSiteFrequencySpectrum(Bool<any> folded, String<any> ambiguityTreatment {valid options: "ancestral"|"derived"|"skip"|"rescale"})'
      arguments:
        - label: 'folded'
          description: 'Should we compute the folded SFS?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'ambiguityTreatment'
          description: 'How should we treat ambiguous characters as derived?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'ancestral'
          options:
            - 'ancestral'
            - 'derived'
            - 'skip'
            - 'rescale'
    - name: 'computeStateFrequencies'
      return_type: 'MatrixReal'
      usage: 'computeStateFrequencies()'
      arguments:
    - name: 'excludeAll'
      return_type: 'void'
      usage: 'excludeAll()'
      arguments:
    - name: 'excludeCharacter'
      return_type: 'void'
      usage: 'excludeCharacter(Natural<any> pos)'
      arguments:
        - label: 'pos'
          description: 'The position of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'excludeCharacter'
      return_type: 'void'
      usage: 'excludeCharacter(Natural[]<any> )'
      arguments:
        - label:
          description: 'A vector of character positions.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural[]'
          default:
          options:
    - name: 'excludeMissingSites'
      return_type: 'void'
      usage: 'excludeMissingSites()'
      arguments:
    - name: 'excludeTaxa'
      return_type: 'void'
      usage: 'excludeTaxa(String|Taxon<any> taxon)'
      arguments:
        - label: 'taxon'
          description: 'The name(s) of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'excludeTaxa'
      return_type: 'void'
      usage: 'excludeTaxa(String[]|Taxon[]<any> taxa)'
      arguments:
        - label: 'taxa'
          description: 'The name(s) of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String[]'
          default:
          options:
    - name: 'expandCharacters'
      return_type: 'AbstractHomologousDiscreteCharacterData'
      usage: 'expandCharacters(Natural<any> factor)'
      arguments:
        - label: 'factor'
          description: 'The factor by which the state space is expanded.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'filename'
      return_type: 'String'
      usage: 'filename()'
      arguments:
    - name: 'getEmpiricalBaseFrequencies'
      return_type: 'Simplex'
      usage: 'getEmpiricalBaseFrequencies()'
      arguments:
    - name: 'getIncludedCharacterIndices'
      return_type: 'Natural[]'
      usage: 'getIncludedCharacterIndices()'
      arguments:
    - name: 'getInvariantSiteIndices'
      return_type: 'Natural[]'
      usage: 'getInvariantSiteIndices(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'getNumInvariantSites'
      return_type: 'Natural'
      usage: 'getNumInvariantSites(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'getNumStatesVector'
      return_type: 'AbstractHomologousDiscreteCharacterData[]'
      usage: 'getNumStatesVector()'
      arguments:
    - name: 'getPairwiseDifference'
      return_type: 'DistanceMatrix'
      usage: 'getPairwiseDifference(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'getStateDescriptions'
      return_type: 'String[]'
      usage: 'getStateDescriptions()'
      arguments:
    - name: 'includeAll'
      return_type: 'void'
      usage: 'includeAll()'
      arguments:
    - name: 'includeCharacter'
      return_type: 'void'
      usage: 'includeCharacter(Natural<any> )'
      arguments:
        - label:
          description: 'The position of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'includeCharacter'
      return_type: 'void'
      usage: 'includeCharacter(Natural[]<any> )'
      arguments:
        - label:
          description: 'A vector of character positions.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural[]'
          default:
          options:
    - name: 'includeTaxa'
      return_type: 'void'
      usage: 'includeTaxa(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'includeTaxa'
      return_type: 'void'
      usage: 'includeTaxa(String[]<any> names)'
      arguments:
        - label: 'names'
          description: 'The names of the taxa.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String[]'
          default:
          options:
    - name: 'isHomologous'
      return_type: 'Bool'
      usage: 'isHomologous()'
      arguments:
    - name: 'isResolved'
      return_type: 'Bool'
      usage: 'isResolved(Natural<any> taxonIndex, Natural<any> charIndex)'
      arguments:
        - label: 'taxonIndex'
          description: 'The index of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'charIndex'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'isSequenceMissing'
      return_type: 'Bool'
      usage: 'isSequenceMissing(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'maxGcContent'
      return_type: 'Probability'
      usage: 'maxGcContent(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'maxInvariableBlockLength'
      return_type: 'Natural'
      usage: 'maxInvariableBlockLength(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'maxPairwiseDifference'
      return_type: 'Natural'
      usage: 'maxPairwiseDifference(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'maxStates'
      return_type: 'Natural'
      usage: 'maxStates()'
      arguments:
    - name: 'maxVariableBlockLength'
      return_type: 'Natural'
      usage: 'maxVariableBlockLength(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'meanGcContent'
      return_type: 'Probability'
      usage: 'meanGcContent(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'meanGcContentByCodonPosition'
      return_type: 'Probability'
      usage: 'meanGcContentByCodonPosition(Natural<any> index, Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'index'
          description: 'The index of the codon position.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'minGcContent'
      return_type: 'Probability'
      usage: 'minGcContent(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'minPairwiseDifference'
      return_type: 'Natural'
      usage: 'minPairwiseDifference(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'names'
      return_type: 'String[]'
      usage: 'names()'
      arguments:
    - name: 'nchar'
      return_type: 'Natural'
      usage: 'nchar()'
      arguments:
    - name: 'ntaxa'
      return_type: 'Natural'
      usage: 'ntaxa()'
      arguments:
    - name: 'numInvariableBlocks'
      return_type: 'Natural'
      usage: 'numInvariableBlocks(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'numTaxaMissingSequence'
      return_type: 'Natural'
      usage: 'numTaxaMissingSequence(Probability<any> x)'
      arguments:
        - label: 'x'
          description: 'The percentage/threshold for the missing sequence.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default:
          options:
    - name: 'percentageMissing'
      return_type: 'Probability'
      usage: 'percentageMissing(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'removeExcludedCharacters'
      return_type: 'void'
      usage: 'removeExcludedCharacters()'
      arguments:
    - name: 'removeTaxa'
      return_type: 'void'
      usage: 'removeTaxa(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'removeTaxa'
      return_type: 'void'
      usage: 'removeTaxa(String[]<any> names)'
      arguments:
        - label: 'names'
          description: 'The names of the taxa.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String[]'
          default:
          options:
    - name: 'replaceRandomSitesByMissingData'
      return_type: 'void'
      usage: 'replaceRandomSitesByMissingData(Probability<any> fraction)'
      arguments:
        - label: 'fraction'
          description: 'The fraction of sites to remove.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default:
          options:
    - name: 'setCodonPartition'
      return_type: 'void'
      usage: 'setCodonPartition(Natural<any> )'
      arguments:
        - label:
          description: 'The index of the codon position.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'setCodonPartition'
      return_type: 'void'
      usage: 'setCodonPartition(Natural[]<any> )'
      arguments:
        - label:
          description: 'The indicies of the codon positions.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural[]'
          default:
          options:
    - name: 'setHomeologPhase'
      return_type: 'void'
      usage: 'setHomeologPhase(String<any> data_name, String<any> tip_name)'
      arguments:
        - label: 'data_name'
          description: 'The name used in the character alignment.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'tip_name'
          description: 'The tip name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'setNumStatesPartition'
      return_type: 'void'
      usage: 'setNumStatesPartition(Natural<any> )'
      arguments:
        - label:
          description: 'The number of states in this partition.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'setTaxonName'
      return_type: 'void'
      usage: 'setTaxonName(String<any> current, String<any> new)'
      arguments:
        - label: 'current'
          description: 'The old name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'new'
          description: 'The new name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'setTaxonObject'
      return_type: 'void'
      usage: 'setTaxonObject(String<any> current, Taxon<any> new)'
      arguments:
        - label: 'current'
          description: 'The old name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'new'
          description: 'The new name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon'
          default:
          options:
    - name: 'show'
      return_type: 'void'
      usage: 'show()'
      arguments:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
    - name: 'taxa'
      return_type: 'Taxon[]'
      usage: 'taxa()'
      arguments:
    - name: 'taxonIndex'
      return_type: 'Natural'
      usage: 'taxonIndex(String<any> name)'
      arguments:
        - label: 'name'
          description: 'he name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'translateCharacters'
      return_type: 'AbstractHomologousDiscreteCharacterData'
      usage: 'translateCharacters(String<any> type)'
      arguments:
        - label: 'type'
          description: 'The character type into which we want to translate.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'varGcContent'
      return_type: 'Probability'
      usage: 'varGcContent(Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'varGcContentByCodonPosition'
      return_type: 'Probability'
      usage: 'varGcContentByCodonPosition(Natural<any> index, Bool<any> excludeAmbiguous)'
      arguments:
        - label: 'index'
          description: 'The index of the codon position.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'excludeAmbiguous'
          description: 'Should we exclude ambiguous and missing characters?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  references:
- name: 'AverageDistanceMatrix'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: 'completeness'
      return_type: 'Real'
      usage: 'completeness()'
      arguments:
    - name: 'distanceMatrix'
      return_type: 'DistanceMatrix'
      usage: 'distanceMatrix()'
      arguments:
    - name: 'getElement'
      return_type: 'Real[]'
      usage: 'getElement(Natural<any> i, Natural<any> j)'
      arguments:
        - label: 'i'
          description: 'The row.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'j'
          description: 'The column.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'mask'
      return_type: 'MatrixBoolean'
      usage: 'mask()'
      arguments:
    - name: 'names'
      return_type: 'String[]'
      usage: 'names()'
      arguments:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
    - name: 'ultrametricImputation'
      return_type: 'void'
      usage: 'ultrametricImputation()'
      arguments:
  references:
- name: 'Bool'
  title: 'Datatype for logical variables.'
  aliases:
  description: 'Bool variables can be either `true` or `false` (`TRUE` or `FALSE` also work).'
  details:
  example: |
    a <- FALSE
    if(!a)
        print("a is not true")
    # this will print the statement in parentheses
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
  references:
- name: 'BootstrapAnalysis'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'BootstrapAnalysis(MaximumLikelihoodAnalysis<any> estimator, Natural<any> simulations)'
      arguments:
        - label: 'estimator'
          description: 'The maximum likelihood estimation object.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'MaximumLikelihoodAnalysis'
          default:
          options:
        - label: 'simulations'
          description: 'How many replicate simulations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  methods:
    - name: 'run'
      return_type: 'void'
      usage: 'run(RealPos<any> epsilon)'
      arguments:
        - label: 'epsilon'
          description: 'The minimum improvement in the last interval.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0.001'
          options:
  references:
- name: 'BranchLengthTree'
  title: 'Tree datatype'
  aliases:
  description: 'The Tree datatype stores information to describe the shared ancestry of a taxon set. Information includes taxon labels, topology, nodecount, and branch lengths. Tree objects also possess several useful methods to traverse and manipulate the Tree''s value.'
  details:
  example:
  authors:
  see_also:
    - 'TimeTree'
    - 'BranchLengthTree'
  type_spec:
    - 'Tree'
    - 'RevObject'
  constructor:
  methods:
    - name: 'addFossil'
      return_type: 'void'
      usage: 'addFossil(Taxon<any> fossil, Taxon[]|Clade<any> clade)'
      arguments:
        - label: 'fossil'
          description: 'The fossil taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon'
          default:
          options:
        - label: 'clade'
          description: 'Vector of some/all of the taxa included in the clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
    - name: 'branchLength'
      return_type: 'RealPos'
      usage: 'branchLength(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'calculateEDR'
      return_type: 'RealPos[]'
      usage: 'calculateEDR()'
      arguments:
    - name: 'calculateMNTD'
      return_type: 'Real'
      usage: 'calculateMNTD(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex, Natural<any> site, Bool<any> zScore, Bool<any> useBranchLengths, Natural<any> randomizations)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Mean Nearest Taxon Distance.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The index of the character state.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'site'
          description: 'The index of the site in the alignment.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'zScore'
          description: 'Calculate the MNTD z-score or the observed MNTD?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'useBranchLengths'
          description: 'Should MNTD use branch length or nodal distances?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'randomizations'
          description: 'How many randomizations should be performed when calculating z-score?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
    - name: 'calculateMPD'
      return_type: 'Real'
      usage: 'calculateMPD(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex, Natural<any> site, Bool<any> zScore, Bool<any> useBranchLengths, Natural<any> randomizations)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Mean Phylogenetic Distance.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The index of the character state.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'site'
          description: 'The index of the site in the alignment.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'zScore'
          description: 'Calculate the MPD z-score or the observed MPD?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'useBranchLengths'
          description: 'Should MPD use branch length or nodal distances?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'randomizations'
          description: 'How many randomizations should be performed when calculating z-score?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
    - name: 'child'
      return_type: 'Natural'
      usage: 'child(Natural<any> node, Natural<any> index)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'index'
          description: 'The index of the child of this node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'containsClade'
      return_type: 'Bool'
      usage: 'containsClade(Clade<any> clade)'
      arguments:
        - label: 'clade'
          description: 'The embracing clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
    - name: 'dropTip'
      return_type: 'void'
      usage: 'dropTip(String|Taxon<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'fitchScore'
      return_type: 'Natural'
      usage: 'fitchScore(AbstractHomologousDiscreteCharacterData<any> characters)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Fitch Score.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
    - name: 'getClade'
      return_type: 'Clade'
      usage: 'getClade(Taxon[]|Clade<any> clade)'
      arguments:
        - label: 'clade'
          description: 'Vector of some of the taxa included in the clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
    - name: 'getDescendantTaxa'
      return_type: 'Taxon[]'
      usage: 'getDescendantTaxa(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'the index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'getIndices'
      return_type: 'Natural[]'
      usage: 'getIndices()'
      arguments:
    - name: 'getInverseES'
      return_type: 'RealPos[]'
      usage: 'getInverseES()'
      arguments:
    - name: 'getNodeIndex'
      return_type: 'Natural'
      usage: 'getNodeIndex(Clade<any> node)'
      arguments:
        - label: 'node'
          description: 'The clade representing this node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade'
          default:
          options:
    - name: 'getPSSP'
      return_type: 'RealPos[]'
      usage: 'getPSSP(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex)'
      arguments:
        - label: 'characters'
          description: 'The character alignment to use when computing the Parsimoniously Same State Paths (PSSP).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The state index.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'getRootIndex'
      return_type: 'Natural'
      usage: 'getRootIndex()'
      arguments:
    - name: 'hasSameTopology'
      return_type: 'Bool'
      usage: 'hasSameTopology(Tree<any> tree)'
      arguments:
        - label: 'tree'
          description: 'The reference tree.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
    - name: 'isBinary'
      return_type: 'Bool'
      usage: 'isBinary()'
      arguments:
    - name: 'isContainedInClade'
      return_type: 'Bool'
      usage: 'isContainedInClade(Natural<any> node, Clade<any> clade)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'clade'
          description: 'The embracing clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
    - name: 'isInternal'
      return_type: 'Bool'
      usage: 'isInternal(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'makeUltrametric'
      return_type: 'void'
      usage: 'makeUltrametric()'
      arguments:
    - name: 'meanInverseES'
      return_type: 'RealPos'
      usage: 'meanInverseES(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the mean inverse ES metric.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The state index.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'names'
      return_type: 'String[]'
      usage: 'names()'
      arguments:
    - name: 'nbranches'
      return_type: 'Natural'
      usage: 'nbranches()'
      arguments:
    - name: 'nnodes'
      return_type: 'Natural'
      usage: 'nnodes()'
      arguments:
    - name: 'nodeName'
      return_type: 'String'
      usage: 'nodeName(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'ntips'
      return_type: 'Natural'
      usage: 'ntips()'
      arguments:
    - name: 'offset'
      return_type: 'void'
      usage: 'offset(RealPos<any> factor)'
      arguments:
        - label: 'factor'
          description: 'The offset factor.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'parent'
      return_type: 'Natural'
      usage: 'parent(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'removeDuplicateTaxa'
      return_type: 'void'
      usage: 'removeDuplicateTaxa()'
      arguments:
    - name: 'renumberNodes'
      return_type: 'void'
      usage: 'renumberNodes(Tree<any> referenceTree)'
      arguments:
        - label: 'referenceTree'
          description: 'Tree with identical topology but different node ids.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Tree'
          default:
          options:
    - name: 'reroot'
      return_type: 'void'
      usage: 'reroot(String|Clade<any> outgroup, Bool<any> makeBifurcating)'
      arguments:
        - label: 'outgroup'
          description: 'The leaf or clade to use as outgroup.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'makeBifurcating'
          description: 'Do we want a bifurcation at the root?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'rescale'
      return_type: 'void'
      usage: 'rescale(RealPos<any> factor)'
      arguments:
        - label: 'factor'
          description: 'The scaling factor.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'resolveMultifurcations'
      return_type: 'void'
      usage: 'resolveMultifurcations(Bool<any> resolveRoot)'
      arguments:
        - label: 'resolveRoot'
          description: 'Do we want a bifurcation at the root as well?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'setBranchLength'
      return_type: 'void'
      usage: 'setBranchLength(Natural<any> index, RealPos<any> value)'
      arguments:
        - label: 'index'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'value'
          description: 'The new branch length value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'setNegativeConstraint'
      return_type: 'void'
      usage: 'setNegativeConstraint(Bool<any> flag)'
      arguments:
        - label: 'flag'
          description: 'Is the tree a negative constraint?.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'setTaxonName'
      return_type: 'void'
      usage: 'setTaxonName(String<any> current, String<any> new)'
      arguments:
        - label: 'current'
          description: 'The old name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'new'
          description: 'The new name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'suppressOutdegreeOneNodes'
      return_type: 'void'
      usage: 'suppressOutdegreeOneNodes(Bool<any> replace)'
      arguments:
        - label: 'replace'
          description: 'Should we replace outdegree-1 nodes with bifurcations plus zero-length branches, or should we remove them altogether?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'taxa'
      return_type: 'Taxon[]'
      usage: 'taxa()'
      arguments:
    - name: 'tipIndex'
      return_type: 'Natural'
      usage: 'tipIndex(String|Taxon<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the tip/taxon.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'treeLength'
      return_type: 'RealPos'
      usage: 'treeLength()'
      arguments:
  references:
- name: 'CharacterHistoryRateModifier'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
  references:
- name: 'CladogeneticProbabilityMatrix'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
  references:
- name: 'CladogeneticSpeciationRateMatrix'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: 'getCladogeneticProbabilityMatrix'
      return_type: 'CladogeneticProbabilityMatrix'
      usage: 'getCladogeneticProbabilityMatrix()'
      arguments:
    - name: 'getEvents'
      return_type: 'Natural[][]'
      usage: 'getEvents()'
      arguments:
    - name: 'getRate'
      return_type: 'RealPos'
      usage: 'getRate(Natural<any> ancestorState, Natural<any> childState1, Natural<any> childState2)'
      arguments:
        - label: 'ancestorState'
          description: 'The state of the ancestral lineage before cladogenesis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'childState1'
          description: 'The state of the first child lineage after cladogenesis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'childState2'
          description: 'The state of the second child lineage after cladogenesis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'getSpeciationRateSumPerState'
      return_type: 'RealPos[]'
      usage: 'getSpeciationRateSumPerState()'
      arguments:
  references:
- name: 'ContinuousCharacterData'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'ModelObject'
    - 'RevObject'
  constructor:
  methods:
    - name: '[]'
      return_type: 'ContinuousTaxonData'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'addMissingTaxa'
      return_type: 'void'
      usage: 'addMissingTaxa(String|Taxon|String[]|Taxon[]<any> taxon)'
      arguments:
        - label: 'taxon'
          description: 'The name(s) of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'discretizeCharacter'
      return_type: 'AbstractHomologousDiscreteCharacterData'
      usage: 'discretizeCharacter(RealPos<any> error, Natural<any> nBins, RealPos<any> cushionWidth)'
      arguments:
        - label: 'error'
          description: 'The amount of error in the measured tip states (currently a global value). NULL means all the probability will be placed in the bin closes to the observed value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'nBins'
          description: 'The number of discrete bins.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'cushionWidth'
          description: 'The amount of padding around the range of observed values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '5'
          options:
    - name: 'excludeAll'
      return_type: 'void'
      usage: 'excludeAll()'
      arguments:
    - name: 'excludeCharacter'
      return_type: 'void'
      usage: 'excludeCharacter(Natural<any> pos)'
      arguments:
        - label: 'pos'
          description: 'The position of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'excludeCharacter'
      return_type: 'void'
      usage: 'excludeCharacter(Natural[]<any> )'
      arguments:
        - label:
          description: 'A vector of character positions.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural[]'
          default:
          options:
    - name: 'excludeTaxa'
      return_type: 'void'
      usage: 'excludeTaxa(String|Taxon<any> taxon)'
      arguments:
        - label: 'taxon'
          description: 'The name(s) of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'excludeTaxa'
      return_type: 'void'
      usage: 'excludeTaxa(String[]|Taxon[]<any> taxa)'
      arguments:
        - label: 'taxa'
          description: 'The name(s) of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String[]'
          default:
          options:
    - name: 'filename'
      return_type: 'String'
      usage: 'filename()'
      arguments:
    - name: 'get'
      return_type: 'Real'
      usage: 'get(Natural<any> i, Natural<any> j)'
      arguments:
        - label: 'i'
          description: 'The index of the taxon.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'j'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'getIncludedCharacterIndices'
      return_type: 'Natural[]'
      usage: 'getIncludedCharacterIndices()'
      arguments:
    - name: 'getPairwiseSpeciesDifference'
      return_type: 'DistanceMatrix'
      usage: 'getPairwiseSpeciesDifference(Natural<any> charIndex)'
      arguments:
        - label: 'charIndex'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'getTaxon'
      return_type: 'ContinuousTaxonData'
      usage: 'getTaxon(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'includeAll'
      return_type: 'void'
      usage: 'includeAll()'
      arguments:
    - name: 'includeCharacter'
      return_type: 'void'
      usage: 'includeCharacter(Natural<any> )'
      arguments:
        - label:
          description: 'The position of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'includeCharacter'
      return_type: 'void'
      usage: 'includeCharacter(Natural[]<any> )'
      arguments:
        - label:
          description: 'A vector of character positions.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural[]'
          default:
          options:
    - name: 'includeTaxa'
      return_type: 'void'
      usage: 'includeTaxa(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'includeTaxa'
      return_type: 'void'
      usage: 'includeTaxa(String[]<any> names)'
      arguments:
        - label: 'names'
          description: 'The names of the taxa.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String[]'
          default:
          options:
    - name: 'isResolved'
      return_type: 'Bool'
      usage: 'isResolved(Natural<any> taxonIndex, Natural<any> charIndex)'
      arguments:
        - label: 'taxonIndex'
          description: 'The index of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'charIndex'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'isSequenceMissing'
      return_type: 'Bool'
      usage: 'isSequenceMissing(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'maxDifference'
      return_type: 'Real'
      usage: 'maxDifference(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'maxSpeciesDifference'
      return_type: 'Real'
      usage: 'maxSpeciesDifference(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'meanDifference'
      return_type: 'Real'
      usage: 'meanDifference(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'meanSpeciesDifference'
      return_type: 'Real'
      usage: 'meanSpeciesDifference(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'meanValue'
      return_type: 'Real'
      usage: 'meanValue(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'minDifference'
      return_type: 'Real'
      usage: 'minDifference(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'minSpeciesDifference'
      return_type: 'Real'
      usage: 'minSpeciesDifference(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'names'
      return_type: 'String[]'
      usage: 'names()'
      arguments:
    - name: 'nchar'
      return_type: 'Natural'
      usage: 'nchar()'
      arguments:
    - name: 'ntaxa'
      return_type: 'Natural'
      usage: 'ntaxa()'
      arguments:
    - name: 'percentageMissing'
      return_type: 'Probability'
      usage: 'percentageMissing(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'removeTaxa'
      return_type: 'void'
      usage: 'removeTaxa(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'removeTaxa'
      return_type: 'void'
      usage: 'removeTaxa(String[]<any> names)'
      arguments:
        - label: 'names'
          description: 'The names of the taxa.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String[]'
          default:
          options:
    - name: 'setHomeologPhase'
      return_type: 'void'
      usage: 'setHomeologPhase(String<any> data_name, String<any> tip_name)'
      arguments:
        - label: 'data_name'
          description: 'The name used in the character alignment.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'tip_name'
          description: 'The tip name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'setTaxonName'
      return_type: 'void'
      usage: 'setTaxonName(String<any> current, String<any> new)'
      arguments:
        - label: 'current'
          description: 'The old name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'new'
          description: 'The new name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'setTaxonObject'
      return_type: 'void'
      usage: 'setTaxonObject(String<any> current, Taxon<any> new)'
      arguments:
        - label: 'current'
          description: 'The old name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'new'
          description: 'The new name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon'
          default:
          options:
    - name: 'show'
      return_type: 'void'
      usage: 'show()'
      arguments:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
    - name: 'taxa'
      return_type: 'Taxon[]'
      usage: 'taxa()'
      arguments:
    - name: 'taxonIndex'
      return_type: 'Natural'
      usage: 'taxonIndex(String<any> name)'
      arguments:
        - label: 'name'
          description: 'he name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'var'
      return_type: 'RealPos'
      usage: 'var(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'varDifference'
      return_type: 'Real'
      usage: 'varDifference(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'varSpeciesDifference'
      return_type: 'Real'
      usage: 'varSpeciesDifference(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'withinSpeciesVar'
      return_type: 'RealPos'
      usage: 'withinSpeciesVar(Natural<any> species, Natural<any> site)'
      arguments:
        - label: 'species'
          description: 'The index of the species.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'site'
          description: 'The index of the character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  references:
- name: 'CorrespondenceAnalysis'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'CorrespondenceAnalysis(MatrixReal<any> data, Natural<any> numAxes, RealPos<any> tolerance)'
      arguments:
        - label: 'data'
          description: 'The matrix of numerical values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'MatrixReal'
          default:
          options:
        - label: 'numAxes'
          description: 'The number of principle components.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'tolerance'
          description: 'The allowed machine tolerance.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1e-07'
          options:
  methods:
    - name: 'columnCoordinates'
      return_type: 'MatrixReal'
      usage: 'columnCoordinates()'
      arguments:
    - name: 'columnWeights'
      return_type: 'RealPos[]'
      usage: 'columnWeights()'
      arguments:
    - name: 'principalAxes'
      return_type: 'MatrixReal'
      usage: 'principalAxes()'
      arguments:
    - name: 'rank'
      return_type: 'Natural'
      usage: 'rank()'
      arguments:
    - name: 'rowCoordinates'
      return_type: 'MatrixReal'
      usage: 'rowCoordinates()'
      arguments:
  references:
- name: 'DistanceMatrix'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: 'getElement'
      return_type: 'Real'
      usage: 'getElement(Natural<any> i, Natural<any> j)'
      arguments:
        - label: 'i'
          description: 'The row.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'j'
          description: 'The column.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'matrix'
      return_type: 'MatrixReal'
      usage: 'matrix()'
      arguments:
    - name: 'names'
      return_type: 'String[]'
      usage: 'names()'
      arguments:
    - name: 'setElement'
      return_type: 'void'
      usage: 'setElement(Natural<any> i, Natural<any> j, Real<any> v)'
      arguments:
        - label: 'i'
          description: 'The row.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'j'
          description: 'The column.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'v'
          description: 'The value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Real'
          default:
          options:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
    - name: 'symmetricMatrix'
      return_type: 'MatrixRealSymmetric'
      usage: 'symmetricMatrix()'
      arguments:
  references:
- name: 'HillClimber'
  title: 'Hill-Climber analysis object'
  aliases:
  description: 'The HillClimber analysis object keeps a model and the associated moves and monitors. The object is used to run Markov chain Monte Carlo (HillClimber) simulation on the model, using the provided moves, to obtain a sample of the posterior probability distribution. During the analysis, the monitors are responsible for sampling model parameters of interest.'
  details: ' The HillClimber analysis object produced by a call to this function keeps copies of the model and the associated moves and monitors. The HillClimber analysis object is used to run Markov chain Monte Carlo (HillClimber) simulation on the model, using the provided moves, to obtain a sample of the posterior probability distribution. During the analysis, the monitors are responsible for sampling model parameters of interest.'
  example: |
    # Create a simple model (unclamped)
    a ~ exponential(1)
    mymodel = model(a)
    
    # Create a move vector and a monitor vector
    moves[1] = mvScale(a, lambda=1.0, weight=1.0)
    monitors[1] = mnFile(a,"output/out.log")
    
    # Create an HillClimber object
    myHillClimberObject = HillClimber( mymodel, monitors, moves)
    
    # Run a short analysis
    myHillClimberObject.burnin( generations = 400, tuningInterval = 100)
    myHillClimberObject.run( generations = 400)
    
    # print the summary of the operators (now tuned)
    myHillClimberObject.operatorSummary()
  authors:
  see_also: 'SimulatedAnnealing'
  type_spec:
    - 'MaximumLikelihoodAnalysis'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'HillClimber(Model<any> model, Monitor[]<any> monitors, Move[]<any> moves, String<any> moveschedule {valid options: "sequential"|"random"|"single"})'
      arguments:
        - label: 'model'
          description: 'The model graph.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Model'
          default:
          options:
        - label: 'monitors'
          description: 'The monitors used for this analysis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Monitor[]'
          default:
          options:
        - label: 'moves'
          description: 'The moves used for this analysis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Move[]'
          default:
          options:
        - label: 'moveschedule'
          description: 'The strategy how the moves are used.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'random'
          options:
            - 'sequential'
            - 'random'
            - 'single'
  methods:
    - name: 'run'
      return_type: 'void'
      usage: 'run(RealPos<any> epsilon)'
      arguments:
        - label: 'epsilon'
          description: 'The minimum improvement in the last interval.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0.001'
          options:
    - name: 'variable'
      return_type: 'RevObject'
      usage: 'variable(String<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the variable.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
  references:
- name: 'Integer'
  title: 'Integer data type'
  aliases:
  description: 'All whole numbers, whether positive, negative, or zero.'
  details:
  example: |
    x = -1
    y ~ dnUniformInteger(1, 10)
  authors:
  see_also:
    - 'Natural'
    - 'Real'
  type_spec: 'RevObject'
  constructor:
  methods:
  references:
- name: 'IntegerPos'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Integer'
    - 'RevObject'
  constructor:
  methods:
  references:
- name: 'MatrixBoolean'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: '[]'
      return_type: 'Bool[]'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the row.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'column'
      return_type: 'Bool[]'
      usage: 'column(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the column.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'ncolumns'
      return_type: 'Natural'
      usage: 'ncolumns()'
      arguments:
    - name: 'nrows'
      return_type: 'Natural'
      usage: 'nrows()'
      arguments:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
  references:
- name: 'MatrixReal'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: '[]'
      return_type: 'Real[]'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the row.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'column'
      return_type: 'Real[]'
      usage: 'column(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the column.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'max'
      return_type: 'Real'
      usage: 'max()'
      arguments:
    - name: 'min'
      return_type: 'Real'
      usage: 'min()'
      arguments:
    - name: 'ncolumns'
      return_type: 'Natural'
      usage: 'ncolumns()'
      arguments:
    - name: 'nrows'
      return_type: 'Natural'
      usage: 'nrows()'
      arguments:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
  references:
- name: 'MatrixRealPos'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'MatrixReal'
    - 'RevObject'
  constructor:
  methods:
    - name: '[]'
      return_type: 'RealPos[]'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the row.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'column'
      return_type: 'RealPos[]'
      usage: 'column(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the column.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'max'
      return_type: 'RealPos'
      usage: 'max()'
      arguments:
    - name: 'min'
      return_type: 'RealPos'
      usage: 'min()'
      arguments:
    - name: 'ncolumns'
      return_type: 'Natural'
      usage: 'ncolumns()'
      arguments:
    - name: 'nrows'
      return_type: 'Natural'
      usage: 'nrows()'
      arguments:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
  references:
- name: 'MatrixRealSymmetric'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'MatrixReal'
    - 'RevObject'
  constructor:
  methods:
    - name: '[]'
      return_type: 'Real[]'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the row.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'column'
      return_type: 'Real[]'
      usage: 'column(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the column.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'diagonal'
      return_type: 'RealPos[]'
      usage: 'diagonal()'
      arguments:
    - name: 'max'
      return_type: 'Real'
      usage: 'max()'
      arguments:
    - name: 'min'
      return_type: 'Real'
      usage: 'min()'
      arguments:
    - name: 'ncolumns'
      return_type: 'Natural'
      usage: 'ncolumns()'
      arguments:
    - name: 'nrows'
      return_type: 'Natural'
      usage: 'nrows()'
      arguments:
    - name: 'precision'
      return_type: 'MatrixRealSymmetric'
      usage: 'precision()'
      arguments:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
    - name: 'upperTriangle'
      return_type: 'RealPos[]'
      usage: 'upperTriangle()'
      arguments:
  references:
- name: 'Natural'
  title: 'Natural number data type'
  aliases:
  description: 'All whole numbers greater than or equal to zero.'
  details:
  example: |
    x = 0
    y = 1
    z ~ dnUniformNatural(0, 2)
  authors:
  see_also:
    - 'Integer'
    - 'RealPos'
  type_spec:
    - 'Integer'
    - 'RevObject'
  constructor:
  methods:
  references:
- name: 'Probability'
  title: 'Probability data type'
  aliases:
  description: 'A `Probability` is a real value between 0.0 and 1.0 (inclusive).'
  details:
  example: |
    # Create a RealPos
    x <- 12/13
    type(x)
    
    # Convert the RealPos to Probability
    y := Probability(x)
    type(y)
  authors:
  see_also:
    - 'Real'
    - 'RealPos'
  type_spec:
    - 'RealPos'
    - 'Real'
    - 'RevObject'
  constructor:
    - usage: 'Probability(Real<any> x)'
      arguments:
        - label: 'x'
          description: 'The value.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
  methods:
  references:
- name: 'RateGenerator'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: 'getStateDescriptions'
      return_type: 'String[]'
      usage: 'getStateDescriptions()'
      arguments:
    - name: 'getTransitionProbabilities'
      return_type: 'RealPos[][]'
      usage: 'getTransitionProbabilities(RealPos<any> rate, RealPos<any> startAge, RealPos<any> endAge)'
      arguments:
        - label: 'rate'
          description: 'The rate of the process (or duration of the process assuming rate=1).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
        - label: 'startAge'
          description: 'The start age of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'endAge'
          description: 'The end age of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0'
          options:
  references:
- name: 'Real'
  title: 'Real number data type'
  aliases:
  description: |
    The real number data type can hold any real number value.
    Not to be confused with integers which are whole numbers, or
    `Natural` which are the counting numbers (e.g. 1,2,3,...).
  details:
  example: |
    a = 1.1
    b = 1.3
    c = a + b
    # c will be 2.4
  authors:
  see_also:
    - 'Integer'
    - 'Natural'
    - 'Probability'
    - 'RealPos'
  type_spec: 'RevObject'
  constructor:
  methods:
  references:
- name: 'RealPos'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Real'
    - 'RevObject'
  constructor:
  methods:
  references:
- name: 'RevObject'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
  constructor:
  methods:
  references:
- name: 'RlRegionalFeatureLayer'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: 'get'
      return_type: 'Natural[][]'
      usage: 'get()'
      arguments:
    - name: 'nLayers'
      return_type: 'String[]'
      usage: 'nLayers()'
      arguments:
  references:
- name: 'Simplex'
  title: 'Simplex'
  aliases: 'simplex'
  description: 'A simplex is a vector of elements that sum to 1.'
  details:
  example: |
    x <- simplex([2, 2, 6])
    x # = [ 0.2, 0.2, 0.6]
    sum(x) # 1, by definition
  authors:
  see_also:
    - 'mvBetaSimplex'
    - 'mvDirichletSimplex'
    - 'mvElementSwapSimplex'
  type_spec:
    - 'ModelObject'
    - 'RevObject'
  constructor:
    - usage: 'Simplex(RealPos[]<any> x, RealPos<any> x1, RealPos<any> x2, RealPos ...)'
      arguments:
        - label: 'x'
          description: 'A vector of values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'x1'
          description: 'first value'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'x2'
          description: 'second value'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label:
          description: 'additional values'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
  references:
- name: 'SiteMixtureModel'
  title: 'SiteMixtureModel'
  aliases:
  description: 'A weighted collection of discrete character evolution models.'
  details: |
    The SiteMixtureModel datatype is a mixture distribution where each
    component is a model of discrete character evolution.  Each character evolves
    according to one of the component models.  However, the specific model for each
    character is not specified in advance.  Instead, each character has some
    probability of choosing each component.  These probabilities are specified by
    the mixture weights.
  example: |
    M := fnInvASRV(fnGammaASRV(fnJC(4),alpha=1),pInv=0.1)
    M.weights()
    M.nComponents()
    M.rootFrequencies(1)
    
    # It possible to express nested models using pipes.
    M := fnJC(4) |> fnGammaASRV(alpha=1) |> fnInvASRV(pInv=0.1)
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: 'getTransitionProbabilities'
      return_type: 'RealPos[][][]'
      usage: 'getTransitionProbabilities(Tree<any> tree, Natural<any> node, RealPos<any> rate)'
      arguments:
        - label: 'tree'
          description: 'The mixture component index.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'node'
          description: 'The mixture component index.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'rate'
          description: 'The rate of the process (or duration of the process assuming rate=1).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'nComponents'
      return_type: 'Natural'
      usage: 'nComponents()'
      arguments:
    - name: 'nStates'
      return_type: 'Natural'
      usage: 'nStates()'
      arguments:
    - name: 'rate'
      return_type: 'RealPos'
      usage: 'rate()'
      arguments:
    - name: 'rootFrequencies'
      return_type: 'Simplex'
      usage: 'rootFrequencies(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The mixture component index.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'weights'
      return_type: 'Simplex'
      usage: 'weights()'
      arguments:
  references:
- name: 'StochasticMatrix'
  title:
  aliases: 'stochasticMatrix'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'MatrixReal'
    - 'RevObject'
  constructor:
    - usage: 'StochasticMatrix(Simplex[]<any> x)'
      arguments:
        - label: 'x'
          description: 'A vector of simplices. Each simplex corresponds to a row in the stochastic matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex[]'
          default:
          options:
  methods:
    - name: '[]'
      return_type: 'RealPos[]'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the row.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'column'
      return_type: 'RealPos[]'
      usage: 'column(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the column.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'ncolumns'
      return_type: 'Natural'
      usage: 'ncolumns()'
      arguments:
    - name: 'nrows'
      return_type: 'Natural'
      usage: 'nrows()'
      arguments:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
  references:
- name: 'String'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: '[]'
      return_type: 'String'
      usage: '[](Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the element.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'charAt'
      return_type: 'String'
      usage: 'charAt(Natural<any> index)'
      arguments:
        - label: 'index'
          description: 'The index of the element.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'find'
      return_type: 'Natural'
      usage: 'find(String<any> substr)'
      arguments:
        - label: 'substr'
          description: 'The substring for which we want to find the position.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'indexOf'
      return_type: 'Natural'
      usage: 'indexOf(String<any> substr)'
      arguments:
        - label: 'substr'
          description: 'The substring for which we want to find the position.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size()'
      arguments:
    - name: 'substr'
      return_type: 'String'
      usage: 'substr(Natural<any> begin, Natural<any> end)'
      arguments:
        - label: 'begin'
          description: 'The index of the first character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'end'
          description: 'The index of the last character.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  references:
- name: 'TimeTree'
  title: 'Tree datatype'
  aliases:
  description: 'The Tree datatype stores information to describe the shared ancestryof a taxon set. Information includes taxon labels, topology, nodecount, and branch lengths. Tree objects also possess several usefulmethods to traverse and manipulate the Tree''s value.'
  details:
  example:
  authors:
  see_also:
    - 'TimeTree'
    - 'BranchLengthTree'
  type_spec:
    - 'Tree'
    - 'RevObject'
  constructor:
  methods:
    - name: 'addFossil'
      return_type: 'void'
      usage: 'addFossil(Taxon<any> fossil, Taxon[]|Clade<any> clade)'
      arguments:
        - label: 'fossil'
          description: 'The fossil taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon'
          default:
          options:
        - label: 'clade'
          description: 'Vector of some/all of the taxa included in the clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
    - name: 'branchLength'
      return_type: 'RealPos'
      usage: 'branchLength(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'calculateEDR'
      return_type: 'RealPos[]'
      usage: 'calculateEDR()'
      arguments:
    - name: 'calculateMNTD'
      return_type: 'Real'
      usage: 'calculateMNTD(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex, Natural<any> site, Bool<any> zScore, Bool<any> useBranchLengths, Natural<any> randomizations)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Mean Nearest Taxon Distance.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The index of the character state.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'site'
          description: 'The index of the site in the alignment.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'zScore'
          description: 'Calculate the MNTD z-score or the observed MNTD?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'useBranchLengths'
          description: 'Should MNTD use branch length or nodal distances?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'randomizations'
          description: 'How many randomizations should be performed when calculating z-score?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
    - name: 'calculateMPD'
      return_type: 'Real'
      usage: 'calculateMPD(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex, Natural<any> site, Bool<any> zScore, Bool<any> useBranchLengths, Natural<any> randomizations)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Mean Phylogenetic Distance.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The index of the character state.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'site'
          description: 'The index of the site in the alignment.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'zScore'
          description: 'Calculate the MPD z-score or the observed MPD?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'useBranchLengths'
          description: 'Should MPD use branch length or nodal distances?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'randomizations'
          description: 'How many randomizations should be performed when calculating z-score?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
    - name: 'child'
      return_type: 'Natural'
      usage: 'child(Natural<any> node, Natural<any> index)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'index'
          description: 'The index of the child of this node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'collapseNegativeBranches'
      return_type: 'void'
      usage: 'collapseNegativeBranches(RealPos<any> length)'
      arguments:
        - label: 'length'
          description: 'The new length of all negative branches.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
    - name: 'colless'
      return_type: 'Natural'
      usage: 'colless()'
      arguments:
    - name: 'containsClade'
      return_type: 'Bool'
      usage: 'containsClade(Clade<any> clade)'
      arguments:
        - label: 'clade'
          description: 'The embracing clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
    - name: 'dropFossils'
      return_type: 'void'
      usage: 'dropFossils()'
      arguments:
    - name: 'dropTip'
      return_type: 'void'
      usage: 'dropTip(String|Taxon<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'fitchScore'
      return_type: 'Natural'
      usage: 'fitchScore(AbstractHomologousDiscreteCharacterData<any> characters)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Fitch Score.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
    - name: 'gammaStatistic'
      return_type: 'Real'
      usage: 'gammaStatistic()'
      arguments:
    - name: 'getClade'
      return_type: 'Clade'
      usage: 'getClade(Taxon[]|Clade<any> clade)'
      arguments:
        - label: 'clade'
          description: 'Vector of some of the taxa included in the clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
    - name: 'getDescendantTaxa'
      return_type: 'Taxon[]'
      usage: 'getDescendantTaxa(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'the index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'getFossils'
      return_type: 'Taxon[]'
      usage: 'getFossils()'
      arguments:
    - name: 'getIndices'
      return_type: 'Natural[]'
      usage: 'getIndices()'
      arguments:
    - name: 'getInverseES'
      return_type: 'RealPos[]'
      usage: 'getInverseES()'
      arguments:
    - name: 'getNodeIndex'
      return_type: 'Natural'
      usage: 'getNodeIndex(Clade<any> node)'
      arguments:
        - label: 'node'
          description: 'The clade representing this node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade'
          default:
          options:
    - name: 'getPSSP'
      return_type: 'RealPos[]'
      usage: 'getPSSP(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex)'
      arguments:
        - label: 'characters'
          description: 'The character alignment to use when computing the Parsimoniously Same State Paths (PSSP).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The state index.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'getRootIndex'
      return_type: 'Natural'
      usage: 'getRootIndex()'
      arguments:
    - name: 'hasSameTopology'
      return_type: 'Bool'
      usage: 'hasSameTopology(Tree<any> tree)'
      arguments:
        - label: 'tree'
          description: 'The reference tree.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
    - name: 'isBinary'
      return_type: 'Bool'
      usage: 'isBinary()'
      arguments:
    - name: 'isContainedInClade'
      return_type: 'Bool'
      usage: 'isContainedInClade(Natural<any> node, Clade<any> clade)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'clade'
          description: 'The embracing clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
    - name: 'isInternal'
      return_type: 'Bool'
      usage: 'isInternal(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'isRoot'
      return_type: 'Bool'
      usage: 'isRoot(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'meanInverseES'
      return_type: 'RealPos'
      usage: 'meanInverseES(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the mean inverse ES metric.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The state index.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'names'
      return_type: 'String[]'
      usage: 'names()'
      arguments:
    - name: 'nbranches'
      return_type: 'Natural'
      usage: 'nbranches()'
      arguments:
    - name: 'nnodes'
      return_type: 'Natural'
      usage: 'nnodes()'
      arguments:
    - name: 'nodeAge'
      return_type: 'RealPos'
      usage: 'nodeAge(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'nodeName'
      return_type: 'String'
      usage: 'nodeName(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'ntips'
      return_type: 'Natural'
      usage: 'ntips()'
      arguments:
    - name: 'numSampledAncestors'
      return_type: 'Natural'
      usage: 'numSampledAncestors()'
      arguments:
    - name: 'offset'
      return_type: 'void'
      usage: 'offset(RealPos<any> factor)'
      arguments:
        - label: 'factor'
          description: 'The offset factor.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'parent'
      return_type: 'Natural'
      usage: 'parent(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'removeDuplicateTaxa'
      return_type: 'void'
      usage: 'removeDuplicateTaxa()'
      arguments:
    - name: 'renumberNodes'
      return_type: 'void'
      usage: 'renumberNodes(Tree<any> referenceTree)'
      arguments:
        - label: 'referenceTree'
          description: 'Tree with identical topology but different node ids.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Tree'
          default:
          options:
    - name: 'reroot'
      return_type: 'void'
      usage: 'reroot(String|Clade<any> outgroup, Bool<any> makeBifurcating)'
      arguments:
        - label: 'outgroup'
          description: 'The leaf or clade to use as outgroup.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'makeBifurcating'
          description: 'Do we want a bifurcation at the root?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'rescale'
      return_type: 'void'
      usage: 'rescale(RealPos<any> factor)'
      arguments:
        - label: 'factor'
          description: 'The scaling factor.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'resolveMultifurcations'
      return_type: 'void'
      usage: 'resolveMultifurcations(Bool<any> resolveRoot)'
      arguments:
        - label: 'resolveRoot'
          description: 'Do we want a bifurcation at the root as well?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'rootAge'
      return_type: 'RealPos'
      usage: 'rootAge()'
      arguments:
    - name: 'setAge'
      return_type: 'void'
      usage: 'setAge(Natural<any> index, RealPos<any> value)'
      arguments:
        - label: 'index'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'value'
          description: 'The new age value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'setBranchLength'
      return_type: 'void'
      usage: 'setBranchLength(Natural<any> index, RealPos<any> value)'
      arguments:
        - label: 'index'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'value'
          description: 'The new branch length value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'setNegativeConstraint'
      return_type: 'void'
      usage: 'setNegativeConstraint(Bool<any> flag)'
      arguments:
        - label: 'flag'
          description: 'Is the tree a negative constraint?.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'setTaxonName'
      return_type: 'void'
      usage: 'setTaxonName(String<any> current, String<any> new)'
      arguments:
        - label: 'current'
          description: 'The old name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'new'
          description: 'The new name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'suppressOutdegreeOneNodes'
      return_type: 'void'
      usage: 'suppressOutdegreeOneNodes(Bool<any> replace)'
      arguments:
        - label: 'replace'
          description: 'Should we replace outdegree-1 nodes with bifurcations plus zero-length branches, or should we remove them altogether?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'taxa'
      return_type: 'Taxon[]'
      usage: 'taxa()'
      arguments:
    - name: 'tipIndex'
      return_type: 'Natural'
      usage: 'tipIndex(String|Taxon<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the tip/taxon.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'treeLength'
      return_type: 'RealPos'
      usage: 'treeLength()'
      arguments:
    - name: 'unroot'
      return_type: 'BranchLengthTree'
      usage: 'unroot()'
      arguments:
  references:
- name: 'Trace'
  title: 'Trace of numeric parameter values.'
  aliases:
  description: 'Corresponds to a single column of a log file, usually produced by the `mnModel` monitor in an MCMC or MCMCMC run.'
  details: |
    Method description:
    
    - `getBurnin()`: Return the number of samples that were discarded as burnin, after thinning.
    - `getValues()`: Return a vector (e.g. `Real[]`) containing the values of the sampled parameter,
      after excluding burnin samples.
    - `setBurnin()`: Modify the number (if >= 1) or fraction (if < 1) of samples to discard as burnin, after thinning.
    - `size()`, `getNumberSamples()`: Report the number of values stored in `trace`,
      including (`post = FALSE`) or excluding (`post = TRUE`) burnin samples.
    - `summarize()`: Display summary statistics of trace.
  example: |
    # Read in a log file as a vector of traces
    traces = readTrace("out.log", burnin = 0)
    
    # Get the posterior trace (2nd column in the log file)
    posterior = traces[2]
    posterior.getBurnin() # will return 0
    
    # Change burnin from 0 to 50 samples
    posterior.setBurnin(50)
    posterior.getBurnin() # will return 50
    
    # Get summary statistics
    posterior.summarize()
  authors:
  see_also:
    - 'mnModel'
    - 'readTrace'
    - 'TraceTree'
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
  methods:
    - name: 'getBurnin'
      return_type: 'Natural'
      usage: 'getBurnin()'
      arguments:
    - name: 'getNumberSamples'
      return_type: 'Natural'
      usage: 'getNumberSamples(Bool<any> post)'
      arguments:
        - label: 'post'
          description: 'Get the post-burnin number of samples?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'getValues'
      return_type: 'void'
      usage: 'getValues()'
      arguments:
    - name: 'setBurnin'
      return_type: 'void'
      usage: 'setBurnin(Probability|Integer<any> burnin)'
      arguments:
        - label: 'burnin'
          description: 'The fraction/number of samples to disregard as burnin.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default:
          options:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size(Bool<any> post)'
      arguments:
        - label: 'post'
          description: 'Get the post-burnin number of samples?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'summarize'
      return_type: 'void'
      usage: 'summarize()'
      arguments:
  references:
- name: 'TraceTree'
  title: 'Trace of trees.'
  aliases:
  description: |
    Stores a tree trace, usually produced by passing a variable of type `Tree` to
    the `mnFile` monitor in an MCMC or MCMCMC run.
  details: |
    Individual trees can be accessed as follows:
    
    - `getTree(n)`: returns the `n`th tree.
    - `getTree(n, post=TRUE)`: returns the `n`th post-burnin tree.
    - `getTrees()`: returns the entire vector of post-burnin trees.
          
    The methods `.computeEntropy()`, `.computePairwiseRFDistances`,
    `.getUniqueTrees()`, `.isTreeCovered()`, and `.summarize()` first construct
    a credible set of trees, and then perform the corresponding operation on this
    set. A credible set is constructed by ordering all trees in the trace by their
    posterior probability, and adding them to the set one by one until the included
    trees accumulate the desired probability specified by `credibleTreeSetSize`.
    By default, this argument is set to 0.95; to perform a given operation on all
    trees in the trace, set it to 1.
    
    The credible set methods also take a `probabilistic` argument that determines
    how the credible set should be constructed when it is not possible to obtain a
    cumulative probability precisely equal to `credibleTreeSetSize`. This will be
    the case when the probability p of the first n trees falls short of it, and the
    probability (p + q) of the first n + 1 trees exceeds it (Huelsenbeck & Rannala
    2004). If `probabilistic=TRUE` (default), the (n + 1)-th tree will be included
    in the set with probability (`credibleTreeSetSize` - p) / q. It will always be
    included if `probabilistic=FALSE`. Note that when `probabilistic=TRUE`, the
    methods in question may yield different results under different random seeds,
    and they may even construct an empty credible set a certain fraction of the
    time if the trace is dominated by a particular tree whose probability exceeds
    `credibleTreeSetSize`. An exception is thrown when an empty credible set is
    encountered by a method that does not expect one.
  example: |
    # read a tree trace and ignore the first 10 samples
    thinned_trees = readTreeTrace("my_filename.tree", offset = 10, thinning = 10, burnin = 0.5)
    
    thinned_trees.getTree(1) # Returns the 11th tree (offset + 1) in the file
    thinned_trees.getTree(2) # Returns the 21st tree (offset + 1 + thinning) in the file
    
    thinned_trees.getTrees()[1] # Returns the first sampled tree after excluding the burnin fraction
  authors:
  see_also:
    - 'mnFile'
    - 'readAncestralStateTreeTrace'
    - 'readTreeTrace'
    - 'Trace'
    - 'Tree'
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
  methods:
    - name: 'cladeProbability'
      return_type: 'Probability'
      usage: 'cladeProbability(Clade<any> clade, Bool<any> verbose)'
      arguments:
        - label: 'clade'
          description: 'The clade whose probability is to be computed.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
    - name: 'computeEntropy'
      return_type: 'RealPos'
      usage: 'computeEntropy(Probability<any> credibleTreeSetSize, Bool<any> probabilistic, Bool<any> verbose)'
      arguments:
        - label: 'credibleTreeSetSize'
          description: 'The cumulative probability of trees to be included in the credible set.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.95'
          options:
        - label: 'probabilistic'
          description: 'Should we construct the credible set probabilistically if we cannot obtain a cumulative probability precisely equal to credibleTreeSetSize?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
    - name: 'computePairwiseRFDistances'
      return_type: 'RealPos[]'
      usage: 'computePairwiseRFDistances(Probability<any> credibleTreeSetSize, Bool<any> probabilistic, Bool<any> verbose)'
      arguments:
        - label: 'credibleTreeSetSize'
          description: 'The cumulative probability of trees to be included in the credible set.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.95'
          options:
        - label: 'probabilistic'
          description: 'Should we construct the credible set probabilistically if we cannot obtain a cumulative probability precisely equal to credibleTreeSetSize?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
    - name: 'computeTreeLengths'
      return_type: 'RealPos[]'
      usage: 'computeTreeLengths()'
      arguments:
    - name: 'getBurnin'
      return_type: 'Natural'
      usage: 'getBurnin()'
      arguments:
    - name: 'getNumberSamples'
      return_type: 'Natural'
      usage: 'getNumberSamples(Bool<any> post)'
      arguments:
        - label: 'post'
          description: 'Get the post-burnin number of samples?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'getTMRCA'
      return_type: 'Real[]'
      usage: 'getTMRCA(Clade<any> clade, Bool<any> strict, Bool<any> stem)'
      arguments:
        - label: 'clade'
          description: 'A clade object containing the taxa whose TMRCA (time to the most recent common ancestor) is to be computed.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
        - label: 'strict'
          description: 'Do not report the TMRCA of given taxa for those trees in which the taxa do not form an exclusive clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'stem'
          description: 'Do we want the age of the stem or crown of this clade?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'getTopologyFrequency'
      return_type: 'RealPos'
      usage: 'getTopologyFrequency(Tree<any> tree, Bool<any> verbose)'
      arguments:
        - label: 'tree'
          description: 'The tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Tree'
          default:
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
    - name: 'getTree'
      return_type: 'Tree'
      usage: 'getTree(Natural<any> index, Bool<any> post)'
      arguments:
        - label: 'index'
          description: 'The index of the tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'post'
          description: 'Use post-burnin indices?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'getTrees'
      return_type: 'Tree[]'
      usage: 'getTrees()'
      arguments:
    - name: 'getUniqueClades'
      return_type: 'Clade[]'
      usage: 'getUniqueClades(Probability<any> minCladeProbability, Bool<any> nonTrivial, Bool<any> verbose)'
      arguments:
        - label: 'minCladeProbability'
          description: 'List only clades with a probability above this threshold.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.05'
          options:
        - label: 'nonTrivial'
          description: 'Retrieve only the non-trivial clades.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
    - name: 'getUniqueTrees'
      return_type: 'Tree[]'
      usage: 'getUniqueTrees(Probability<any> credibleTreeSetSize, Bool<any> probabilistic, Bool<any> verbose)'
      arguments:
        - label: 'credibleTreeSetSize'
          description: 'The cumulative probability of trees to be included in the credible set.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.95'
          options:
        - label: 'probabilistic'
          description: 'Should we construct the credible set probabilistically if we cannot obtain a cumulative probability precisely equal to credibleTreeSetSize?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
    - name: 'isTreeCovered'
      return_type: 'Bool'
      usage: 'isTreeCovered(Tree<any> tree, Probability<any> credibleTreeSetSize, Bool<any> probabilistic, Bool<any> verbose)'
      arguments:
        - label: 'tree'
          description: 'The tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Tree'
          default:
          options:
        - label: 'credibleTreeSetSize'
          description: 'The size of the credible set.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.95'
          options:
        - label: 'probabilistic'
          description: 'Should we construct the credible set probabilistically if we cannot obtain a cumulative probability precisely equal to credibleTreeSetSize?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
    - name: 'jointCladeProbability'
      return_type: 'Probability'
      usage: 'jointCladeProbability(Clade[]<any> clades, Bool<any> verbose)'
      arguments:
        - label: 'clades'
          description: 'The set of clades whose joint probability is to be computed.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade[]'
          default:
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
    - name: 'setBurnin'
      return_type: 'void'
      usage: 'setBurnin(Probability|Integer<any> burnin)'
      arguments:
        - label: 'burnin'
          description: 'The fraction/number of samples to disregard as burnin.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default:
          options:
    - name: 'setOutgroup'
      return_type: 'void'
      usage: 'setOutgroup(Clade<any> clade)'
      arguments:
        - label: 'clade'
          description: 'The (monophyletic) outgroup.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
    - name: 'size'
      return_type: 'Natural'
      usage: 'size(Bool<any> post)'
      arguments:
        - label: 'post'
          description: 'Get the post-burnin number of samples?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'summarize'
      return_type: 'void'
      usage: 'summarize(Probability<any> credibleTreeSetSize, Probability<any> minCladeProbability, Bool<any> probabilistic, Bool<any> verbose)'
      arguments:
        - label: 'credibleTreeSetSize'
          description: 'The cumulative probability of trees to be included in the credible set.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.95'
          options:
        - label: 'minCladeProbability'
          description: 'Print only clades with a probability above this threshold.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.05'
          options:
        - label: 'probabilistic'
          description: 'Should we construct the credible set probabilistically if we cannot obtain a cumulative probability precisely equal to credibleTreeSetSize?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'verbose'
          description: 'Printing verbose output.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  references:
    - citation: 'Huelsenbeck JP, Rannala B (2004). Frequentist properties of Bayesian posterior probabilities of phylogenetic trees under simple and complex substitution models. Systematic Biology, 53(6):904-913.'
      doi: '10.1080/10635150490522629'
      url: 'https://academic.oup.com/sysbio/article-abstract/53/6/904/1651356'
- name: 'Tree'
  title: 'Tree datatype'
  aliases:
  description: 'The Tree datatype stores information to describe the shared ancestryof a taxon set. Information includes taxon labels, topology, nodecount, and branch lengths. Tree objects also possess several usefulmethods to traverse and manipulate the Tree''s value.'
  details:
  example:
  authors:
  see_also:
    - 'TimeTree'
    - 'BranchLengthTree'
  type_spec: 'RevObject'
  constructor:
  methods:
    - name: 'addFossil'
      return_type: 'void'
      usage: 'addFossil(Taxon<any> fossil, Taxon[]|Clade<any> clade)'
      arguments:
        - label: 'fossil'
          description: 'The fossil taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon'
          default:
          options:
        - label: 'clade'
          description: 'Vector of some/all of the taxa included in the clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
    - name: 'branchLength'
      return_type: 'RealPos'
      usage: 'branchLength(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'calculateEDR'
      return_type: 'RealPos[]'
      usage: 'calculateEDR()'
      arguments:
    - name: 'calculateMNTD'
      return_type: 'Real'
      usage: 'calculateMNTD(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex, Natural<any> site, Bool<any> zScore, Bool<any> useBranchLengths, Natural<any> randomizations)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Mean Nearest Taxon Distance.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The index of the character state.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'site'
          description: 'The index of the site in the alignment.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'zScore'
          description: 'Calculate the MNTD z-score or the observed MNTD?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'useBranchLengths'
          description: 'Should MNTD use branch length or nodal distances?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'randomizations'
          description: 'How many randomizations should be performed when calculating z-score?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
    - name: 'calculateMPD'
      return_type: 'Real'
      usage: 'calculateMPD(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex, Natural<any> site, Bool<any> zScore, Bool<any> useBranchLengths, Natural<any> randomizations)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Mean Phylogenetic Distance.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The index of the character state.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'site'
          description: 'The index of the site in the alignment.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'zScore'
          description: 'Calculate the MPD z-score or the observed MPD?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'useBranchLengths'
          description: 'Should MPD use branch length or nodal distances?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'randomizations'
          description: 'How many randomizations should be performed when calculating z-score?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
    - name: 'child'
      return_type: 'Natural'
      usage: 'child(Natural<any> node, Natural<any> index)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'index'
          description: 'The index of the child of this node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'containsClade'
      return_type: 'Bool'
      usage: 'containsClade(Clade<any> clade)'
      arguments:
        - label: 'clade'
          description: 'The embracing clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
    - name: 'dropTip'
      return_type: 'void'
      usage: 'dropTip(String|Taxon<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'fitchScore'
      return_type: 'Natural'
      usage: 'fitchScore(AbstractHomologousDiscreteCharacterData<any> characters)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the Fitch Score.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
    - name: 'getClade'
      return_type: 'Clade'
      usage: 'getClade(Taxon[]|Clade<any> clade)'
      arguments:
        - label: 'clade'
          description: 'Vector of some of the taxa included in the clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
    - name: 'getDescendantTaxa'
      return_type: 'Taxon[]'
      usage: 'getDescendantTaxa(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'the index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'getIndices'
      return_type: 'Natural[]'
      usage: 'getIndices()'
      arguments:
    - name: 'getInverseES'
      return_type: 'RealPos[]'
      usage: 'getInverseES()'
      arguments:
    - name: 'getNodeIndex'
      return_type: 'Natural'
      usage: 'getNodeIndex(Clade<any> node)'
      arguments:
        - label: 'node'
          description: 'The clade representing this node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade'
          default:
          options:
    - name: 'getPSSP'
      return_type: 'RealPos[]'
      usage: 'getPSSP(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex)'
      arguments:
        - label: 'characters'
          description: 'The character alignment to use when computing the Parsimoniously Same State Paths (PSSP).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The state index.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'getRootIndex'
      return_type: 'Natural'
      usage: 'getRootIndex()'
      arguments:
    - name: 'hasSameTopology'
      return_type: 'Bool'
      usage: 'hasSameTopology(Tree<any> tree)'
      arguments:
        - label: 'tree'
          description: 'The reference tree.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
    - name: 'isBinary'
      return_type: 'Bool'
      usage: 'isBinary()'
      arguments:
    - name: 'isContainedInClade'
      return_type: 'Bool'
      usage: 'isContainedInClade(Natural<any> node, Clade<any> clade)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'clade'
          description: 'The embracing clade.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default:
          options:
    - name: 'isInternal'
      return_type: 'Bool'
      usage: 'isInternal(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'meanInverseES'
      return_type: 'RealPos'
      usage: 'meanInverseES(AbstractHomologousDiscreteCharacterData<any> characters, Natural<any> stateIndex)'
      arguments:
        - label: 'characters'
          description: 'The character alignment from which to compute the mean inverse ES metric.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'stateIndex'
          description: 'The state index.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'names'
      return_type: 'String[]'
      usage: 'names()'
      arguments:
    - name: 'nbranches'
      return_type: 'Natural'
      usage: 'nbranches()'
      arguments:
    - name: 'nnodes'
      return_type: 'Natural'
      usage: 'nnodes()'
      arguments:
    - name: 'nodeName'
      return_type: 'String'
      usage: 'nodeName(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'ntips'
      return_type: 'Natural'
      usage: 'ntips()'
      arguments:
    - name: 'offset'
      return_type: 'void'
      usage: 'offset(RealPos<any> factor)'
      arguments:
        - label: 'factor'
          description: 'The offset factor.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'parent'
      return_type: 'Natural'
      usage: 'parent(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'removeDuplicateTaxa'
      return_type: 'void'
      usage: 'removeDuplicateTaxa()'
      arguments:
    - name: 'renumberNodes'
      return_type: 'void'
      usage: 'renumberNodes(Tree<any> referenceTree)'
      arguments:
        - label: 'referenceTree'
          description: 'Tree with identical topology but different node ids.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Tree'
          default:
          options:
    - name: 'reroot'
      return_type: 'void'
      usage: 'reroot(String|Clade<any> outgroup, Bool<any> makeBifurcating)'
      arguments:
        - label: 'outgroup'
          description: 'The leaf or clade to use as outgroup.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'makeBifurcating'
          description: 'Do we want a bifurcation at the root?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'rescale'
      return_type: 'void'
      usage: 'rescale(RealPos<any> factor)'
      arguments:
        - label: 'factor'
          description: 'The scaling factor.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'resolveMultifurcations'
      return_type: 'void'
      usage: 'resolveMultifurcations(Bool<any> resolveRoot)'
      arguments:
        - label: 'resolveRoot'
          description: 'Do we want a bifurcation at the root as well?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'setBranchLength'
      return_type: 'void'
      usage: 'setBranchLength(Natural<any> index, RealPos<any> value)'
      arguments:
        - label: 'index'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'value'
          description: 'The new branch length value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
    - name: 'setNegativeConstraint'
      return_type: 'void'
      usage: 'setNegativeConstraint(Bool<any> flag)'
      arguments:
        - label: 'flag'
          description: 'Is the tree a negative constraint?.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'setTaxonName'
      return_type: 'void'
      usage: 'setTaxonName(String<any> current, String<any> new)'
      arguments:
        - label: 'current'
          description: 'The old name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'new'
          description: 'The new name.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
    - name: 'suppressOutdegreeOneNodes'
      return_type: 'void'
      usage: 'suppressOutdegreeOneNodes(Bool<any> replace)'
      arguments:
        - label: 'replace'
          description: 'Should we replace outdegree-1 nodes with bifurcations plus zero-length branches, or should we remove them altogether?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'taxa'
      return_type: 'Taxon[]'
      usage: 'taxa()'
      arguments:
    - name: 'tipIndex'
      return_type: 'Natural'
      usage: 'tipIndex(String|Taxon<any> name)'
      arguments:
        - label: 'name'
          description: 'The name of the tip/taxon.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'treeLength'
      return_type: 'RealPos'
      usage: 'treeLength()'
      arguments:
  references:
- name: '_add'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: '_add(Distribution__RealPos|Distribution__Probability<any> baseDistribution, RealPos<any> delta)'
      arguments:
        - label: 'baseDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__RealPos'
          default:
          options:
        - label: 'delta'
          description: 'The amount added to base random variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: '_mul'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Probability'
  constructor:
    - usage: '_mul(Distribution__Probability<any> baseDistribution, Probability<any> lambda)'
      arguments:
        - label: 'baseDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Probability'
          default:
          options:
        - label: 'lambda'
          description: 'The amount muled to base random variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: '_sub'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: '_sub(Distribution__Real|Distribution__RealPos|Distribution__Probability<any> firstDistribution, Real<any> second)'
      arguments:
        - label: 'firstDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
        - label: 'second'
          description: 'The amount sub1ed to base random variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
  methods:
  references:
- name: 'beca'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'beca(String|String[]<any> filename, String<any> separator)'
      arguments:
        - label: 'filename'
          description: 'The name of the file with the parameter samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'separator'
          description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
  methods:
    - name: 'run'
      return_type: 'void'
      usage: 'run()'
      arguments:
    - name: 'setBurninMethod'
      return_type: 'void'
      usage: 'setBurninMethod(String<any> method {valid options: "ESS"|"SEM"})'
      arguments:
        - label: 'method'
          description: 'The burnin estimation method.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
            - 'ESS'
            - 'SEM'
    - name: 'verbose'
      return_type: 'void'
      usage: 'verbose(Bool<any> x)'
      arguments:
        - label: 'x'
          description: 'Should the output be verbose?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
  references:
- name: 'clade'
  title: 'Clade'
  aliases:
  description: 'A clade is a subtree within a phylogeny.'
  details: 'Clades are defined in terms of a taxon set and a shared tree topology. In phylogenetic analyses, clades are generally used (a) to constrain tree topologies to match provided taxon relationships, (b) to identify the most recent common ancestor of a taxon set within a phylogeny, or (c) to apply node age calibrations on particular nodes in the phylogeny.'
  example: |
    # read in a tree
    phy = readTrees("primates.tre")[1]
    # get taxa from the tree
    taxa = phy.taxa()
    # create a clade for (1,2) using taxon objects
    clade_12 = clade( taxa[1], taxa[2] )
    # create a clade for (1,2,3)
    clade_123 = clade( taxa[3], clade_12 )
    # create a clade for (4,5) using taxon names
    clade_45 = clade( "Taxon_4", "Taxon_5" )
    # create a negative clade constraint
    clade_not_23 = clade( taxa[2], taxa[3], negative=true )
    # create an optional clade constraint
    clade_67 = clade( taxa[6], taxa[7] )
    clade_68 = clade( taxa[6], taxa[8] )
    clade_67_or_68 = clade( clade_67, clade_68, optional_match=true )
  authors:
  see_also:
    - 'dnConstrainedTopology'
    - 'tmrca'
    - 'mrcaIndex'
  type_spec:
    - 'ModelObject'
    - 'RevObject'
  constructor:
    - usage: 'clade(String ..., String[] ..., Clade ..., Taxon ..., Taxon[] ..., RealPos<any> age, String<any> name, Natural<any> missing, Bool<any> negative, Bool<any> optional_match)'
      arguments:
        - label:
          description: 'Taxon names as string values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
        - label:
          description: 'Taxon names as a vector of string values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String[]'
          default:
          options:
        - label:
          description: 'Taxa as clade objects.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade'
          default:
          options:
        - label:
          description: 'Taxon names as taxon values'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon'
          default:
          options:
        - label:
          description: 'Taxon names as a vector of taxons'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'age'
          description: 'The age of the clade (optional).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'name'
          description: 'The name of the clade (optional).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'NULL'
          options:
        - label: 'missing'
          description: 'Number of missing taxa in the clade (optional).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: 'NULL'
          options:
        - label: 'negative'
          description: 'Is this a negative clade constraint?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'optional_match'
          description: 'Clade constraint satisfied when any Clade argument matched'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'getAge'
      return_type: 'RealPos'
      usage: 'getAge()'
      arguments:
    - name: 'getCladeName'
      return_type: 'String'
      usage: 'getCladeName()'
      arguments:
    - name: 'getNumberOfTaxaMissing'
      return_type: 'Natural'
      usage: 'getNumberOfTaxaMissing()'
      arguments:
    - name: 'getTaxon'
      return_type: 'Taxon'
      usage: 'getTaxon(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'getTaxonName'
      return_type: 'String'
      usage: 'getTaxonName(Natural<any> node)'
      arguments:
        - label: 'node'
          description: 'The index of the node.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'setAge'
      return_type: 'void'
      usage: 'setAge(RealPos<any> a)'
      arguments:
        - label: 'a'
          description: 'The age of the clade.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
    - name: 'setCladeName'
      return_type: 'void'
      usage: 'setCladeName(String<any> x)'
      arguments:
        - label: 'x'
          description: 'The name of the clade.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'setNumberOfTaxaMissing'
      return_type: 'void'
      usage: 'setNumberOfTaxaMissing(Natural<any> n)'
      arguments:
        - label: 'n'
          description: 'The number of missing taxa.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
    - name: 'size'
      return_type: 'void'
      usage: 'size()'
      arguments:
  references:
- name: 'dfConstant'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'DemographicFunction'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'dfConstant(RealPos<any> theta)'
      arguments:
        - label: 'theta'
          description: 'The population size.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dfExponential'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'DemographicFunction'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'dfExponential(RealPos<any> N0, RealPos<any> N1, RealPos<any> t0, RealPos<any> t1)'
      arguments:
        - label: 'N0'
          description: 'The population size at the beginning of the growth period (towards the present).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'N1'
          description: 'The population size at the end of the growth period (towards the past).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 't0'
          description: 'The time of the beginning of the growth period (towards the present).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 't1'
          description: 'The time of the end of the growth period (towards the past).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dfLinear'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'DemographicFunction'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'dfLinear(RealPos<any> N0, RealPos<any> N1, RealPos<any> t0, RealPos<any> t1)'
      arguments:
        - label: 'N0'
          description: 'The population size at the beginning of the growth period (towards the present).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'N1'
          description: 'The population size at the end of the growth period (towards the past).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 't0'
          description: 'The time of the beginning of the growth period (towards the present).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 't1'
          description: 'The time of the end of the growth period (towards the past).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnAutocorrelatedEvent'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__MultiValueEvent'
    - 'Distribution'
    - 'RevObject'
  domain: 'MultiValueEvent'
  constructor:
    - usage: 'dnAutocorrelatedEvent(Distribution__Natural<any> eventDistribution, Distribution[]<any> valueDistribution, String[]<any> names, Natural[]<any> minNumberEvents, String[]<any> autocorrelationTypes, String[]<any> autocorrelationDependencies, RealPos[]<any> autocorrelationSigmas, String<any> sort)'
      arguments:
        - label: 'eventDistribution'
          description: 'The prior on the number of events.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Natural'
          default:
          options:
        - label: 'valueDistribution'
          description: 'The base distribution for the per category values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution[]'
          default:
          options:
        - label: 'names'
          description: 'The names of the values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String[]'
          default:
          options:
        - label: 'minNumberEvents'
          description: 'The minum number of values per value category.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural[]'
          default:
          options:
        - label: 'autocorrelationTypes'
          description: 'The autocorrelation types per variables. Allowed values are NONE|ACN|ACLN.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String[]'
          default:
          options:
        - label: 'autocorrelationDependencies'
          description: 'The autocorrelation dependencies per variables. This is important if you want autocorrelation to be time-dependent. Allowed values are NONE or the name of another variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String[]'
          default:
          options:
        - label: 'autocorrelationSigmas'
          description: 'The standard deviation parameters of the autocorrelated variables.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'sort'
          description: 'The name of the variable to sort by. For example, if you want to enforce sorting by time the you need to specify the name of your time variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default: 'none'
          options:
  methods:
  references:
- name: 'dnBernoulli'
  title: 'Bernoulli Distribution'
  aliases:
  description: 'The Bernoulli distribution represents a weighted coin toss.'
  details: 'The Bernoulli distribution takes a parameter p, between 0 and 1, and returns 1 with probability p and 0 with probability (1 - p).'
  example: |
    p ~ dnBeta(1.0,1.0)
    x ~ dnBernoulli(p)
    x.clamp(1)
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", x)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also: 'dnBinomial'
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural'
  constructor:
    - usage: 'dnBernoulli(Probability<any> p)'
      arguments:
        - label: 'p'
          description: 'The probability of success.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'dnBeta'
  title: 'Beta Distribution'
  aliases:
  description: 'The Beta distribution is a flexible distribution that returns a number between 0 and 1, so it is often used as a distribution for probabilities themselves.'
  details: |
    The Beta distribution takes two parameters, alpha and beta. It is equivalent to the uniform when alpha = beta = 1. 
    
    The probability density function is f(x) = x^(alpha - 1) * (1 - x)^(beta - 1) * Gamma(alpha + beta) / (Gamma(alpha) * Gamma(beta)), where Gamma is the gamma function.
  example: |
    p ~ dnBeta(1.0, 1.0)
    x ~ dnBernoulli(p)
    x.clamp(1)
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = mnScreen(p, printgen=1000)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000, tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also:
    - 'dnDirichlet'
    - 'dnGamma'
  type_spec:
    - 'ProbabilityContinuousDistribution'
    - 'Distribution__Probability'
    - 'Distribution'
    - 'RevObject'
  domain: 'Probability'
  constructor:
    - usage: 'dnBeta(RealPos<any> alpha, RealPos<any> beta)'
      arguments:
        - label: 'alpha'
          description: 'The alpha shape parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'beta'
          description: 'The beta shape parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnBimodalLognormal'
  title: 'Bimodal Lognormal Distribution'
  aliases:
  description: 'The Bimodal Lognormal distribution unites two separate lognormal distributions.'
  details: 'The bimodal lognormal distribution takes five parameters: mean1 and mean2 (the means (in log-space) of the two lognormal distributions), sd1 and sd2 (the standard deviations (in log-space) of the two lognormal distributions), and p (between 0 and 1). The value will be distributed according to the first lognormal distribution with probability p, and distributed according to the second lognormal distribution with probability (1 - p).'
  example: |
    p ~ dnBeta(1.0,1.0)
    x ~ dnBimodalLognormal(mean1=-1,mean2=1,sd1=0.1,sd2=0.1,p=p)
    x.clamp( exp(1) )
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", x)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also:
    - 'dnBimodalNormal'
    - 'dnLognormal'
  type_spec:
    - 'PositiveContinuousDistribution'
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnBimodalLognormal(Real<any> mean1, Real<any> mean2, RealPos<any> sd1, RealPos<any> sd2, Probability<any> p)'
      arguments:
        - label: 'mean1'
          description: 'The mean (in log-space) of the first lognormal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'mean2'
          description: 'The mean (in log-space) of the second lognormal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'sd1'
          description: 'The standard deviation (in log-space) of the first lognormal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'sd2'
          description: 'The standard deviation (in log-space) of the second lognormal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'p'
          description: 'The probability to belong to the first distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'dnBimodalNormal'
  title: 'Bimodal Normal dsitribution'
  aliases:
  description: 'The Bimodal Normal distribution unites two separate normal distributions.'
  details: 'The bimodal normal distribution takes five parameters: mean1 and mean2 (the means of two normal distributions), sd1 and sd2 (the standard deviations of two normal distributions), and p (between 0 and 1). The value will be distributed according to the first normal distribution with probability p, and distributed according to the second normal distribution with probability (1 - p).'
  example: |
    p ~ dnBeta(1.0,1.0)
    x ~ dnBimodalNormal(mean1=-1,mean2=1,sd1=0.1,sd2=0.1,p=p)
    x.clamp( 1 )
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", x)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also:
    - 'dnBimodalLognormal'
    - 'dnNormal'
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnBimodalNormal(Real<any> mean1, Real<any> mean2, RealPos<any> sd1, RealPos<any> sd2, Probability<any> p)'
      arguments:
        - label: 'mean1'
          description: 'Mean of the first normal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'mean2'
          description: 'Mean of the second normal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'sd1'
          description: 'Standard deviation of the first normal distributin.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'sd2'
          description: 'Standard deviation of the second normal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'p'
          description: 'Probability that the value belongs to the first normal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'dnBinomial'
  title: 'Binomial Distribution'
  aliases: 'dnBinom'
  description: 'The Binomial probability distribution describes the probability of a number of successes for an experiment with a certain number of trials and probability of success per trial.'
  details: |
    The binomial distribution takes two parameters, p and size. It defines the number of successes in size trials, where each trial has the same success probability p. 
    
    The probability density function is f(x) =  choose(size,x) * p^(x) * (1-p)^(size-p).
  example: |
    p ~ dnBeta(1.0,1.0)
    x ~ dnBinomial(size=10,p)
    x.clamp(8)
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", x)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also: 'dnBernoulli'
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural'
  constructor:
    - usage: 'dnBinomial(Probability<any> p, Natural<any> size)'
      arguments:
        - label: 'p'
          description: 'Probability of success.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
        - label: 'size'
          description: 'Number of trials.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'dnBirthDeath'
  title:
  aliases: 'dnBDP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnBirthDeath(RealPos<any> lambda, RealPos<any> mu, Probability<any> rho, RealPos<any> rootAge, String<any> samplingStrategy {valid options: "uniform"|"diversified"}, String<any> condition {valid options: "time"|"survival"|"nTaxa"}, Taxon[]<any> taxa, Clade[]<any> incompleteClades)'
      arguments:
        - label: 'lambda'
          description: 'The speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The extinction rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'rho'
          description: 'The taxon sampling fraction.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'rootAge'
          description: 'The time of the process starting at the root, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'samplingStrategy'
          description: 'The sampling strategy of including taxa at the present.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'uniform'
          options:
            - 'uniform'
            - 'diversified'
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'nTaxa'
        - label: 'taxa'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'incompleteClades'
          description: 'Vector of incompletely sampled clades with number of missing species.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade[]'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnBirthDeathBurstProcess'
  title:
  aliases: 'dnBDBP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnBirthDeathBurstProcess(RealPos<any> lambda, RealPos<any> mu, Probability<any> beta, RealPos<any> burstTime, Probability<any> rho, RealPos<any> rootAge, String<any> samplingStrategy {valid options: "uniform"|"diversified"}, String<any> condition {valid options: "time"|"survival"|"nTaxa"}, Taxon[]<any> taxa, Clade[]<any> incompleteClades)'
      arguments:
        - label: 'lambda'
          description: 'The speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The piecewise-constant extinction rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'beta'
          description: 'The constant extinction rate change times.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
        - label: 'burstTime'
          description: 'The constant extinction rate change times.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rho'
          description: 'The taxon sampling fraction(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'rootAge'
          description: 'The time of the process starting at the root, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'samplingStrategy'
          description: 'The sampling strategy of including taxa at the present.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'uniform'
          options:
            - 'uniform'
            - 'diversified'
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'nTaxa'
        - label: 'taxa'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'incompleteClades'
          description: 'Vector of incompletely sampled clades with number of missing species.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade[]'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnBirthDeathSamplingTreatment'
  title:
  aliases: 'dnBDSTP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnBirthDeathSamplingTreatment(RealPos<any> rootAge, RealPos|RealPos[]<any> lambda, RealPos|RealPos[]<any> mu, RealPos|RealPos[]<any> phi, RealPos[]<any> timeline, RealPos[]<any> lambdaTimeline, RealPos[]<any> muTimeline, RealPos[]<any> phiTimeline, RealPos[]<any> PhiTimeline, String<any> condition {valid options: "time"|"survival"|"sampling"}, Taxon[]<any> taxa, TimeTree<any> initialTree, Natural<any> ageCheckPrecision, Probability[]<any> Lambda, Probability[]<any> Mu, RealPos[]<any> LambdaTimeline, RealPos[]<any> MuTimeline, Probability|Probability[]<any> Phi, Probability[]<any> R, Probability|Probability[]<any> r, RealPos[]<any> rTimeline)'
      arguments:
        - label: 'rootAge/originAge'
          description: 'The start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The birth rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The death rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'phi/psi'
          description: 'The serial sampling rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'timeline'
          description: 'The rate interval change times of the piecewise constant process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'lambdaTimeline'
          description: 'The rate interval change times of the speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'muTimeline'
          description: 'The rate interval change times of the extinction rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'phiTimeline/psiTimeline'
          description: 'The rate interval change times of the sampling rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'PhiTimeline/rhoTimeline'
          description: 'Times at which all taxa are sampled with some probability. There is always additionally a sampling event at the present.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'sampling'
        - label: 'taxa'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'initialTree'
          description: 'Instead of drawing a tree from the distribution, initialize distribution with this tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'ageCheckPrecision'
          description: 'If an initial tree is provided, how many decimal places should be used when checking its tip ages against a taxon file?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '4'
          options:
        - label: 'Lambda'
          description: 'The episodic birth burst probabilities.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[]'
          default: 'NULL'
          options:
        - label: 'Mu'
          description: 'The episodic death burst (mass extinction) probabilities.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[]'
          default: 'NULL'
          options:
        - label: 'LambdaTimeline'
          description: 'Times at which all taxa give birth with some probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'MuTimeline'
          description: 'Times at which all taxa die with some probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'Phi/rho'
          description: 'The probability of sampling taxa at sampling events (at present only if input is scalar).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
        - label: 'R'
          description: 'The treatment probabilities for the sampling events (excluding sampling at present).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[]'
          default: 'NULL'
          options:
        - label: 'r'
          description: 'The probabilit(y|ies) of death upon sampling (treatment).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
        - label: 'rTimeline'
          description: 'The rate interval change times of the (serial) treatment probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnBivariatePoisson'
  title: 'Bivariate Poisson Distribution'
  aliases:
  description: 'A Bivariate Poisson distribution defines probabilities for pairs of natural numbers.'
  details:
  example: |
    th0 ~ dnUniform(0.0, 10.0)
        th1 ~ dnUniform(0.0, 10.0)
        th2 ~ dnUniform(0.0, 10.0)
        x ~ dnBivariatePoisson(th0, th1, th2)
        x.clamp([3, 3, 3])
        moves[1] = mvSlide(th0, delta=0.01, weight=1.0)
        moves[2] = mvSlide(th1, delta=0.01, weight=1.0)
        moves[3] = mvSlide(th2, delta=0.01, weight=1.0)
        monitors[1] = mnScreen(printgen=20000, th0)
        mymodel = model(th1)
        mymcmc = mcmc(mymodel, monitors, moves)
        mymcmc.burnin(generations=20000, tuningInterval=100)
        mymcmc.run(generations=200000)
  authors:
  see_also: 'dnPoisson'
  type_spec:
    - 'Distribution__Natural'
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural[]'
  constructor:
    - usage: 'dnBivariatePoisson(RealPos<any> theta1, RealPos<any> theta2, RealPos<any> theta0)'
      arguments:
        - label: 'theta1'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'theta2'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'theta0'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
    - citation: 'Karlis D, Ntzoufras J (2003). Bayesian and Non-Bayesian Analysis of Soccer Data using Bivariate Poisson Regression Models. 16th Panhelenic Conference in Statistics, Kavala, April 2003.'
      doi:
      url:
- name: 'dnBranchRateTree'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__BranchLengthTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'BranchLengthTree'
  constructor:
    - usage: 'dnBranchRateTree(Distribution__RealPos<any> branchRatePrior, TimeTree<any> timeTree, Probability<any> rootBranchFraction)'
      arguments:
        - label: 'branchRatePrior'
          description: 'The prior distribution for the branch rates.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Distribution__RealPos'
          default:
          options:
        - label: 'timeTree'
          description: 'The time tree'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'rootBranchFraction'
          description: 'The fraction of how much of the root branch is assigned to the left subtree.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Probability'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnCBDSP'
  title: 'Conditioned birth-death-shift process'
  aliases:
  description: |
    Simulates a tree under a birth-death process with shifts in birth and death
    rates among lineages, conditioned on the assumption that no shifts take place
    along extinct lineages.
  details: |
    The initial birth and death rates can be specified with the `rootLambda` and
    `rootMu` arguments, respectively. The rate at which speciation and extinction
    rate shifts take place is specified by the `delta` argument, and the new
    speciation or extinction rates are drawn from prior distributions specified in
    the `lambda` and `mu` arguments. Similar to other birth-death processes in
    RevBayes, `dnCBDSP` also takes arguments specifying the stopping `condition`
    of the simulator (either survival or time) and the extant sampling probability
    `rho`.
    
    `dnCBDSP` is very similar to the model implemented in Bayesian Analysis
    of Macroevolutionary Mixtures (BAMM; Rabosky 2014), particularly in making
    a strong and potentially problematic assumption that all rate-shift events
    have been observed (Moore et al. 2016) -- i.e., that no rate shifts are mapped
    onto unobserved (extinct) branches. For an alternative birth-death-shift model
    that relaxes this assumption, see `dnCDBDP` (Hhna et al. 2019), which employs
    a finite number of rate categories instead of drawing rates directly from
    a continuous distribution.
  example: |
    # draw basic process parameters
    taxa <- [taxon("A"), taxon("B"), taxon("C"), taxon("D"), taxon("E")]
    root_age ~ dnUniform(0, 2)
    root_lambda ~ dnUniform(0, 1)
    root_mu ~ dnUniform(0, 1)
    sampling_prob <- 1
    
    # simulate tree
    tree ~ dnCBDSP(rootAge    = root_age,
                   rootLambda = root_lambda,
                   rootMu     = root_mu,
                   delta      = 0.2,
                   rho        = sampling_prob,
                   condition  = "survival",
                   taxa       = taxa)
  authors:
  see_also:
    - 'dnCDBDP'
    - 'mvBirthDeathEventContinuous'
    - 'mvContinuousEventScale'
    - 'mvEventTimeBeta'
    - 'mvEventTimeSlide'
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnCBDSP(RealPos<any> rootAge, RealPos<any> rootLambda, RealPos<any> rootMu, Distribution__RealPos<any> lambda, Distribution__RealPos<any> mu, RealPos<any> delta, Probability<any> rho, String<any> condition {valid options: "time"|"survival"}, Taxon[]<any> taxa)'
      arguments:
        - label: 'rootAge'
          description: 'The age of the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rootLambda'
          description: 'The speciation rate at the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rootMu'
          description: 'The extinction rate at the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The prior distribution for the speciation rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__RealPos'
          default: 'NULL'
          options:
        - label: 'mu'
          description: 'The prior distribution for the extinction rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__RealPos'
          default: 'NULL'
          options:
        - label: 'delta'
          description: 'The rate of jumping between rate categories.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rho'
          description: 'The taxon sampling probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
        - label: 'condition'
          description: 'The condition of the birth-death process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'survival'
          options:
            - 'time'
            - 'survival'
        - label: 'taxa'
          description: 'The taxon names used for initialization.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
    - citation: 'Hhna S, Freyman WA, Nolen Z, Huelsenbeck JP, May MR, Moore BR (2019). A Bayesian approach for estimating branch-specific speciation and extinction rates. bioRxiv.'
      doi: '10.1101/555805'
      url: 'https://www.biorxiv.org/content/10.1101/555805v1.full'
    - citation: 'Moore BR, Hhna S, May MR, Rannala B, Huelsenbeck JP (2016). Critically evaluating the theory and performance of Bayesian analysis of macroevolutionary mixtures. Proceedings of the National Academy of Sciences of the USA, 113(34):9569-9574.'
      doi: '10.1073/pnas.1518659113'
      url: 'https://www.pnas.org/doi/full/10.1073/pnas.1518659113'
    - citation: 'Rabosky DL (2014). Automatic detection of key innovations, rate shifts, and diversity-dependence on phylogenetic trees. PLoS ONE, 9(2):e89543.'
      doi: '10.1371/journal.pone.0089543'
      url: 'https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0089543'
- name: 'dnCDBDP'
  title: 'Character-dependent birth-death process'
  aliases:
    - 'dnCDSSBDP'
    - 'dnCDFBDP'
    - 'dnBirthDeathMultiRate'
    - 'dnBirthDeathShift'
    - 'dnCDCladoBDP'
  description: 'Simulates a tree under a multi-type birth-death process.'
  details: |
    This distribution is a flexible simulator that can be used for several
    lineage-heterogeneous diversification models. Specifically, `dnCDBDP` allows
    the tree to be divided into multiple segments (also referred to as "regimes"
    or "types"; Barido-Sottani et al. 2020) separated by discrete shifts in birth
    and death rates, such that each segment draws its rate vector from a finite
    number of categories. These categories can (but need not) correspond to the
    states of an observed discrete character, in which case the shifts correspond
    to inferred state transitions: hence the characterization of `dnCDBDP` as
    a "character-dependent" model.
    
    Applications of this multi-type model include:
    
    1. Multiple State-dependent Speciation Extinction (MuSSE) (Maddison et al.
       2007; FitzJohn 2012)
    
    This model uses a state-dependent birth-death process to simulate a tree with
    only anagenetic state changes, i.e., changes taking place along the branches
    of the tree. When `dnCDBDP` is used to implement MuSSE, the `lambda` argument
    represents a vector of speciation rates for each state, and its length is
    therefore equal to the number of states. The rates at which the character
    transitions from one state to another are specified by the matrix `Q` (with as
    many rows and columns as there are states), and the extinction rates for each
    state are specified using the vector `mu` (with as many elements as there are
    states). A draw from the distribution needs to be fixed both to a previously
    inferred tree (using `.clamp()`), and to a matrix recording which state is
    observed at a given tip (using `.clampCharData()`).
    
    2. Cladogenetic State-dependent Speciation Extinction (ClaSSE) (Goldberg &
       Igi 2012)
    
    This model additionally allows for cladogenetic state changes, i.e., changes
    that take place at nodes, corresponding to the assumption that state change
    either induces or immediately follows speciation. When `dnCDBDP` is used to
    implement ClaSSE, the `lambda` argument corresponds to a cladogenetic event
    map. A cladogenetic event map is a matrix specifying the speciation rates
    associated with the different character state triplets that can be observed
    for the parent and its two children at a given node (= cladogenetic event).
    As before, anagenetic state change is still allowed, with its rates described
    by the `Q` matrix, and each state is associated with a distinct extinction
    rate specified in the `mu` vector. A draw from the distribution again has to 
    be clamped both to a tree and to a character matrix. See the example below
    for implementation.
    
    3. Branch-specific Diversification Rate Estimation (Hhna et al. 2019)
    
    `dnCDBDP` can also be used to estimate the number and placement of events 
    at which the rates of speciation and extinction shift from one category
    to another, without the assumption that such rate shifts correspond to state
    transitions in an observed character. While the number of shifts is inferred,
    the number of categories N has to be specified by the user, and relates
    to the length of the `lambda` and `mu` vectors. If only one of the two rates
    is allowed to shift, both vectors have to be of length N (with one containing
    N distinct and the other N identical elements); if both rates are allowed to
    shift independently of each other, the vectors have to be of length N^2. The
    `Q` matrix gives the rates of shifts between any two individual categories.
    In this case, a draw from the distribution is only fixed to a tree using 
    `.clamp()`.
  example: |
    # setup for a two-state ClaSSE model
    num_states = 2          # 0 and 1 are the only states
    
    # set basic process parameters
    root_age ~ dnUniform(0, 2)
    rho <- Probability(1/2) # sampling one half of extant lineages
    
    # specify extinction probabilities for each state
    mu_vec <- rep(0.1, 2)
    
    # Set up cladogenetic events and speciation rates. Each element
    # in clado_events describes a state pattern at the cladogenetic
    # event: for example, [0, 0, 1] denotes a parent having state 0
    # and its two children having states 0 and 1.
    clado_events = [[0, 0, 1], [0, 1, 0], [1, 0, 1], [1, 1, 0]]
    
    # set speciation rates for each cladogenetic event described above
    lambda ~ dnExponential( 10.0 )
    speciation_rates := rep(lambda, 4)
    
    # create cladogenetic rate matrix
    clado_matrix = fnCladogeneticSpeciationRateMatrix(clado_events,
                                                      speciation_rates,
                                                      num_states)
    
    # set up Q-matrix to specify rates of state changes along branches
    ana_rate_matrix <- fnFreeK( [[0, .2], [.2, 0]], rescaled=FALSE )
    
    # create vector of state frequencies at the root
    pi <- simplex([1, 2])
    
    # basic use of the function
    timetree ~ dnCDBDP(rootAge   = root_age,
                       lambda    = clado_matrix,
                       mu        = mu_vec,
                       Q         = ana_rate_matrix,
                       pi        = pi,
                       rho       = rho,
                       condition = "time")
  authors:
  see_also:
    - 'dnCBDSP'
    - 'fnCladogeneticProbabilityMatrix'
    - 'fnCladogeneticSpeciationRateMatrix'
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnCDBDP(RealPos<any> rootAge, CladogeneticSpeciationRateMatrix|RealPos[]<any> speciationRates, RealPos[]<any> extinctionRates, RealPos[]<any> psi, RateGenerator<any> Q, RealPos<any> delta, Simplex<any> pi, Probability|Probability[]<any> rho, String<any> condition {valid options: "time"|"survival"}, RealPos<any> nTimeSlices, String<any> simulateCondition {valid options: "startTime"|"numTips"|"tipStates"|"tree"}, Natural<any> minNumLineages, Natural<any> maxNumLineages, Natural<any> exactNumLineages, RealPos<any> maxTime, Bool<any> pruneExtinctLineages, Bool<any> allowRateShiftsAtExtinctLineages)'
      arguments:
        - label: 'rootAge/originAge'
          description: 'The start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'speciationRates/lambda/cladoEventMap'
          description: 'The vector of speciation rates (for anagenetic-only models), or the map of speciation rates to cladogenetic event types.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'CladogeneticSpeciationRateMatrix'
          default:
          options:
        - label: 'extinctionRates/mu'
          description: 'The vector of extinction rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'psi/phi'
          description: 'The vector of serial sampling rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'Q'
          description: 'The rate matrix of jumping between rate categories.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGenerator'
          default: 'NULL'
          options:
        - label: 'delta'
          description: 'The rate-factor of jumping between rate categories.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'pi'
          description: 'State frequencies at the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'rho'
          description: 'The taxon sampling probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'condition'
          description: 'The condition of the birth-death process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
        - label: 'nTimeSlices'
          description: 'The number of time slices for the numeric ODE.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '500'
          options:
        - label: 'simulateCondition'
          description: 'The conditions under which to simulate.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'startTime'
          options:
            - 'startTime'
            - 'numTips'
            - 'tipStates'
            - 'tree'
        - label: 'minNumLineages'
          description: 'The minimum number of lineages to simulate; applied under the startTime condition.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'maxNumLineages'
          description: 'The maximum number of lineages to simulate; applied under the startTime condition.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '500'
          options:
        - label: 'exactNumLineages'
          description: 'The exact number of lineages to simulate; applied under the numTips condition.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '100'
          options:
        - label: 'maxTime'
          description: 'Maximum time for lineages to coalesce when simulating; applied under the numTips and tipStates condition.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1000'
          options:
        - label: 'pruneExtinctLineages'
          description: 'When simulating should extinct lineages be pruned off?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'allowRateShiftsAtExtinctLineages'
          description: 'Should we allow rate shifts to occur on extinct lineages?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  methods:
  references:
    - citation: 'Barido-Sottani J, Vaughan TG, Stadler T (2020). A multitype birth--death model for Bayesian inference of lineage-specific birth and death rates. Systematic Biology, 69(5):973-986.'
      doi: '10.1093/sysbio/syaa016'
      url: 'https://academic.oup.com/sysbio/article/69/5/973/5762626'
    - citation: 'FitzJohn RG (2012). Diversitree: comparative phylogenetic analyses of diversification in R. Methods in Ecology and Evolution, 3(6):1084-1092.'
      doi: '10.1111/j.2041-210X.2012.00234.x'
      url: 'https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/j.2041-210X.2012.00234.x'
    - citation: 'Goldberg EE, Igi B (2012). Tempo and mode in plant breeding system evolution. Evolution, 66(12):3701-3709.'
      doi: '10.1111/j.1558-5646.2012.01730.x'
      url: 'https://academic.oup.com/evolut/article/66/12/3701/6851227'
    - citation: 'Hhna S, Freyman WA, Nolen Z, Huelsenbeck JP, May MR, Moore BR (2019). A Bayesian approach for estimating branch-specific speciation and extinction rates. bioRxiv.'
      doi: '10.1101/555805'
      url: 'https://www.biorxiv.org/content/10.1101/555805v1.full'
    - citation: 'Maddison WP, Midford PE, Otto SP (2007). Estimating a binary character''s effect on speciation and extinction. Systematic Biology, 56(5):701-710.'
      doi: '10.1080/10635150701607033'
      url: 'https://academic.oup.com/sysbio/article/56/5/701/1694265'
- name: 'dnCTMC'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'AbstractDiscreteTaxonData'
  constructor:
    - usage: 'dnCTMC(RateGenerator|RateGenerator[]<any> Q, Simplex<any> rootFrequencies, Simplex|Bool<any> siteMatrices, RealPos[]<any> siteRates, Simplex<any> siteRatesProbs, Natural<any> nSites, String<any> type {valid options: "DNA"|"RNA"|"AA"|"Codon"|"PoMo"|"Protein"|"Standard"|"NaturalNumbers"|"Binary"|"Restriction"})'
      arguments:
        - label: 'Q'
          description: 'The global or site-mixture rate matrices.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGenerator'
          default:
          options:
        - label: 'rootFrequencies'
          description: 'The root specific frequencies of the characters, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'siteMatrices'
          description: 'Simplex of site matrix mixture probabilities. Treats Q as vector of site mixture categories instead of branch-specific matrices.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'siteRates'
          description: 'The rate categories for the sites.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'siteRatesProbs'
          description: 'The probability weights of rate categories for the sites.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'nSites'
          description: 'The number of sites, used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'type'
          description: 'The data type, used for simulation and initialization.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'DNA'
          options:
            - 'DNA'
            - 'RNA'
            - 'AA'
            - 'Codon'
            - 'PoMo'
            - 'Protein'
            - 'Standard'
            - 'NaturalNumbers'
            - 'Binary'
            - 'Restriction'
  methods:
  references:
- name: 'dnCategorical'
  title: 'The Categorical Distribution'
  aliases: 'dnCat'
  description: 'The Categorical distribution generalizes the Bernoulli distribution, describing the probability of choosing from a number of outcomes, each with their own probability.'
  details: |
    The categorical distribution takes a parameter p, a simplex (i.e. vector, the elements of which sum to 1). It returns outcome i with probability p[i].
    
    A typical scenario where a categorical variable is used is in the definition of a variable drawn from a mixture. A vector of mixture components is set up first, and then a stochastic variable drawn from a categorical distribution is used as an index in a deterministic assignment that points to a component in the mixture. See example below.
  example: |
    # Define a stochastic variable x that is drawn from
    # a categorical distribution with 4 categories, each
    # category having the same probability, then examine
    # the value of x.
    x ~ dnCat( simplex(1,1,1,1) )
    x
    
    # Draw 10 values from the distribution and place them
    # in a vector a, then examine a.
    for ( i in 1:10 ) {
        a[i] <- x
        x.redraw()
    }
    a
    
    # Use x in defining a deterministic variable y taking
    # on values from a mixture of RealPos values representing
    # rates from a discretized scaled gamma distribution
    # with four categories.
    shape ~ dnExp( 10.0 )
    rates := fnDiscretizeGamma( shape, shape, 4 )
    y := rates[x]
  authors:
  see_also: 'dnBinomial'
  type_spec:
    - 'Distribution__Natural'
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural'
  constructor:
    - usage: 'dnCategorical(Simplex<any> p)'
      arguments:
        - label: 'p'
          description: 'The probability for each category.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default:
          options:
  methods:
  references:
- name: 'dnCauchy'
  title: 'Cauchy Distribution'
  aliases: 'dnLorentz'
  description: 'The Cauchy distribution describes the distribution of the ratio of two independent normal variables with mean 0 and variance 1.'
  details: 'The Cauchy distribution takes two parameters, location and scale. It is a symmetric distribution, but its tails are broad enough that it has no defined mean or variance. The probability density function is f(x) = 1/(pi * scale) * 1 / (1 + x - (location/scale)^2)'
  example: |
    # we simulate some obversations
    x <- rCauchy(n=10,location=0,scale=1)
    # let's see what the mean and the variance are.
    The mean will not converge with more samples, the Cauchy family has no moments.
    mean(x)
    var(x)
    sd(x)
  authors:
  see_also:
    - 'dnNormal'
    - 'dnChisq'
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnCauchy(Real<any> location, RealPos<any> scale)'
      arguments:
        - label: 'location'
          description: 'The location parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'scale'
          description: 'The scale parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnChisq'
  title: 'Chi-Square Distribution'
  aliases:
  description: 'The chi-square distribution with df degrees of freedom describes the distribution of the sum of the squares of df independent normal variables with mean 0 and variance 1.'
  details: 'The chi-square distribution takes one parameter, df, the number of degrees of freedom. The probability density function is f(x) = x^(df/2 - 1) * e^(-x/2) / (2^(df/2) * Gamma(df/2)), where Gamma is the gamma function.'
  example: |
    # The most important use of the chi-square distribution
    # is arguable the quantile function.
    # You can access it the following way:
    df <- 10
    a := qchisq(0.025, df)
    a
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnChisq(Natural<any> df)'
      arguments:
        - label: 'df'
          description: 'The degrees of freedom.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'dnCoalescent'
  title: 'Constant population size coalescent process'
  aliases:
  description: 'The constant population size coalescent process specifies a probability density on genealogies, both node ages and the topology.'
  details: |
    The underlying theory of the constant population size coalescent implemented here is Kingman's coalescent. The implementation here assumes haploid individuals, so for diploid study systems one needs to multiply the effective population size by 2 and the true effective population size in units of individuals needs to be divided by 2 afterwards.
    
    The coalescent process is parameterized with `theta`, which here stands for the effective population size (not 4 * Ne * mu). For detailed examples see https://revbayes.github.io/tutorials/coalescent/
  example: |
    # specify a prior distribution on the constant population size
    pop_size ~ dnUniform(0,1E6)
    moves.append( mvScale(pop_size, lambda=0.1, tune=true, weight=2.0) )
    
    # specify the coalescent process.
    # note that you need to have a vector of taxa
    psi ~ dnCoalescent(theta=pop_size, taxa=taxa)
    
    # for monitoring purposes, you may want the root age
    root_height := psi.rootAge()
    
    # continue as usual to either clamp the genealogy or infer the genealogy based on sequence data
  authors:
  see_also:
    - 'dnCoalescentSkyline'
    - 'dnCoalescentDemography'
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnCoalescent(RealPos<any> theta, Taxon[]<any> taxa, Clade[]<any> constraints)'
      arguments:
        - label: 'theta'
          description: 'The constant population size.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'taxa'
          description: 'The taxa used when drawing a random tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'constraints'
          description: 'The topological constraints strictly enforced.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade[]'
          default: '[ ]'
          options:
  methods:
  references:
    - citation: 'Billenstein R, Hhna S (2024). Comparison of Bayesian coalescent skyline plot models for inferring demographic histories. Molecular Biology and Evolution, 41(5):msae073.'
      doi: '10.1093/molbev/msae073'
      url: 'https://academic.oup.com/mbe/article/41/5/msae073/7648822'
- name: 'dnCoalescentDemography'
  title:
  aliases: 'dnHeterochronousCoalescentDemography'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnCoalescentDemography(DemographicFunction[]<any> df, RealPos[]<any> changePoints, Taxon[]<any> taxa, Clade[]<any> constraints)'
      arguments:
        - label: 'df'
          description: 'The vector of demographic functions.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'DemographicFunction[]'
          default:
          options:
        - label: 'changePoints'
          description: 'The times when the demographic function changes.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'taxa'
          description: 'The taxon names used for initialization.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'constraints'
          description: 'The topological constraints strictly enforced.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade[]'
          default: '[ ]'
          options:
  methods:
  references:
- name: 'dnCoalescentSkyline'
  title: 'Heterochronous and homochronous skyline coalescent process'
  aliases:
  description: 'The skyline coalescent process specifies a probability density on genealogies, both node ages and the topology. It is used for both heterochronous samples and homochronous samples.'
  details: |
    The underlying theory of the skyline coalescent implemented here is Kingman's coalescent. The implementation here assumes haploid individuals, so for diploid study systems one needs to multiply the effective population size by 2 and the true effective population size in units of individuals needs to be divided by 2 afterwards.
    
    The coalescent process is parameterized with `theta`, which here stands for the effective population size (not 4 * Ne * mu). For detailed examples see https://revbayes.github.io/tutorials/coalescent/
  example: |
    NUM_INTERVALS = ceil(n_taxa / 5)
    for (i in 1:NUM_INTERVALS) {
    
        pop_size[i] ~ dnUniform(0,1E6)
        pop_size[i].setValue(100.0)
        moves.append( mvScale(pop_size[i], lambda=0.1, tune=true, weight=2.0) )
    
    }
    
    # next we specify a prior on the number of events per interval
    # we use a multinomial prior offset to have at least one event per interval
    # first, specify the offset
    num_events_pi <- rep(1, NUM_INTERVALS)
    
    # next, specify the prior for the multinomial distribution
    num_e_simplex_init <- rep(1, NUM_INTERVALS)
    num_e_simplex <- simplex(num_e_simplex_init)
    
    # calculate the number of coalescent events that we distribute over the intervals
    n_multi <- n_taxa-1-NUM_INTERVALS
    
    # draw the coalescent events into intervals
    number_events_pi ~ dnMultinomial(p=num_e_simplex, size=n_multi)
    
    # compute the actual number of events per interval, so the drawn number plus offset
    final_number_events_pi := num_events_pi + number_events_pi
    
    moves.append( mvIidPrior(x=number_events_pi) )
    
    # the time tree is a stochastic node modeled by the constant-rate coalescent process (dnCoalescent)
    psi ~ dnCoalescentSkyline(theta=pop_size, events_per_interval=final_number_events_pi, method="events", taxa=taxa)
    
    interval_times := psi.getIntervalAges()
    
    root_height := psi.rootAge()
    
    # continue as usual to either clamp the genealogy or infer the genealogy based on sequence data
  authors:
  see_also:
    - 'dnCoalescent'
    - 'dnCoalescentDemography'
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnCoalescentSkyline(RealPos[]<any> theta, RealPos[]<any> times, Natural[]<any> events_per_interval, String<any> method {valid options: "events"|"specified"}, String<any> model {valid options: "constant"|"linear"}, Taxon[]<any> taxa, Clade[]<any> constraints)'
      arguments:
        - label: 'theta'
          description: 'A vector of per interval population sizes.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'times'
          description: 'A vector of times for the intervals, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'events_per_interval'
          description: 'A vector of number of coalescent events for the intervals, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural[]'
          default: 'NULL'
          options:
        - label: 'method'
          description: 'The method how intervals are defined.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'events'
          options:
            - 'events'
            - 'specified'
        - label: 'model'
          description: 'The demographic model for the intervals.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'constant'
          options:
            - 'constant'
            - 'linear'
        - label: 'taxa'
          description: 'The taxa used when drawing a random tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'constraints'
          description: 'The strictly enforced topology constraints.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade[]'
          default: '[ ]'
          options:
  methods:
  references:
    - citation: 'Billenstein R, Hhna S (2024). Comparison of Bayesian coalescent skyline plot models for inferring demographic histories. Molecular Biology and Evolution, 41(5):msae073.'
      doi: '10.1093/molbev/msae073'
      url: 'https://academic.oup.com/mbe/article/41/5/msae073/7648822'
- name: 'dnCompleteBirthDeath'
  title:
  aliases: 'dnCompleteBDP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnCompleteBirthDeath(RealPos<any> rootAge, RealPos<any> lambda, RealPos<any> mu, String<any> condition {valid options: "time"|"survival"|"nTaxa"}, Taxon[]<any> taxa)'
      arguments:
        - label: 'rootAge/originAge/mrcaAge'
          description: 'The start age of the process, either the root age, mrca age or the origin time.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The constant speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The constant extinction rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'nTaxa'
        - label: 'taxa'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnConstrainedNodeAge'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnConstrainedNodeAge(Distribution__TimeTree<any> treeDistribution, Clade[][]<any> constraints)'
      arguments:
        - label: 'treeDistribution'
          description: 'The base distribution for the tree.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__TimeTree'
          default:
          options:
        - label: 'constraints'
          description: 'The node Age constraints.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade[][]'
          default:
          options:
  methods:
  references:
- name: 'dnConstrainedNodeOrder'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnConstrainedNodeOrder(Distribution__TimeTree<any> treeDistribution, RlRelativeNodeAgeConstraints<any> constraints)'
      arguments:
        - label: 'treeDistribution'
          description: 'The base distribution for the tree.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__TimeTree'
          default:
          options:
        - label: 'constraints'
          description: 'The node order constraints.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RlRelativeNodeAgeConstraints'
          default:
          options:
  methods:
  references:
- name: 'dnConstrainedTopology'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnConstrainedTopology(Distribution__TimeTree<any> treeDistribution, Clade[]<any> constraints, TimeTree<any> initialTree, Natural<any> ageCheckPrecision, TimeTree|TimeTree[]<any> backbone, Bool<any> inverse)'
      arguments:
        - label: 'treeDistribution'
          description: 'The base distribution for the tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Distribution__TimeTree'
          default:
          options:
        - label: 'constraints'
          description: 'The topological constraints.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade[]'
          default: '[ ]'
          options:
        - label: 'initialTree'
          description: 'Instead of drawing a tree from the distribution, initialize distribution with this tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'ageCheckPrecision'
          description: 'If an initial tree is provided, how many decimal places should be used when checking its tip ages against a taxon file?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '4'
          options:
        - label: 'backbone'
          description: 'The backbone topological constraints.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'inverse'
          description: 'Should the constraint be inverted?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
  references:
- name: 'dnConstrainedTopologySSE'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnConstrainedTopologySSE(Distribution__TimeTree<any> treeDistribution, Clade[]<any> constraints, TimeTree<any> initialTree, Natural<any> ageCheckPrecision, TimeTree|TimeTree[]<any> backbone, Bool<any> inverse)'
      arguments:
        - label: 'treeDistribution'
          description: 'The base distribution for the tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Distribution__TimeTree'
          default:
          options:
        - label: 'constraints'
          description: 'The topological constraints.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade[]'
          default: '[ ]'
          options:
        - label: 'initialTree'
          description: 'Instead of drawing a tree from the distribution, initialize distribution with this tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'ageCheckPrecision'
          description: 'If an initial tree is provided, how many decimal places should be used when checking its tip ages against a taxon file?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '4'
          options:
        - label: 'backbone'
          description: 'The backbone topological constraints.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'inverse'
          description: 'Should the constraint be inverted?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
  references:
- name: 'dnCppNormal'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnCppNormal(RealPos<any> lambda, Real<any> mu, RealPos<any> sigma)'
      arguments:
        - label: 'lambda'
          description: 'The rate of the Poisson distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The mean of the normal distribution'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'sigma'
          description: 'The standard deviation of the normal distribution'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnDPP'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real[]'
  constructor:
    - usage: 'dnDPP(RealPos<any> concentration, Distribution__Real<any> baseDistribution, Natural<any> numElements)'
      arguments:
        - label: 'concentration'
          description: 'The concentration parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'baseDistribution'
          description: 'The base distribution for the per category values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
        - label: 'numElements'
          description: 'The number of elements drawn from this distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'dnDecomposedInvWishart'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'MatrixReal'
  constructor:
    - usage: 'dnDecomposedInvWishart(MatrixRealSymmetric<any> sigma, RealPos[]<any> diagonal, Natural<any> df, RealPos<any> kappa, Natural<any> dim)'
      arguments:
        - label: 'sigma'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'MatrixRealSymmetric'
          default: '[ [ 0.0000 ] ]'
          options:
        - label: 'diagonal'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'df'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'kappa'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'dim'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default: '0'
          options:
  methods:
  references:
- name: 'dnDirichlet'
  title: 'Dirichlet Distribution'
  aliases:
  description: 'The Dirichlet distribution is a generalization of the Beta distribution for multiple variables.'
  details: 'The Dirichlet distribution takes one parameter, alpha, a vector of numbers representing the concentration of the distribution on each variable. It then returns a simplex (i.e. a vector whose elements sum to 1) representing the relative probability of each variable. Note that when every element of alpha is 1, the distribution is equivalent to a uniform on each element.'
  example: |
    # lets get a draw from a Dirichlet distribution
    a <- [1,1,1,1]   # we could also use rep(1,4)
    b ~ dnDirichlet(a)
    b
    # let check if b really sums to 1
    sum(b)
  authors:
  see_also: 'simplex'
  type_spec:
    - 'Distribution__Simplex'
    - 'Distribution'
    - 'RevObject'
  domain: 'Simplex'
  constructor:
    - usage: 'dnDirichlet(RealPos[]<any> alpha)'
      arguments:
        - label: 'alpha'
          description: 'The concentration parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
  methods:
  references:
- name: 'dnDiversityDependentYule'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnDiversityDependentYule(RealPos<any> lambda, Natural<any> capacity, RealPos<any> rootAge, String<any> condition {valid options: "time"|"survival"|"nTaxa"}, Taxon[]<any> taxa)'
      arguments:
        - label: 'lambda'
          description: 'The initial speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'capacity'
          description: 'The carrying capacity.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'rootAge'
          description: 'The time of the process since the root, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'survival'
          options:
            - 'time'
            - 'survival'
            - 'nTaxa'
        - label: 'taxa'
          description: 'The names of the taxa used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnDuplicationLoss'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnDuplicationLoss(TimeTree<any> individualTree, RealPos|RealPos[]<any> lambda, RealPos|RealPos[]<any> mu, Taxon[]<any> taxa)'
      arguments:
        - label: 'individualTree'
          description: 'The individual tree in which the gene trees evolve.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'lambda'
          description: 'The duplication rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The loss rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnEmpiricalSample'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Natural[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural[]'
  constructor:
    - usage: 'dnEmpiricalSample(Distribution__Natural<any> baseDistribution)'
      arguments:
        - label: 'baseDistribution'
          description: 'The base distribution for the sampled values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Natural'
          default:
          options:
  methods:
  references:
- name: 'dnEmpiricalTree'
  title:
  aliases:
  description: 'Creates a distribution of trees from a trace of trees.'
  details:
  example: |
    # Read in tree trace
    tree_trace = readTreeTrace("output/my.trees", burnin=0.25)
    
    # Create a distribution of trees
    tree ~ dnEmpiricalTree(tree_trace)
    
    # Add an MCMC move
    moves[1] = mvEmpiricalTree(tree)
  authors:
  see_also:
    - 'mvEmpiricalTree'
    - 'treeTrace'
    - 'readTreeTrace'
  type_spec:
    - 'Distribution__Tree'
    - 'Distribution'
    - 'RevObject'
  domain: 'Tree'
  constructor:
    - usage: 'dnEmpiricalTree(TraceTree<any> trace, Trace<any> density)'
      arguments:
        - label: 'trace'
          description: 'The trace of tree samples.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'TraceTree'
          default:
          options:
        - label: 'density'
          description: 'Optional trace of probability density values for each tree.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Trace'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnEpisodicBirthDeath'
  title:
  aliases: 'dnEBDP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnEpisodicBirthDeath(RealPos|RealPos[]<any> lambdaRates, RealPos|RealPos[]<any> lambdaTimes, RealPos|RealPos[]<any> muRates, RealPos|RealPos[]<any> muTimes, Probability<any> rho, RealPos<any> rootAge, String<any> samplingStrategy {valid options: "uniform"|"diversified"}, String<any> condition {valid options: "time"|"survival"|"nTaxa"}, Taxon[]<any> taxa, Clade[]<any> incompleteClades, TimeTree<any> initialTree)'
      arguments:
        - label: 'lambdaRates'
          description: 'The piecewise-constant speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambdaTimes'
          description: 'The speciation rate change times.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '[ ]'
          options:
        - label: 'muRates'
          description: 'The piecewise-constant extinction rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'muTimes'
          description: 'The constant extinction rate change times.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '[ ]'
          options:
        - label: 'rho'
          description: 'The taxon sampling fraction(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'rootAge'
          description: 'The time of the process starting at the root, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'samplingStrategy'
          description: 'The sampling strategy of including taxa at the present.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'uniform'
          options:
            - 'uniform'
            - 'diversified'
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'nTaxa'
        - label: 'taxa'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'incompleteClades'
          description: 'Vector of incompletely sampled clades with number of missing species.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade[]'
          default: 'NULL'
          options:
        - label: 'initialTree'
          description: 'Instead of drawing a tree from the distribution, initialize distribution with this tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnEvent'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real[]'
  constructor:
    - usage: 'dnEvent(Distribution__Natural<any> eventDistribution, Distribution__Real<any> valueDistribution)'
      arguments:
        - label: 'eventDistribution'
          description: 'The prior on the number of events.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Natural'
          default:
          options:
        - label: 'valueDistribution'
          description: 'The base distribution for the per category values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
  methods:
  references:
- name: 'dnExponential'
  title: 'Exponential Distribution'
  aliases: 'dnExp'
  description: 'The Exponential distribution describes the distribution of the times between events in a Poisson point process.'
  details: 'The exponential distribution takes one parameter, lambda, describing the rate (i.e. 1/mean). The probability density function is f(x) = lambda * exp(-lambda*x).'
  example: |
    # we set a rate parameter
    rate <- 10.0
    # we create an exponentially distributed random variable
    x ~ dnExponential(lambda=rate)
    # compute the probability of the variable
    x.probability()
  authors:
  see_also:
  type_spec:
    - 'PositiveContinuousDistribution'
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnExponential(RealPos<any> lambda, RealPos<any> offset)'
      arguments:
        - label: 'lambda'
          description: 'The rate parameter ( rate = 1/mean ).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'offset'
          description: 'The offset of the distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
  methods:
  references:
- name: 'dnExponentialError'
  title:
  aliases: 'dnExpError'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'AverageDistanceMatrix'
  constructor:
    - usage: 'dnExponentialError(AverageDistanceMatrix<any> avgDistMat, DistanceMatrix<any> distMat, RealPos<any> lambda)'
      arguments:
        - label: 'avgDistMat'
          description: 'The average distance matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AverageDistanceMatrix'
          default: 'NULL'
          options:
        - label: 'distMat'
          description: 'The distance matrix of the proposed supertree.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'DistanceMatrix'
          default: 'NULL'
          options:
        - label: 'lambda'
          description: 'The rate of the exponential distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnFossilizedBirthDeath'
  title:
  aliases: 'dnFBDP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnFossilizedBirthDeath(RealPos<any> rootAge, RealPos|RealPos[]<any> lambda, RealPos|RealPos[]<any> mu, RealPos|RealPos[]<any> phi, RealPos[]<any> timeline, RealPos[]<any> lambdaTimeline, RealPos[]<any> muTimeline, RealPos[]<any> phiTimeline, RealPos[]<any> PhiTimeline, String<any> condition {valid options: "time"|"survival"|"sampling"}, Taxon[]<any> taxa, TimeTree<any> initialTree, Natural<any> ageCheckPrecision, Probability[]<any> Lambda, Probability[]<any> Mu, RealPos[]<any> LambdaTimeline, RealPos[]<any> MuTimeline, Probability|Probability[]<any> rho)'
      arguments:
        - label: 'rootAge/originAge'
          description: 'The start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The birth rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The death rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'phi/psi'
          description: 'The serial sampling rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'timeline'
          description: 'The rate interval change times of the piecewise constant process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'lambdaTimeline'
          description: 'The rate interval change times of the speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'muTimeline'
          description: 'The rate interval change times of the extinction rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'phiTimeline/psiTimeline'
          description: 'The rate interval change times of the sampling rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'PhiTimeline/rhoTimeline'
          description: 'Times at which all taxa are sampled with some probability. There is always additionally a sampling event at the present.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'sampling'
        - label: 'taxa'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'initialTree'
          description: 'Instead of drawing a tree from the distribution, initialize distribution with this tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'ageCheckPrecision'
          description: 'If an initial tree is provided, how many decimal places should be used when checking its tip ages against a taxon file?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '4'
          options:
        - label: 'Lambda'
          description: 'The episodic birth burst probabilities.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[]'
          default: 'NULL'
          options:
        - label: 'Mu'
          description: 'The episodic death burst (mass extinction) probabilities.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[]'
          default: 'NULL'
          options:
        - label: 'LambdaTimeline'
          description: 'Times at which all taxa give birth with some probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'MuTimeline'
          description: 'Times at which all taxa die with some probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'rho/Phi'
          description: 'The probability of sampling taxa at sampling events (at present only if input is scalar).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'dnFossilizedBirthDeathRange'
  title:
  aliases: 'dnFBDRP'
  description: 'The fossilized birth death range process (FBDRP) describes the distribution of a matrix of species origination and extinction times under a model of asymmetric speciation and sampling of extinct species.'
  details: 'Fossil species are represented by a collection of fossil occurrences with uncertainty. Speciation, extinction and sampling rates may be time-homogeneous or piecewise time-heterogeneous. If time-heterogeneous rates are provided, then a vector of rate change time-points musts also be provided. If only a subset of fossil occurrences is provided for each species (e.g. only first and last occurrencces), then the remaining number of fossil samples may be marginalized by specifying `complete=FALSE`. Under the hood, the fossil data is augmented with oldest occurrence ages for each species, which must be sampled during MCMC using `mvResampleFBD`. Setting `BDS` to true causes the model to assume complete lineage sampling i.e. using the Birth-Death with Rateshifts (BDS) model of Silvestro et al. (2019).'
  example: |
    lambda ~ dnExp(10)
    mu ~ dnExp(10)
    psi ~ dnExp(10)
    
    bd ~ dnFBDRP(lambda=lambda, mu=mu, psi=psi, rho=1, taxa=taxa)
    
    moves.append( mvMatrixElementScale(bd, weight=taxa.size()) )
    moves.append( mvMatrixElementSlide(bd, weight=taxa.size()) )
  authors:
  see_also:
    - 'dnBirthDeathSamplingTreatment'
    - 'mvResampleFBD'
  type_spec:
    - 'Distribution__RealPos[][]'
    - 'Distribution'
    - 'RevObject'
  domain: 'MatrixReal'
  constructor:
    - usage: 'dnFossilizedBirthDeathRange(Bool<any> BDS, RealPos|RealPos[]<any> lambda, RealPos|RealPos[]<any> mu, RealPos|RealPos[]<any> psi, Probability<any> rho, RealPos[]<any> timeline, String<any> condition {valid options: "time"|"sampling"|"survival"}, Taxon[]<any> taxa, Bool<any> complete)'
      arguments:
        - label: 'BDS'
          description: 'Assume complete lineage sampling? (BDS model of Silvestro et al. 2019)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'lambda'
          description: 'The speciation rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The extinction rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'psi'
          description: 'The fossil sampling rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'rho'
          description: 'The extant sampling fraction.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'timeline'
          description: 'The rate interval change times of the piecewise constant process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'sampling'
            - 'survival'
        - label: 'taxa'
          description: 'The taxa with fossil occurrence information.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'complete'
          description: 'Assume complete fossil sampling?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
  references:
    - citation: 'The fossilized birth-death model for the analysis of stratigraphic range data under different speciation modes. Stadler, Tanja et al. Journal of theoretical biology, 447:41-55.'
      doi:
      url: 'https://www.sciencedirect.com/science/article/pii/S002251931830119X'
    - citation: 'Improved estimation of macroevolutionary rates from fossil data using a Bayesian framework. Silvestro, Daniele et al. Paleobiology, 45:546-570.'
      doi: 'https://doi.org/10.1017/pab.2019.23'
      url: 'https://www.cambridge.org/core/journals/paleobiology/article/improved-estimation-of-macroevolutionary-rates-from-fossil-data-using-a-bayesian-framework/334F08A74A6C92F1FEAD91A71FE59A1C'
- name: 'dnFossilizedBirthDeathSpecies'
  title:
  aliases: 'dnFBDSP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'FossilizedBirthDeathRangeProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnFossilizedBirthDeathSpecies(RealPos<any> originAge, RealPos|RealPos[]<any> lambda, RealPos|RealPos[]<any> mu, RealPos|RealPos[]<any> psi, Probability<any> rho, RealPos[]<any> timeline, String<any> condition {valid options: "time"|"sampling"|"survival"}, Taxon[]<any> taxa, Bool<any> complete, RealPos|RealPos[]<any> lambda_a, Probability|Probability[]<any> beta)'
      arguments:
        - label: 'originAge'
          description: 'The start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The speciation rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The extinction rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'psi'
          description: 'The fossil sampling rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'rho'
          description: 'The extant sampling fraction.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'timeline'
          description: 'The rate interval change times of the piecewise constant process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'sampling'
            - 'survival'
        - label: 'taxa'
          description: 'The taxa with fossil occurrence information.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'complete'
          description: 'Assume complete fossil sampling?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'lambda_a'
          description: 'The anagenetic speciation rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'beta'
          description: 'The probability of symmetric speciation.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '0'
          options:
  methods:
  references:
- name: 'dnGamma'
  title: 'Gamma Distribution'
  aliases:
  description: 'The Gamma distribution describes the probability of the sum of exponentially distributed variables.'
  details: |
    The gamma distribution takes two parameters, shape and rate. Similar to how 1/rate gives the mean of the exponential, shape/rate gives the mean of the gamma. It provides a natural prior distribution for parameters that could be considered as sums of exponential variables.
    
    The probability density function is f(x) = rate^shape * x^(shape - 1) * e^(-rate * x) / Gamma(shape), where Gamma is the gamma function. Note that for shape = 1, the gamma distribution reduces to an exponential distribution.
  example: |
    # lets simulate
    a <- rgamma(1000,shape=4,rate=4)
    # we expect a mean of 1
    mean(a)
    
    # create a random variable
    x ~ dnGamma(shape=4,rate=1)
    x
  authors:
  see_also: 'dnExponential'
  type_spec:
    - 'PositiveContinuousDistribution'
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnGamma(RealPos<any> shape, RealPos<any> rate)'
      arguments:
        - label: 'shape'
          description: 'The shape parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rate'
          description: 'The rate parameter (rate = 1/scale).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnGeneralizedLineageHeterogeneousBirthDeathProcess'
  title:
  aliases:
    - 'dnGLHBDSP'
    - 'dnTimeHeterogeneousLineageHeterogeneousBirthDeathSamplingProcess'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnGeneralizedLineageHeterogeneousBirthDeathProcess(RealPos<any> rootAge, Simplex<any> pi, RealPos[]|RealPos[][]<any> lambda, RealPos[]<any> lambdaTimes, RealPos[]|RealPos[][]<any> mu, RealPos[]<any> muTimes, RealPos[]|RealPos[][]<any> phi, RealPos[]<any> phiTimes, RealPos[]|RealPos[][]<any> delta, RealPos[]<any> deltaTimes, Probability[][]<any> upsilon, RealPos[]<any> upsilonTimes, Probability[][]<any> gamma, RealPos[]<any> gammaTimes, Probability|Probability[][]<any> rho, RealPos[]<any> rhoTimes, Probability[][]<any> xi, RealPos[]<any> xiTimes, RealPos|RateGenerator|RateGenerator[]<any> eta, RealPos[]<any> etaTimes, CladogeneticProbabilityMatrix|CladogeneticProbabilityMatrix[]<any> omega, RealPos[]<any> omegaTimes, StochasticMatrix[]<any> zeta, String<any> condition {valid options: "time"|"survival"|"sampled"|"sampledExtant"|"sampledMRCA"|"tree"|"treeExtant"}, Taxon[]<any> taxa, Natural<any> nStates, Natural<any> nProc, RealPos<any> absTol, RealPos<any> relTol, Natural<any> maxDenseSteps, Bool<any> zeroIndex)'
      arguments:
        - label: 'rootAge/originAge'
          description: 'The start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'pi'
          description: 'Frequencies of each state at the beginning of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default:
          options:
        - label: 'lambda'
          description: 'The vector of speciation rates for each time interval.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'lambdaTimes'
          description: 'The times at which speciation rates change.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'mu'
          description: 'The vector of extinction rates for each time interval.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'muTimes'
          description: 'The times at which extinction rates change.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'phi'
          description: 'The vector of sampling rates for each time interval.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'phiTimes'
          description: 'The times at which sampling rates change.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'delta'
          description: 'The vector of destructive-sampling rates for each time interval.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'deltaTimes'
          description: 'The times at which destructive-sampling rates change.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'upsilon'
          description: 'The vector of speciation probabilities for each mass-speciation event.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[][]'
          default: 'NULL'
          options:
        - label: 'upsilonTimes'
          description: 'The times at which mass-speciation events occur.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'gamma'
          description: 'The vector of extinction probabilities for each mass-extinction event.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[][]'
          default: 'NULL'
          options:
        - label: 'gammaTimes'
          description: 'The times at which mass-extinction events occur.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'rho'
          description: 'The vector of sampling probabilities for each mass-sampling event.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: 'NULL'
          options:
        - label: 'rhoTimes'
          description: 'The times at which mass-sampling events occur.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'xi'
          description: 'The vector of destructive-sampling probabilities for each mass-destructive-sampling event.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[][]'
          default: 'NULL'
          options:
        - label: 'xiTimes'
          description: 'The times at which mass-destructive-sampling events occur.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'eta'
          description: 'The anagenetic rates of change for each time interval.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'etaTimes'
          description: 'The times at which the anagenetic rates change.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'omega'
          description: 'The cladogenetic event probabilities for each time interval.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'CladogeneticProbabilityMatrix'
          default: 'NULL'
          options:
        - label: 'omegaTimes'
          description: 'The times at which the cladogenetic rates change.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'zeta'
          description: 'The probabilities of change for each mass-extinction event.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'StochasticMatrix[]'
          default: 'NULL'
          options:
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'sampled'
            - 'sampledExtant'
            - 'sampledMRCA'
            - 'tree'
            - 'treeExtant'
        - label: 'taxa'
          description: 'The taxa in the tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'nStates'
          description: 'The number of discrete states.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '2'
          options:
        - label: 'nProc'
          description: 'The number of processors for parallel calculations.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'absTol'
          description: 'The absolute tolerance of the numerical integrator.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1e-07'
          options:
        - label: 'relTol'
          description: 'The relative tolerance of the numerical integrator.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1e-07'
          options:
        - label: 'maxDenseSteps'
          description: 'The maximum number of steps dense approximators are allowed to try before giving up.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10000'
          options:
        - label: 'zeroIndex'
          description: 'Does the state space include zero?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  methods:
  references:
- name: 'dnGeometric'
  title: 'Geometric Distribution'
  aliases: 'dnGeom'
  description: 'A geometric distribution defines a random variable on natural numbers. The geometric distribution describes the number of success until the first failure, with success probability p.'
  details:
  example: |
    p ~ dnBeta(1.0,1.0)
    x ~ dnGeom(p)
    x.clamp(10)
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", p)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also:
    - 'dnPoisson'
    - 'mvRandomIntegerWalk'
  type_spec:
    - 'Distribution__Natural'
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural'
  constructor:
    - usage: 'dnGeometric(Probability<any> p)'
      arguments:
        - label: 'p'
          description: 'The probability of success.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'dnGilbertGraph'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'MatrixRealSymmetric'
  constructor:
    - usage: 'dnGilbertGraph(RealPos<any> p, Natural<any> n)'
      arguments:
        - label: 'p'
          description: 'The probability that two vertices share an edge.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'n'
          description: 'The dimensions of the correlation matrix.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'dnHBDP'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnHBDP(RealPos<any> rootAge, Natural<any> rootState, RealPos[]<any> lambda, RealPos[]<any> mu, RealPos<any> delta, Probability<any> rho, String<any> condition {valid options: "time"|"survival"}, Bool<any> allowSameCategory, Taxon[]<any> taxa)'
      arguments:
        - label: 'rootAge'
          description: 'The age of the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rootState'
          description: 'The index of the rate category at the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'lambda'
          description: 'The vector of speciation rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'mu'
          description: 'The vector of extinction rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'delta'
          description: 'The rate of jumping between rate categories.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rho'
          description: 'The taxon sampling probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
        - label: 'condition'
          description: 'The condition of the birth-death process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'survival'
          options:
            - 'time'
            - 'survival'
        - label: 'allowSameCategory'
          description: 'Do we allow shifts into the same category'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'taxa'
          description: 'The taxon names used for initialization.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnHalfCauchy'
  title: 'half-Cauchy Distribution'
  aliases: 'dnCauchyPlus'
  description: 'Half-Cauchy distribution with location equal to `location` and scale equal to `scale`.'
  details: |
    The half-Cauchy distribution has density:
    
    f(x) = 2/(pi * sigma) * 1/(1 + x-(location/scale)^2)
  example: |
    # we simulate some obversations
    x <- rHalfCauchy(n=10,location=0,scale=1)
    # let's see what the minimum is (you could do the max too). If this is not `location`, we're in trouble!
    min(x)
    # let's also see what the mean and the variance are.
    The mean will not converge with more samples, the Cauchy family has no moments.
    mean(x)
    var(x)
    sd(x)
  authors:
  see_also:
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnHalfCauchy(Real<any> location, RealPos<any> scale)'
      arguments:
        - label: 'location'
          description: 'The location parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'scale'
          description: 'The scale parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnHalfNormal'
  title: 'half-Normal Distribution'
  aliases:
  description: 'half-normal (gaussian) distribution with offset equal to `offset` and standard deviation equal to `sd`.'
  details: |
    The half-normal distribution has density:
    
     f(x) = 2/(sqrt(2 pi) sigma) e^-((x - offset)^2/(2 sigma^2)) where offset is the offset of the distribution and sigma the standard deviation.
    
    f(x) = 2/(sqrt(2 pi) sigma) e^-((x - offset)^2/(2 sigma^2))
    
    where offset is the offset of the distribution and sigma the standard deviation.
  example: |
    # we simulate some oversations
    x <- rhalfNormal(n=10,offset=0,sd=10)
    # let's see what the minimum is (you could do the max too)
    # the minimum should never be less than the offset
    min(x)
    # let's also see what the mean and the variance are
    mean(x)
    var(x)
    sd(x)
  authors:
  see_also:
    - 'dnNormal'
    - 'dnLognormal'
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnHalfNormal(Real<any> offset, RealPos<any> sd)'
      arguments:
        - label: 'offset'
          description: 'The offset parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'sd'
          description: 'The standard deviation parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnIID'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real[]'
  constructor:
    - usage: 'dnIID(Natural<any> numValues, Distribution__Real<any> valueDistribution)'
      arguments:
        - label: 'numValues'
          description: 'The number of IID samples.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'valueDistribution'
          description: 'The base distribution for the per category values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
  methods:
  references:
- name: 'dnInverseGamma'
  title: 'inverseGamma Distribution'
  aliases:
  description: 'inverse-gamma probability distribution for positive real numbers.'
  details: 'The inverse Gamma distribution is the probability of the sum of exponentially distributed variables. Thus, it provides a natural prior distribution for parameters that could be considered as sums of exponential variables.'
  example: |
    # lets simulate
    a <- rinverseGamma(1000,shape=4,rate=4)
    # we expect a mean of 1
    mean(a)
    
    # create a random variable
    x ~ dnInverseGamma(shape=4,rate=1)
    x
  authors:
  see_also: 'dnExponential'
  type_spec:
    - 'PositiveContinuousDistribution'
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnInverseGamma(RealPos<any> shape, RealPos<any> rate)'
      arguments:
        - label: 'shape'
          description: 'The shape parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rate'
          description: 'The rate parameter (rate = 1/scale).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnInverseWishart'
  title:
  aliases: 'dnInvWishart'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'MatrixRealSymmetric'
  constructor:
    - usage: 'dnInverseWishart(MatrixRealSymmetric<any> sigma, RealPos[]<any> diagonal, Natural<any> df, RealPos<any> kappa, Natural<any> dim)'
      arguments:
        - label: 'sigma'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'MatrixRealSymmetric'
          default: 'NULL'
          options:
        - label: 'diagonal'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'df'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default: 'NULL'
          options:
        - label: 'kappa'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'dim'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnLKJ'
  title: 'LKJ Distribution'
  aliases:
  description: 'The LKJ (Lewandowski-Kurowicka-Joe) distribution on correlation matrices with concentration parameter eta.'
  details: 'The LKJ distribution is uniform over positive-definite correlation matrices when eta=1.The probability density of a correlation matrix under the LKJ distribution is:f(x) = det(x)^(eta - 1)'
  example: |
    
    # we simulate a correlation matrix.
    R <- rLKJ(n=1, eta=1, dim=5)
    
    # let's print the simulated correlation matrix
    R
  authors:
  see_also: 'dnLKJPartial'
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'MatrixRealSymmetric'
  constructor:
    - usage: 'dnLKJ(RealPos<any> eta, Natural<any> dim)'
      arguments:
        - label: 'eta'
          description: 'The parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'dim'
          description: 'The dimensions of the correlation matrix.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
    - citation: 'Lewandowski D, D Kurowicka, H Joe (2009). Generating random correlation matrices based on vines and extended onion method. Journal of Multivariate Analysis, 100(9):1989-2001.'
      doi:
      url:
- name: 'dnLKJPartial'
  title: 'LKJ Distribution (for partial correlation matrices)'
  aliases:
  description: 'The LKJ (Lewandowski-Kurowicka-Joe) distribution (on the partial correlation matrix) with concentration parameter eta.'
  details: |
    The LKJPartial distribution is uniform over positive-definite correlation matrices when eta=1.
    
    The probability density of a correlation matrix under the LKJ distribution is:
    
    f(x) = det(x)^(eta - 1)
  example: |
    # we simulate a partial correlation matrix.
    P <- rLKJPartial(n=1, eta=1, dim=5)
    
    # let's print the simulated partial correlation matrix
    P
  authors:
  see_also: 'dnLKJ'
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'MatrixRealSymmetric'
  constructor:
    - usage: 'dnLKJPartial(RealPos<any> eta, Natural<any> dim)'
      arguments:
        - label: 'eta'
          description: 'The parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'dim'
          description: 'The dimensions of the correlation matrix.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
    - citation: 'Lewandowski D, D Kurowicka, H Joe (2009). Generating random correlation matrices based on vines and extended onion method. Journal of Multivariate Analysis, 100(9):1989-2001.'
      doi:
      url:
- name: 'dnLaplace'
  title: 'Laplace Distribution'
  aliases:
  description: 'Laplace distribution with mean equal to `mean` and scale equal to `scale`.'
  details: |
    The Laplace distribution has density:
    
    f(x) = 1/(2 b) e^-(abs(x-mu)/b)
    
    where mu is the mean of the distribution and b the scale.
  example:
  authors:
  see_also:
    - 'dnExponential'
    - 'dnNormal'
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnLaplace(Real<any> mean, RealPos<any> scale)'
      arguments:
        - label: 'mean'
          description: 'The mean parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'scale'
          description: 'The scale parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
  methods:
  references:
- name: 'dnLog'
  title: 'Log-scaled distribution'
  aliases:
  description: 'Log-scales a given distribution.'
  details: |
    If X ~ dist then exp(X) ~ dnLog(dist)
    
    This provides a way to construct distributions like dnLognormal and
    dnLoguniform directly from the underlying distribution in log-space.
    It can therefore express distributions that are not directly implemented.
    
    The distribution `dist` can be either univariate (dnNormal) or
    multivariate (dnMultivariateNormal).
  example: |
    x ~ dnLog(dnNormal(0,1))          # Draw from the log-Normal distribution
    x ~ dnNormal(0,1) |> dnLog()      # Expressed using pipes.
    x ~ dnLognormal(0,1)              # This is equivalent.
    y ~ dnNormal(0,1)
    x := exp(y)                       # This is also equivalent.
    
    x ~ dnLog(dnGamma(2,3))           # There is no equivalent for this.
    x ~ dnIID(10,dnLog(dnGamma(2,3))) # Draw 10 log-Gamma(2,3) random variables.
    
    mu = [1.0, 2.0, 3.0, 4.0]
    Sigma ~ dnWishart(df=4, kappa=2, dim=4)
    x ~ dnLog(dnMultivariateNormal(mu,Sigma))
  authors:
  see_also:
    - 'dnLognormal'
    - 'dnLoguniform'
  type_spec:
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnLog(Distribution__Real|Distribution__RealPos|Distribution__Probability<any> logDistribution)'
      arguments:
        - label: 'logDistribution'
          description: 'The distribution in log-space.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
  methods:
  references:
- name: 'dnLogExponential'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnLogExponential(RealPos<any> lambda)'
      arguments:
        - label: 'lambda'
          description: 'The rate of the exonential distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnLognormal'
  title: 'Lognormal Distribution'
  aliases: 'dnLnorm'
  description: 'Lognormal distribution is the distribution for a log-transformed normally distributed random variable with mean ''mu'' and standard deviation ''sigma''.'
  details: |
    The lognormal random variable is defined as
    
    :X = exp(mu + sigma Z)
    
    where mu is the mean parameter, sigma is the standard deviation, and Z is a standard normal random variable. Note, in effect, the mean and standard deviation provide the location and scale of the exponentiated normal variate, mu + sigma Z.The lognormal distribution has density:
    
    f(x) = 1/(x sigma sqrt(2 pi)) e^-((ln x - mu)^2/(2 sigma^2))
    
    where mu is the mean of the distribution and sigma the standard deviation.
  example: |
    # set an expected value for x
    expectation_of_x <- 1
    # set a mean and sd parameter
    sd <- 0.5
    mean <- ln(expectation_of_x) - 0.5 * sd^2
    # create a lognormal distribution with expected value of 1
    x ~ dnLognormal(mean=mean, sd=sd)
  authors:
  see_also:
  type_spec:
    - 'PositiveContinuousDistribution'
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnLognormal(Real<any> mean, RealPos<any> sd, RealPos<any> offset)'
      arguments:
        - label: 'mean'
          description: 'The mean in log-space (observed mean is exp(m)).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'sd'
          description: 'The standard deviation in log-space.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'offset'
          description: 'The offset in real-space.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
  methods:
  references:
- name: 'dnLoguniform'
  title: 'Log-Uniform Distribution'
  aliases:
  description: 'A strictly positive real number x has a log-uniform distribution over interval (min,max) if its logarithm y = ln(x) has uniform distribution over interval (ln(min),ln(max)).'
  details: |
    The log-uniform distribution is defined over strictly positive real numbers. Saying that x is log-uniform is equivalent to saying that y = ln(x) is uniform. The log-uniform distribution therefore expresses lack of information about the order of magnitude of a scale parameter:  if x has a log-uniform distribution, then it has equal chance to be contained by any of the intervals of the form (10^k, 10^(k+1)) within the allowed range.
    
    The density is p(x) = 1/x, which can be seen by defining x = exp(y) where y has uniform distribution and apply the change-of-variable formula.
    
    The log-uniform distribution is improper when defined over the entire positive real line. To always make it proper, in RevBayes, a min and a max should always be specified.
  example: |
    # a log-uniform prior over the rate of change of a Brownian trait (or a Brownian relaxed clock)
    trueTree = readTrees("data/primates.tree")[1]
    sigma ~ dnLogUniform(min=0.001, max=1000)
    X ~ dnBrownian(trueTree,sigma)
    # ...
  authors:
  see_also: 'dnUniform'
  type_spec:
    - 'PositiveContinuousDistribution'
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnLoguniform(RealPos<any> min, RealPos<any> max)'
      arguments:
        - label: 'min'
          description: 'The lower bound.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'max'
          description: 'The upper bound.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnMarkovEvents'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'OrderedEvents<Real>'
  constructor:
    - usage: 'dnMarkovEvents(OrderedEventTimes<any> eventTimes, Distribution__Real<any> baseDistribution)'
      arguments:
        - label: 'eventTimes'
          description: 'The times of the events.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'OrderedEventTimes'
          default:
          options:
        - label: 'baseDistribution'
          description: 'The base distribution for the per event values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
  methods:
  references:
- name: 'dnMarkovTimes'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__OrderedEventTimes'
    - 'Distribution'
    - 'RevObject'
  domain: 'OrderedEventTimes'
  constructor:
    - usage: 'dnMarkovTimes(RealPos<any> rate, RealPos<any> age)'
      arguments:
        - label: 'rate'
          description: 'The rate of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'age'
          description: 'The age of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnMixture'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnMixture(Real[]<any> values, Simplex<any> probabilities)'
      arguments:
        - label: 'values'
          description: 'The potential values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'probabilities'
          description: 'The probabilitoes for each value.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default:
          options:
  methods:
  references:
- name: 'dnMixtureAnalytical'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnMixtureAnalytical(Distribution__Real[]<any> baseDistributions, Simplex<any> probabilities)'
      arguments:
        - label: 'baseDistributions'
          description: 'The base distribution for the per category values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real[]'
          default:
          options:
        - label: 'probabilities'
          description: 'The probabilities for each value.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default:
          options:
  methods:
  references:
- name: 'dnMixtureVector'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real[]'
  constructor:
    - usage: 'dnMixtureVector(Distribution__Real[]<any> baseDistributions, Simplex<any> probabilities, Natural<any> numValues)'
      arguments:
        - label: 'baseDistributions'
          description: 'The base distribution for the per category values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real[]'
          default:
          options:
        - label: 'probabilities'
          description: 'The probabilities for each value.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default:
          options:
        - label: 'numValues'
          description: 'The number of values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'dnMultiSpeciesCoalescent'
  title: 'Multispecies coalescent distribution'
  aliases:
  description: 'Multispecies coalescent distribution describing how gene trees can be generated from within a species tree given a constant effective population size. Requires an ultrametric species tree, effective population size(s) (a single real positive or a vector of real positives), and taxa with species and individual names.'
  details: |
    The species tree must be ultrametric.
    Effective population sizes can be constant across the species tree, if a single real positive is provided, or branchwise, if a vector is provided.
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a constant effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescent(speciesTree=spTree, Ne=popSize, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # We can save the species tree:
    write(spTree, filename=dataFolder+"speciesTree")
    
    # Saving the gene trees:
    for (i in 1:(n_genes)) {
        write(geneTrees[i], filename=dataFolder+"geneTree_"+i+".tree")
    }
  authors:
  see_also:
    - 'dnMultiSpeciesCoalescentInverseGamma'
    - 'dnMultiSpeciesCoalescentUniformPrior'
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnMultiSpeciesCoalescent(TimeTree<any> speciesTree, RealPos|RealPos[]<any> Ne, Taxon[]<any> taxa)'
      arguments:
        - label: 'speciesTree'
          description: 'The species tree in which the gene trees evolve.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'Ne'
          description: 'The effective population size(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
    - citation: 'Rannala B, Yang Z (2003). Bayes estimation of species divergence times and ancestral population sizes using DNA sequences from multiple loci. Genetics, 164(4):1645-1656.'
      doi: '10.1093/genetics/164.4.1645'
      url: 'https://academic.oup.com/genetics/article-abstract/164/4/1645/6050371'
- name: 'dnMultiSpeciesCoalescentInverseGamma'
  title: 'Multispecies coalescent distribution with inverse gamma prior on effective population sizes'
  aliases:
  description: 'Multispecies coalescent distribution describing how gene trees can be generated from within a species tree given effective population sizes. Requires an ultrametric species tree, parameters of an inverse gamma prior on effective population sizes, and taxa with species and individual names.'
  details: |
    The species tree must be ultrametric.
    Parameters of an inverse gamma prior on effective population sizes must be provided.
    This distribution uses a conjugate prior on effective population sizes. As a consequence, effective population sizes are analytically integrated out and treated as nuisance parameters (Jones 2016). If you are interested in inferring ancestral effective population sizes, use `dnMultiSpeciesCoalescent`.
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick constant parameters for the inverse gamma distribution:
    alpha <- 3
    beta <- 0.003
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescentInverseGamma(speciesTree=spTree, shape=alpha, scale=beta, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # We can save the species tree:
    write(spTree, filename=dataFolder+"speciesTree")
    
    # Saving the gene trees:
    for (i in 1:(n_genes)) {
        write(geneTrees[i], filename=dataFolder+"geneTree_"+i+".tree")
    }
  authors:
  see_also:
    - 'dnMultiSpeciesCoalescent'
    - 'dnMultiSpeciesCoalescentUniformPrior'
  type_spec:
    - 'Distribution__TimeTree[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree[]'
  constructor:
    - usage: 'dnMultiSpeciesCoalescentInverseGamma(TimeTree<any> speciesTree, RealPos<any> shape, RealPos<any> scale, Natural<any> num_genes, Taxon[][]<any> taxa)'
      arguments:
        - label: 'speciesTree'
          description: 'The species tree in which the gene trees evolve.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'shape'
          description: 'The shape of the inverse gamma prior distribution on the effective population sizes.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'scale'
          description: 'The scale of the inverse gamma prior distribution on the effective population sizes.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'num_genes'
          description: 'The number of genes.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[][]'
          default:
          options:
  methods:
  references:
    - citation: 'Jones G (2016). Algorithmic improvements to species delimitation and phylogeny estimation under the multispecies coalescent. Journal of Mathematical Biology, 74:447-467.'
      doi: '10.1007/s00285-016-1034-0'
      url: 'http://www.indriid.com/2016/2016-06-01-STACEY.pdf'
- name: 'dnMultiSpeciesCoalescentUniformPrior'
  title: 'Multispecies coalescent distribution with uniform prior on effective population sizes'
  aliases:
  description: 'Multispecies coalescent distribution describing how gene trees can be generated from within a species tree given effective population sizes. Requires an ultrametric species tree, an upper bound for the uniform prior on effective population sizes (a single real positive), and taxa with species and individual names.'
  details: |
    The species tree must be ultrametric.
    This distribution uses a uniform prior on effective population sizes. As a consequence, effective population sizes are analytically integrated out and treated as nuisance parameters (Hey & Nielsen 2007).
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a maximum effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescentUniformPrior(speciesTree=spTree, max=popSize, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # We can save the species tree:
    write(spTree, filename=dataFolder+"speciesTree")
    
    # Saving the gene trees:
    for (i in 1:(n_genes)) {
        write(geneTrees[i], filename=dataFolder+"geneTree_"+i+".tree")
    }
  authors:
  see_also:
    - 'dnMultiSpeciesCoalescent'
    - 'dnMultiSpeciesCoalescentInverseGamma'
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnMultiSpeciesCoalescentUniformPrior(TimeTree<any> speciesTree, RealPos<any> max, Taxon[]<any> taxa)'
      arguments:
        - label: 'speciesTree'
          description: 'The species tree in which the gene trees evolve.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'max'
          description: 'The maximum effective population size.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
    - citation: 'Rannala B, Yang Z (2003). Bayes estimation of species divergence times and ancestral population sizes using DNA sequences from multiple loci. Genetics, 164(4):1645-1656.'
      doi: '10.1093/genetics/164.4.1645'
      url: 'https://academic.oup.com/genetics/article-abstract/164/4/1645/6050371'
    - citation: 'Heled J, Drummond AJ (2010). Bayesian inference of species trees from multilocus data. Molecular Biology and Evolution, 27(3):570-580.'
      doi: '10.1093/molbev/msp274'
      url: 'https://academic.oup.com/mbe/article/27/3/570/999753'
    - citation: 'Hey J, Nielsen R (2007). Integration within the Felsenstein equation for improved Markov chain Monte Carlo methods in population genetics. Proceedings of the National Academy of Sciences of the USA, 104(8):2785-2790.'
      doi: '10.1073/pnas.0611164104'
      url: 'https://www.pnas.org/content/104/8/2785'
- name: 'dnMultiValueEvent'
  title: 'MultiValueEvent Distribution'
  aliases:
  description: 'A MultiValueEvent distribution.'
  details:
  example:
  authors:
  see_also: 'dnEvent'
  type_spec:
    - 'Distribution__MultiValueEvent'
    - 'Distribution'
    - 'RevObject'
  domain: 'MultiValueEvent'
  constructor:
    - usage: 'dnMultiValueEvent(Distribution__Natural<any> eventDistribution, Distribution[]<any> valueDistribution, String[]<any> names, Natural[]<any> minNumberEvents)'
      arguments:
        - label: 'eventDistribution'
          description: 'The prior on the number of events.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Natural'
          default:
          options:
        - label: 'valueDistribution'
          description: 'The base distribution for the per category values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution[]'
          default:
          options:
        - label: 'names'
          description: 'The names of the values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String[]'
          default:
          options:
        - label: 'minNumberEvents'
          description: 'The minum number of values per value category.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural[]'
          default:
          options:
  methods:
  references:
- name: 'dnMultinomial'
  title: 'Multinomial Distribution'
  aliases:
  description: 'A multinomial distribution defines a probability distribution on a vector of natural numbers. It is understood as randomly picking n times from the k categories with replacement where each catefory has its own probability p[i].'
  details:
  example: |
    p <- simplex(1,1,1,1)
    x ~ dnMultinomial(10, p)
    y ~ dnDirichlet(x)
    y.clamp( simplex(1,2,3,4) )
    moves[1] = mvSlide(x, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", x)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also: 'dnDirichlet'
  type_spec:
    - 'Distribution__Natural[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural[]'
  constructor:
    - usage: 'dnMultinomial(Simplex<any> p, Natural<any> size)'
      arguments:
        - label: 'p'
          description: 'The simplex of probabilities for the categories.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default:
          options:
        - label: 'size'
          description: 'The number of draws.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'dnMultispeciesCoalescentMigration'
  title:
  aliases: 'dnMSCM'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnMultispeciesCoalescentMigration(TimeTree<any> speciesTree, RealPos|RealPos[]<any> Ne, RateGenerator<any> Q, RealPos<any> rate, Taxon[]<any> taxa)'
      arguments:
        - label: 'speciesTree'
          description: 'The species tree in which the gene trees evolve.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'Ne'
          description: 'The effective population size(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'Q'
          description: 'The migration rate matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGenerator'
          default:
          options:
        - label: 'rate'
          description: 'The rate scalar of the migration rate matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnMultivariateNormal'
  title: 'Multivariate Normal Distribution'
  aliases:
  description: |
    The multivariate normal distribution has the probability density:
    
    f(x) = det(2 pi Sigma)^(-1/2) e^{-(1/2) (x-mu)' Sigma^-1 (x-mu)}
    
    where mu is a vector of mean values and Sigma is a covariance matrix. Note, this distribution may also be parameterized in terms of the precision matrix, Sigma^-1.
  details:
  example: |
    dim = 4
    df = 100
    kappa <- 2
    Sigma ~ dnWishart(df, kappa, dim)
    for (i in 1:dim) { mu[i] ~ dnUnif(-1, 1) }
    x ~ dnMultivariateNormal( mean=mu, covariance=Sigma )
    mv[1] = mvCorrelationMatrixElementSwap(Sigma)
    mv[2] = mvCorrelationMatrixRandomWalk(Sigma)
    mv[3] = mvCorrelationMatrixSingleElementBeta(Sigma)
    mv[4] = mvCorrelationMatrixSpecificElementBeta(Sigma)
    mv[5] = mvCorrelationMatrixUpdate(Sigma)
    mv[6] = mvVectorSlide(x)
  authors:
  see_also:
    - 'dnNormal'
    - 'dnWishart'
    - 'mvCorrelationMatrixUpdate'
  type_spec:
    - 'Distribution__Real[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real[]'
  constructor:
    - usage: 'dnMultivariateNormal(Real[]<any> mean, MatrixRealSymmetric<any> covariance, MatrixRealSymmetric<any> precision, RealPos<any> scale)'
      arguments:
        - label: 'mean'
          description: 'The vector of mean values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'covariance'
          description: 'The variance-covariance matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'MatrixRealSymmetric'
          default: 'NULL'
          options:
        - label: 'precision'
          description: 'The precision matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'MatrixRealSymmetric'
          default: 'NULL'
          options:
        - label: 'scale'
          description: 'The scaling factor of the variance matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
  methods:
    - name: 'clampAt'
      return_type: 'void'
      usage: 'clampAt(Natural<any> index, Real<any> value)'
      arguments:
        - label: 'index'
          description: 'The index of the value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'value'
          description: 'The observed value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Real'
          default:
          options:
  references:
- name: 'dnNbinomial'
  title: 'Negative Binomial Distribution'
  aliases: 'dnNbinom'
  description: 'Negative binomial probability distribution of x successes before r failures.'
  details: 'The negative binomial probability distribution describes the number of successes before r failures, where the success probability is p. The probability is given by (x + r - 1 choose x) p^(x) * (1-p)^r'
  example: |
    p ~ dnBeta(1.0,1.0)
    x ~ dnNegativeBinomial(r=10,p)
    x.clamp(8)
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", x)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also: 'dnBinomial'
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural'
  constructor:
    - usage: 'dnNbinomial(Natural<any> size, Probability<any> p)'
      arguments:
        - label: 'size'
          description: 'Number of failures.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'p'
          description: 'Probability of success.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'dnNormal'
  title: 'Normal Distribution'
  aliases: 'dnNorm'
  description: 'Normal (gaussian) distribution with mean equal to `mean` and standard deviation equal to `sd`.'
  details: |
    The normal distribution has density:
    
    f(x) = 1/(sqrt(2 pi) sigma) e^-((x - mu)^2/(2 sigma^2))
    
    where mu is the mean of the distribution and sigma the standard deviation.
  example: |
    # we simulate some observations
    x <- rnorm(n=10,mean=5,sd=10)
    # let's see what the minimum is (you could do the max too)
    min(x)
    # let's also see what the mean and the variance are
    mean(x)
    var(x)
    sd(x)
  authors:
  see_also: 'dnLognormal'
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnNormal(Real<any> mean, RealPos<any> sd)'
      arguments:
        - label: 'mean'
          description: 'The mean parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'sd'
          description: 'The standard deviation parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
  methods:
  references:
- name: 'dnOrnsteinUhlenbeck'
  title: 'Bernoulli Distribution'
  aliases: 'dnOU'
  description: 'A Bernoulli-distributed random variable takes the value 1 with probability p and the value 0 with probability 1-p.'
  details:
  example: |
    p ~ dnBeta(1.0,1.0)
    x ~ dnBernoulli(p)
    x.clamp(1)
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", speciation)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also: 'dnBinomial'
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnOrnsteinUhlenbeck(Real<any> x0, Real<any> theta, RealPos<any> alpha, RealPos<any> sigma, RealPos<any> time)'
      arguments:
        - label: 'x0'
          description: 'The root parameter value.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'theta'
          description: 'The location of the optimum parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'alpha'
          description: 'The attraction to the optimum parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'sigma'
          description: 'The scaling parameter of the time.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'time'
          description: 'The duration of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnOutgroupBirthDeath'
  title:
  aliases: 'dnOutgroupBDP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnOutgroupBirthDeath(RealPos<any> lambda, RealPos<any> mu, Probability<any> rhoIngroup, Probability<any> rhoOutgroup, Taxon[]<any> taxaOutgroup, String<any> samplingStrategyOutgroup {valid options: "uniform"|"diversified"}, String<any> samplingStrategyIngroup {valid options: "uniform"|"diversified"}, RealPos<any> rootAge, String<any> samplingStrategy {valid options: "uniform"|"diversified"}, String<any> condition {valid options: "time"|"survival"|"nTaxa"}, Taxon[]<any> taxa, Clade[]<any> incompleteClades)'
      arguments:
        - label: 'lambda'
          description: 'The constant speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The constant extinction rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'rhoIngroup'
          description: 'The ingroup sampling probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'rhoOutgroup'
          description: 'The outgroup sampling probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'taxaOutgroup'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'samplingStrategyOutgroup'
          description: 'The sampling strategy of including outgroup taxa at the present.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'uniform'
          options:
            - 'uniform'
            - 'diversified'
        - label: 'samplingStrategyIngroup'
          description: 'The sampling strategy of including ingroup taxa at the present.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'uniform'
          options:
            - 'uniform'
            - 'diversified'
        - label: 'rootAge'
          description: 'The time of the process starting at the root, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'samplingStrategy'
          description: 'The sampling strategy of including taxa at the present.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'uniform'
          options:
            - 'uniform'
            - 'diversified'
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'nTaxa'
        - label: 'taxa'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'incompleteClades'
          description: 'Vector of incompletely sampled clades with number of missing species.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade[]'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnPhyloBranchRateBM'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__RealPos[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos[]'
  constructor:
    - usage: 'dnPhyloBranchRateBM(TimeTree<any> tree, RealPos<any> rootState, RealPos<any> sigma, Real<any> drift)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the continuous character evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'rootState'
          description: 'The value of the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'sigma'
          description: 'The branch-length multiplier to scale the variance of the Brownian motion.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'drift'
          description: 'The drift parameter of the Brownian motion.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
  methods:
  references:
- name: 'dnPhyloBrownian'
  title:
  aliases: 'dnPhyloBM'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Real[]'
  constructor:
    - usage: 'dnPhyloBrownian(TimeTree<any> tree, RealPos<any> sigma, Real<any> drift)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the continuous character evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'sigma'
          description: 'The branch-length multiplier to scale the variance of the Brownian motion.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'drift'
          description: 'The drift parameter of the Brownian motion.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
  methods:
  references:
- name: 'dnPhyloBrownianMVN'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloBrownianMVN(Tree<any> tree, RealPos|RealPos[]<any> branchRates, RealPos|RealPos[]<any> siteRates, Real|Real[]<any> rootStates, Natural<any> nSites)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the character evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'branchRates'
          description: 'The rate of evolution along a branch.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'siteRates'
          description: 'The rate of evolution per site.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'rootStates'
          description: 'The vector of root states.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'nSites'
          description: 'The number of sites which is used for the initialized (random draw) from this distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
  methods:
  references:
- name: 'dnPhyloBrownianMultiSampleREML'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloBrownianMultiSampleREML(Tree<any> tree, RealPos|RealPos[]<any> branchRates, RealPos[]<any> withinSpeciesVariances, RealPos|RealPos[]<any> siteRates, Taxon[]<any> taxa, Natural<any> nSites)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'branchRates'
          description: 'The per branch rate-multiplier(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'withinSpeciesVariances'
          description: 'The per species within-species variances.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'siteRates'
          description: 'The per site rate-multiplier(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'nSites'
          description: 'The number of sites used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
  methods:
  references:
- name: 'dnPhyloBrownianMultiVariate'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Real[][]'
  constructor:
    - usage: 'dnPhyloBrownianMultiVariate(TimeTree<any> tree, MatrixRealSymmetric<any> sigma)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'sigma'
          description: 'The variance-covariance matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'MatrixRealSymmetric'
          default:
          options:
  methods:
  references:
- name: 'dnPhyloBrownianREML'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloBrownianREML(Tree<any> tree, RealPos|RealPos[]<any> branchRates, RealPos|RealPos[]<any> siteRates, Natural<any> nSites)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'branchRates'
          description: 'The per branch rate-multiplier(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'siteRates'
          description: 'The per site rate-multiplier(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'nSites'
          description: 'The number of sites used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
  methods:
  references:
- name: 'dnPhyloCTMC'
  title: 'Distribution of a phylogenetic continuous-time Markov chain'
  aliases:
  description: |
    Gives the probability distribution of the character state vectors at the leaves
    of a phylogenetic tree, given a phylogenetic continuous-time Markov chain
    model.
  details: |
    The parameters of a phylogenetic model -- a tree topology with branch lengths,
    a substitution model that describes how observations evolve over the tree, etc.
    -- collectively form a distribution called the _phylogenetic continuous-time
    Markov chain_.
    
    The likelihood of observed character state vectors (specified via clamping the
    distribution to a `AbstractHomologousDiscreteCharacterData` object) is computed
    using Felsenstein's pruning algorithm, with partial likelihoods stored for each
    branch of the tree. It is automatically outputted in the `Likelihood` column of
    the `mnFile()` and `mnScreen()` monitors (which can be suppressed with
    `likelihood = FALSE`).
    
    Optionally, an observation error model can be applied to 
    account for scoring ambiguity (e.g., in morphological datasets). 
    This distinguishes between the true biological state and the recorded score.
    When `observationErrorProbability` (epsilon) is > 0, the tip likelihoods
    are initialized as a mixture: with probability (1 - epsilon), the score 
    is accurate; with probability epsilon, the score is drawn from the 
    distribution defined by `observationErrorFrequencies`
    
    For more details, see the tutorials on [graphical models](https://revbayes.github.io/tutorials/intro/graph_models) and on
    [specifying a phylogenetic continuous-time Markov chain](https://revbayes.github.io/tutorials/ctmc/) model.
  example: |
    # Read character data from a file
    chars <- readDiscreteCharacterData("myData.nex")
    taxa = chars.taxa()
    
    # Draw a tree with branch lengths
    tree ~ dnUniformTopologyBranchLength( taxa, branchLengthDistribution=dnExp(10.0) )
    
    # Define a rate matrix
    q_matrix <- fnJC(4)
    
    # Create stochastic node with the tip distribution given by `tree` and `q_matrix`
    x ~ dnPhyloCTMC(tree = tree, Q = q_matrix)
    
    # Clamp observed characters to the node
    x.clamp(chars)
    
    # Calculate the probability of the observed characters under the given distribution
    x.lnProbability()
    
    # Simulate characters
    sim ~ dnPhyloCTMC(tree = tree, Q = q_matrix, nSites = 24)
    
    # Print simulated characters to screen
    sim.show()
    
    # Write dataset to file
    writeNexus("simulatedData.nex", sim)
  authors:
  see_also:
  type_spec:
    - 'Distribution__AbstractHomologousDiscreteCharacterData'
    - 'Distribution'
    - 'RevObject'
  domain: 'AbstractHomologousDiscreteCharacterData'
  constructor:
    - usage: 'dnPhyloCTMC(Tree<any> tree, RateGenerator|RateGenerator[]|SiteMixtureModel<any> Q, Simplex<any> rootFrequencies, RealPos|RealPos[]<any> branchRates, Simplex|Bool<any> siteMatrices, RealPos[]<any> siteRates, Simplex<any> siteRatesProbs, Probability<any> pInv, Probability<any> observationErrorProbability, Simplex<any> observationErrorFrequencies, Natural<any> nSites, String<any> type {valid options: "DNA"|"RNA"|"AA"|"Codon"|"Doublet"|"PoMo"|"Protein"|"Standard"|"NaturalNumbers"|"Binary"|"Restriction"}, Bool<any> treatAmbiguousAsGap, String<any> coding {valid options: "all"|"noabsencesites"|"nopresencesites"|"informative"|"variable"|"nosingletonpresence"|"nosingletonabsence"|"nosingletons"}, Bool<any> storeInternalNodes, Bool<any> gapMatchClamped)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'Q'
          description: 'The global, branch-specific or site-mixture rate matrices.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGenerator'
          default:
          options:
        - label: 'rootFrequencies'
          description: 'The root specific frequencies of the characters, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'branchRates'
          description: 'The global or branch-specific rate multipliers.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'siteMatrices'
          description: 'Simplex of site matrix mixture probabilities. Treats Q as vector of site mixture categories instead of branch-specific matrices.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'siteRates'
          description: 'The rate categories for the sites.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'siteRatesProbs'
          description: 'The probability weights of rate categories for the sites.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'pInv'
          description: 'The probability of a site being invariant.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: 'NULL'
          options:
        - label: 'observationErrorProbability'
          description: 'The observational error probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: 'NULL'
          options:
        - label: 'observationErrorFrequencies'
          description: 'The observational error frequencies of the states once there was an observation error.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'nSites'
          description: 'The number of sites, used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'type'
          description: 'The data type, used for simulation and initialization.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'DNA'
          options:
            - 'DNA'
            - 'RNA'
            - 'AA'
            - 'Codon'
            - 'Doublet'
            - 'PoMo'
            - 'Protein'
            - 'Standard'
            - 'NaturalNumbers'
            - 'Binary'
            - 'Restriction'
        - label: 'treatAmbiguousAsGap'
          description: 'Should we treat ambiguous characters as gaps/missing?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'coding'
          description: 'What character patterns have been sampled?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'all'
          options:
            - 'all'
            - 'noabsencesites'
            - 'nopresencesites'
            - 'informative'
            - 'variable'
            - 'nosingletonpresence'
            - 'nosingletonabsence'
            - 'nosingletons'
        - label: 'storeInternalNodes'
          description: 'Should we store internal node states in the character matrix?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'gapMatchClamped'
          description: 'Should we set the simulated character to be gap or missing if the corresponding character in the clamped matrix is gap or missing?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  methods:
  references:
    - citation: 'Felsenstein J (1973). Maximum likelihood and minimum-steps methods for estimating evolutionary trees from data on discrete characters. Systematic Biology, 22(3):240--249.'
      doi: '10.1093/sysbio/22.3.240'
      url:
    - citation: 'Felsenstein J (1981). Evolutionary trees from DNA sequences: A maximum likelihood approach. Journal of Molecular Evolution, 17(6):368--376.'
      doi: '10.1007/BF01734359'
      url:
    - citation: 'Hhna S, Landis MJ, Heath TA (2017). Phylogenetic inference using `RevBayes`. Current Protocols in Bioinformatics, 57:6.16.1--6.16.34.'
      doi: '10.1002/cpbi.22'
      url:
- name: 'dnPhyloCTMCClado'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'AbstractHomologousDiscreteCharacterData'
  constructor:
    - usage: 'dnPhyloCTMCClado(Tree<any> tree, RateGenerator|RateGenerator[]|SiteMixtureModel<any> Q, CladogeneticProbabilityMatrix|CladogeneticProbabilityMatrix[]<deterministic> cladoProbs, Simplex<any> rootFrequencies, RealPos|RealPos[]<any> branchRates, RealPos[]<any> siteRates, Probability<any> pInv, Natural<any> nSites, String<any> type {valid options: "DNA"|"RNA"|"AA"|"PoMo"|"Protein"|"Standard"|"NaturalNumbers"|"Taxa"}, Bool<any> treatAmbiguousAsGap, Bool<any> storeInternalNodes, Bool<any> gapMatchClamped)'
      arguments:
        - label: 'tree'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'Q'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGenerator'
          default:
          options:
        - label: 'cladoProbs'
          description:
          dag_type: '<deterministic>'
          pass_by: 'const reference'
          value_type: 'CladogeneticProbabilityMatrix'
          default:
          options:
        - label: 'rootFrequencies'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'branchRates'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'siteRates'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'pInv'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '0'
          options:
        - label: 'nSites'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
        - label: 'type'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'NaturalNumbers'
          options:
            - 'DNA'
            - 'RNA'
            - 'AA'
            - 'PoMo'
            - 'Protein'
            - 'Standard'
            - 'NaturalNumbers'
            - 'Taxa'
        - label: 'treatAmbiguousAsGap'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'storeInternalNodes'
          description: 'Should we store internal node states in the character matrix?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'gapMatchClamped'
          description: 'Should we set the simulated character to gap or missing if the corresponding character in the clamped matrix is gap or missing?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  methods:
  references:
- name: 'dnPhyloCTMCDASequence'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'AbstractHomologousDiscreteCharacterData'
  constructor:
    - usage: 'dnPhyloCTMCDASequence(Tree<any> tree, RateGeneratorSequence|RateGeneratorSequence[]<any> Q, CladogeneticProbabilityMatrix<any> cladoProbs, Simplex<any> rootFrequencies, RealPos|RealPos[]<any> branchRates, RealPos[]<any> siteRates, Probability<any> pInv, Natural<any> nSites, String<any> type {valid options: "DNA"|"RNA"|"AA"|"PoMo"|"Protein"|"Standard"|"NaturalNumbers"|"Restriction"}, Bool<any> storeInternalNodes, Bool<any> treatAmbiguousAsGap, String<any> coding)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'Q'
          description: 'The global or branch-specific rate matrices.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGeneratorSequence'
          default:
          options:
        - label: 'cladoProbs'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'CladogeneticProbabilityMatrix'
          default: 'NULL'
          options:
        - label: 'rootFrequencies'
          description: 'The root specific frequencies of the characters, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'branchRates'
          description: 'The global or branch-specific rate multipliers.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'siteRates'
          description: 'The rate categories for the sites.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'pInv'
          description: 'The probability of a site being invariant.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '0'
          options:
        - label: 'nSites'
          description: 'The number of sites, used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
        - label: 'type'
          description: 'The data type, used for simulation and initialization.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'DNA'
          options:
            - 'DNA'
            - 'RNA'
            - 'AA'
            - 'PoMo'
            - 'Protein'
            - 'Standard'
            - 'NaturalNumbers'
            - 'Restriction'
        - label: 'storeInternalNodes'
          description: 'Should we store internal node states in the character matrix?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'treatAmbiguousAsGap'
          description: 'Should we treat ambiguous characters as gaps/missing?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'coding'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'all'
          options:
  methods:
  references:
- name: 'dnPhyloCTMCDASiteIID'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'AbstractHomologousDiscreteCharacterData'
  constructor:
    - usage: 'dnPhyloCTMCDASiteIID(Tree<any> tree, RateGenerator|RateGenerator[]<any> Q, Simplex<any> rootFrequencies, RealPos|RealPos[]<any> branchRates, RealPos[]<any> siteRates, Probability<any> pInv, Natural<any> nSites, String<any> type {valid options: "DNA"|"RNA"|"AA"|"PoMo"|"Protein"|"Standard"|"NaturalNumbers"|"Restriction"}, Bool<any> treatAmbiguousAsGap, String<any> coding)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'Q'
          description: 'The global or branch-specific rate matrices.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGenerator'
          default:
          options:
        - label: 'rootFrequencies'
          description: 'The root specific frequencies of the characters, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'branchRates'
          description: 'The global or branch-specific rate multipliers.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'siteRates'
          description: 'The rate categories for the sites.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'pInv'
          description: 'The probability of a site being invariant.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '0'
          options:
        - label: 'nSites'
          description: 'The number of sites, used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
        - label: 'type'
          description: 'The data type, used for simulation and initialization.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'DNA'
          options:
            - 'DNA'
            - 'RNA'
            - 'AA'
            - 'PoMo'
            - 'Protein'
            - 'Standard'
            - 'NaturalNumbers'
            - 'Restriction'
        - label: 'treatAmbiguousAsGap'
          description: 'Should we treat ambiguous characters as gaps/missing?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'coding'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'all'
          options:
  methods:
  references:
- name: 'dnPhyloCTMCDollo'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'AbstractHomologousDiscreteCharacterData'
  constructor:
    - usage: 'dnPhyloCTMCDollo(Tree<any> tree, RateGenerator|RateGenerator[]<any> Q, RealPos<any> deathRate, Simplex<any> rootFrequencies, RealPos|RealPos[]<any> branchRates, RealPos[]<any> siteRates, Natural<any> nSites, String<any> type {valid options: "Standard"|"Binary"|"Restriction"}, Bool<any> normalize, String<any> coding)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'Q'
          description: 'The global or branch-specific rate matrices.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGenerator'
          default: 'NULL'
          options:
        - label: 'deathRate'
          description: 'The Dollo character death rate'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'rootFrequencies'
          description: 'The root specific frequencies of the characters, if applicable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'branchRates'
          description: 'The global or branch-specific rate multipliers.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'siteRates'
          description: 'The rate categories for the sites.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'nSites'
          description: 'The number of sites, used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'type'
          description: 'The data type, used for simulation and initialization.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'Standard'
          options:
            - 'Standard'
            - 'Binary'
            - 'Restriction'
        - label: 'normalize'
          description: 'Should we normalize the Dollo substitution matrices?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'coding'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'noabsencesites'
          options:
  methods:
  references:
- name: 'dnPhyloDistanceGamma'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__DistanceMatrix'
    - 'Distribution'
    - 'RevObject'
  domain: 'DistanceMatrix'
  constructor:
    - usage: 'dnPhyloDistanceGamma(Tree<any> tree, DistanceMatrix<any> distanceMatrix, DistanceMatrix<any> varianceMatrix, String[]<any> names)'
      arguments:
        - label: 'tree'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'distanceMatrix'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'DistanceMatrix'
          default:
          options:
        - label: 'varianceMatrix'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'DistanceMatrix'
          default:
          options:
        - label: 'names'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String[]'
          default:
          options:
  methods:
  references:
- name: 'dnPhyloMultiSampleOrnsteinUhlenbeck'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloMultiSampleOrnsteinUhlenbeck(Tree<any> tree, RealPos|RealPos[]<any> alpha, Real|Real[]<any> theta, RealPos|RealPos[]<any> sigma, RealPos[]<any> withinSpeciesVariances, Real|Real[]<any> rootStates, Natural<any> nSites, Taxon[]<any> taxa)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the character evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'alpha'
          description: 'The rate of attraction/selection (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'theta'
          description: 'The optimum value (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '1'
          options:
        - label: 'sigma'
          description: 'The rate of random drift (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'withinSpeciesVariances'
          description: 'The per species within-species variances.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'rootStates'
          description: 'The vector of root states.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'nSites'
          description: 'The number of sites which is used for the initialized (random draw) from this distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnPhyloMultiSampleOrnsteinUhlenbeckREML'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloMultiSampleOrnsteinUhlenbeckREML(Tree<any> tree, RealPos|RealPos[]<any> alpha, Real|Real[]<any> theta, RealPos|RealPos[]<any> sigma, RealPos[]<any> withinSpeciesVariances, Real|Real[]<any> rootStates, Natural<any> nSites, Taxon[]<any> taxa)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the character evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'alpha'
          description: 'The rate of attraction/selection (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'theta'
          description: 'The optimum value (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '1'
          options:
        - label: 'sigma'
          description: 'The rate of random drift (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'withinSpeciesVariances'
          description: 'The per species within-species variances.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'rootStates'
          description: 'The vector of root states.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'nSites'
          description: 'The number of sites which is used for the initialized (random draw) from this distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnPhyloMultivariateBrownianMultiSampleREML'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloMultivariateBrownianMultiSampleREML(Tree<any> tree, RealPos|RealPos[]<any> branchRates, MatrixRealSymmetric|MatrixReal<any> rateMatrix, RealPos[][]<any> withinSpeciesVariances, Taxon[]<any> taxa)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'branchRates'
          description: 'The per branch rate-multiplier(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'rateMatrix'
          description: 'The variance-covariance matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'MatrixRealSymmetric'
          default:
          options:
        - label: 'withinSpeciesVariances'
          description: 'The per species per site within-species variances.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[][]'
          default:
          options:
        - label: 'taxa'
          description: 'The vector of taxa which have species and individual names.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnPhyloMultivariateBrownianREML'
  title: 'Phylogenetic Multivariate Brownian Motion'
  aliases:
  description: 'Multivariate Brownian motion over a phylogeny with variance-covariance matrix rateMatrix.'
  details:
  example: |
    
    # generate a tree and variance-covariance matrix.
    psi ~ dnUniformTimeTree(1, [taxon("A"),taxon("B"),taxon("C")])
    Sigma <- diagonalMatrix(5)
    
    # generate the multivariate data.
    x ~ dnPhyloMultivariateBrownianREML(tree=psi, rateMatrix=Sigma)
    
    # print the simulated data.
    x
  authors:
  see_also:
    - 'dnPhyloBrownianREML'
    - 'dnPhyloBrownianMVN'
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloMultivariateBrownianREML(Tree<any> tree, RealPos|RealPos[]<any> branchRates, MatrixRealSymmetric|MatrixReal<any> rateMatrix)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'branchRates'
          description: 'The per branch rate-multiplier(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'rateMatrix'
          description: 'The variance-covariance matrix.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'MatrixRealSymmetric'
          default:
          options:
  methods:
  references:
    - citation: 'Huelsenbeck JP, B Rannala (2003). Detecting correlation between characters in a comparative analysis with uncertain phylogeny. Evolution, 57(6):1237-1247.'
      doi:
      url:
- name: 'dnPhyloOrnsteinUhlenbeck'
  title:
  aliases: 'dnPhyloOU'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Real[]'
  constructor:
    - usage: 'dnPhyloOrnsteinUhlenbeck()'
      arguments:
  methods:
  references:
- name: 'dnPhyloOrnsteinUhlenbeckMVN'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloOrnsteinUhlenbeckMVN(Tree<any> tree, RealPos|RealPos[]<any> alpha, Real|Real[]<any> theta, RealPos|RealPos[]<any> sigma, Real|Real[]<any> rootStates, Natural<any> nSites)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the character evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'alpha'
          description: 'The rate of attraction/selection (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'theta'
          description: 'The optimum value (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '1'
          options:
        - label: 'sigma'
          description: 'The rate of random drift (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'rootStates'
          description: 'The vector of root states.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'nSites'
          description: 'The number of sites which is used for the initialized (random draw) from this distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
  methods:
  references:
- name: 'dnPhyloOrnsteinUhlenbeckPruning'
  title:
  aliases: 'dnPhyloOrnsteinUhlenbeckREML'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloOrnsteinUhlenbeckPruning(Tree<any> tree, RealPos|RealPos[]<any> alpha, Real|Real[]<any> theta, RealPos|RealPos[]<any> sigma, Real|Real[]<any> rootStates, Natural<any> nSites)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the character evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'alpha'
          description: 'The rate of attraction/selection (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'theta'
          description: 'The optimum value (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '1'
          options:
        - label: 'sigma'
          description: 'The rate of random drift (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'rootStates'
          description: 'The vector of root states.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'nSites'
          description: 'The number of sites which is used for the initialized (random draw) from this distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
  methods:
  references:
- name: 'dnPhyloOrnsteinUhlenbeckThreePoint'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'ContinuousCharacterData'
  constructor:
    - usage: 'dnPhyloOrnsteinUhlenbeckThreePoint(Tree<any> tree, RealPos|RealPos[]<any> alpha, Real|Real[]<any> theta, RealPos|RealPos[]<any> sigma, Real|Real[]<any> rootStates, Natural<any> nSites)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the character evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'alpha'
          description: 'The rate of attraction/selection (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'theta'
          description: 'The optimum value (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '1'
          options:
        - label: 'sigma'
          description: 'The rate of random drift (per branch).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'rootStates'
          description: 'The vector of root states.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'nSites'
          description: 'The number of sites which is used for the initialized (random draw) from this distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
  methods:
  references:
- name: 'dnPhyloWhiteNoise'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos[]'
  constructor:
    - usage: 'dnPhyloWhiteNoise(TimeTree<any> tree, RealPos<any> sigma)'
      arguments:
        - label: 'tree'
          description: 'The tree along which the process evolves.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'sigma'
          description: 'The standard deviation.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnPhylodynamicBirthDeathProcess'
  title:
  aliases:
    - 'dnPhylodynamicBDP'
    - 'dnPhylodynamicBDSTP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnPhylodynamicBirthDeathProcess(RealPos<any> rootAge, RealPos|RealPos[]<any> lambda, RealPos|RealPos[]<any> mu, RealPos|RealPos[]<any> phi, RealPos[]<any> timeline, RealPos[]<any> lambdaTimeline, RealPos[]<any> muTimeline, RealPos[]<any> phiTimeline, RealPos[]<any> PhiTimeline, String<any> condition {valid options: "time"|"survival"|"sampling"}, Taxon[]<any> taxa, TimeTree<any> initialTree, Natural<any> ageCheckPrecision, Probability|Probability[]<any> Phi, Probability[]<any> R, Probability|Probability[]<any> r, RealPos[]<any> rTimeline)'
      arguments:
        - label: 'rootAge/originAge'
          description: 'The start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The birth rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The death rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'phi/psi'
          description: 'The serial sampling rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'timeline'
          description: 'The rate interval change times of the piecewise constant process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'lambdaTimeline'
          description: 'The rate interval change times of the speciation rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'muTimeline'
          description: 'The rate interval change times of the extinction rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'phiTimeline/psiTimeline'
          description: 'The rate interval change times of the sampling rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'PhiTimeline/rhoTimeline'
          description: 'Times at which all taxa are sampled with some probability. There is always additionally a sampling event at the present.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'condition'
          description: 'The condition of the process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
            - 'sampling'
        - label: 'taxa'
          description: 'The taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'initialTree'
          description: 'Instead of drawing a tree from the distribution, initialize distribution with this tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'ageCheckPrecision'
          description: 'If an initial tree is provided, how many decimal places should be used when checking its tip ages against a taxon file?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '4'
          options:
        - label: 'Phi/rho'
          description: 'The probability of sampling taxa at sampling events (at present only if input is scalar).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '0'
          options:
        - label: 'R'
          description: 'The treatment probabilities for the sampling events (excluding sampling at present).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability[]'
          default: 'NULL'
          options:
        - label: 'r'
          description: 'The probabilit(y|ies) of death upon sampling (treatment).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'rTimeline'
          description: 'The rate interval change times of the (serial) treatment probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnPiecewiseOccurrenceBirthDeath'
  title:
  aliases: 'dnOBDP'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'BirthDeathProcess'
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnPiecewiseOccurrenceBirthDeath(RealPos<any> rootAge, RealPos|RealPos[]<any> lambda, RealPos|RealPos[]<any> mu, RealPos|RealPos[]<any> psi, RealPos|RealPos[]<any> r, RealPos|RealPos[]<any> omega, Probability|Probability[]<any> rho, RealPos[]<any> timeline, RealPos[]<any> lambdaTimeline, RealPos[]<any> muTimeline, RealPos[]<any> psiTimeline, RealPos[]<any> omegaTimeline, RealPos[]<any> rTimeline, String<any> condition {valid options: "survival"|"survival2"}, Taxon[]<any> taxa, TimeTree<any> initialTree, Natural<any> maxHiddenLin, Real[]<any> occurrence_ages, Bool<any> useMt, Bool<any> verbose)'
      arguments:
        - label: 'rootAge/originAge'
          description: 'Start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'Speciation/birth rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'Extinction/death rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'psi'
          description: 'Serial sampling rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'r'
          description: 'Probabilit(y|ies) of death upon sampling (treatment).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'omega'
          description: 'Occurrence sampling rate(s).'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'rho'
          description: 'Sampling fraction at present.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: 'NULL'
          options:
        - label: 'timeline'
          description: 'Rate interval change times of the piecewise constant process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: '[ ]'
          options:
        - label: 'lambdaTimeline'
          description: 'The rate interval change times of the speciation/birth rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'muTimeline'
          description: 'The rate interval change times of the extinction/death rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'psiTimeline'
          description: 'The rate interval change times of the serial sampling rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'omegaTimeline'
          description: 'The rate interval change times of the occurrence sampling rate.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'rTimeline'
          description: 'The rate interval change times of the (serial) treatment probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'condition'
          description: 'Condition of the process on the survival of either 1 (survival) or 2 lineages (survival2) to the present'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'none'
          options:
            - 'survival'
            - 'survival2'
        - label: 'taxa'
          description: 'Taxa used for initialization.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'initialTree'
          description: 'Instead of drawing a tree from the distribution, initialize distribution with this tree.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'maxHiddenLin'
          description: 'Maximum number of hidden lineages.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default: '30'
          options:
        - label: 'occurrence_ages'
          description: 'Fixed occurrence ages'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Real[]'
          default: 'NULL'
          options:
        - label: 'useMt'
          description: 'If true computes densities with the Mt forward traversal algorithm otherwise uses Lt backward one.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'verbose'
          description: 'If true displays warnings and information messages.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
  references:
- name: 'dnPointMass'
  title: 'Point Mass Distribution'
  aliases: 'dnDiracDelta'
  description: 'Point mass distribution.'
  details: 'The point mass distribution, or Dirac delta function, has density f(x) = 1 when x is equal to the point mass value.'
  example: 'u ~ dnPointMass(1.2)'
  authors:
  see_also:
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnPointMass(Real<any> value)'
      arguments:
        - label: 'value'
          description: 'The value where mass is concentrated.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
  methods:
  references:
- name: 'dnPoisson'
  title: 'Poisson Distribution'
  aliases: 'dnPois'
  description: 'A Poisson distribution defines probabilities for natural numbers. It is defined as the number of exponentially distributed events in a given interval.'
  details:
  example: |
    l ~ dnUniform(0.0,100.0)
    x ~ dnPoisson(l)
    x.clamp(10)
    moves[1] = mvSlide(l, delta=0.1, weight=1.0)
    monitors[1] = mnScreen(printgen=1000, separator = "        ", l)
    mymodel = model(l)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also: 'dnGeom'
  type_spec:
    - 'Distribution__Natural'
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural'
  constructor:
    - usage: 'dnPoisson(RealPos<any> lambda)'
      arguments:
        - label: 'lambda'
          description: 'The rate (rate = 1/mean) parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnReversibleJumpMixture'
  title:
  aliases: 'dnRJMixture'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnReversibleJumpMixture(Real<any> constantValue, Distribution__Real<any> baseDistribution, Probability<any> p)'
      arguments:
        - label: 'constantValue'
          description: 'The fixed value this distribution can take.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'baseDistribution'
          description: 'The distribution from which the value is alternatively drawn.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
        - label: 'p'
          description: 'The probability of being the fixed value.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'dnSSBDP'
  title: 'Sampled-speciation birth-death process'
  aliases:
  description: |
    Uses a data augmentation approach to sample hidden speciation events on
    a birth-death tree.
  details: |
    The sampled-speciation process is intended to be used in conjunction with
    dispersal-extinction-cladogenesis (DEC) biogeographic models.
  example: |
    # draw basic process parameters
    taxa <- [taxon("A"), taxon("B"), taxon("C"), taxon("D"), taxon("E")]
    root_age ~ dnUniform(0, 2)
    lambda ~ dnUniform(0, 1)
    mu ~ dnUniform(0, 1)
    rho <- 1
    
    # simulate tree
    tree ~ dnSSBDP(rootAge = root_age,
                   lambda  = lambda,
                   mu      = mu,
                   rho     = rho,
                   taxa    = taxa)
  authors:
  see_also:
    - 'dnCDBDP'
    - 'dnPhyloCTMCClado'
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnSSBDP(RealPos<any> rootAge, RealPos<any> lambda, RealPos<any> mu, Probability<any> rho, Taxon[]<any> taxa)'
      arguments:
        - label: 'rootAge'
          description: 'The age of the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The vector of speciation rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'mu'
          description: 'The vector of extinction rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rho'
          description: 'The taxon sampling probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
        - label: 'taxa'
          description: 'The taxa used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnScaledDirichlet'
  title: 'Scaled Dirichlet Distribution'
  aliases:
  description: 'Scaled Dirichlet probability distribution on a simplex.'
  details: 'The scaled Dirichlet probability distribution is the generalization of the dirichlet distribution. A random variable from a scaled Dirichlet distribution is a simplex, i.e., a vector of probabilities that sum to 1. If b[1]=b[2]=...=b[n], then the scaledDirichlet(alpha,beta) collapses to the Dirichlet with the same alphas.'
  example: |
    # lets get a draw from a Dirichlet distribution
    a <- [1,1,1,1]   # we could also use rep(1,4)
    b <- [1,2,3,4]   # if these are all equal, the scaled Dirichlet is equivilent to the Dirichlet(a)x ~ dnScaledDirichlet(a,b)
    x
    # let check if b really sums to 1
    sum(x)
  authors:
  see_also:
    - 'dnDirichlet'
    - 'simplex'
  type_spec:
    - 'Distribution__Simplex'
    - 'Distribution'
    - 'RevObject'
  domain: 'Simplex'
  constructor:
    - usage: 'dnScaledDirichlet(RealPos[]<any> alpha, RealPos[]<any> beta)'
      arguments:
        - label: 'alpha'
          description: 'The concentration parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'beta'
          description: 'The rate parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
  methods:
  references:
- name: 'dnSoftBoundUniformNormal'
  title: 'Softbound Uniform Distribution with Normal distributed tails.'
  aliases:
  description: 'A softbound uniform distribution with normally distributed tails outside the interval of the uniform distribution.'
  details: 'The center piece of this distribution a uniform distribution defined between the given interval. A variable is drawn from that uniform distribution with probability p and with probability 1-p outside the interval. The probability density outside the interval is described by a normal distribution with standard deviation sd.'
  example: |
    p ~ dnBeta(1.0,1.0)
    x ~ dnBernoulli(p)
    x.clamp(1)
    moves[1] = mvSlide(p, delta=0.1, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, separator = "        ", speciation)
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also: 'dnUniform'
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnSoftBoundUniformNormal(Real<any> min, Real<any> max, RealPos<any> sd, Probability<any> p)'
      arguments:
        - label: 'min'
          description: 'The min value of the uniform distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'max'
          description: 'The max value of the uniform distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'sd'
          description: 'The standard deviation of the normal distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'p'
          description: 'The probability of being within the uniform distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'dnStudentT'
  title: 'Student T Distribution'
  aliases:
    - 'dnStudentT'
    - 'dnT'
    - 'dnGossetT'
  description: 'The student''s t probability distribution.'
  details:
  example: |
    # The most important use of the Student T distribution
    # is arguable the quantile function.
    # You can access it the following way:
    df <- 10
    a := qStudentT(0.025, df)
    a
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnStudentT(Natural<any> df)'
      arguments:
        - label: 'df'
          description: 'The degrees of freedom.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'dnTimeVaryingStateDependentSpeciationExtinction'
  title:
  aliases: 'dnTVSSE'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnTimeVaryingStateDependentSpeciationExtinction(RealPos<any> rootAge, CladogeneticSpeciationRateMatrix|RealPos[][]<any> speciationRates, RealPos[][]<any> extinctionRates, RealPos[][]<any> psi, RealPos[]<any> epochs, RateGenerator[]<any> Q, RealPos<any> delta, Simplex<any> pi, Probability<any> rho, String<any> condition {valid options: "time"|"survival"}, RealPos<any> nTimeSlices, Natural<any> minNumLineages, Natural<any> maxNumLineages, Bool<any> pruneExtinctLineages)'
      arguments:
        - label: 'rootAge/originAge'
          description: 'The start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'speciationRates/lambda/cladoEventMap'
          description: 'The vector of speciation rates (for anagenetic-only models), or the map of speciation rates to cladogenetic event types.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'CladogeneticSpeciationRateMatrix'
          default:
          options:
        - label: 'extinctionRates/mu'
          description: 'The vector of extinction rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[][]'
          default:
          options:
        - label: 'psi/phi'
          description: 'The vector of serial sampling rates.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[][]'
          default: 'NULL'
          options:
        - label: 'epochs'
          description: 'The time intervals when the diversification and transition rates change.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'Q'
          description: 'The rate matrix of jumping between rate categories.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RateGenerator[]'
          default: 'NULL'
          options:
        - label: 'delta'
          description: 'The rate-factor of jumping between rate categories.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'pi'
          description: 'State frequencies at the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Simplex'
          default: 'NULL'
          options:
        - label: 'rho'
          description: 'The taxon sampling probability.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'condition'
          description: 'The condition of the birth-death process.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'time'
          options:
            - 'time'
            - 'survival'
        - label: 'nTimeSlices'
          description: 'The number of time slices for the numeric ODE.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '500'
          options:
        - label: 'minNumLineages'
          description: 'The minimum number of lineages to simulate.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'maxNumLineages'
          description: 'The maximum number of lineages to simulate.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '500'
          options:
        - label: 'pruneExtinctLineages'
          description: 'When simulating should extinct lineages be pruned off?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  methods:
  references:
- name: 'dnUPP'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__RealPos[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos[]'
  constructor:
    - usage: 'dnUPP(RealPos[]<any> values, Bool<any> include_zero)'
      arguments:
        - label: 'values'
          description: 'The possible non-zero values in the most fragmented partition of the set.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'include_zero'
          description: 'Should the partitions also include zero values?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  methods:
  references:
- name: 'dnUltrametricTree'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnUltrametricTree(Distribution__TimeTree<any> treePrior, Distribution__RealPos<any> ratePrior, RealPos<any> rootAge, Probability<any> rootBranchFraction, TraceTree<any> trees, Trace<any> density)'
      arguments:
        - label: 'treePrior'
          description: 'The prior distribution for the time tree (divergence times).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Distribution__TimeTree'
          default:
          options:
        - label: 'ratePrior'
          description: 'The prior distribution for the branch rates.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Distribution__RealPos'
          default:
          options:
        - label: 'rootAge'
          description: 'The root age variable.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'rootBranchFraction'
          description: 'The fraction of how much of the root branch is assigned to the left subtree.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Probability'
          default: 'NULL'
          options:
        - label: 'trees'
          description: 'The trace of tree samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'TraceTree'
          default:
          options:
        - label: 'density'
          description: 'Optional trace of probability density values for each tree.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Trace'
          default: 'NULL'
          options:
  methods:
  references:
- name: 'dnUniform'
  title: 'Uniform Distribution'
  aliases: 'dnUnif'
  description: 'Uniform distribution with lower and uppper bounds.'
  details: 'The uniform distribution has density, f(x) = 1/(b-a), where b is the upper bound and a is the lower bound.'
  example: |
    # set the lower bound
    a <- -2.5
    # set the upper bound
    b <- -3.9
    # create a stochastic node with a uniform prior
    u ~ dnUniform(a, b)
  authors:
  see_also:
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnUniform(Real<any> lower, Real<any> upper)'
      arguments:
        - label: 'lower'
          description: 'The lower bound.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
        - label: 'upper'
          description: 'The upper bound.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default:
          options:
  methods:
  references:
- name: 'dnUniformInteger'
  title: 'Uniform Integer Distribution'
  aliases: 'dnUnifInt'
  description: 'This distribution creates a stochastic node drawing a random integer from a uniform distribution.'
  details: |
    This distribution will randomly draw an integer using uniform distribution
    from a minimum to maximum integer set in the first and second arguments.
    This function can also be called using the alias 'dnUnifInt'.
  example: |
    # Create and assign stochastic node
    x ~ dnUniformInteger(1, 10)
  authors:
  see_also:
    - 'dnUniform'
    - 'dnNormal'
  type_spec:
    - 'Distribution__Integer'
    - 'Distribution'
    - 'RevObject'
  domain: 'Integer'
  constructor:
    - usage: 'dnUniformInteger(Integer<any> lower, Integer<any> upper)'
      arguments:
        - label: 'lower'
          description: 'The lower bound.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Integer'
          default:
          options:
        - label: 'upper'
          description: 'The upper bound.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Integer'
          default:
          options:
  methods:
  references:
- name: 'dnUniformNatural'
  title:
  aliases: 'dnUnifNat'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__Natural'
    - 'Distribution'
    - 'RevObject'
  domain: 'Natural'
  constructor:
    - usage: 'dnUniformNatural(Natural<any> lower, Natural<any> upper)'
      arguments:
        - label: 'lower'
          description: 'The lower bound.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'upper'
          description: 'The upper bound.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'dnUniformSerialSampledTimeTree'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnUniformSerialSampledTimeTree(RealPos<any> rootAge, Taxon[]<any> taxa)'
      arguments:
        - label: 'rootAge/originAge'
          description: 'The start time of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'taxa'
          description: 'The taxa used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnUniformTimeTree'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnUniformTimeTree(RealPos<any> rootAge, Taxon[]<any> taxa)'
      arguments:
        - label: 'rootAge'
          description: 'The age of the root.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'taxa'
          description: 'The taxa used for simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Taxon[]'
          default:
          options:
  methods:
  references:
- name: 'dnUniformTopology'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__BranchLengthTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'BranchLengthTree'
  constructor:
    - usage: 'dnUniformTopology(Taxon[]<any> taxa, Clade<any> outgroup, Clade[]<any> constraints, Bool<any> rooted)'
      arguments:
        - label: 'taxa'
          description: 'The vector of taxa that will be used for the tips.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'outgroup'
          description: 'The clade (consisting of one or more taxa) used as an outgroup.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade'
          default: 'NULL'
          options:
        - label: 'constraints'
          description: 'The topological constraints that will be enforced.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade[]'
          default: 'NULL'
          options:
        - label: 'rooted'
          description: 'Is the distribution over rooted topologies?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
  references:
- name: 'dnUniformTopologyBranchLength'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__BranchLengthTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'BranchLengthTree'
  constructor:
    - usage: 'dnUniformTopologyBranchLength(Taxon[]<any> taxa, Clade<any> outgroup, Distribution__RealPos<any> branchLengthDistribution)'
      arguments:
        - label: 'taxa'
          description: 'The vector of taxa that will be used for the tips.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Taxon[]'
          default:
          options:
        - label: 'outgroup'
          description: 'The clade (consisting of one or more taxa) used as an outgroup.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Clade'
          default: 'NULL'
          options:
        - label: 'branchLengthDistribution'
          description: 'The base distribution for the branch lengths.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Distribution__RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnVarianceGamma'
  title: 'Variance-gamma Distribution'
  aliases: 'dnVG'
  description: 'Variance-gamma distribution with location `mu`.'
  details: |
    The variance-gamma distribution has density:
    
    f(x) = 1/(sqrt(2 pi) sigma) e^-((x - mu)^2/(2 sigma^2))
    
    where mu is the mean of the distribution and sigma the standard deviation.
  example: |
    # we simulate some oversations
    x <- rnorm(n=10,mean=5,sd=10)
    # let's see what the minum is (you could do the max too)
    min(x)
    # let's also see what the mean and the variance are
    mean(x)
    var(x)
    sd(x)
  authors:
  see_also:
  type_spec:
    - 'ContinuousDistribution'
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'dnVarianceGamma(Real<any> mu, RealPos<any> kappa, RealPos<any> tau, RealPos<any> time)'
      arguments:
        - label: 'mu'
          description: 'The mean parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'kappa'
          description: 'The standard deviation parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tau'
          description: 'The standard deviation parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'time'
          description: 'The duration of time for the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default: '1'
          options:
  methods:
  references:
- name: 'dnWeightedConstrainedNodeOrder'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree'
  constructor:
    - usage: 'dnWeightedConstrainedNodeOrder(Distribution__TimeTree<any> treeDistribution, RlRelativeNodeAgeWeightedConstraints<any> constraints, RealPos<any> beta)'
      arguments:
        - label: 'treeDistribution'
          description: 'The base distribution for the tree.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__TimeTree'
          default:
          options:
        - label: 'constraints'
          description: 'The node order constraints.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RlRelativeNodeAgeWeightedConstraints'
          default:
          options:
        - label: 'beta'
          description: 'The beta weight for the constraints.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnWeightedSample'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution__TimeTree[]'
    - 'Distribution'
    - 'RevObject'
  domain: 'TimeTree[]'
  constructor:
    - usage: 'dnWeightedSample(Distribution__TimeTree|Distribution__TimeTree[]<any> baseDistribution, Natural<any> numSamples)'
      arguments:
        - label: 'baseDistribution'
          description: 'The base distribution(s) for the sampled values.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__TimeTree'
          default:
          options:
        - label: 'numSamples'
          description: 'The number of samples in the weighted average.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
  methods:
  references:
- name: 'dnWhiteNoise'
  title: 'White-Noise Process'
  aliases:
  description: 'White-Noise process for positive real numbers.'
  details: 'The white-noise process is a process of a positive continuous variable similar to Brownian motion and the Ornstein-Uhlenbeck process. However, the white-noise process has a large variance when the time is small, and has small variance if the time is large.'
  example: |
    # lets simulate
    a <- rWhiteNoise(1000,mu=1,sigma=4,time=4)
    # we expect a mean of 1
    mean(a)
    
    # create a random variable
    x ~ dnWhiteNoise(mu=1.0,sigma=4,time=1)
    x
  authors:
  see_also: 'dnGamma'
  type_spec:
    - 'PositiveContinuousDistribution'
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'dnWhiteNoise(RealPos<any> mu, RealPos<any> sigma, RealPos<any> time)'
      arguments:
        - label: 'mu'
          description: 'The mean of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'sigma'
          description: 'The standard deviation of the process.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'time'
          description: 'The time that the process has run.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'dnWishart'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'MatrixRealSymmetric'
  constructor:
    - usage: 'dnWishart(Natural<any> df, RealPos<any> kappa, Natural<any> dim)'
      arguments:
        - label: 'df'
          description: 'The degrees of dreedom.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'kappa'
          description: 'The scaling parameter.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'dim'
          description: 'The dimension of the distribution.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'mcmc'
  title: 'MCMC analysis object'
  aliases:
  description: 'The MCMC analysis object keeps a model and the associated moves and monitors. The object is used to run Markov chain Monte Carlo (MCMC) simulation on the model, using the provided moves, to obtain a sample of the posterior probability distribution. During the analysis, the monitors are responsible for sampling model parameters of interest.'
  details: |
    The MCMC analysis object produced by a call to this function keeps copies of the model and the associated moves and monitors. The MCMC analysis object is used to run Markov chain Monte Carlo (MCMC) simulation on the model, using the provided moves, to obtain a sample of the posterior probability distribution. During the analysis, the monitors are responsible for sampling model parameters of interest.
    
    The `mcmc.run()` method begins or continues an MCMC analysis. 
    
    During each iteration of an analysis, moves are selected from those listed in the `moves` parameter.  With the default `moveschedule = "random"`, or `moveschedule = "sequential"`, moves will be attempted, on average, `weight` times per iteration.  If `moveschedule = "single"`, RevBayes will attempt exactly one move per iteration, corresponding to the behavior of software like BEAST or MrBayes. See Hhna et al. (2017) for details.
    
    The run will continue for `generations` iterations, or until a stopping rule is triggered: perhaps once the run has attained convergence, or after a certain amount of time has passed.  The run will be terminated once *all* convergence rules ([`srGelmanRubin()`], [`srGeweke()`], [`srMinESS()`], [`srStationarity()`]) in its `StoppingRule[]` argument have been fulfilled; or once *any* threshold rules ([`srMaxTime()`], [`srMaxIteration()`]) are met.
    
    The parameters `checkpointFile` and `checkpointInterval` generate snapshots of the current state of the MCMC run from which the run can be continued if interrupted using the `mcmc.initializeFromCheckpoint()` method.
    
    The `mcmc.initializeFromCheckpoint()` method allows an analysis to be continued from a checkpoint file. New generations will be appended to existing monitor files.
  example: |
    # Create a simple model (unclamped)
    a ~ dnExponential(1)
    mymodel = model(a)
    
    # Create a move vector and a monitor vector
    moves[1] = mvScale( a, lambda = 1.0, weight = 1.0 )
    monitors[1] = mnFile( a, filename = "output/out.log" )
    
    # Create an mcmc object
    mymcmcObject = mcmc( mymodel, monitors, moves )
    
    # Run a short analysis
    mymcmcObject.burnin( generations = 400, tuningInterval = 100 )
    mymcmcObject.run( generations = 400, checkpointFile = "output/out.ckp", checkpointInterval = 100 )
    
    # print the summary of the operators (now tuned)
    mymcmcObject.operatorSummary()
    
    # Resume analysis from the checkpoint file
    mymcmcObject.initializeFromCheckpoint( "output/out.ckp" )
    
    # Conduct an additional 400 generations
    mymcmcObject.run( generations = 400 )
    
    # Stopping rules are defined on the total number of generations
    # This command will have no effect, as 400 generations have already been performed.
    mymcmcObject.run( rules = [ srMaxIteration(400) ] )
  authors:
  see_also: 'mcmcmc'
  type_spec:
    - 'MonteCarloAnalysis'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mcmc(Model<any> model, Monitor[]<any> monitors, Move[]<any> moves, String<any> moveschedule {valid options: "sequential"|"random"|"single"}, Natural<any> nruns, String<any> combine {valid options: "sequential"|"mixed"|"none"}, Natural<any> ntries, RealPos<any> priorHeat, RealPos<any> likelihoodHeat, RealPos<any> posteriorHeat)'
      arguments:
        - label: 'model'
          description: 'The model graph.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Model'
          default:
          options:
        - label: 'monitors'
          description: 'The monitors used for this analysis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Monitor[]'
          default:
          options:
        - label: 'moves'
          description: 'The moves used for this analysis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Move[]'
          default:
          options:
        - label: 'moveschedule'
          description: 'The strategy how the moves are used.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'random'
          options:
            - 'sequential'
            - 'random'
            - 'single'
        - label: 'nruns'
          description: 'The number of replicate analyses.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'combine'
          description: 'How should we combine the traces once the simulation is finished.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'none'
          options:
            - 'sequential'
            - 'mixed'
            - 'none'
        - label: 'ntries'
          description: 'The number of initialization attempts.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
        - label: 'priorHeat'
          description: 'The power that the prior will be raised to.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'likelihoodHeat'
          description: 'The power that the likelihood will be raised to.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'posteriorHeat'
          description: 'The power that the posterior will be raised to.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
  methods:
    - name: 'burnin'
      return_type: 'void'
      usage: 'burnin(Natural<any> generations, Natural<any> tuningInterval, Natural<any> verbose, Bool<any> underPrior)'
      arguments:
        - label: 'generations'
          description: 'The number of generation to run this burnin simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'tuningInterval'
          description: 'The interval when to update the tuning parameters of the moves.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'verbose'
          description: 'How much information to print to the screen (0: none, 1: basic information only, 2: more information at extra CPU time cost).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'underPrior'
          description: 'DEPRECATED'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'NULL'
          options:
    - name: 'initializeFromCheckpoint'
      return_type: 'void'
      usage: 'initializeFromCheckpoint(String<any> checkpointFile)'
      arguments:
        - label: 'checkpointFile'
          description: 'The checkpoint filename.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'operatorSummary'
      return_type: 'void'
      usage: 'operatorSummary(Bool<any> currentPeriod)'
      arguments:
        - label: 'currentPeriod'
          description: 'Should the operator summary (number of tries and acceptance, and the acceptance ratio) of only the current period (i.e., after the last tuning) be printed?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'run'
      return_type: 'void'
      usage: 'run(Natural<any> generations, StoppingRule[]<any> rules, Natural<any> tuningInterval, String<any> checkpointFile, Natural<any> checkpointInterval, Natural<any> verbose, Bool<any> underPrior)'
      arguments:
        - label: 'generations'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'rules'
          description: 'The rules when to automatically stop the run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'StoppingRule[]'
          default: 'NULL'
          options:
        - label: 'tuningInterval'
          description: 'The interval when to update the tuning parameters of the moves.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'checkpointFile'
          description: 'The filename for the checkpoint file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'checkpointInterval'
          description: 'The interval when to write parameters values to a files for checkpointing.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'verbose'
          description: 'How much information to print to the screen (0: none, 1: basic information only, 2: more information at extra CPU time cost).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'underPrior'
          description: 'DEPRECATED'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'NULL'
          options:
  references:
    - citation: 'Metropolis N, AW Rosenbluth, MN Rosenbluth, AH Teller, E Teller (1953). Equation of state calculations by fast computing machines. Journal of Chemical Physics, 21:1087-1092.'
      doi: '10.1063/1.1699114'
      url:
    - citation: 'Hastings WK (1970) Monte Carlo sampling methods using Markov chains and their applications. Biometrika, 57:97-109.'
      doi: '10.2307/2334940'
      url:
    - citation: 'Hhna S, Landis MJ, Heath TA (2017). Phylogenetic inference using `RevBayes`. Current Protocols in Bioinformatics, 57:6.16.1--6.16.34.'
      doi: '10.1002/cpbi.22'
      url:
- name: 'mcmcmc'
  title: 'Metropolis-Coupled MCMC analysis object'
  aliases:
  description: 'The Mcmcmc analysis object keeps a model and the associated moves and monitors. The object is used to run Metropolis Couped Markov chain Monte Carlo (Mcmcmc) simulation on the model, using the provided moves, to obtain a sample of the posterior probability distribution. During the analysis, the monitors are responsible for sampling model parameters of interest.'
  details: |
    The Mcmcmc analysis object produced by a call to this function keeps copies of the model and the associated moves and monitors. The Mcmcmc analysis object is used to run Markov chain Monte Carlo (Mcmcmc) simulation on the model, using the provided moves, to obtain a sample of the posterior probability distribution. During the analysis, the monitors are responsible for sampling model parameters of interest.
    
    An MCMCMC analysis is initiated using the `mcmcmc.run()` method.  
    The `StoppingRule[]` argument provides a mechanism to automatically terminate a run once a set of rules are met: perhaps once the run has attained convergence, or after a certain amount of time has passed.  The run will be terminated once *all* convergence rules ([`srGelmanRubin()`], [`srGeweke()`], [`srMinESS()`], [`srStationarity()`]) have been fulfilled; or once *any* threshold rules ([`srMaxTime()`], [`srMaxIteration()`]) are met.
    The parameters `checkpointFile` and `checkpointInterval` generate snapshots of the current state of the MCMCMC run from which the run can be continued if interrupted using the `mcmc.initializeFromCheckpoint()` method. An example is given on the documentation page for [`mcmc()`].
  example: |
    # Create a simple model (unclamped)
    a ~ dnExponential(1)
    mymodel = model(a)
    
    # Create a move vector and a monitor vector
    moves[1] = mvScale(a, lambda=1.0, weight=1.0)
    monitors[1] = mnFile(a,"output/out.log")
    
    # Create an mcmcmc object
    myMcmcmcObject = mcmcmc( mymodel, monitors, moves, nchains=4, deltaHeat=5)
    
    # Run a short analysis
    myMcmcmcObject.burnin( generations = 400, tuningInterval = 100)
    myMcmcmcObject.run( generations = 400)
    
    # print the summary of the operators (now tuned)
    myMcmcmcObject.operatorSummary()
  authors:
  see_also: 'mcmc'
  type_spec:
    - 'MonteCarloAnalysis'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mcmcmc(Model<any> model, Monitor[]<any> monitors, Move[]<any> moves, String<any> moveschedule {valid options: "sequential"|"random"|"single"}, Natural<any> nruns, String<any> combine {valid options: "sequential"|"mixed"|"none"}, Natural<any> ntries, Natural<any> nchains, Natural<any> swapInterval, RealPos<any> deltaHeat, Probability[]<any> heats, Bool<any> tuneHeat, Probability<any> tuneHeatTarget, String<any> swapMethod {valid options: "neighbor"|"random"|"both"}, Natural<any> swapInterval2, String<any> swapMode {valid options: "single"|"multiple"})'
      arguments:
        - label: 'model'
          description: 'The model graph.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Model'
          default:
          options:
        - label: 'monitors'
          description: 'The monitors used for this analysis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Monitor[]'
          default:
          options:
        - label: 'moves'
          description: 'The moves used for this analysis.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Move[]'
          default:
          options:
        - label: 'moveschedule'
          description: 'The strategy how the moves are used.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'random'
          options:
            - 'sequential'
            - 'random'
            - 'single'
        - label: 'nruns'
          description: 'The number of replicate analyses.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'combine'
          description: 'How should we combine the traces once the simulation is finished.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'none'
          options:
            - 'sequential'
            - 'mixed'
            - 'none'
        - label: 'ntries'
          description: 'The number of initialization attempts.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
        - label: 'nchains'
          description: 'The number of chains to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '4'
          options:
        - label: 'swapInterval'
          description: 'The interval at which swaps (between neighbor chains if the swapMethod is neighbor or both, or between chains chosen randomly if the swapMethod is random) will be attempted.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10'
          options:
        - label: 'deltaHeat'
          description: 'The delta parameter for the heat function.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0.2'
          options:
        - label: 'heats'
          description: 'The heats of chains, starting from the cold chain to hotter chains so the first value must be 1.0. If heats are specified directly then the delta parameter would be ignored.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability[]'
          default: 'NULL'
          options:
        - label: 'tuneHeat'
          description: 'Should we tune the heats during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'tuneHeatTarget'
          description: 'The acceptance probability of adjacent chain swaps targeted by heats auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.23'
          options:
        - label: 'swapMethod'
          description: 'The method used to swap chains.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'neighbor'
          options:
            - 'neighbor'
            - 'random'
            - 'both'
        - label: 'swapInterval2'
          description: 'The interval at which swaps between randomly chosen chains will be attempted (if the swapMethod is specified as both; otherwise it would be the same as swapInterval if not provided).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: 'NULL'
          options:
        - label: 'swapMode'
          description: 'Whether make a single attempt per swap interval or attempt multiple (= nchains-1 or choose(nchains,2) for neighbor or random swaps, respectively) times.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'single'
          options:
            - 'single'
            - 'multiple'
  methods:
    - name: 'burnin'
      return_type: 'void'
      usage: 'burnin(Natural<any> generations, Natural<any> tuningInterval, Natural<any> verbose, Bool<any> underPrior)'
      arguments:
        - label: 'generations'
          description: 'The number of generation to run this burnin simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'tuningInterval'
          description: 'The interval when to update the tuning parameters of the moves.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'verbose'
          description: 'How much information to print to the screen (0: none, 1: basic information only, 2: more information at extra CPU time cost).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'underPrior'
          description: 'DEPRECATED'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'NULL'
          options:
    - name: 'initializeFromCheckpoint'
      return_type: 'void'
      usage: 'initializeFromCheckpoint(String<any> checkpointFile)'
      arguments:
        - label: 'checkpointFile'
          description: 'The checkpoint filename.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
    - name: 'operatorSummary'
      return_type: 'void'
      usage: 'operatorSummary(Bool<any> currentPeriod)'
      arguments:
        - label: 'currentPeriod'
          description: 'Should the operator summary (number of tries and acceptance, and the acceptance ratio) of only the current period (i.e., after the last tuning) be printed?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
    - name: 'run'
      return_type: 'void'
      usage: 'run(Natural<any> generations, StoppingRule[]<any> rules, Natural<any> tuningInterval, String<any> checkpointFile, Natural<any> checkpointInterval, Natural<any> verbose, Bool<any> underPrior)'
      arguments:
        - label: 'generations'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'rules'
          description: 'The rules when to automatically stop the run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'StoppingRule[]'
          default: 'NULL'
          options:
        - label: 'tuningInterval'
          description: 'The interval when to update the tuning parameters of the moves.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'checkpointFile'
          description: 'The filename for the checkpoint file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'checkpointInterval'
          description: 'The interval when to write parameters values to a files for checkpointing.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'verbose'
          description: 'How much information to print to the screen (0: none, 1: basic information only, 2: more information at extra CPU time cost).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'underPrior'
          description: 'DEPRECATED'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'NULL'
          options:
  references:
    - citation: '"Geyer,C.J. (1991) Markov chain Monte Carlo maximum likelihood. In Keramidas  (ed.), Computing Science and Statistics: Proceedings of the 23rd Symposium on  the Interface. Interface Foundation, Fairfax Station, pp. 156\u2013163."'
      doi:
      url:
    - citation: '"Gilks,W.R. and Roberts,G.O. (1996) Strategies for improving MCMC. In  Gilks,W.R., Richardson,S. and Spiegelhalter (eds) Markov chain Monte Carlo in  Practice. Chapman&Hall, London, 89\u2013114."'
      doi:
      url:
    - citation: 'Altekar, G.; Dwarkadas, S.; Huelsenbeck, J. P. & Ronquist, F. Parallel metropolis coupled Markov chain Monte Carlo for Bayesian phylogenetic inference Bioinformatics, Oxford Univ Press, 2004, 20, 407-415.'
      doi:
      url:
- name: 'mnAncestralState'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnAncestralState(Tree<any> tree, RevObject<stochastic> ctmc, String<any> type, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'tree'
          description: 'The tree which we monitor.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'ctmc'
          description: 'The CTMC process.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
        - label: 'type'
          description: 'The type of data to store.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnCharHistoryNewick'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnCharHistoryNewick(AbstractHomologousDiscreteCharacterData<any> ctmc, TimeTree<any> tree, Bool<any> posterior, Bool<any> likelihood, Bool<any> prior, String<any> style {valid options: "events"|"counts"}, String<any> type {valid options: "biogeo"}, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'ctmc'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'tree'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'posterior'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'likelihood'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'prior'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'style'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'events'
          options:
            - 'events'
            - 'counts'
        - label: 'type'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'biogeo'
          options: 'biogeo'
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnCharHistoryNhx'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnCharHistoryNhx(AbstractHomologousDiscreteCharacterData<any> ctmc, TimeTree<any> tree, RlAtlas<any> atlas, IntegerPos<any> maxgen, Probability|Integer<any> burnin, Bool<any> posterior, Bool<any> likelihood, Bool<any> prior, String<any> type {valid options: "biogeo"}, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'ctmc'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'tree'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'atlas'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RlAtlas'
          default:
          options:
        - label: 'maxgen'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: 'NULL'
          options:
        - label: 'burnin'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.25'
          options:
        - label: 'posterior'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'likelihood'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'prior'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'type'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'biogeo'
          options: 'biogeo'
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnCharacterHistorySummary'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnCharacterHistorySummary(AbstractHomologousDiscreteCharacterData<any> ctmc, TimeTree<any> tree, IntegerPos<any> printgen, Bool<any> posterior, Bool<any> likelihood, Bool<any> prior, String<any> style {valid options: "events"|"counts"}, String<any> type {valid options: "biogeo"}, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'ctmc'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'tree'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'printgen'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'posterior'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'likelihood'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'prior'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'style'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'events'
          options:
            - 'events'
            - 'counts'
        - label: 'type'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'biogeo'
          options: 'biogeo'
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnExtNewick'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnExtNewick(TimeTree<any> tree, RevObject ..., Bool<any> isNodeParameter, Bool<any> posterior, Bool<any> likelihood, Bool<any> prior, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'tree'
          description: 'The tree variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label:
          description: 'Variables at nodes or branches.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RevObject'
          default:
          options:
        - label: 'isNodeParameter'
          description: 'Is this a node or branch parameter?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'posterior'
          description: 'Should we print the posterior probability as well.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'likelihood'
          description: 'Should we print the likelihood as well?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'prior'
          description: 'Should we print the prior probability as well?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnFile'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnFile(RevObject ..., Bool<any> posterior, Bool<any> likelihood, Bool<any> prior, String<any> format, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label:
          description: 'Variables to monitor.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RevObject'
          default:
          options:
        - label: 'posterior'
          description: 'Should we print the posterior probability as well?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'likelihood'
          description: 'Should we print the likelihood as well?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'prior'
          description: 'Should we print the prior probability as well?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'format'
          description: 'Output format'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'separator'
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnHomeologPhase'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnHomeologPhase(AbstractHomologousDiscreteCharacterData<any> ctmc, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'ctmc'
          description:
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default: 'NULL'
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnJointConditionalAncestralState'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnJointConditionalAncestralState(Tree<any> tree, AbstractHomologousDiscreteCharacterData<any> ctmc, TimeTree<any> cdbdp, TimeTree<any> glhbdsp, String<any> type, Bool<any> withTips, Bool<any> withStartStates, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'tree'
          description:
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'ctmc'
          description:
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default: 'NULL'
          options:
        - label: 'cdbdp'
          description:
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'glhbdsp'
          description:
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'type'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'withTips'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'withStartStates'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnModel'
  title: 'Monitor of Numeric Parameters'
  aliases:
  description: 'Saves the values of numeric parameters sampled by an MCMC analysis to a file.'
  details: |
    Every `printgen` iterations, the `mnModel` monitor saves the values of numeric
    parameters or vectors thereof (including nested vectors) to a file known as
    a trace file, created at the path specified by the `filename` argument. Each
    row of a trace file corresponds to one recorded iteration of an MCMC simulation
    (or of an alternative sampler such as MCMCMC). The first column of a trace file
    records the "Iteration" at which the samples were taken. By default, the next
    three columns record the "Posterior", "Likelihood", and "Prior" of the
    corresponding state of the simulation. Each of these can be suppressed by
    setting the corresponding argument (`posterior`, `likelihood`, `prior`) to
    `FALSE`. The subsequent columns represent individual variables. By default,
    `mnModel` automatically monitors all non-constant (i.e., both stochastic and
    deterministic) numeric variables in the graphical model. This behavior can be
    suppressed by setting `stochasticOnly=TRUE`, and individual variables can be
    omitted from the trace file using the `exclude` argument.
    
    By default, `mnModel` prints tab-separated files, but it can also output JSON
    files (by setting `format="json"`) or employ a different column separator
    (specified using the `separator` argument) to produce tabular files in
    alternative formats such as CSV. Tabular trace files produced by `mnModel` can
    be read back into RevBayes using the `readTrace` function. The tab-separated
    trace files produced under default settings can also be parsed by a number
    of third-party tools such as Tracer (Rambaut et al. 2018) or RWTY (Warren et
    al. 2017).
    
    The `mnModel` can only save the values of simple, numeric parameters. More
    complex parameters such as trees or rate matrices can instead be recorded using
    the `mnFile` monitor.
  example: |
    # Binomial example: estimate success probability given 7 successes out of 20 trials
    r ~ dnExp(10)
    p := Probability(ifelse(r < 1, r, 1))
    n <- 20
    k ~ dnBinomial(n, p)
    k.clamp(7)
    mymodel = model(k)
    
    moves = VectorMoves()
    moves.append( mvScale(r, weight=1) )
    
    # Set up a monitor for both r and p
    all_params = mnModel(filename="all_params.log", printgen=10)
    # Set up a monitor for r only
    stoch_only = mnModel(filename="stoch_only.log", stochasticOnly=TRUE, printgen=10)
    # Set up a monitor for p only
    p_only = mnModel(filename="p_only.log", exclude=["r"], printgen=10)
    
    # Apply the monitors and run a short simulation
    mymcmc = mcmc(model=mymodel, moves=moves, monitors=[all_params, stoch_only, p_only])
    mymcmc.run(generations=1000)
  authors:
  see_also:
    - 'mnFile'
    - 'readTrace'
    - 'Trace'
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnModel(Bool<any> posterior, Bool<any> likelihood, Bool<any> prior, Bool<any> stochasticOnly, String[]<any> exclude, String<any> format, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'posterior'
          description: 'Should we print the joint posterior probability?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'likelihood'
          description: 'Should we print the likelihood?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'prior'
          description: 'Should we print the joint prior probability?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'stochasticOnly'
          description: 'Should we monitor stochastic variables only?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'exclude'
          description: 'Variables to exclude from the monitor'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String[]'
          default: '[ ]'
          options:
        - label: 'format'
          description: 'Output format'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'separator'
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
    - citation: 'Rambaut A, Drummond AJ, Xie D, Baele G, Suchard MA (2018). Posterior summarization in Bayesian phylogenetics using Tracer 1.7. Systematic Biology, 67(5):901-904.'
      doi: '10.1093/sysbio/syy032'
      url: 'https://academic.oup.com/sysbio/article/67/5/901/4989127'
    - citation: 'Warren DL, Geneva AJ, Lanfear R (2017). RWTY (R We There Yet): an R package for examining convergence of Bayesian phylogenetic analyses. Molecular Biology and Evolution, 34(4):1016-1020.'
      doi: '10.1093/molbev/msw279'
      url: 'https://academic.oup.com/mbe/article/34/4/1016/2900564'
- name: 'mnNexus'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnNexus(String<any> filename, TimeTree<any> tree, RevObject ..., Bool<any> isNodeParameter, Bool<any> writeTaxa, IntegerPos<any> printgen)'
      arguments:
        - label: 'filename'
          description: 'The name of the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'tree'
          description: 'The tree variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'TimeTree'
          default:
          options:
        - label:
          description: 'Variables at nodes or branches.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RevObject'
          default:
          options:
        - label: 'isNodeParameter'
          description: 'Is this a node or branch parameter?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'writeTaxa'
          description: 'Should a taxa block be written?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnProbability'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnProbability(Bool<any> posterior, Bool<any> likelihood, Bool<any> prior, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'posterior'
          description: 'Should we print the joint posterior probability?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'likelihood'
          description: 'Should we print the likelihood?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'prior'
          description: 'Should we print the joint prior probability?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnScreen'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnScreen(RevObject ..., IntegerPos<any> printgen, Bool<any> posterior, Bool<any> likelihood, Bool<any> prior)'
      arguments:
        - label:
          description: 'Variables to monitor.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RevObject'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between displayed samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'posterior'
          description: 'Monitor the joint posterior probability.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'likelihood'
          description: 'Monitor the joint likelihood.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'prior'
          description: 'Monitor the joint prior probability.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnSiteMixtureAllocation'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnSiteMixtureAllocation(AbstractHomologousDiscreteCharacterData<any> ctmc, String<any> type, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'ctmc'
          description:
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default: 'NULL'
          options:
        - label: 'type'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnStochasticBranchRate'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnStochasticBranchRate(TimeTree<any> cdbdp, TimeTree<any> glhbdsp, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'cdbdp'
          description: 'The character dependent birth-death process to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'glhbdsp'
          description: 'The lineage-heterogeneous birth-death process to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnStochasticBranchStateTimes'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnStochasticBranchStateTimes(TimeTree<any> cdbdp, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'cdbdp'
          description: 'The character dependent birth-death process to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnStochasticCharacterMap'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnStochasticCharacterMap(AbstractHomologousDiscreteCharacterData<any> ctmc, TimeTree<any> cdbdp, TimeTree<any> glhbdsp, Bool<any> include_simmap, Bool<any> use_simmap_default, Natural<any> index, Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'ctmc'
          description: 'The continuous-time Markov process to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default: 'NULL'
          options:
        - label: 'cdbdp'
          description: 'The character dependent birth-death process to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'glhbdsp'
          description: 'The lineage-heterogeneous birth-death process to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default: 'NULL'
          options:
        - label: 'include_simmap'
          description: 'Should we log SIMMAP/phytools compatible newick strings? True by default.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'use_simmap_default'
          description: 'Should we use the default SIMMAP/phytools event ordering (i.e., young/left -> old/right)? True by default.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'index'
          description: 'The index of the character to be monitored.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mnStochasticVariable'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Monitor'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mnStochasticVariable(Bool<any> append, String<any> filename, IntegerPos<any> printgen, String<any> separator, Bool<any> version)'
      arguments:
        - label: 'append'
          description: 'Should we append or overwrite if the file exists?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'filename'
          description: 'The name of the file for storing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'printgen'
          description: 'The number of generations between stored samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'IntegerPos'
          default: '1'
          options:
        - label: 'separator'
          description: 'The separator/delimiter between columns in the file.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: ''
          options:
        - label: 'version'
          description: 'Should we record the software version?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RevObject<any> x)'
      arguments:
        - label: 'x'
          description: 'A variable you want to monitor.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'model'
  title: 'Create a model object'
  aliases:
  description: 'Creates a model object that can be graphed or subjected to Bayesian inference.'
  details: |
    `model(x)` creates a model object by creating a copy of all elements and 
    parameters that influence or are influenced by the likelihood of `x`.
    
    Because `model` works with copies of objects, conducting an mcmc(mc) analysis
    on a model object will not change the values of the objects in the RevBayes
    workspace.
    
    The model object can be modified to ignore specific data elements using the
    method `ignoreData`.  Thus to run without the sequence data `phySeq` you
    might specify:
    
       mymodel.ignoreData(phySeq)
    
    Only clamped nodes can be ignored. To ignore all clamped nodes you can use
    the method `ignoreAllData`:
    
       mymodel.ignoreAllData()
  example: |
    # Create a simple model (unclamped)
    a ~ dnExponential(1)
    b ~ dnExponential(a)
    mymodel = model(b) # equivalent to model(a) or model(a, b)
    
    # Save a DOT visualization of the model to file
    mymodel.graph("mymodel.dot")
    
    # Create a move vector and a monitor vector
    moves = [ mvScale( a, lambda = 1.0, weight = 1.0 ) ]
    monitors = [ mnScreen(printgen = 10, a) ]
    
    # Create an mcmc object
    mymcmcObject = mcmc( mymodel, monitors, moves )
    
    # Print value of a
    print(a)
    
    # Run a short analysis
    mymcmcObject.run( generations = 100 )
    
    print(a) # Value is unchanged in the workspace - only the copy is modified
  authors:
  see_also:
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'model(RevObject<any> x, RevObject ...)'
      arguments:
        - label: 'x'
          description: 'Any variable that is connected in the model graph.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RevObject'
          default:
          options:
        - label:
          description: 'Additional variables.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RevObject'
          default:
          options:
  methods:
    - name: 'graph'
      return_type: 'void'
      usage: 'graph(String<any> file, Bool<any> verbose, String<any> bg)'
      arguments:
        - label: 'file'
          description: 'The name of the file where to save the model graph.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'verbose'
          description: 'Verbose output?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'bg'
          description: 'The background color.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'lavenderblush2'
          options:
    - name: 'ignoreAllData'
      return_type: 'void'
      usage: 'ignoreAllData()'
      arguments:
    - name: 'ignoreData'
      return_type: 'void'
      usage: 'ignoreData(RevObject ...)'
      arguments:
        - label:
          description: 'Clamped variables to ignore.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RevObject'
          default:
          options:
  references:
- name: 'mvAVMVN'
  title:
  aliases:
  description: |
    The adaptive variance multivariate-normal proposal of Baele et al. 2017, uses MCMC samples to fit covariance matrix to parameters.
    
    After user-defined waiting time, proposes using covariance matrix epsilon * I + (1 - epsilon) * sigmaSquared * empirical_matrix.
    
    Internally transforms variables based on whether variables are (finitely) bounded, strictly positive, or simplexed.
    
    Non-simplex-valued vector random variables are untransformed.
    
    Add random variables to the move directly (e.g. branch_rates[1], not branch_rates).WARNING: Disabling tuning disables both tuning of proposal variance and learning of empirical covariance matrix.
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvAVMVN(RealPos<any> sigmaSquared, RealPos<any> epsilon, Natural<any> waitBeforeLearning, Natural<any> waitBeforeUsing, Natural<any> maxUpdates, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'sigmaSquared'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'epsilon'
          description: 'The mixture weight of the post-learning move on a simple identity matrix.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0.05'
          options:
        - label: 'waitBeforeLearning'
          description: 'The number of move attempts to wait before tracking the covariance of the variables.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '2500'
          options:
        - label: 'waitBeforeUsing'
          description: 'The number of move attempts to wait before using the learned covariance matrix.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '5000'
          options:
        - label: 'maxUpdates'
          description: 'The maximum number of updates to the empirical covariance matrix (matrix is only updated when MCMC tunes).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10000'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real<stochastic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RealPos<stochastic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Simplex<stochastic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Simplex'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real[]<stochastic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real<stochastic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(RealPos<stochastic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Simplex<stochastic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Simplex'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real[]<stochastic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
  references:
- name: 'mvBetaProbability'
  title:
  aliases: 'mvProbabilityElementScale'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvBetaProbability(Probability<stochastic> x, RealPos<any> delta, RealPos<any> offset, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Probability'
          default:
          options:
        - label: 'delta'
          description: 'The concentration parameter on the current value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'offset'
          description: 'The offset used to center proposals around 0.5.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'tune'
          description: 'Should we tune the concentration parameter during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvBetaSimplex'
  title: 'Beta Simplex move'
  aliases: 'mvSimplexElementScale'
  description: 'The Beta Simplex move selects one element of the a vector and proposes a new value for it drawn from a Beta distribution. A usage example can be found at https://revbayes.github.io/tutorials/chromo/#root'
  details:
  example:
  authors:
  see_also:
    - 'mvDirichletSimplex'
    - 'mvElementSwapSimplex'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvBetaSimplex(Simplex<stochastic> x, RealPos<any> alpha, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Simplex'
          default:
          options:
        - label: 'alpha'
          description: 'The concentration parameter on the current value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the concentration parameter during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvBinarySwitch'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvBinarySwitch(Natural<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvBirthDeathEvent'
  title:
  aliases: 'mvBirthDeathEventDiscrete'
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvBirthDeathEvent(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvBirthDeathEventContinuous'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvBirthDeathEventContinuous(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvBirthDeathFromAgeEvent'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvBirthDeathFromAgeEvent(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvBranchLengthScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvBranchLengthScale(BranchLengthTree<stochastic> tree, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree variable the move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'BranchLengthTree'
          default:
          options:
        - label: 'delta'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvBurstEvent'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvBurstEvent(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this moves operates on. It should be a fossil tree!'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvCharacterHistory'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvCharacterHistory(AbstractHomologousDiscreteCharacterData<stochastic> ctmc, RateGenerator<any> qmap_site, RateGeneratorSequence<any> qmap_seq, Probability<any> lambda, String<any> graph {valid options: "node"|"branch"|"cladogenetic"|"cladogenetic2"}, String<any> proposal {valid options: "rejection"|"rejection_shift"|"uniformization"}, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'ctmc'
          description: 'The PhyloCTMC variable.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'qmap_site'
          description: 'Per-site rate generator.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RateGenerator'
          default: 'NULL'
          options:
        - label: 'qmap_seq'
          description: 'Per-sequence rate generator.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RateGeneratorSequence'
          default: 'NULL'
          options:
        - label: 'lambda'
          description: 'Tuning probability to propose new site history.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'graph'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'node'
          options:
            - 'node'
            - 'branch'
            - 'cladogenetic'
            - 'cladogenetic2'
        - label: 'proposal'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'rejection'
          options:
            - 'rejection'
            - 'rejection_shift'
            - 'uniformization'
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvCollapseExpandFossilBranch'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvCollapseExpandFossilBranch(TimeTree<stochastic> tree, RealPos<any> origin, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this moves operates on. It should be a fossil tree!'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'origin'
          description: 'The variable for the origin of the process giving a maximum age for the new fossil attachement time.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvConjugateInverseWishart'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvConjugateInverseWishart(MatrixRealSymmetric<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixRealSymmetric'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvContinuousCharacterDataSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvContinuousCharacterDataSlide(ContinuousCharacterData<stochastic> x, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operators on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'ContinuousCharacterData'
          default:
          options:
        - label: 'delta'
          description: 'The sliding window width parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune this move during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvContinuousEventScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvContinuousEventScale(TimeTree<stochastic> tree, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvCorrelationMatrixElementSwap'
  title: 'Correlation Matrix element swap move.'
  aliases:
  description: 'Swaps elements i and j of the correlation matrix (i != j).'
  details:
  example: |
    
    # we draw a correlation matrix from an LKJ distribution
    R ~ dnLKJ(eta=1, dim=5)
    
    # we specify an element swap move
    moves[1] = mvCorrelationMatrixElementSwap(R)
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvCorrelationMatrixElementSwap(MatrixReal<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixReal'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvCorrelationMatrixRandomWalk'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvCorrelationMatrixRandomWalk(MatrixReal<stochastic> x, RealPos<any> sigma, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixReal'
          default:
          options:
        - label: 'sigma'
          description: 'The standard deviation of the normal distribution to draw from.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0.1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvCorrelationMatrixSingleElementBeta'
  title: 'Correlation Matrix Beta proposal.'
  aliases:
  description: 'Beta proposal on a random element of a correlation matrix.'
  details: 'This move chooses a single element of the correlation matrix at random, and draws a proposed value from a Beta distribution centered on the current value (and stretched to range from -1 to 1).'
  example: |
    
    # we draw a correlation matrix from an LKJ distribution
    R ~ dnLKJ(eta=1, dim=5)
    
    # we specify a beta move on the correlation matrix
    moves[1] = mvCorrelationMatrixSingleElementBeta(R, alpha=10.0)
  authors:
  see_also:
    - 'mvCorrelationMatrixSpecificElementBeta'
    - 'mvCorrelationMatrixRandomWalk'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvCorrelationMatrixSingleElementBeta(MatrixReal<stochastic> x, RealPos<any> alpha, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixReal'
          default:
          options:
        - label: 'alpha'
          description: 'The shape of the beta distribution to draw from.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '10'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvCorrelationMatrixSpecificElementBeta'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvCorrelationMatrixSpecificElementBeta(MatrixReal<stochastic> x, Natural<any> row, Natural<any> col, RealPos<any> alpha, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixReal'
          default:
          options:
        - label: 'row'
          description: 'The row of the variable on which this move operates.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'col'
          description: 'The column of the variable on which this move operates.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'alpha'
          description: 'The shape of the beta distribution to draw from.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '10'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvCorrelationMatrixUpdate'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvCorrelationMatrixUpdate(MatrixReal<stochastic> r, RealPos[]<any> s, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'r'
          description: 'The correlation matrix on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixReal'
          default:
          options:
        - label: 's'
          description: 'The vector of variances needed to complete the move.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvDPPAllocateAuxGibbs'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvDPPAllocateAuxGibbs(Real[]<stochastic> x, Integer<any> numAux, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'numAux'
          description: 'The number of auxillary categories.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Integer'
          default: '4'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvDPPGibbsConcentration'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvDPPGibbsConcentration(RealPos<stochastic> concentration, Integer<any> numDPPCats, RealPos<any> gammaShape, RealPos<any> gammaRate, RealPos<any> numElements, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'concentration'
          description:
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'numDPPCats'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Integer'
          default:
          options:
        - label: 'gammaShape'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'gammaRate'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'numElements'
          description:
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvDPPValueBetaSimplex'
  title: 'Beta simplex move applied to individual categories of a Dirichlet process mixture'
  aliases:
  description: 'Operates on draws from a Dirichlet process prior (DPP) on mixtures of [Simplex](https://revbayes.github.io/documentation/Simplex.html) distributions, i.e., distributions defined over vectors whose elements are positive and sum to 1.'
  details: 'In Dirichlet process mixtures, the number of categories (= clusters) is not specified beforehand but inferred from the data, and can range anywhere from 1 to the total number of elements (= observations). The move takes the current number of categories and simultaneously updates the value of every category using the beta simplex move with a concentration parameter (alpha) of 10.'
  example: |
    # Here, we draw from a DP mixture for 3 elements, where every element
    # is itself a 2-element simplex drawn from a flat Dirichlet distribution
    x ~ dnDPP(1, dnDirichlet( [1, 1] ), 3)
    
    # Next, we add the move. Note that without moves other than
    # mvDPPValueBetaSimplex, only the values of the categories will be
    # updated: the total number of categories and the assignment of elements
    # to categories will be determined by the initial draw.
    moves[1] = mvDPPValueBetaSimplex(x, weight=1)
    
    monitors[1] = mnScreen(x, printgen=1)
    mymodel = model(x)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.run(generations=50)
  authors:
  see_also:
    - 'dnDPP'
    - 'mvBetaSimplex'
    - 'mvDPPValueScaling'
    - 'mvDPPValueSliding'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvDPPValueBetaSimplex(Simplex[]<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Simplex[]'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvDPPValueScaling'
  title: 'Scaling move applied to individual categories of a Dirichlet process mixture'
  aliases:
  description: 'Operates on draws from a Dirichlet process prior (DPP) on mixtures of [RealPos](https://revbayes.github.io/documentation/RealPos.html) distributions, i.e., distributions defined over non-negative real numbers.'
  details: 'In Dirichlet process mixtures, the number of categories (= clusters) is not specified beforehand but inferred from the data, and can range anywhere from 1 to the total number of elements (= observations). The move takes the current number of categories and simultaneously updates the value of every category using the scaling move with a scaling factor (lambda) of 1.'
  example: |
    # Here, we draw from a DP mixture for 3 elements, where every element
    # is a non-negative real number drawn from an exponential distribution
    x ~ dnDPP(1, dnExp(1), 3)
    
    # Next, we add the move. Note that without moves other than
    # mvDPPValueScaling, only the values of the categories will be updated:
    # the total number of categories and the assignment of elements to
    # categories will be determined by the initial draw.
    moves[1] = mvDPPValueScaling(x, weight=1)
    
    monitors[1] = mnScreen(x, printgen=1)
    mymodel = model(x)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.run(generations=50)
  authors:
  see_also:
    - 'dnDPP'
    - 'mvScale'
    - 'mvDPPValueBetaSimplex'
    - 'mvDPPValueSliding'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvDPPValueScaling(RealPos[]<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvDPPValueSliding'
  title: 'Sliding move applied to individual categories of a Dirichlet process mixture'
  aliases:
  description: 'Operates on draws from a Dirichlet process prior (DPP) on mixtures of [Real](https://revbayes.github.io/documentation/Real.html) distributions, i.e., distributions defined over all real numbers.'
  details: 'In Dirichlet process mixtures, the number of categories (= clusters) is not specified beforehand but inferred from the data, and can range anywhere from 1 to the total number of elements (= observations). The move takes the current number of categories and simultaneously updates the value of every category using the sliding move with a window size (delta) of 1.'
  example: |
    # Here, we draw from a DP mixture for 3 elements, where every element
    # is a real number drawn from the standard normal distribution
    x ~ dnDPP(1, dnNormal(0, 1), 3)
    
    # Next, we add the move. Note that without moves other than
    # mvDPPValueSliding, only the values of the categories will be updated:
    # the total number of categories and the assignment of elements to
    # categories will be determined by the initial draw.
    moves[1] = mvDPPValueSliding(x, weight=1)
    
    monitors[1] = mnScreen(x, printgen=1)
    mymodel = model(x)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.run(generations=50)
  authors:
  see_also:
    - 'dnDPP'
    - 'mvSlide'
    - 'mvDPPValueBetaSimplex'
    - 'mvDPPValueScaling'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvDPPValueSliding(Real[]<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvDirichletSimplex'
  title: 'Dirichlet Simplex move'
  aliases: 'mvSimplex'
  description: |
    A Dirichlet-simplex proposal randomly changes some values of a [Simplex](https://revbayes.github.io/documentation/Simplex.html)
    (a vector whose elements sum to 1). The other values change too because of renormalization.
     
    First, some random indices are drawn.
    Then, the proposal draws a new simplex `u ~ Dirichlet(val[index] * alpha)`, where alpha is the tuning parameter.
    The new value is set to `u`.
    The simplex is then renormalized.
    
    Usage examples can be found at https://revbayes.github.io/tutorials/morph_tree/V2.html and https://revbayes.github.io/tutorials/morph_ase/ase_free.html
  details:
  example:
  authors:
  see_also:
    - 'mvBetaSimplex'
    - 'mvElementSwapSimplex'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvDirichletSimplex(Simplex<stochastic> x, RealPos<any> alpha, Natural<any> numCats, RealPos<any> offset, RealPos<any> kappa, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The simplex on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Simplex'
          default:
          options:
        - label: 'alpha'
          description: 'The concentration parameter on the previous value.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'numCats'
          description: 'The number of categories changed per move.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'offset'
          description: 'The offset of the current value to center new proposals (x+offset).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'kappa'
          description: 'The offset of tuning parameter (x * alpha + kappa).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'tune'
          description: 'Should we tune this move during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvDiscreteEventCategoryRandomWalk'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvDiscreteEventCategoryRandomWalk(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvElementSwapSimplex'
  title: 'Element Swap Simplex move'
  aliases:
  description: 'An Element Swap Simplex move selects two elements of a vector and exchanges their values.'
  details:
  example:
  authors:
  see_also:
    - 'mvBetaSimplex'
    - 'mvDirichletSimplex'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvElementSwapSimplex(Simplex<stochastic> x, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Simplex'
          default:
          options:
        - label: 'tune'
          description: 'Should we tune the concentration parameter during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvEllipticalSliceSamplingSimple'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvEllipticalSliceSamplingSimple(Real[]<deterministic> x, RealPos<any> window, Bool<any> tune, Bool<any> forceAccept, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'window'
          description: 'The anglular window (steps-size) of proposals, a value in the interval (0,2*pi].'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '6.283185'
          options:
        - label: 'tune'
          description: 'Should we tune the move during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'forceAccept'
          description: 'If we hit maximum slice iterations, should we force the sampler to return the initial values (accept a step of size 0)? Not generally recommended.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvEmpiricalTree'
  title: 'Move on an empirical tree distribution'
  aliases:
  description: 'An MCMC move that operates on empirical tree distributions.'
  details:
  example: |
    # Read in tree trace
    tree_trace = readTreeTrace("output/my.trees", burnin=0.25)
    
    # Create a distribution of trees
    tree ~ dnEmpiricalTree(tree_trace)
    
    # Add an MCMC move
    moves[1] = mvEmpiricalTree(tree)
  authors:
  see_also:
    - 'mvEmpiricalTree'
    - 'treeTrace'
    - 'readTreeTrace'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvEmpiricalTree(Tree<stochastic> tree, Bool<any> metropolisHastings, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The stochastic tree variable on which this moves operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'metropolisHastings'
          description: 'If TRUE, use the regular Metropolis-Hastings acceptance ratio. If FALSE, always accept this move and sample every tree uniformly.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvEventTimeBeta'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvEventTimeBeta(TimeTree<stochastic> tree, RealPos<any> delta, RealPos<any> offset, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'delta'
          description: 'The concentration parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'offset'
          description: 'The offset for the proposal density.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '2'
          options:
        - label: 'tune'
          description: 'Should we tune the concentration parameter during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvEventTimeSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvEventTimeSlide(TimeTree<stochastic> tree, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'delta'
          description: 'The concentration parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the concentration parameter during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvFNPR'
  title: 'Fixed Node-height Prune and Regraft (FNPR) move.'
  aliases:
  description: |
    Tree topology move that prunes and re-attaches a subtree without changing any
    node heights.
  details: |
    `mvFNPR` randomly picks node i which is neither a tip nor the root, and prunes
    the subtree originating with this node. It then picks another node j such that
    j is younger than i but the parent of j is older than i, and re-attaches the
    pruned subtree onto the branch above j. Because the node height of i is fixed
    rather than re-adjusted, the FNPR move represents a special case of the fully
    general time tree version of the subtree prune and regraft (SPR) move. This
    fully general version is also known as the Wilson-Balding move. `mvFNPR` often
    exhibits higher acceptance rates than the Wilson-Balding move.
  example: |
    taxa <- v(taxon("A"), taxon("B"), taxon("C"), taxon("D"), taxon("E"), taxon("F"))
    height ~ dnUniform(0, 10)
    moves = VectorMoves()
    
    # Simulate a simple TimeTree
    tree ~ dnBDP(lambda=1.0, mu=0.2, rootAge=height, taxa=taxa)
    
    # Assign it a mvFNPR move
    moves.append( mvFNPR(tree, weight=taxa.size()) )
  authors:
  see_also: 'mvSPR'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvFNPR(TimeTree|TimeTree[]<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
    - citation: 'Hhna S, Defoin-Platel M, Drummond AJ (2008). Clock-constrained tree proposal operators in Bayesian phylogenetic inference. 1--7 in 8th IEEE International Conference on BioInformatics and BioEngineering (BIBE 2008). Athens, Greece, October 2008.'
      doi: '10.1109/BIBE.2008.4696663'
      url: 'https://alexeidrummond.org/assets/publications/2008-hoehna-clock-bibe.pdf'
- name: 'mvFossilTipTimeSlideUniform'
  title: 'Sliding move to change a fossil tip age'
  aliases:
    - 'mvFossilTimeSlideUniform'
    - 'mvTipTimeSlideUniform'
  description: 'This moves either takes a specific fossil, or randomly picks a fossil, and then performs a sliding move on the tip age.'
  details: |
    This sliding move uses the possible minimum and maximum ages as reflection boundaries.
    The maximum ages is computed either by its parents or the maximum age in the uncertainty of the fossil, which can be provided to the move or is taken from the taxon object.
    The minimum ages is computed either by its oldest descendant (for sampled ancestors) or the minimum age in the uncertainty of the fossil, which can be provided to the move or is taken from the taxon object.
  example: |
    
    # Use a for loop to create a uniform distribution on the occurrence time for each fossil #
    # The boundaries of the uniform distribution are specified in the tsv file #
    fossils = fbd_tree.getFossils()
    for(i in 1:fossils.size())
    {
        t[i] := tmrca(fbd_tree, clade(fossils[i]))
    
        a[i] = fossils[i].getMinAge()
        b[i] = fossils[i].getMaxAge()
    
        F[i] ~ dnUniform(t[i] - b[i], t[i] - a[i])
        F[i].clamp( 0 )
        moves.append( mvFossilTipTimeUniform(fbd_tree, origin_time, min=a[i], max=b[i], tip=fossils[i], weight=5.0) )
        moves.append( mvFossilTipTimeSlideUniform(fbd_tree, origin_time, min=a[i], max=b[i], tip=fossils[i], weight=5.0) )
    }
  authors:
  see_also: 'mvFossilTipTimeSlideUniform'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvFossilTipTimeSlideUniform(TimeTree<stochastic> tree, RealPos<any> origin, RealPos<any> max, RealPos<any> min, String|Taxon<any> tip, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'origin'
          description: 'The variable for the origin of the process giving a maximum age.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'max'
          description: 'The variable for the maximum age of this fossil tip.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'min'
          description: 'The variable for the minimun age of this fossil tip.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'tip'
          description: 'The name of a specific tip/taxon.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
        - label: 'delta'
          description: 'The window size parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the window size during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvFossilTipTimeUniform'
  title: 'Move to uniformly draw fossil tip ages'
  aliases:
  description: 'This moves either takes a specific fossil, or randomly picks a fossil, and then draws the new ages randomly between the maximum and minimum ages.'
  details: |
    The maximum ages is computed either by its parents or the maximum age in the uncertainty of the fossil, which can be provided to the move or is taken from the taxon object.
    The minimum ages is computed either by its oldest descendant (for sampled ancestors) or the minimum age in the uncertainty of the fossil, which can be provided to the move or is taken from the taxon object.
  example: |
    
    # Use a for loop to create a uniform distribution on the occurrence time for each fossil #
    # The boundaries of the uniform distribution are specified in the tsv file #
    fossils = fbd_tree.getFossils()
    for(i in 1:fossils.size())
    {
        t[i] := tmrca(fbd_tree, clade(fossils[i]))
    
        a[i] = fossils[i].getMinAge()
        b[i] = fossils[i].getMaxAge()
    
        F[i] ~ dnUniform(t[i] - b[i], t[i] - a[i])
        F[i].clamp( 0 )
        moves.append( mvFossilTipTimeUniform(fbd_tree, origin_time, min=a[i], max=b[i], tip=fossils[i], weight=5.0) )
        moves.append( mvFossilTipTimeSlideUniform(fbd_tree, origin_time, min=a[i], max=b[i], tip=fossils[i], weight=5.0) )
    }
  authors:
  see_also: 'mvFossilTipTimeSlideUniform'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvFossilTipTimeUniform(TimeTree<stochastic> tree, RealPos<any> origin, RealPos<any> max, RealPos<any> min, String|Taxon<any> tip, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'origin'
          description: 'The variable for the origin of the process giving a maximum age.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'max'
          description: 'The variable for the maximum age of this fossil tip.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'min'
          description: 'The variable for the minimun age of this fossil tip.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'tip'
          description: 'The name of a specific tip/taxon.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'String'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGMRFHyperpriorGibbs'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGMRFHyperpriorGibbs(RealPos<stochastic> x, Real[]<deterministic> normals, RealPos<any> zeta, Natural<any> order, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'normals'
          description: 'The vector of Normal RVs defining the field'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'zeta'
          description: 'The value controlling the shrinkage of the field, a scale by which x is multiplied, effectively making x ~ halfCauchy(0,zeta).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
        - label: 'order'
          description: 'The order of this GMRF model, first (1) or second (2). Defaults to first order.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGMRFUnevenGridHyperpriorGibbs'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGMRFUnevenGridHyperpriorGibbs(RealPos<stochastic> x, Real[]<deterministic> normals, RealPos[]<deterministic> grid, RealPos<any> zeta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'normals'
          description: 'The vector of Normal RVs defining the field'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'grid'
          description: 'The space between i and i-1.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'zeta'
          description: 'The value controlling the shrinkage of the field, a scale by which x is multiplied, effectively making x ~ halfCauchy(0,zeta).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGPR'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGPR(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGammaScale'
  title:
  aliases:
  description: 'A move to scale a single continuous value by multiplying by a value drawn from a Gamma(lambda,1) distribution. Lambda is the tuning parameter that controls the size of the proposals.'
  details:
  example: |
    # Here is a simple example for conducting MCMC on the mean and sd of a Normal distribution.
    
    # Uniform(0,1) priors on the mean and sd
    mean ~ dnUnif(0,1)
    sd ~ dnUnif(0,1)
    
    # Dummy data (will not actually be analyzed)
    data <- v(0.4,0.5,0.6)
    
    # Clamping data
    for (i in 1:data.size()){ outcomes[i] ~ dnNorm(mean,sd); outcomes[i].clamp(data[i]) }
    
    # Initializing move and monitor counters
    mvi = 1
    mni = 1
    
    # Adding Gamma scale moves for the mean and sd (THIS MOVE IS HERE)
    moves[mvi++] = mvGammaScale(mean)
    moves[mvi++] = mvGammaScale(sd)
    
    # Instantiating the model
    mymodel = model(outcomes)
    
    # Adding screen monitor for the mean
    monitors[mni++] = mnScreen(mean, printgen=1000)
    
    # Creating MCMC object
    mymcmc = mcmc(mymodel, moves, monitors)
    
    # Running MCMC under the prior
    mymcmc.run(30000,underPrior=TRUE);
  authors:
  see_also: 'mvScale'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGammaScale(RealPos<stochastic> x, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The strength of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune lambda during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGibbsDrawCharacterHistory'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGibbsDrawCharacterHistory(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The time-tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGibbsMixtureAllocation'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGibbsMixtureAllocation(Real<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGraphFlipClique'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGraphFlipClique(MatrixRealSymmetric<stochastic> x, RealPos<any> r_set, Probability<any> p_vertex, Probability<any> p_edge, Natural[]<any> vertices, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixRealSymmetric'
          default:
          options:
        - label: 'r_set'
          description: 'Rate that is equal to the expected number of vertex-sets to perturb (min 1).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'p_vertex'
          description: 'Probability of including a vertex in a vertex-set (min 2 vertices/set).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.1'
          options:
        - label: 'p_edge'
          description: 'Probability of forcing edge to consensus value (0,1) in a vertex-set.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'vertices'
          description: 'A vector of vertices to target with this proposal. An empty vector is interpretted as the full list of vertices.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Natural[]'
          default: '[ ]'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGraphFlipEdge'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGraphFlipEdge(MatrixRealSymmetric<stochastic> x, Probability<any> p, Natural[][]<any> edges, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixRealSymmetric'
          default:
          options:
        - label: 'p'
          description: 'The probability of flipping each edge in edges (min flips == 1).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0'
          options:
        - label: 'edges'
          description: 'A vector of [i,j] edges to target with this proposal. An empty vector is interpretted as the full list of edges.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Natural[][]'
          default: '[ ]'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvGraphShiftEdge'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvGraphShiftEdge(MatrixRealSymmetric<stochastic> x, Probability<any> p, Natural[]<any> vertices, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixRealSymmetric'
          default:
          options:
        - label: 'p'
          description: 'The probability of flipping each edge in edges.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'vertices'
          description: 'A vector of vertices to target with this proposal. An empty vector is interpretted as the full list of vertices.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Natural[]'
          default: '[ ]'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvHSRFHyperpriorsGibbs'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvHSRFHyperpriorsGibbs(RealPos<stochastic> gs, RealPos[]<deterministic> ls, Real[]<deterministic> normals, RealPos<any> zeta, Probability<any> propGlobalOnly, Natural<any> order, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'gs'
          description: 'The global scale variable on which this move operates'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'ls'
          description: 'The local scales variables on which this move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'normals'
          description: 'The vector of Normal RVs defining the field'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'zeta'
          description: 'The value controlling the shrinkage of the field.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
        - label: 'propGlobalOnly'
          description: 'The proportion of all of these moves that only move the global scale.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0'
          options:
        - label: 'order'
          description: 'The order of this HSRF model, first (1) or second (2). Defaults to first order.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvHSRFIntervalSwap'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvHSRFIntervalSwap(Real[]<deterministic> deltas, RealPos[]<deterministic> sigmas, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'deltas'
          description: 'The HSMRF delta parameters on which the move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'sigmas'
          description: 'The HSMRF sigma parameters on which the move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvHSRFUnevenGridHyperpriorsGibbs'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvHSRFUnevenGridHyperpriorsGibbs(RealPos<stochastic> gs, RealPos[]<deterministic> ls, Real[]<deterministic> normals, RealPos[]<deterministic> grid, RealPos<any> zeta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'gs'
          description: 'The global scale variable on which this move operates'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'ls'
          description: 'The local scales variables on which this move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'normals'
          description: 'The vector of Normal RVs defining the field'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'grid'
          description: 'The space between i and i-1.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'zeta'
          description: 'The value controlling the shrinkage of the field.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvHomeologPhase'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvHomeologPhase(AbstractHomologousDiscreteCharacterData<stochastic> ctmc, String<any> tip1, String<any> tip2, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'ctmc'
          description: 'The PhyloCTMC variable.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'AbstractHomologousDiscreteCharacterData'
          default:
          options:
        - label: 'tip1'
          description: 'Tip 1 to switch.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'String'
          default:
          options:
        - label: 'tip2'
          description: 'Tip 2 to switch.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'String'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvIidPrior'
  title: 'Move to propose from prior'
  aliases:
  description: 'This move proposes new values drawn from the prior.'
  details: 'Using this move, one actually gets an independence sampler as the proposal doesn''t depend on the current state. The move calls redraw based on the distribution attached to the random variable.'
  example: |
    x ~ dnUnif(0,10000)
    moves[1] = mvIidPrior(x, weight=1.0)
    monitors[1] = screenmonitor(printgen=1000, x)
    mymodel = model(x)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.run(generations=200000)
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvIidPrior(Real<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvIndependentTopology'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvIndependentTopology(TimeTree<stochastic> tree, Distribution__Tree<any> proposal, RealPos[]<any> rates, Clade<any> outgroup, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The stochastic time tree variable on which this moves operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'proposal'
          description: 'The proposal topology distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Distribution__Tree'
          default:
          options:
        - label: 'rates'
          description: 'The vector of branch-specific substitution rates.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'outgroup'
          description: 'Outgroup used to root the proposal topologies.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Clade'
          default: 'NA'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvLayeredScaleProposal'
  title: 'Rescales all the subtrees below some age.'
  aliases:
  description: 'Makes a subtree scale move on all subtrees below a given age in the tree. Tree topology is not altered.'
  details: |
    The tree must be ultrametric.
    
    An age is randomly drawn between the root age and the age of the oldest tip. Then all subtrees below this age are scaled up or down depending on a scaler drawn from an exponential distribution.
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a constant effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescent(speciesTree=spTree, Ne=popSize, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # Set my move index:
    mi = 0
    move_species_subtree_scale = mvLayeredScaleProposal( speciesTree=spTree, weight=5 )
    for (i in 1:n_genes) {
        move_species_subtree_scale.addGeneTreeVariable( geneTrees[i] )
    }
    moves[++mi] = move_species_subtree_scale
    
    # We get a handle on our model.
    # We can use any node of our model as a handle; here we choose to use the topology.
    mymodel = model(spTree)
    
    # Monitors to check the progression of the program:
    monitors[1] = mnScreen(printgen=10, spTree)
    
    # Here we use a plain MCMC. You could also use mcmcmc with heated chains.
    mymcmc = mcmc(mymodel, monitors, moves, nruns=4)
    mymcmc.run(generations=1000)
    mymcmc.operatorSummary()
  authors:
  see_also: 'mvSubTreeScale'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvLayeredScaleProposal(TimeTree<stochastic> tree, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'lambda'
          description: 'The strength of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune lambda during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvLevyJump'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvLevyJump(Real<stochastic> x, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'delta'
          description: 'The window size of the proposals.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvLevyJumpSum'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvLevyJumpSum(Real<stochastic> value_1, Real<stochastic> value_2, RealPos<any> slide, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'value_1'
          description:
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'value_2'
          description:
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'slide'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description:
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMatrixElementScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMatrixElementScale(RealPos[][]|Real[][]|MatrixRealSymmetric|MatrixReal<stochastic> x, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos[][]'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMatrixElementSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMatrixElementSlide(RealPos[][]|Real[][]|MatrixRealSymmetric|MatrixReal<stochastic> x, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos[][]'
          default:
          options:
        - label: 'delta'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMirror'
  title:
  aliases:
  description: 'The adaptive mirror (normal) proposal of Thawornwattana et al. 2017, uses MCMC samples to find posterior mean and variance. After user-defined waiting time, proposes moves on opposite side of posterior mean from current location using a normal distribution with the learned posterior standard deviation (scaled by lambda). Before this time, the move uses mu0 as the mean, and lambda as the standard deviation. WARNING: Disabling tuning disables both tuning of proposal variance and learning of empirical mean and variance. To learn the empirical mean and variance without tuning sigma, set adaptOnly=true.'
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMirror(Real<stochastic> x, Natural<any> waitBeforeLearning, Natural<any> waitBeforeUsing, Natural<any> maxUpdates, Real<any> mu0, RealPos<any> sigma, Bool<any> tune, Bool<any> adaptOnly, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'waitBeforeLearning'
          description: 'The number of move attempts to wait before tracking the mean and variance of the variable.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '500'
          options:
        - label: 'waitBeforeUsing'
          description: 'The number of move attempts to wait before using the learned mean and variance.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
        - label: 'maxUpdates'
          description: 'The maximum number of updates to the empirical mean and variance.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10000'
          options:
        - label: 'mu0'
          description: 'Initial guess at posterior mean.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'sigma'
          description: 'The tuning parameter, adjusts variance of proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the move during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'adaptOnly'
          description: 'If true, sigma is not tuned but mean and variance are still learned'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMirrorMultiplier'
  title:
  aliases:
  description: 'The adaptive mirror multiplier (normal) proposal of Thawornwattana et al. 2017, uses MCMC samples to find posterior mean and variance on the log-scale. After user-defined waiting time, proposes moves (on the log-scale) on opposite side of posterior mean from current location using a normal distribution with the learned posterior standard deviation (scaled by lambda). Before this time, the move uses mu0 as the mean, and lambda as the standard deviation. WARNING: Disabling tuning disables both tuning of proposal variance and learning of empirical mean and variance. To learn the empirical mean and variance without tuning sigma, set adaptOnly=true.'
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMirrorMultiplier(Real<stochastic> x, Natural<any> waitBeforeLearning, Natural<any> waitBeforeUsing, Natural<any> maxUpdates, Real<any> mu0, RealPos<any> sigma, Bool<any> tune, Bool<any> adaptOnly, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'waitBeforeLearning'
          description: 'The number of move attempts to wait before tracking the mean and variance of the variable.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '500'
          options:
        - label: 'waitBeforeUsing'
          description: 'The number of move attempts to wait before using the learned mean and variance.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1000'
          options:
        - label: 'maxUpdates'
          description: 'The maximum number of updates to the empirical mean and variance.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10000'
          options:
        - label: 'mu0'
          description: 'Initial guess at posterior log-mean.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Real'
          default: '0'
          options:
        - label: 'sigma'
          description: 'The tuning parameter, adjusts variance of proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the move during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'adaptOnly'
          description: 'If true, sigma is not tuned but mean and variance are still learned'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMixtureAllocation'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMixtureAllocation(Real<stochastic> x, Natural<any> delta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'delta'
          description: 'The window of how many categories to propose left and right.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '0'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMultiValueEventBirthDeath'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMultiValueEventBirthDeath(MultiValueEvent<stochastic> x, Bool<any> ac, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MultiValueEvent'
          default:
          options:
        - label: 'ac'
          description: 'Should we use the autocorrelated proposal?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMultiValueEventScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMultiValueEventScale(MultiValueEvent<stochastic> x, String<any> name, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MultiValueEvent'
          default:
          options:
        - label: 'name'
          description: 'The name of the value for the multi-variate event object on which this move works.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we auto-tune?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMultiValueEventSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMultiValueEventSlide(MultiValueEvent<stochastic> x, String<any> name, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MultiValueEvent'
          default:
          options:
        - label: 'name'
          description: 'The name of the value for the multi-variate event object on which this move works.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we auto-tune?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvMultipleElementVectorScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvMultipleElementVectorScale(RealPos[]<deterministic> x, Natural<any> numToMove, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which the move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'numToMove'
          description: 'The number of vector elements changed per move.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvNNI'
  title: 'Nearest Neighbor Interchange (NNI) move.'
  aliases:
  description: |
    Tree topology move that performs a Nearest Neighbor Interchange (NNI) on
    a rooted or unrooted tree.
  details: |
    `mvNNI` changes tree topology by interchanging the positions of two subtrees
    around an internal branch. For each selected internal edge, the move considers
    two alternative topologies. As there are (n - 3) internal edges in an unrooted
    tree of n taxa, every such tree has (2n - 6) NNI "neighbors" that are one NNI
    move away. This neighborhood is smaller than that induced by more complex
    topology moves such as `mvSPR`. As a result, `mvNNI` is computationally cheaper
    than `mvSPR` and will often exhibit higher acceptance rates, but explores tree
    space less thoroughly and is more likely to get stuck in local optima
    (resulting in poor mixing). The RevBayes implementation of the NNI move can be
    applied to both `BranchLengthTree` and `TimeTree` objects.
  example: |
    taxa <- v(taxon("A"), taxon("B"), taxon("C"), taxon("D"), taxon("E"), taxon("F"))
    height ~ dnUniform(0, 10)
    moves = VectorMoves()
    
    # Apply the NNI move to an unrooted BranchLengthTree
    bltree ~ dnUniformTopology(taxa)
    moves.append( mvNNI(tree=bltree, weight=taxa.size()) )
    
    # Apply the NNI move to a rooted TimeTree
    timetree ~ dnUniformTimeTree(rootAge=height, taxa=taxa)
    moves.append( mvNNI(tree=timetree, weight=taxa.size()) )
  authors:
  see_also:
    - 'mvFNPR'
    - 'mvSPR'
    - 'mvTreeScale'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNNI(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
    - citation: 'Robinson DF (1971). Comparison of labeled trees with valency three. Journal of Combinatorial Theory, Series B, 11(2):105-119.'
      doi: '10.1016/0095-8956(71)90020-7'
      url: 'https://www.sciencedirect.com/science/article/pii/0095895671900207'
    - citation: 'Waterman MS, Smith TF (1978). On the similarity of dendrograms. Journal of Theoretical Biology, 73(4):789-800.'
      doi: '10.1016/0022-5193(78)90137-6'
      url: 'https://dornsife.usc.edu/msw/wp-content/uploads/sites/236/2023/09/msw-029.pdf'
- name: 'mvNarrow'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNarrow(TimeTree|TimeTree[]<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvNarrowExchangeRateMatrix'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNarrowExchangeRateMatrix(TimeTree<stochastic> tree, RateGenerator[]<deterministic> rateMatrices, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'rateMatrices'
          description: 'The branch-specific rate matrices.'
          dag_type: '<deterministic>'
          pass_by: 'const reference'
          value_type: 'RateGenerator[]'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvNodeRateTimeSlideUniform'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNodeRateTimeSlideUniform(TimeTree<stochastic> tree, RealPos[]<any> rates, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'rates'
          description: 'The vector of branch-specific substitution rates.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvNodeTimeScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNodeTimeScale(TimeTree<stochastic> tree, RealPos<any> lambda, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposals.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvNodeTimeSlideBeta'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNodeTimeSlideBeta(TimeTree<stochastic> tree, RealPos<any> delta, RealPos<any> offset, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'delta'
          description: 'The concentration parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'offset'
          description: 'The offset for the proposal density.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '2'
          options:
        - label: 'tune'
          description: 'Should we tune the concentration parameter during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvNodeTimeSlidePathTruncatedNormal'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNodeTimeSlidePathTruncatedNormal(TimeTree<stochastic> tree, TimeTree<stochastic> sigma, Bool<any> scaleByAge, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'sigma'
          description: 'The sd of the proposal.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default: '1'
          options:
        - label: 'scaleByAge'
          description: 'Should we additionally use age of node to adjust sd?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'tune'
          description: 'Should we tune sigma during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvNodeTimeSlideUniform'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNodeTimeSlideUniform(TimeTree|TimeTree[]<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvNodeTimeSlideUniformAgeConstrained'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvNodeTimeSlideUniformAgeConstrained(TimeTree<stochastic> tree, Clade[]<stochastic> constraints, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'constraints'
          description: 'The age constraints.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Clade[]'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventBirthDeath'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventBirthDeath(OrderedEventTimes<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEventTimes'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventScaleRealPos'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventScaleRealPos(OrderedEvents<RealPos><stochastic> x, RealPos<any> lambda, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEvents<RealPos>'
          default:
          options:
        - label: 'lambda'
          description: 'The size of the window to scale values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventSlideProbability'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventSlideProbability(OrderedEvents<Probability><stochastic> x, RealPos<any> delta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEvents<Probability>'
          default:
          options:
        - label: 'delta'
          description: 'The side of the window to slide values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventSlideReal'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventSlideReal(OrderedEvents<Real><stochastic> x, RealPos<any> delta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEvents<Real>'
          default:
          options:
        - label: 'delta'
          description: 'The side of the window to slide values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventSlideRealPos'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventSlideRealPos(OrderedEvents<RealPos><stochastic> x, RealPos<any> delta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEvents<RealPos>'
          default:
          options:
        - label: 'delta'
          description: 'The side of the window to slide values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventTimeSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventTimeSlide(OrderedEventTimes<stochastic> x, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEventTimes'
          default:
          options:
        - label: 'delta'
          description: 'The side of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we auto-tune?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventVectorScaleRealPos'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventVectorScaleRealPos(OrderedEvents<RealPos[]><stochastic> x, RealPos<any> lambda, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEvents<RealPos[]>'
          default:
          options:
        - label: 'lambda'
          description: 'The side of the window to scale values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventVectorSlideProbability'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventVectorSlideProbability(OrderedEvents<Probability[]><stochastic> x, RealPos<any> delta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEvents<Probability[]>'
          default:
          options:
        - label: 'delta'
          description: 'The side of the window to slide values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventVectorSlideReal'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventVectorSlideReal(OrderedEvents<Real[]><stochastic> x, RealPos<any> delta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEvents<Real[]>'
          default:
          options:
        - label: 'delta'
          description: 'The side of the window to slide values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvOrderedEventVectorSlideRealPos'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvOrderedEventVectorSlideRealPos(OrderedEvents<RealPos[]><stochastic> x, RealPos<any> delta, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'OrderedEvents<RealPos[]>'
          default:
          options:
        - label: 'delta'
          description: 'The side of the window to slide values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRJSwitch'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRJSwitch(Real<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRandomDive'
  title:
  aliases:
  description: |
    The multiplicative proposal of Dutta 2012, allows for long-distance moves.
    
    Useful for fat-tailed distributions, possibly for bimoodal distributions.
    
    Variables on [0,infinity) are log-transformed for proposals.
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRandomDive(Real<stochastic> x, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'delta'
          description: 'The tuning parameter, larger values for bolder moves.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the window size during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRandomGeometricWalk'
  title: 'Geometric random walk'
  aliases:
  description: 'A move that performs geometric random walk on an integer variable. The displacement of the random walk is drawn from a geometric distribution, mirrored for positive and negative steps.'
  details:
  example: |
    
    p <- 0.8
    x ~ dnGeom(p)
    
    moves[1] = mvRandomGeometricWalk(x, weight=1.0)
    monitors[1] = mvScreen(printgen=1000, x)
    
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also:
    - 'mvRandomNaturalWalk'
    - 'mvRandomIntegerWalk'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRandomGeometricWalk(Integer<stochastic> x, Probability<any> alpha, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Integer'
          default:
          options:
        - label: 'alpha'
          description: 'The success probability of the geometric distribution.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.5'
          options:
        - label: 'tune'
          description: 'Should we tune the success probability during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRandomIntegerWalk'
  title: 'Random walk on integers'
  aliases:
  description: 'A move that performs random walk on an integer variable. The displacement of the random walk is exactly one step, either positive or negative.'
  details:
  example: |
    
    p <- 0.8
    x ~ dnGeom(p)
    
    moves[1] = mvRandomIntegerWalk(x, weight=1.0)
    monitors[1] = mvScreen(printgen=1000, x)
    
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also:
    - 'mvRandomNaturalWalk'
    - 'mvRandomGeometricWalk'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRandomIntegerWalk(Integer<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Integer'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRandomNaturalWalk'
  title: 'Random walk on natural numbers'
  aliases:
  description: 'A move that performs random walk on a natural number variable. The displacement of the random walk is exactly one step, either positive or negative.'
  details:
  example: |
    
    p <- 0.8
    x ~ dnGeom(p)
    
    moves[1] = mvRandomNaturalWalk(x, weight=1.0)
    monitors[1] = mvScreen(printgen=1000, x)
    
    mymodel = model(p)
    mymcmc = mcmc(mymodel, monitors, moves)
    mymcmc.burnin(generations=20000,tuningInterval=100)
    mymcmc.run(generations=200000)
  authors:
  see_also:
    - 'mvRandomIntegerWalk'
    - 'mvRandomGeometricWalk'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRandomNaturalWalk(Natural<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Natural'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRateAgeBetaShift'
  title: 'The RateAgeBetaShift move'
  aliases: 'mvNodeRateTimeSlideBeta'
  description: 'Resample a single node age and adjust neighboring rates to preserve distances'
  details: |
    This move first selects a tree node that is not a tip or the root of the tree.
    
    The age of the tree node is resampled from the interval
       [max(child1.age, child2.age), parent.age]
    using a Beta distribution.
    
    The rates of the parent edge and two child edges are then modified to ensure that the rate*time
    remains unchanged for the tree branches.
  example: 'moves.append( mvRateAgeBetaShift(tree=timetree, rates=branch_rates, tune=true, weights=n_taxa ) )'
  authors:
  see_also:
    - 'mvRateAgeProposal'
    - 'mvRateAgeSubtreeProposal'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRateAgeBetaShift(Tree<stochastic> tree, RealPos[]<any> rates, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'rates'
          description: 'The vector of per-branch rates (from a relaxed clock).'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'delta'
          description: 'The concentration of the move on the previous age.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune this move during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRateAgeProposal'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRateAgeProposal(Tree<any> tree, RealPos<any> alpha, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree to which the branch-rates belong.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'alpha'
          description: 'The scaling factor (strength) of this move.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addRates'
      return_type: 'void'
      usage: 'addRates(RealPos[]<deterministic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
  references:
- name: 'mvRateAgeSubtreeProposal'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRateAgeSubtreeProposal(Tree<any> tree, RealPos<any> alpha, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree to which the branch-rates belong.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Tree'
          default:
          options:
        - label: 'alpha'
          description: 'The scaling factor (strength) of this move.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addRates'
      return_type: 'void'
      usage: 'addRates(RealPos[]<deterministic> var)'
      arguments:
        - label: 'var'
          description: 'The variable to move'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
  references:
- name: 'mvResampleFBD'
  title:
  aliases:
  description: 'This move resamples an oldest occurrence age for a random species in a fossilized birth death process described by `dnFBDRP` or `dnFBDRMatrix`'
  details: 'Under the hood, FBD fossil data is augmented with oldest occurrence ages for each species, which are automatically marginalized during when the model is sampled using MCMC. These ages can also be resampled manually using this move.'
  example: |
    bd ~ dnFBDRP(lambda=lambda, mu=mu, psi=psi, rho=1, taxa=taxa, resample=FALSE)
    
    moves.append( mvResampleFBD(bd, weight=taxa.size()) )
  authors:
  see_also:
    - 'dnFossilizedBirthDeathRange'
    - 'dnFossilizedBirthDeathRangeMatrix'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvResampleFBD(TimeTree|MatrixReal<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The fossilized birth death process whose ages to resample.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
    - citation: 'The fossilized birth-death model for the analysis of stratigraphic range data under different speciation modes. Stadler, Tanja et al. Journal of theoretical biology, 447:41-55.'
      doi:
      url: 'https://www.sciencedirect.com/science/article/pii/S002251931830119X'
- name: 'mvRootTimeScaleBactrian'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRootTimeScaleBactrian(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRootTimeSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRootTimeSlide(TimeTree<stochastic> tree, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'delta'
          description: 'The tuning parameter.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvRootTimeSlideUniform'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvRootTimeSlideUniform(TimeTree|TimeTree[]<stochastic> tree, RealPos<any> origin, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree(s) on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'origin'
          description: 'The maximum root age.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvSPR'
  title: 'Subtree Prune and Regraft (SPR) move.'
  aliases:
  description: |
    Tree topology move that performs a Subtree Prune and Regraft (SPR) on
    an unrooted tree.
  details: |
    `mvSPR` changes tree topology by cutting off a subtree and reattaching it
    elsewhere in the original tree using the same subtree branch that was
    originally cut. Every unrooted tree of n taxa has 2(n - 3)(2n - 7) SPR
    "neighbors" that are one SPR move away (Allen & Steel 2001). This neighborhood
    is larger than, and inclusive of, the neighborhood induced by Nearest-Neighbor
    Interchange (`mvNNI`). As a result, `mvSPR` is more computationally demanding
    than `mvNNI` and may exhibit lower acceptance rates, but explores a broader
    range of different topologies and is less likely to get stuck in local optima.
    The `mvSPR` move can be applied only to `BranchLengthTreee` objects.
    An analogous move for `TimeTree` objects (Fixed Node-height Prune and Regraft;
    FNPR) is implemented in `mvFNPR`.
  example: |
    taxa <- v(taxon("A"), taxon("B"), taxon("C"), taxon("D"), taxon("E"), taxon("F"))
    moves = VectorMoves()
    
    topology ~ dnUniformTopology(taxa)
    moves.append( mvSPR(topology, weight=taxa.size()) )
  authors:
  see_also:
    - 'mvFNPR'
    - 'mvNNI'
    - 'mvSubtreeSwap'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSPR(BranchLengthTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'BranchLengthTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
    - citation: 'Allen BL, Steel M (2001). Subtree transfer operations and their induced metrics on evolutionary trees. Annals of Combinatorics, 5:1-15.'
      doi: '10.1007/s00026-001-8006-8'
      url: 'https://link.springer.com/article/10.1007/s00026-001-8006-8'
    - citation: 'Swofford DL, Olsen GJ (1990). Phylogeny reconstruction. Pp. 411--501 in Hillis DM, Moritz C, eds. Molecular Systematics, 1st ed. Sunderland, MA: Sinauer Associates.'
      doi:
      url:
- name: 'mvScale'
  title: 'Proportional Scaling Move'
  aliases:
  description: 'Proposes multiplicative updates to continuous parameters.'
  details: |
    The `mvScale` move updates a parameter by multiplying it with a randomly chosen
    factor from a proposal distribution. The move takes arguments that control how
    often it should be used (`weight`) and the size of the scaling factor
    (`lambda`). When the `tune` argument is set to `TRUE`, the value of `lambda` is
    automatically adjusted so that the acceptance rate of the move reaches
    `tuneTarget`. Since multiplicative updates do not change the sign, `mvScale` is
    most often applied to parameters that are constrained to be positive, such as
    rates or branch lengths in phylogenetic models.
  example: |
    moves = VectorMoves()
    speciation_rate ~ dnExponential(10)
    moves.append( mvScale(speciation_rate, weight=1) )
  authors:
  see_also:
    - 'mvScaleBactrian'
    - 'mvSlide'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvScale(Real<stochastic> x, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'lambda'
          description: 'The strength of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune lambda during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvScaleBactrian'
  title: 'Scaling Move Employing Bactrian Distribution'
  aliases:
  description: 'Scales a parameter by a Bactrian-distributed factor.'
  details: |
    Proposes multiplicative changes to a real-valued parameter using a Bactrian
    kernel -- a bimodal distribution centered at zero, obtained as a mixture of two
    unimodal component distributions. Specifically, `mvScaleBactrian` scales
    parameter values by a random factor of exp(lambda * delta), where lambda is a
    tuning parameter and delta is drawn from a mixture of two normal distributions
    following Yang & Rodrguez (2013: Supplementary Information, Eq. 19): 
    
        u ~ Unif(0, 1)
        x ~ N(0, 1)
        delta = m + x * sqrt(1 - m^2)  if u < 0.5
              = -m + x * sqrt(1 - m^2) otherwise
    
    with m set to 0.95. As a result, the move is less likely to propose very small
    steps and encourages larger changes, which improves mixing efficiency and
    reduces autocorrelation. Since multiplicative updates do not change the sign,
    `mvBactrianScale` is most often applied to parameters that are constrained to
    be positive.
  example: |
    moves = VectorMoves()
    speciation_rate ~ dnGamma(2, 4)
    moves.append( mvScaleBactrian(speciation_rate, weight=5) )
  authors:
  see_also:
    - 'mvScale'
    - 'mvScaleBactrianCauchy'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvScaleBactrian(Real<stochastic> x, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'lambda'
          description: 'The strength of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune lambda during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
    - citation: 'Yang Z, Rodrguez CE (2013). Searching for efficient Markov chain Monte Carlo proposal kernels. Proc. Natl. Acad. Sci. USA, 110(48):19307-19312.'
      doi: '10.1073/pnas.1311790110'
      url: 'https://www.pnas.org/doi/full/10.1073/pnas.1311790110'
- name: 'mvScaleBactrianCauchy'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvScaleBactrianCauchy(RealPos<stochastic> x, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'lambda'
          description: 'The strength of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune lambda during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvShrinkExpand'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvShrinkExpand(RealPos[]|Real[]<deterministic> x, RealPos<stochastic> sd, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which the move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'sd'
          description: 'The standard deviation parameter if available.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvShrinkExpandScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvShrinkExpandScale(RealPos[]<deterministic> x, RealPos<stochastic> sd, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which the move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'sd'
          description: 'The standard deviation parameter if available.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvSlice'
  title: 'Propose a slice move'
  aliases:
  description: '`mvSlice` proposes a new value for a variable based on the current shape of its likelihood function.'
  details: |
    A slice proposal uses the shape of the current likelihood distribution of a variable to propose a new value.
    First, a likelihood value is drawn uniformly in order to define a horizontal 'slice' through the likelihood distribution.
    Then, a new value is drawn uniformly from those values that lie within this slice.
    
    This allows parameter space to be traversed more efficiently than a random walk.
    A practical outcome of the implementation is that small moves are proposed in certain parts of parameter space, and large moves in other parts of the space, as appropriate.
    
    A detailed explanation with figures is provided in Neal (2003).
  example:
  authors:
  see_also: '`mvSlide` and `mvScale` are possible alternatives where a fixed move size is desired.'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSlice(Real<stochastic> x, RealPos<any> window, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget, String<any> search_method {valid options: "stepping_out"|"doubling"})'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'window'
          description: 'The window (steps-size) of proposals.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the move during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
        - label: 'search_method'
          description: 'The method used to find the slice boundaries.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'doubling'
          options:
            - 'stepping_out'
            - 'doubling'
  methods:
  references:
    - citation: 'Slice sampling. Neal (2003). Ann. Statist. 31(3): 705-767'
      doi: '10.1214/aos/1056562461'
      url: 'https://projecteuclid.org/journals/annals-of-statistics/volume-31/issue-3/Slice-sampling/10.1214/aos/1056562461.full'
- name: 'mvSlide'
  title: 'Sliding-Window Move'
  aliases:
  description: 'Proposes additive updates to continuous parameters.'
  details: |
    The `mvSlide` move updates a parameter by drawing a random number from
    a uniform distribution and adding the draw to the current value. The move takes
    arguments that control how often it should be used (`weight`) and its "window
    size", i.e., the width of the uniform distribution, which determines the size
    of the changes it proposes (`delta`). When the `tune` argument is set to
    `TRUE`, the value of `delta` is automatically adjusted so that the acceptance
    rate of the move reaches `tuneTarget`.
  example: |
    moves = VectorMoves()
    p ~ dnUniform(0, 1)
    moves.append(mvSlide(p, delta=0.05, weight=1))
  authors:
  see_also:
    - 'mvScale'
    - 'mvSlideBactrian'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSlide(Real<stochastic> x, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'delta'
          description: 'The window size parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the window size during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvSlideBactrian'
  title: 'Sliding-Window Mode Employing Bactrian Distribution'
  aliases:
  description: 'Updates a parameter by a Bactrian-distributed increment.'
  details: |
    Proposes additive changes to a real-valued parameter using a Bactrian kernel
    -- a bimodal distribution centered at zero, obtained as a mixture of two
    unimodal component distributions. Specifically, `mvSlideBactrian` updates
    the current value by adding a random increment of (lambda * delta), where
    lambda is a tuning parameter and delta is drawn from a mixture of two normal
    distributions following Yang & Rodrguez (2013: Supplementary Information,
    Eq. 19): 
    
        u ~ Unif(0, 1)
        x ~ N(0, 1)
        delta = m + x * sqrt(1 - m^2)  if u < 0.5
              = -m + x * sqrt(1 - m^2) otherwise
    
    with m set to 0.95. As a result, the move is less likely to propose very small
    steps and encourages larger changes, which improves mixing efficiency and
    reduces autocorrelation.
  example: |
    moves = VectorMoves()
    x ~ dnNormal(0, 2)
    moves.append( mvSlideBactrian(x, tune=TRUE, weight=1) )
  authors:
  see_also: 'mvSlide'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSlideBactrian(Real<stochastic> x, RealPos<any> sigma, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'sigma'
          description: 'The scale parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune sigma during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
    - citation: 'Yang Z, Rodrguez CE (2013). Searching for efficient Markov chain Monte Carlo proposal kernels. Proc. Natl. Acad. Sci. USA, 110(48):19307-19312.'
      doi: '10.1073/pnas.1311790110'
      url: 'https://www.pnas.org/doi/full/10.1073/pnas.1311790110'
- name: 'mvSpeciesNarrow'
  title: 'Narrow-exchange joint move on species tree and gene trees for multispecies coalescent models.'
  aliases:
  description: 'Makes a narrow-exchange move both in the species tree and in the gene trees that contain nodes of the relevant populations.'
  details: |
    The species tree must be ultrametric.
    
    All the gene trees that evolved along the species tree according to some form of multispecies coalescent must be added to the move using the addGeneTreeVariable method.
    
    This move jointly performs narrow exchange moves (Nearest-Neighbor Interchanges without branch length alterations) on the species tree and on gene trees, all of which must be ultrametric.
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a constant effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescent(speciesTree=spTree, Ne=popSize, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # Set my move index:
    mi = 0
    move_species_narrow_exchange = mvSpeciesNarrow( speciesTree=spTree, weight=5 )
    for (i in 1:n_genes) {
        move_species_narrow_exchange.addGeneTreeVariable( geneTrees[i] )
    }
    moves[++mi] = move_species_narrow_exchange
    
    # We get a handle on our model.
    # We can use any node of our model as a handle; here we choose to use the topology.
    mymodel = model(spTree)
    
    # Monitors to check the progression of the program:
    monitors[1] = mnScreen(printgen=10, spTree)
    
    # Here we use a plain MCMC. You could also use mcmcmc with heated chains.
    mymcmc = mcmc(mymodel, monitors, moves, nruns=4)
    mymcmc.run(generations=1000)
    mymcmc.operatorSummary()
  authors:
  see_also:
    - 'mvSpeciesSubtreeScale'
    - 'mvSpeciesSubtreeScaleBeta'
    - 'mvSpeciesNodeTimeSlideUniform'
    - 'mvSpeciesTreeScale'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSpeciesNarrow(TimeTree<stochastic> speciesTree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'speciesTree'
          description: 'The species tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addGeneTreeVariable'
      return_type: 'void'
      usage: 'addGeneTreeVariable(TimeTree<stochastic> geneTree)'
      arguments:
        - label: 'geneTree'
          description: 'A gene tree.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
  references:
    - citation: 'Hoehna S, Drummond AJ (2012). Guided tree topology proposals for Bayesian phylogenetic inference. Systematic Biology 61(1):1-11.'
      doi: '10.1093/sysbio/syr074'
      url: 'https://academic.oup.com/sysbio/article-lookup/doi/10.1093/sysbio/syr074'
    - citation: 'Jones G (2016). Algorithmic improvements to species delimitation and phylogeny estimation under the multispecies coalescent. Journal of Mathematical Biology, 74:447-467.'
      doi: '10.1007/s00285-016-1034-0'
      url: 'http://www.indriid.com/2016/2016-06-01-STACEY.pdf'
- name: 'mvSpeciesNodeTimeSlideUniform'
  title: 'Node time slide joint move on species tree and gene trees for multispecies coalescent models.'
  aliases:
  description: 'Makes a node time slide move both in the species tree and in the gene trees that contain nodes of the relevant populations. Tree topologies are not altered.'
  details: |
    The species tree must be ultrametric.
    
    All the gene trees that evolved along the species tree according to some form of multispecies coalescent must be added to the move using the addGeneTreeVariable method.
    
    This move jointly performs node time slides (branch length alterations, keeping the topologies fixed) on the species tree and on gene trees, all of which must be ultrametric.
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a constant effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescent(speciesTree=spTree, Ne=popSize, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # Set my move index:
    mi = 0
    move_species_node_time_slide = mvSpeciesNodeTimeSlideUniform( speciesTree=spTree, weight=5 )
    for (i in 1:n_genes) {
        move_species_node_time_slide.addGeneTreeVariable( geneTrees[i] )
    }
    moves[++mi] = move_species_node_time_slide
    
    # We get a handle on our model.
    # We can use any node of our model as a handle; here we choose to use the topology.
    mymodel = model(spTree)
    
    # Monitors to check the progression of the program:
    monitors[1] = mnScreen(printgen=10, spTree)
    
    # Here we use a plain MCMC. You could also use mcmcmc with heated chains.
    mymcmc = mcmc(mymodel, monitors, moves, nruns=4)
    mymcmc.run(generations=1000)
    mymcmc.operatorSummary()
  authors:
  see_also:
    - 'mvSpeciesSubtreeScale'
    - 'mvSpeciesSubtreeScaleBeta'
    - 'mvSpeciesNarrow'
    - 'mvSpeciesTreeScale'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSpeciesNodeTimeSlideUniform(TimeTree<stochastic> speciesTree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'speciesTree'
          description: 'The ultrametric species tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addGeneTreeVariable'
      return_type: 'void'
      usage: 'addGeneTreeVariable(TimeTree<stochastic> geneTree)'
      arguments:
        - label: 'geneTree'
          description: 'A gene tree.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
  references:
    - citation: 'Hoehna S, Drummond AJ (2012). Guided tree topology proposals for Bayesian phylogenetic inference. Systematic Biology 61(1):1-11.'
      doi: '10.1093/sysbio/syr074'
      url: 'https://academic.oup.com/sysbio/article-lookup/doi/10.1093/sysbio/syr074'
    - citation: 'Jones G (2016). Algorithmic improvements to species delimitation and phylogeny estimation under the multispecies coalescent. Journal of Mathematical Biology, 74:447-467.'
      doi: '10.1007/s00285-016-1034-0'
      url: 'http://www.indriid.com/2016/2016-06-01-STACEY.pdf'
- name: 'mvSpeciesSubtreeScale'
  title: 'Subtree scale move on species tree and gene trees for multispecies coalescent models.'
  aliases:
  description: 'Makes a subtree scale move both in the species tree and in the gene trees that contain nodes of the relevant populations. Tree topologies are not altered.'
  details: |
    The species tree must be ultrametric.
    
    All the gene trees that evolved along the species tree according to some form of multispecies coalescent must be added to the move using the addGeneTreeVariable method.
    
    This move jointly performs a subtree scale move (a whole subtree is scaled up or down, keeping the topology fixed) on the species tree and on gene trees, all of which must be ultrametric.
    
    How this works: we pick a random node which is not the root.
    Then, we uniformly pick an age between the parent and the oldest sampled descendant.
    The picked subtree is then scaled to this new age.
    All gene-trees that are present in the population will be scaled accordingly.
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a constant effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescent(speciesTree=spTree, Ne=popSize, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # Set my move index:
    mi = 0
    move_species_subtree_scale = mvSpeciesSubtreeScale( speciesTree=spTree, weight=5 )
    for (i in 1:n_genes) {
       move_species_subtree_scale.addGeneTreeVariable( geneTrees[i] )
    }
    moves[++mi] = move_species_subtree_scale
    
    # We get a handle on our model.
    # We can use any node of our model as a handle; here we choose to use the topology.
    mymodel = model(spTree)
    
    # Monitors to check the progression of the program:
    monitors[1] = mnScreen(printgen=10, spTree)
    
    # Here we use a plain MCMC. You could also use mcmcmc with heated chains.
    mymcmc = mcmc(mymodel, monitors, moves, nruns=4)
    mymcmc.run(generations=1000)
    mymcmc.operatorSummary()
  authors:
  see_also:
    - 'mvSpeciesNodeTimeSlideUniform'
    - 'mvSpeciesSubtreeScaleBeta'
    - 'mvSpeciesNarrow'
    - 'mvSpeciesTreeScale'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSpeciesSubtreeScale(TimeTree<stochastic> speciesTree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'speciesTree'
          description: 'The species variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addGeneTreeVariable'
      return_type: 'void'
      usage: 'addGeneTreeVariable(TimeTree<stochastic> geneTree)'
      arguments:
        - label: 'geneTree'
          description: 'A gene tree to scale.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
  references:
    - citation: 'Hoehna S, Drummond AJ (2012). Guided tree topology proposals for Bayesian phylogenetic inference. Systematic Biology 61(1):1-11.'
      doi: '10.1093/sysbio/syr074'
      url: 'https://academic.oup.com/sysbio/article-lookup/doi/10.1093/sysbio/syr074'
    - citation: 'Jones G (2016). Algorithmic improvements to species delimitation and phylogeny estimation under the multispecies coalescent. Journal of Mathematical Biology, 74:447-467.'
      doi: '10.1007/s00285-016-1034-0'
      url: 'http://www.indriid.com/2016/2016-06-01-STACEY.pdf'
- name: 'mvSpeciesSubtreeScaleBeta'
  title: 'Subtree scale move on species tree and gene trees for multispecies coalescent models.'
  aliases:
  description: 'Makes a subtree scale move both in the species tree and in the gene trees that contain nodes of the relevant populations. Tree topologies are not altered. Uses a beta distribution to propose a new age value.'
  details: |
    The species tree must be ultrametric.
    
    All the gene trees that evolved along the species tree according to some form of multispecies coalescent must be added to the move using the addGeneTreeVariable method.
    
    This move jointly performs a subtree scale move (a whole subtree is scaled up or down, keeping the topology fixed) on the species tree and on gene trees, all of which must be ultrametric.
    
    How this works: we pick a random node which is not the root.
    Then, we pick a new age between the parent and the oldest sampled descendant according to a beta distribution.
    The picked subtree is then scaled to this new age.
    All gene-trees that are present in the population will be scaled accordingly.
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a constant effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescent(speciesTree=spTree, Ne=popSize, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # Set my move index:
    mi = 0
    move_species_subtree_scale_beta = mvSpeciesSubtreeScaleBeta( speciesTree=spTree, weight=5 )
    for (i in 1:n_genes) {
        move_species_subtree_scale_beta.addGeneTreeVariable( geneTrees[i] )
    }
    moves[++mi] = move_species_subtree_scale_beta
    
    # We get a handle on our model.
    # We can use any node of our model as a handle; here we choose to use the topology.
    mymodel = model(spTree)
    
    # Monitors to check the progression of the program:
    monitors[1] = mnScreen(printgen=10, spTree)
    
    # Here we use a plain MCMC. You could also use mcmcmc with heated chains.
    mymcmc = mcmc(mymodel, monitors, moves, nruns=4)
    mymcmc.run(generations=1000)
    mymcmc.operatorSummary()
  authors:
  see_also:
    - 'mvSpeciesNodeTimeSlideUniform'
    - 'mvSpeciesSubtreeScale'
    - 'mvSpeciesNarrow'
    - 'mvSpeciesTreeScale'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSpeciesSubtreeScaleBeta(TimeTree<stochastic> speciesTree, RealPos<any> alpha, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'speciesTree'
          description: 'The species tree on which this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'alpha'
          description: 'The concentration parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '10'
          options:
        - label: 'tune'
          description: 'Should we tune the concentration parameter during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addGeneTreeVariable'
      return_type: 'void'
      usage: 'addGeneTreeVariable(TimeTree<stochastic> geneTree)'
      arguments:
        - label: 'geneTree'
          description: 'A gene tree.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
  references:
    - citation: 'Hoehna S, Drummond AJ (2012). Guided tree topology proposals for Bayesian phylogenetic inference. Systematic Biology 61(1):1-11.'
      doi: '10.1093/sysbio/syr074'
      url: 'https://academic.oup.com/sysbio/article-lookup/doi/10.1093/sysbio/syr074'
    - citation: 'Jones G (2016). Algorithmic improvements to species delimitation and phylogeny estimation under the multispecies coalescent. Journal of Mathematical Biology, 74:447-467.'
      doi: '10.1007/s00285-016-1034-0'
      url: 'http://www.indriid.com/2016/2016-06-01-STACEY.pdf'
- name: 'mvSpeciesTreeScale'
  title: 'Tree scale move on species tree and gene trees for multispecies coalescent models.'
  aliases:
  description: 'Makes a tree scale move both in the species tree and in the gene trees. Tree topologies are not altered.'
  details: |
    The species tree must be ultrametric.
    
    All the gene trees that evolved along the species tree according to some form of multispecies coalescent must be added to the move using the addGeneTreeVariable method.
    
    This move jointly performs a tree scale move (the entire tree is scaled up or down, keeping the topology fixed) on the species tree and on gene trees, all of which must be ultrametric.
  example: |
    # We are going to save the trees we simulate in the folder simulatedTrees:
    dataFolder = "simulatedTrees/"
    
    # Let's simulate a species tree with 10 taxa, 2 gene trees, 3 alleles per species:
    n_species <- 10
    n_genes <- 2
    n_alleles <- 3
    
    # We simulate an ultrametric species tree.
    # Species names:
    for (i in 1:n_species) {
        species[i] <- taxon(taxonName="Species_"+i, speciesName="Species_"+i)
    }
    spTree ~ dnBirthDeath(lambda=0.3, mu=0.2, rootAge=10, rho=1, samplingStrategy="uniform", condition="nTaxa", taxa=species)
    print(spTree)
    
    # Let's pick a constant effective population size of 50:
    popSize <- 50
    
    # Let's simulate gene trees now.
    # Taxon names:
    for (g in 1:n_genes) {
        for (i in 1:n_species) {
            for (j in 1:n_alleles) {
                taxa[g][(i-1)*n_alleles+j] <- taxon(taxonName="Species_"+i+"_"+j, speciesName="Species_"+i)
            }
        }
        geneTrees[g] ~ dnMultiSpeciesCoalescent(speciesTree=spTree, Ne=popSize, taxa=taxa[g])
        print(geneTrees[g])
    }
    
    # Set my move index:
    mi = 0
    move_species_tree_scale = mvSpeciesTreeScale( speciesTree=spTree, root=root, weight=5 )
    for (i in 1:n_genes) {
        move_species_tree_scale.addGeneTreeVariable( geneTrees[i] )
    }
    moves[++mi] = move_species_tree_scale
    
    # We get a handle on our model.
    # We can use any node of our model as a handle; here we choose to use the topology.
    mymodel = model(spTree)
    
    # Monitors to check the progression of the program:
    monitors[1] = mnScreen(printgen=10, spTree)
    
    # Here we use a plain MCMC. You could also use mcmcmc with heated chains.
    mymcmc = mcmc(mymodel, monitors, moves, nruns=4)
    mymcmc.run(generations=1000)
    mymcmc.operatorSummary()
  authors:
  see_also:
    - 'mvSpeciesNodeTimeSlideUniform'
    - 'mvSpeciesSubtreeScaleBeta'
    - 'mvSpeciesNarrow'
    - 'mvSpeciesSubtreeScale'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSpeciesTreeScale(TimeTree<stochastic> speciesTree, RealPos<stochastic> rootAge, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'speciesTree'
          description: 'The species tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'rootAge'
          description: 'The root age variable.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default:
          options:
        - label: 'delta'
          description: 'The strength of the proposal'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the strength during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addGeneTreeVariable'
      return_type: 'void'
      usage: 'addGeneTreeVariable(TimeTree<stochastic> geneTree)'
      arguments:
        - label: 'geneTree'
          description: 'A gene tree variable.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
  references:
    - citation: 'Hoehna S, Drummond AJ (2012). Guided tree topology proposals for Bayesian phylogenetic inference. Systematic Biology 61(1):1-11.'
      doi: '10.1093/sysbio/syr074'
      url: 'https://academic.oup.com/sysbio/article-lookup/doi/10.1093/sysbio/syr074'
    - citation: 'Jones G (2016). Algorithmic improvements to species delimitation and phylogeny estimation under the multispecies coalescent. Journal of Mathematical Biology, 74:447-467.'
      doi: '10.1007/s00285-016-1034-0'
      url: 'http://www.indriid.com/2016/2016-06-01-STACEY.pdf'
- name: 'mvSubtreeScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSubtreeScale(TimeTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvSubtreeSwap'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSubtreeSwap(BranchLengthTree<stochastic> tree, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree variable this move operates on.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'BranchLengthTree'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvSymmetricMatrixElementSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSymmetricMatrixElementSlide(MatrixRealSymmetric<stochastic> x, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The matrix variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'MatrixRealSymmetric'
          default:
          options:
        - label: 'delta'
          description: 'The sliding window size.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the move during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvSynchronizedVectorFixedSingleElementSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvSynchronizedVectorFixedSingleElementSlide(Real[][]<deterministic> x, Natural|Natural[]<any> element, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable (a deterministic variable holding the vector of stochastic variable) on which this move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[][]'
          default:
          options:
        - label: 'element'
          description: 'The index or indices of the element to scale.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of this move.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvTreeScale'
  title: 'Scaling Move for Time Tree Node Ages'
  aliases:
  description: |
    Scales the ages of all internal nodes in a `TimeTree` by the same factor while
    leaving the topology unchanged.
  details: |
    The `mvTreeScale` move scales the ages of all internal nodes (including
    the root) by a random factor of exp(delta * (u - 0.5)), where delta is a tuning
    parameter and u is a random draw from the uniform distribution on [0, 1].
  example: |
    taxa <- v(taxon("A"), taxon("B"), taxon("C"), taxon("D"), taxon("E"), taxon("F"))
    height ~ dnUniform(0, 10)
    moves = VectorMoves()
    
    # Simulate a simple TimeTree
    tree ~ dnBDP(lambda=1.0, mu=0.2, rootAge=height, taxa=taxa)
    
    # Assign it a mvTreeScale move
    moves.append( mvTreeScale(tree=tree, rootAge=height, delta=1, tune=TRUE, weight=5) )
  authors:
  see_also:
    - 'mvSubtreeScale'
    - 'mvNodeTimeSlide'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvTreeScale(TimeTree|TimeTree[]<stochastic> tree, RealPos<stochastic> rootAge, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'tree'
          description: 'The tree on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'rootAge'
          description: 'The root age variable.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos'
          default: 'NULL'
          options:
        - label: 'delta'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
    - citation: 'Yang Z (2014). Molecular Evolution: A Statistical Approach. Oxford, UK: Oxford University Press.'
      doi: '10.1093/acprof:oso/9780199602605.001.0001'
      url: 'https://academic.oup.com/book/26340'
- name: 'mvUPPAllocation'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvUPPAllocation(RealPos[]<stochastic> x, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvUpDownScale'
  title: 'Up-Down Proposal for Joint Scaling of Multiple Parameters'
  aliases:
  description: |
    Simultaneously scales multiple parameters up, and potentially down, by the same
    factor.
  details: |
    This move scales a set of parameters up by a random factor, and optionally
    scales another set of parameters down by the same value. This may improve
    the mixing of parameters that we expect to be either positively or negatively
    correlated, such as speciation and extinction rates or the clock rate and
    branch durations in time tree inference. The parameters to be scaled up and
    down can be selected by the `.addVariable()` and `.removeVariable()` methods.
    The actual scaling factor is equal to exp( lambda * (u - 0.5) ), where lambda
    is a tuning parameter and u is a random draw from the uniform distribution on
    [0, 1].
  example: |
    moves = VectorMoves()
    
    speciation_rate ~ dnExponential(10)
    extinction_rate ~ dnExponential(10)
    
    # Define the basic properties of the move
    up_down_move = mvUpDownScale(lambda=1.0, weight=5.0)
    
    # Add variables to the move to account for their positive correlation
    up_down_move.addVariable(speciation_rate, up=TRUE)
    up_down_move.addVariable(extinction_rate, up=TRUE)
    
    # Apply the move
    moves.append( up_down_move )
  authors:
  see_also:
    - 'mvScale'
    - 'mvScaleBactrian'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvUpDownScale(RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(TimeTree<stochastic> tree, Bool<any> up)'
      arguments:
        - label: 'tree'
          description: 'The tree variable to scale.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real[]<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RealPos[]<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RealPos[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(TimeTree<stochastic> tree, Bool<any> up)'
      arguments:
        - label: 'tree'
          description: 'The tree variable to scale.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'TimeTree'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real[]<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(RealPos[]<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(RealPos[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
  references:
    - citation: 'Rannala B, Yang Z (2003). Bayes estimation of species divergence times and ancestral population sizes using DNA sequences from multiple loci. Genetics, 164(4):1645-1656.'
      doi: '10.1093/genetics/164.4.1645'
      url: 'https://www.rannala.org/reprints/2003/Rannala2003a.pdf'
- name: 'mvUpDownSlide'
  title: 'Up-Down Proposal for Joint Sliding-Window Adjustments to Multiple Parameters'
  aliases:
  description: |
    Simultaneously applies a sliding adjustment to multiple parameters, potentially
    increasing some and decreasing others by the same amount.
  details: |
    This move adds a random value to a set of parameters, and optionally subtracts
    the same value from another set of parameters. This may improve the mixing
    of parameters that we expect to be either positively or negatively correlated,
    such as speciation and extinction rates or the clock rate and branch durations
    in time tree inference. The parameters to be incremented and decremented can be
    selected using the `.addVariable()` and `.removeVariable()` methods. The actual
    value to be added or subtracted is equal to delta * (u - 0.5), where delta is
    a tuning parameter and u is a random draw from the uniform distribution on
    [0, 1].
  example: |
    moves = VectorMoves()
    
    log_speciation_rate ~ dnNormal(-1, 0.5)
    log_extinction_rate ~ dnNormal(-1, 0.5)
    
    # Define the basic properties of the move
    delta_up_down_move = mvUpDownSlide(delta=0.05, weight=5.0)
    
    # Add variables to the move to account for their positive correlation
    delta_up_down_move.addVariable(log_speciation_rate, up=TRUE)
    delta_up_down_move.addVariable(log_extinction_rate, up=TRUE)
    
    # Apply the move
    moves.append( delta_up_down_move )
  authors:
  see_also:
    - 'mvSlide'
    - 'mvSlideBactrian'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvUpDownSlide(RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'delta'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real[]<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RealPos[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real[]<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(RealPos[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
  references:
- name: 'mvUpDownSlideBactrian'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvUpDownSlideBactrian(RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'lambda'
          description: 'The scaling factor (strength) of the proposal.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real[]<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(Real[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'addVariable'
      return_type: 'void'
      usage: 'addVariable(RealPos[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'The variable to scale'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'up'
          description: 'Scaling up or down?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real[]<stochastic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(Real[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
    - name: 'removeVariable'
      return_type: 'void'
      usage: 'removeVariable(RealPos[]<deterministic> var, Bool<any> up)'
      arguments:
        - label: 'var'
          description: 'Scaling up or down?'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'up'
          description: 'The variable to scale'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default:
          options:
  references:
- name: 'mvVectorBinarySwitch'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvVectorBinarySwitch(Natural[]<deterministic> x, Probability<any> p, Natural[]<any> elements, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Natural[]'
          default:
          options:
        - label: 'p'
          description: 'The probability of applying the move to each element.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Probability'
          default: '1'
          options:
        - label: 'elements'
          description: 'The indices of elements. All are used if this is empty.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Natural[]'
          default: '[ ]'
          options:
        - label: 'tune'
          description: 'Should we tune the window size during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvVectorElementSwap'
  title: 'Move to swap to elements in a vector'
  aliases:
  description: 'Move that randomly picks a pair of elements in a vector on swaps the two with another.'
  details:
  example:
  authors:
  see_also: 'mvVectorBinarySwitch'
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvVectorElementSwap(Real[]<deterministic> x, Bool<any> neighborsOnly, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'neighborsOnly'
          description: 'Should we switch only neighbors or two random elements?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvVectorFixedSingleElementSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvVectorFixedSingleElementSlide(Real[]<stochastic> x, RealPos<any> lambda, Bool<any> tune, Natural<any> element, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of this move.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'element'
          description: 'The index of the element to scale.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvVectorScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvVectorScale(RealPos[]<stochastic> x, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling parameter (strength) of the move.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling parameter during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvVectorSingleElementScale'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvVectorSingleElementScale(RealPos[]<deterministic> x, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'RealPos[]'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (strength) of this move.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvVectorSingleElementSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvVectorSingleElementSlide(Real[]<deterministic> x, RealPos<any> lambda, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'lambda'
          description: 'The scaling factor (or strength) of the proposals.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we auto tune during burning?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvVectorSlide'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvVectorSlide(Real[]<stochastic> x, Natural[]<any> elements, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which this move operates.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'elements'
          description: 'The indices of elements. All are used if this is empty.'
          dag_type: '<any>'
          pass_by: 'reference'
          value_type: 'Natural[]'
          default: '[ ]'
          options:
        - label: 'delta'
          description: 'The window size parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the window size during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'mvVectorSlideRecenter'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'Move'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'mvVectorSlideRecenter(Real[]<deterministic> x, Real<stochastic> mean, RealPos<any> delta, Bool<any> tune, RealPos<any> weight, Probability<any> tuneTarget)'
      arguments:
        - label: 'x'
          description: 'The variable on which the move operates.'
          dag_type: '<deterministic>'
          pass_by: 'reference'
          value_type: 'Real[]'
          default:
          options:
        - label: 'mean'
          description: 'The mean parameter of the variables.'
          dag_type: '<stochastic>'
          pass_by: 'reference'
          value_type: 'Real'
          default:
          options:
        - label: 'delta'
          description: 'The window size parameter.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tune'
          description: 'Should we tune the scaling factor during burnin?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
        - label: 'weight'
          description: 'The weight determines the relative frequency with which this move will be attempted. For details, see the description of the ''moveschedule'' parameter on the documentation page for ''mcmc()''.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '1'
          options:
        - label: 'tuneTarget'
          description: 'The acceptance probability targeted by auto-tuning.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.44'
          options:
  methods:
  references:
- name: 'pathSampler'
  title: 'Path-sampling marginal likelihood estimation'
  aliases:
  description: |
    Applies the path-sampling technique (Gelman & Meng 1998), also known as
    thermodynamic integration (Ogata 1989; Lartillot & Philippe 2006), to estimate
    the marginal likelihood of a model from a series of unnormalized "power
    posterior" densities in which the likelihood term is raised to a power B
    between 0 and 1.
  details: |
    The RevBayes implementation of path sampling allows for an arbitrary choice of
    the powers B, and uses the trapezoidal rule for numerical integration. For K
    power posteriors starting with the posterior proper (B_1 = 1) and ending with
    the prior (B_K = 0), the path-sampling log marginal likelihood estimate r_PS is
    therefore equal to:
    
        r_PS = \sum_{k=1}^{K-1} ( (\sum{i=1}^n L_{k,i} / n) + (\sum{i=1}^n L_{k+1,i} / n) ) * (B_k - B{k+1})/2
    
    where n denotes the number of MCMC samples from each power posterior, and
    L_{k,i} denotes the log likelihood of the i-th MCMC sample from the k-th power
    posterior. The estimate is returned by calling the `.marginal()` method on the
    sampler object. We can also compute the standard error of this estimate in two
    different ways using the `.stdError()` method. By default, RevBayes uses the
    formula:
    
        SE = sqrt( \sum_{k=1}^K w_k^2/4 Var(L_k)/N_{eff,k} )
        
    where w_k is the k-th weight, Var(L_k) is the variance of the log likelihoods
    from the k-th power posterior, and N_{eff,k} is the effective sample size for
    the k-th power posterior. This is the formula given by dos Reis et al. (2018;
    Appendix 2), but RevBayes uses a different numerical integration technique,
    and therefore a different set of weights:
    
               | B_2 - B_1         if k = 1
        w_k = <  B_{k+1} - B_{k-1} if 1 < k < K
               | B_K - B_{K-1}     if k = K
               
    These weights generalize Eqs. 51 and 52 of Lartillot & Philippe (2006) to cases
    in which the powers B are not evenly spaced between 0 and 1. The standard error
    can also be derived using the stationary bootstrap method (Politis & Romano
    1994), which divides the log likelihood values from each power posterior into
    consecutive blocks of random size (drawn from a geometric distribution) and
    resamples them with replacement. The RevBayes implementation of the stationary
    block bootstrap method is based on the mcmc3r R package (lvarez-Carretero et
    al. 2022), and can be accessed by calling `.stdError(bootstrap=TRUE)`.
  example: |
    # Create a simple model (unclamped)
    a ~ dnExponential(1)
    mymodel = model(a)
    
    # Create a move vector and a monitor vector
    moves[1] = mvScale(a, lambda = 1.0, weight = 1.0)
    monitors[1] = mnFile(a, filename = "output/out.log")
    
    # Run 64 power posterior analyses, each with 100 samples
    pow_p = powerPosterior(mymodel, monitors, moves, "output/out.pp", cats=64, sampleFreq=1)
    pow_p.run(generations=200, burninFraction=0.5)
    
    # Create a path sampler object from a file that RevBayes
    # automatically generated by concatenating the likelihoods from
    # individual power posteriors
    ps = pathSampler(file="output/out.pp", powerColumnName="power",
                     likelihoodColumnName="likelihood")
    
    # Compute the marginal likelihood
    ps.marginal()
    
    # Compute the standard error
    ps.stdError()                                               # default formula
    ps.stdError(bootstrap=TRUE)                                 # bootstrap (100 replicates)
    ps.stdError(bootstrap=TRUE, replicates=50, printFiles=TRUE) # bootstrap (50 replicates, save output)
  authors:
  see_also:
    - 'powerPosterior'
    - 'steppingStoneSampler'
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'pathSampler(String<any> filename, String<any> powerColumnName, String<any> likelihoodColumnName, String<any> separator)'
      arguments:
        - label: 'filename'
          description: 'The filename where the likelihood samples are stored in.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'powerColumnName'
          description: 'The name of the column that holds the values of the powers.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'likelihoodColumnName'
          description: 'The name of the column that holds the likelihood values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'separator'
          description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
  methods:
    - name: 'marginal'
      return_type: 'Real'
      usage: 'marginal()'
      arguments:
    - name: 'stdError'
      return_type: 'Real'
      usage: 'stdError(Bool<any> bootstrap, Natural<any> replicates, Probability<any> blockLength, Bool<any> printFiles, Bool<any> verbose)'
      arguments:
        - label: 'bootstrap'
          description: 'Should we use the block bootstrap method to calculate the standard error?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'replicates'
          description: 'How many block bootstrap replicates to generate. (Has effect only if bootstrap=TRUE)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '100'
          options:
        - label: 'blockLength'
          description: 'Average block length, given as a fraction of the total chain length. (Has effect only if bootstrap=TRUE)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.1'
          options:
        - label: 'printFiles'
          description: 'Should we save the bootstrap replicates as text files? (Has effect only if bootstrap=TRUE)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'verbose'
          description: 'Should we print the marginal likelihoods and 95% CI calculated from the bootstrap replicates? (Has effect only if bootstrap=TRUE)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  references:
    - citation: 'lvarez-Carretero S, Tamuri AU, Battini M, Nascimento FF, Carlisle E, Asher RJ, Yang Z, Donoghue PCJ, dos Reis M (2022). A species-level timeline of mammal evolution integrating phylogenomic data. Nature, 602(7896):263-267.'
      doi: '10.1038/s41586-021-04341-1'
      url: 'https://www.nature.com/articles/s41586-021-04341-1'
    - citation: 'dos Reis M, Gunnell GF, Barba-Montoya J, Wilkins A, Yang Z, Yoder AD (2018). Using phylogenomic data to explore the effects of relaxed clocks and calibration strategies on divergence time estimation: primates as a test case. Systematic Biology, 67(4):594-615.'
      doi: '10.1093/sysbio/syy001'
      url: 'https://academic.oup.com/sysbio/article/67/4/594/4802240'
    - citation: 'Gelman A, Meng X-L (1998). Simulating normalizing constants: from importance sampling to bridge sampling to path sampling. Statistical Science, 13(2):163-185.'
      doi: '10.1214/ss/1028905934'
      url: 'https://www.jstor.org/stable/2676756'
    - citation: 'Lartillot N, Philippe H (2006). Computing Bayes factors using thermodynamic integration. Systematic Biology, 55(2):195-207.'
      doi: '10.1080/10635150500433722'
      url: 'https://academic.oup.com/sysbio/article-abstract/55/2/195/1620800'
    - citation: 'Ogata Y (1989). A Monte Carlo method for high dimensional integration. Numerische Mathematik, 55:137-157.'
      doi: '10.1007/BF01406511'
      url: 'https://link.springer.com/article/10.1007/BF01406511'
    - citation: 'Politis DN, Romano JP (1994). The stationary bootstrap. Journal of the American Statistical Association, 89(428):1303-1313.'
      doi: '10.1080/01621459.1994.10476870'
      url: 'https://www.tandfonline.com/doi/abs/10.1080/01621459.1994.10476870'
- name: 'posteriorPredictiveAnalysis'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'posteriorPredictiveAnalysis(MonteCarloAnalysis<any> sampler, String<any> directory)'
      arguments:
        - label: 'sampler'
          description: 'The template Monte Carlo sampler instance.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'MonteCarloAnalysis'
          default:
          options:
        - label: 'directory'
          description: 'The name of the directory where the simulated data are.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
  methods:
    - name: 'run'
      return_type: 'void'
      usage: 'run(Natural<any> generations)'
      arguments:
        - label: 'generations'
          description: 'The number of generation to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  references:
- name: 'posteriorPredictiveSimulation'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'posteriorPredictiveSimulation(Model<any> model, String<any> directory, ModelTrace[]<any> trace, AncestralStateTrace[]<any> ancestralStateTrace)'
      arguments:
        - label: 'model'
          description: 'The reference model instance.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Model'
          default:
          options:
        - label: 'directory'
          description: 'The name of the directory where we store the simulations.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'trace'
          description: 'The sample trace object.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'ModelTrace[]'
          default:
          options:
        - label: 'ancestralStateTrace'
          description: 'The ancestral state trace object. Used only for simulating CDBDP when conditioning on sampled tip states.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'AncestralStateTrace[]'
          default: 'NULL'
          options:
  methods:
    - name: 'run'
      return_type: 'void'
      usage: 'run(Natural<any> thinning)'
      arguments:
        - label: 'thinning'
          description: 'The number of samples to jump over.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
  references:
- name: 'powerPosterior'
  title: 'Power posterior analysis'
  aliases:
  description: |
    Samples from a series of "power posterior" distributions with the likelihood
    term raised to a power between 0 and 1. Such distributions are often used to
    estimate marginal likelihoods for model selection or hypothesis testing via
    Bayes factors (Gelman & Meng 1998; Friel & Pettitt 2008).
  details: |
    A power posterior analysis samples from a series of importance distributions of
    the form:
        f_beta(theta | Y) = f(theta) x f(Y | theta)^beta
        
    where theta jointly denotes the parameters of interest and Y denotes data, so
    f(theta) denotes the prior and f(Y | theta) denotes the likelihood. Since beta
    ranges from 0 to 1, the power posterior distributions form "stepping stones"
    along the path between the prior (beta = 0) and the posterior (beta = 1). For
    this reason, individual power posteriors are also referred to as stones, and
    the two main techniques that employ them to estimate marginal likelihoods are
    known as path sampling (Gelman & Meng 1998; Lartillot & Philippe 2006) and
    stepping-stone sampling (Fan et al. 2011; Xie et al. 2011).
    
    The user can either supply their own vector of beta powers using the `powers`
    argument, or just a number of power posteriors to sample from using the `cats`
    argument. In the latter case, if `cats=K`, the powers are calculated following
    Xie et al. (2011) as:
        beta_i = [i / (K - 1)]^(1 / alpha) for i in K - 1, ..., 0
        
    so that they correspond to evenly spaced quantiles of the Beta(alpha, 1)
    distribution, where the shape parameter `alpha` is a user-specified argument
    set to 0.2 by default. The samples from each distribution are recorded in a
    file with a base name specified by the `filename` argument and an automatically
    appended suffix equal to (K - i). The output file with the suffix "_stone_1" 
    will therefore contain samples from the actual posterior (beta = 1), while the
    file with the suffix "_stone_<K>" will contain samples from the prior. For 
    reasons of numerical stability, the beta of this final stone is not set exactly
    to 0 but to an extremely small positive number (~ 1.2e-302).
    
    The RevBayes implementation of power posterior analysis is fully parallelized
    (Hoehna et al. 2021). In general, after a common pre-burnin stage that should
    allow the sampler to converge to the posterior (see the `.burnin()` method),
    the `.run()` method will distribute the K stones among M available CPUs in such
    a way that each CPU handles floor(K/M) or ceiling(K/M) consecutive powers. This
    has the advantage of allowing the last sample for one power to be used as the
    starting state for the subsequent power. However, to account for the transition
    from one power to the next, each power posterior should still include a small
    burnin fraction (set to 0.25 by default and specified by the `burninFraction`
    argument to the `.run()` method). For example, with K = 50, M = 8, and a single
    CPU used for each likelihood computation (`procPerLikelihood=1`, by default),
    the individual power posteriors will be distributed among the CPUs as follows:
    
        -----------------------------------------------------------------
                            Filename suffix (= K - i)
        -----------------------------------------------------------------
        | CPU 1 | CPU 2 | CPU 3 | CPU 4 | CPU 5 | CPU 6 | CPU 7 | CPU 8 |
        |-------|-------|-------|-------|-------|-------|-------|-------|
        |   1   |   7   |   13  |   19  |   26  |   32  |   38  |   44  |
        |   2   |   8   |   14  |   20  |   27  |   33  |   39  |   45  |
        |  ...  |  ...  |  ...  |  ...  |  ...  |  ...  |  ...  |  ...  |
        |   6   |   12  |   18  |   24  |   31  |   37  |   43  |   49  |
        |       |       |       |   25  |       |       |       |   50  |
    
    More flexible strategies are enabled by the `.runOneStone()` method, which
    allows the user to execute a separate analysis for each power posterior.
  example: |
    # Create a simple model (unclamped)
    a ~ dnExponential(1)
    mymodel = model(a)
    
    # Create a move vector and a monitor vector
    moves[1] = mvScale(a, lambda = 1.0, weight = 1.0)
    monitors[1] = mnFile(a, filename = "output/out.log")
    
    # Create an analysis object to sample from 16 distributions
    pow_p = powerPosterior(mymodel, monitors, moves, "output/out.pp", cats=16, sampleFreq=1)
    
    # Execute a single power posterior ("stone"), or the entire analysis
    pow_p.burnin(generations=100, tuningInterval=50)                # pre-burnin
    pow_p.runOneStone(index=1, generations=20, burninFraction=0.1)  # run just the posterior
    pow_p.runOneStone(index=16, generations=20, burninFraction=0.1) # run just the prior
    pow_p.run(generations=20, burninFraction=0.1)                   # run all stones
    
    # Compute the marginal likelihood using the stepping-stone sampler
    ss = steppingStoneSampler(file="output/out.pp", powerColumnName="power",
                              likelihoodColumnName="likelihood")
    ss.marginal()
  authors:
  see_also:
    - 'pathSampler'
    - 'steppingStoneSampler'
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'powerPosterior(Model<any> model, Move[]<any> moves, Monitor[]<any> monitors, String<any> filename, RealPos[]<any> powers, Natural<any> cats, RealPos<any> alpha, Natural<any> sampleFreq, Natural<any> procPerLikelihood)'
      arguments:
        - label: 'model'
          description: 'The model graph.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Model'
          default:
          options:
        - label: 'moves'
          description: 'The vector moves to use.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Move[]'
          default:
          options:
        - label: 'monitors'
          description: 'The monitors to call. Do not provide a screen monitor.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Monitor[]'
          default:
          options:
        - label: 'filename'
          description: 'The name of the file for the likelihood samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'powers'
          description: 'A vector of powers.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos[]'
          default: 'NULL'
          options:
        - label: 'cats'
          description: 'Number of power posteriors (categories) to run if no powers are specified.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '100'
          options:
        - label: 'alpha'
          description: 'The alpha parameter of the beta distribution if no powers are specified.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0.2'
          options:
        - label: 'sampleFreq'
          description: 'The sampling frequency of the likelihood values.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '100'
          options:
        - label: 'procPerLikelihood'
          description: 'Number of processors used to compute the likelihood.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '1'
          options:
  methods:
    - name: 'burnin'
      return_type: 'void'
      usage: 'burnin(Natural<any> generations, Natural<any> tuningInterval)'
      arguments:
        - label: 'generations'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'tuningInterval'
          description: 'The frequency at which the moves are tuned (usually between 50 and 1000).'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'run'
      return_type: 'void'
      usage: 'run(Natural<any> generations, Probability<any> burninFraction, Natural<any> preburninGenerations, Natural<any> tuningInterval)'
      arguments:
        - label: 'generations'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'burninFraction'
          description: 'The fraction of samples to discard.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.25'
          options:
        - label: 'preburninGenerations'
          description: 'The number of generations to run as pre-burnin when parameter tuning is done.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: 'NULL'
          options:
        - label: 'tuningInterval'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '100'
          options:
    - name: 'runOneStone'
      return_type: 'void'
      usage: 'runOneStone(Natural<any> index, Natural<any> generations, Probability<any> burninFraction, Natural<any> preburninGenerations, Natural<any> tuningInterval)'
      arguments:
        - label: 'index'
          description: 'Index of the stone/power to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'generations'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'burninFraction'
          description: 'The fraction of samples to discard.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.25'
          options:
        - label: 'preburninGenerations'
          description: 'The number of generations to run as pre-burnin when parameter tuning is done.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: 'NULL'
          options:
        - label: 'tuningInterval'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '100'
          options:
    - name: 'summarize'
      return_type: 'void'
      usage: 'summarize()'
      arguments:
  references:
    - citation: 'Fan Y, Wu R, Chen M-H, Kuo L, Lewis PO (2011). Choosing among partition models in Bayesian phylogenetics. Molecular Biology and Evolution, 28(1):523-532.'
      doi: '10.1093/molbev/msq224'
      url: 'https://academic.oup.com/mbe/article/28/1/523/983866'
    - citation: 'Friel N, Pettitt AN (2008). Marginal likelihood estimation via power posteriors. Journal of the Royal Statistical Society Series B: Statistical Methodology, 70(3):589-607.'
      doi: '10.1111/j.1467-9868.2007.00650.x'
      url: 'https://academic.oup.com/jrsssb/article-abstract/70/3/589/7109555'
    - citation: 'Gelman A, Meng X-L (1998). Simulating normalizing constants: from importance sampling to bridge sampling to path sampling. Statistical Science, 13(2):163-185.'
      doi: '10.1214/ss/1028905934'
      url: 'https://www.jstor.org/stable/2676756'
    - citation: 'Hoehna S, Landis MJ, Huelsenbeck JP (2021). Parallel power posterior analyses for fast computation of marginal likelihoods in phylogenetics. PeerJ, 9:e12438.'
      doi: '10.7717/peerj.12438'
      url: 'https://peerj.com/articles/12438/'
    - citation: 'Lartillot N, Philippe H (2006). Computing Bayes factors using thermodynamic integration. Systematic Biology, 55(2):195-207.'
      doi: '10.1080/10635150500433722'
      url: 'https://academic.oup.com/sysbio/article-abstract/55/2/195/1620800'
    - citation: 'Xie W, Lewis PO, Fan Y, Kuo L, Chen M-H (2010). Improving marginal likelihood estimation for Bayesian phylogenetic model selection. Systematic Biology, 60(2):150-160.'
      doi: '10.1093/sysbio/syq085'
      url: 'https://academic.oup.com/sysbio/article-abstract/60/2/150/2461669'
- name: 'srGelmanRubin'
  title: 'Gelman-Rubin (PSRF) stopping rule'
  aliases:
  description: |
    Terminates an MCMC run when the Gelman-Rubin statistic drops below the
    specified value.
  details: |
    The Gelman-Rubin statistic, also referred to as the potential scale reduction
    factor (PSRF), compares the variance of the sample pooled from multiple runs to
    the sum of variances calculated from individual runs. Accordingly, it can only
    be calculated when two or more independent runs are performed, and its value
    tends to unity (1) as the runs converge.
    
    The number of samples to be removed as burnin before calculating the test
    statistic is determined using the `burninMethod`. Different burnin lengths are
    tested, increasing from 0 to 50% (for `ESS`) or 100% (for `SEM`) of the length
    of the trace in increments of 10 samples. If the `ESS` option is chosen
    (default), effective sample sizes (ESS) are calculated for all monitored
    parameters after removing the number of samples corresponding to each candidate
    burnin length. The best burnin length for a given parameter is the one that
    maximizes its ESS value. If the `SEM` option is chosen, the standard error of
    the mean (SEM) is calculated instead, and the best burnin length for a given
    parameter is the one that minimizes its SEM value. In both cases, the final
    burnin length is set to the maximum of the parameter-specific burnin lengths.
    
    See also the tutorial on [convergence assessment](https://revbayes.github.io/tutorials/convergence/).
  example: |
    # Binomial example: estimate success probability given 7 successes out of 20 trials
    r ~ dnExp(10)
    p := Probability(ifelse(r < 1, r, 1))
    n <- 20
    k ~ dnBinomial(n, p)
    k.clamp(7)
    mymodel = model(k)
    
    moves = VectorMoves()
    moves.append( mvSlide(r, delta=0.1, weight=1) )
    
    paramFile = "parameters.log"
    
    monitors = VectorMonitors()
    monitors.append( mnModel(filename=paramFile, printgen=100, p) )
    
    # Stop when the potential scale reduction factor falls below 1.01
    stopping_rules[1] = srGelmanRubin(1.01, file = paramFile, freq = 1000)
    
    # Create the MCMC object.
    # Set nruns = 2 to ensure the Gelman-Rubin statistic is applicable
    mymcmc = mcmc(mymodel, monitors, moves, nruns = 2)
    
    # Begin the MCMC run
    mymcmc.run(rules = stopping_rules)
  authors:
  see_also:
    - 'mcmc'
    - 'srGeweke'
    - 'srMinESS'
    - 'srStationarity'
  type_spec:
    - 'AbstractConvergenceStoppingRule'
    - 'StoppingRule'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'srGelmanRubin(RealPos<any> R, String<any> filename, Natural<any> frequency, String<any> burninMethod {valid options: "ESS"|"SEM"})'
      arguments:
        - label: 'R'
          description: 'The maximum allowed potential scale reduction factor.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
        - label: 'filename'
          description: 'The name of the file containing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'frequency'
          description: 'The frequency how often to check for convergence.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10000'
          options:
        - label: 'burninMethod'
          description: 'Which type of burnin method to use.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'ESS'
          options:
            - 'ESS'
            - 'SEM'
  methods:
  references:
    - citation: 'Gelman A, Rubin DB (1992). Inference from iterative simulation using multiple sequences. Statistical Science, 7(4):457--472.'
      doi: '10.1214/ss/1177011136'
      url:
    - citation: 'Vats D, Knudson C (2021). Revisiting the Gelman--Rubin diagnostic. Statistical Science, 36(4):518--529.'
      doi: '10.1214/20-STS812'
      url:
- name: 'srGeweke'
  title: 'Geweke stopping rule'
  aliases:
  description: |
    Terminates an MCMC run when the Geweke test statistic ceases to be significant
    at the specified level.
  details: |
    Geweke (1992) proposed a convergence diagnostic for Markov chains based on
    a test for equality of the means of the first and last part of a Markov chain
    (by default the first 10% and the last 50%). If the samples are drawn from the
    stationary distribution of the chain, the two means are equal and Geweke's
    statistic has an asymptotically standard normal distribution.
    
    The test statistic is a standard Z-score: the difference between the two sample
    means divided by its estimated standard error. The standard error is estimated
    from the spectral density at zero and so accounts for any autocorrelation. The
    Z-score is calculated under the assumption that the two parts of the chain are
    asymptotically independent, which requires that the sum of `frac1` and `frac2`
    be strictly less than 1.
    
    The number of samples to be removed as burnin before calculating the test
    statistic is determined using the `burninMethod`. Different burnin lengths are
    tested, increasing from 0 to 50% (for `ESS`) or 100% (for `SEM`) of the length
    of the trace in increments of 10 samples. If the `ESS` option is chosen
    (default), effective sample sizes (ESS) are calculated for all monitored
    parameters after removing the number of samples corresponding to each candidate
    burnin length. The best burnin length for a given parameter is the one that
    maximizes its ESS value. If the `SEM` option is chosen, the standard error of
    the mean (SEM) is calculated instead, and the best burnin length for a given
    parameter is the one that minimizes its SEM value. In both cases, the final
    burnin length is set to the maximum of the parameter-specific burnin lengths.
    
    See also the tutorial on [convergence assessment](https://revbayes.github.io/tutorials/convergence/).
    
    This help file incorporates text by Martyn Plummer.
  example: |
    # Binomial example: estimate success probability given 7 successes out of 20 trials
    r ~ dnExp(10)
    p := Probability(ifelse(r < 1, r, 1))
    n <- 20
    k ~ dnBinomial(n, p)
    k.clamp(7)
    mymodel = model(k)
    
    moves = VectorMoves()
    moves.append( mvSlide(r, delta=0.1, weight=1) )
    
    paramFile = "parameters.log"
    
    monitors = VectorMonitors()
    monitors.append( mnModel(filename=paramFile, printgen=100, p) )
    
    # Stop when the Geweke test statistic is no longer significant at alpha = 0.001
    stopping_rules[1] = srGeweke( prob=0.001, file=paramFile, freq=10000 )
    
    # Create the MCMC object
    mymcmc = mcmc( mymodel, monitors, moves )
    
    # Begin the MCMC run
    mymcmc.run( rules = stopping_rules )
  authors:
  see_also:
    - 'mcmc'
    - 'srGelmanRubin'
    - 'srMinESS'
    - 'srStationarity'
  type_spec:
    - 'AbstractConvergenceStoppingRule'
    - 'StoppingRule'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'srGeweke(Probability<any> prob, Probability<any> frac1, Probability<any> frac2, String<any> filename, Natural<any> frequency, String<any> burninMethod {valid options: "ESS"|"SEM"})'
      arguments:
        - label: 'prob'
          description: 'The significance level.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.05'
          options:
        - label: 'frac1'
          description: 'The fraction of samples used for the first window.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.1'
          options:
        - label: 'frac2'
          description: 'The fraction of samples used for the second window.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.5'
          options:
        - label: 'filename'
          description: 'The name of the file containing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'frequency'
          description: 'The frequency how often to check for convergence.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10000'
          options:
        - label: 'burninMethod'
          description: 'Which type of burnin method to use.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'ESS'
          options:
            - 'ESS'
            - 'SEM'
  methods:
  references:
    - citation: 'Geweke J (1992). Evaluating the accuracy of sampling-based approaches to calculating posterior moments. Pp. 169--194 in Bernado M, Berger JO, Dawid AP, Smith AFM, eds. Bayesian Statistics 4. Clarendon Press, Oxford, UK.'
      doi: '10.1093/oso/9780198522669.003.0010'
      url: 'https://academic.oup.com/book/54041/chapter-abstract/422209572'
- name: 'srMaxIteration'
  title: 'Maximum iteration stopping rule'
  aliases:
  description: |
    Terminates an MCMC run once the specified number of iterations have been
    performed. This rule would typically be used alongside other stopping criteria.
  details:
  example: |
    # Binomial example: estimate success probability given 7 successes out of 20 trials
    r ~ dnExp(10)
    p := Probability(ifelse(r < 1, r, 1))
    n <- 20
    k ~ dnBinomial(n, p)
    k.clamp(7)
    mymodel = model(k)
    
    moves = VectorMoves()
    moves.append( mvSlide(r, delta=0.1, weight=1) )
    
    paramFile = "parameters.log"
    
    monitors = VectorMonitors()
    monitors.append( mnModel(filename=paramFile, printgen=100, p) )
    
    # Stop when 1000 iterations have been completed
    stopping_rules[1] = srMaxIteration(1000)
    
    # Create the MCMC object
    mymcmc = mcmc(mymodel, monitors, moves)
    
    # Begin the MCMC run
    mymcmc.run(rules = stopping_rules)
  authors:
  see_also:
    - 'mcmc'
    - 'srMaxTime'
  type_spec:
    - 'StoppingRule'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'srMaxIteration(Natural<any> maxIteration)'
      arguments:
        - label: 'maxIteration'
          description: 'The maximum number of iterations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
  methods:
  references:
- name: 'srMaxTime'
  title: 'Maximum time stopping rule'
  aliases:
  description: 'Terminates an MCMC run once the specified time has elapsed.'
  details:
  example: |
    # Binomial example: estimate success probability given 7 successes out of 20 trials
    r ~ dnExp(10)
    p := Probability(ifelse(r < 1, r, 1))
    n <- 20
    k ~ dnBinomial(n, p)
    k.clamp(7)
    mymodel = model(k)
    
    moves = VectorMoves()
    moves.append( mvSlide(r, delta=0.1, weight=1) )
    
    paramFile = "parameters.log"
    
    monitors = VectorMonitors()
    monitors.append( mnModel(filename=paramFile, printgen=100, p) )
    
    # Stop when the five seconds have elapsed
    stopping_rules[1] = srMaxTime(5, "seconds")
    
    # Create the MCMC object
    mymcmc = mcmc(mymodel, monitors, moves)
    
    # Begin the MCMC run
    mymcmc.run(rules = stopping_rules)
  authors:
  see_also:
    - 'mcmc'
    - 'srMaxIteration'
  type_spec:
    - 'StoppingRule'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'srMaxTime(RealPos<any> maxTime, String<any> unit {valid options: "seconds"|"minutes"|"hours"})'
      arguments:
        - label: 'maxTime'
          description: 'The maximum time to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
        - label: 'unit'
          description: 'The unit in which we measure the maximum time.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'seconds'
          options:
            - 'seconds'
            - 'minutes'
            - 'hours'
  methods:
  references:
- name: 'srMinESS'
  title: 'Effective sample size stopping rule'
  aliases:
  description: |
    Terminates an MCMC run when the effective sample sizes (ESS) of all parameters
    exceed the specified value.
  details: |
    The ESS is the number of independent samples generated by a MCMC sampler.
    It takes into account the correlation between samples within a chain. Low ESS
    values represent high autocorrelation, and consequently more uncertainty
    associated with the parameter estimate.
    
    The MCMC analysis will terminate once all parameters in every run meet the ESS
    threshold. As such, performing additional runs will not decrease the number
    of generations required to meet the ESS threshold, even though it may increase
    the number of indepedent samples in the final, pooled posterior sample.
    
    The number of samples to be removed as burnin before calculating the test
    statistic is determined using the `burninMethod`. Different burnin lengths are
    tested, increasing from 0 to 50% (for `ESS`) or 100% (for `SEM`) of the length
    of the trace in increments of 10 samples. If the `ESS` option is chosen
    (default), ESS is calculated for all monitored parameters after removing the
    number of samples corresponding to each candidate burnin length. The best
    burnin length for a given parameter is the one that maximizes its ESS value.
    If the `SEM` option is chosen, the standard error of the mean (SEM) is
    calculated instead, and the best burnin length for a given parameter is the one
    that minimizes its SEM value. In both cases, the final burnin length is set to
    the maximum of the parameter-specific burnin lengths.
    
    The [convergence assessment](https://revbayes.github.io/tutorials/convergence/)
    tutorial contains a discusson on the calculation and interpretation of the ESS
    diagnostic.
  example: |
    # Binomial example: estimate success probability given 7 successes out of 20 trials
    r ~ dnExp(10)
    p := Probability(ifelse(r < 1, r, 1))
    n <- 20
    k ~ dnBinomial(n, p)
    k.clamp(7)
    mymodel = model(k)
    
    moves = VectorMoves()
    moves.append( mvSlide(r, delta=0.1, weight=1) )
    
    paramFile = "parameters.log"
    
    monitors = VectorMonitors()
    monitors.append( mnModel(filename=paramFile, printgen=100, p) )
    
    # Stop when all monitored parameters have attained an estimated sample size of 50
    stopping_rules[1] = srMinESS(50, file = paramFile, freq = 1000)
    
    # Create the MCMC object
    mymcmc = mcmc(mymodel, monitors, moves)
    
    # Begin the MCMC run
    mymcmc.run(rules = stopping_rules)
  authors:
  see_also:
    - 'mcmc'
    - 'srGelmanRubin'
    - 'srGeweke'
    - 'srStationarity'
  type_spec:
    - 'AbstractConvergenceStoppingRule'
    - 'StoppingRule'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'srMinESS(RealPos<any> minEss, String<any> filename, Natural<any> frequency, String<any> burninMethod {valid options: "ESS"|"SEM"})'
      arguments:
        - label: 'minEss'
          description: 'The minimum ESS threshold when stopping is allowed.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default:
          options:
        - label: 'filename'
          description: 'The name of the file containing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'frequency'
          description: 'The frequency how often to check for convergence.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10000'
          options:
        - label: 'burninMethod'
          description: 'Which type of burnin method to use.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'ESS'
          options:
            - 'ESS'
            - 'SEM'
  methods:
  references:
    - citation: 'Guimares Fabreti L, Hhna S (2022). Convergence assessment for Bayesian phylogenetic analysis using MCMC simulation. Methods in Ecology and Evolution, 13(1):77--90.'
      doi: '10.1111/2041-210X.13727'
      url: 'https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.13727'
- name: 'srStationarity'
  title: 'Stationarity stopping rule'
  aliases:
  description: |
    Terminates an MCMC run when the difference between the means of individual runs
    and the mean of the sample pooled from all runs ceases to be significant.
  details: |
    This convergence criterion evaluates whether the mean of the sample pooled
    from multiple runs lies outside the confidence interval of width 1 - `prob`
    constructed for the mean of each individual run. Accordingly, it can only be
    calculated when two or more independent runs are performed.
    
    The number of samples to be removed as burnin before calculating the test
    statistic is determined using the `burninMethod`. Different burnin lengths are
    tested, increasing from 0 to 50% (for `ESS`) or 100% (for `SEM`) of the length
    of the trace in increments of 10 samples. If the `ESS` option is chosen
    (default), effective sample sizes (ESS) are calculated for all monitored
    parameters after removing the number of samples corresponding to each candidate
    burnin length. The best burnin length for a given parameter is the one that
    maximizes its ESS value. If the `SEM` option is chosen, the standard error of
    the mean (SEM) is calculated instead, and the best burnin length for a given
    parameter is the one that minimizes its SEM value. In both cases, the final
    burnin length is set to the maximum of the parameter-specific burnin lengths.
    
    See also the tutorial on [convergence assessment](https://revbayes.github.io/tutorials/convergence/).
  example: |
    # Binomial example: estimate success probability given 7 successes out of 20 trials
    r ~ dnExp(10)
    p := Probability(ifelse(r < 1, r, 1))
    n <- 20
    k ~ dnBinomial(n, p)
    k.clamp(7)
    mymodel = model(k)
    
    moves = VectorMoves()
    moves.append( mvSlide(r, delta=0.1, weight=1) )
    
    paramFile = "parameters.log"
    
    monitors = VectorMonitors()
    monitors.append( mnModel(filename=paramFile, printgen=100, p) )
    
    # Stop when stationarity has been attained at confidence level gamma = 0.25
    stopping_rules[1] = srStationarity(prob = 0.25, file = paramFile, freq = 1000)
    
    # Create the MCMC object
    # Set nruns = 2 to ensure the stationarity statistic is applicable
    mymcmc = mcmc(mymodel, monitors, moves, nruns = 2)
    
    # Begin the MCMC run
    mymcmc.run(rules = stopping_rules)
  authors:
  see_also:
    - 'mcmc'
    - 'srGelmanRubin'
    - 'srGeweke'
    - 'srMinESS'
  type_spec:
    - 'AbstractConvergenceStoppingRule'
    - 'StoppingRule'
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'srStationarity(Probability<any> prob, String<any> filename, Natural<any> frequency, String<any> burninMethod {valid options: "ESS"|"SEM"})'
      arguments:
        - label: 'prob'
          description: 'The significance level.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default:
          options:
        - label: 'filename'
          description: 'The name of the file containing the samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'frequency'
          description: 'The frequency how often to check for convergence.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '10000'
          options:
        - label: 'burninMethod'
          description: 'Which type of burnin method to use.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'ESS'
          options:
            - 'ESS'
            - 'SEM'
  methods:
  references:
    - citation: 'Hill SD, Spall JC (2011). Stationarity and convergence of the Metropolis-Hastings algorithm: insights into theoretical aspects. IEEE Control Systems Magazine 39(1):56--67.'
      doi: '10.1109/MCS.2018.2876959'
      url:
- name: 'steppingStoneSampler'
  title: 'Stepping-stone marginal likelihood estimation'
  aliases:
  description: |
    Applies the stepping-stone technique (Fan et al. 2011; Xie et al. 2011) to
    estimate the marginal likelihood of a model from a series of unnormalized
    "power posterior" densities in which the likelihood term is raised to a power
    B between 0 and 1.
  details: |
    For K power posteriors starting with the posterior proper (B_1 = 1) and ending
    with the prior (B_K = 0), the stepping-stone marginal likelihood estimate r_SS
    is equal to:
    
        r_SS = \prod_{k=1}^K r_{SS,k}
        
    where
    
        r_{SS,k} = (1/n) * L_{max,k}^(B_{k-1} - B_k) * \sum_{i=1}^n (L_{i,k - 1} / L_{max,k})^(B_{k-1} - B_k)
        
    where n denotes the number of MCMC samples from each power posterior,
    L_{max,k} denotes the highest likelihood sampled for the k-th power posterior,
    and L_{k,i} denotes the likelihood of the i-th MCMC sample from the k-th power
    posterior (Xie et al. 2011: 153). If we instead assume that L_{max,k} and
    L_{i,k} are given on the log scale, and that r_SS is to be expressed on the
    log scale as well, this yields:
    
        r_SS = \sum_{k=1}^K L_{max,k} * (B_k - B_{k-1}) + log( \sum_{i=1}^n exp( (L_{i,k-1} - L_{max,k}) * (B_{k-1} - B_k) ) / n )
        
    which is how the method is implemented in RevBayes. The estimate is returned by
    calling the `.marginal()` method on the sampler object. We can also compute the
    standard error of this estimate in two different ways using the `.stdError()`
    method. By default, the method uses the delta approximation suggested by Xie et 
    al. (2011: 153):
    
        SE = sqrt( \sum_{k=1}^K 1/r_{SS,k}^2 * Var( r_{SS,k} )/N_{eff,k} )
        
    where N_{eff,k} is the effective sample size for the k-th power posterior. The
    approximation may be unreliable if any individual summand exceeds ~0.1, which
    may occur when the sample size for a given power posterior is too low. This is
    common in analyses employing a large number of relatively short power posterior
    runs. In these cases, it may be preferable to derive the standard error using
    the stationary bootstrap method (Politis & Romano 1994), which divides the log
    likelihood values from each power posterior into consecutive blocks of random
    size (drawn from a geometric distribution) and resamples them with replacement.
    The RevBayes implementation of the stationary block bootstrap method is based
    on the mcmc3r R package (lvarez-Carretero et al. 2022), and can be accessed by
    calling `.stdError(bootstrap=TRUE)`.
  example: |
    # Create a simple model (unclamped)
    a ~ dnExponential(1)
    mymodel = model(a)
    
    # Create a move vector and a monitor vector
    moves[1] = mvScale(a, lambda = 1.0, weight = 1.0)
    monitors[1] = mnFile(a, filename = "output/out.log")
    
    # Run 64 power posterior analyses, each with 100 samples
    pow_p = powerPosterior(mymodel, monitors, moves, "output/out.pp", cats=64, sampleFreq=1)
    pow_p.run(generations=200, burninFraction=0.5)
    
    # Create a stepping-stone sampler object from a file that RevBayes
    # automatically generated by concatenating the likelihoods from
    # individual power posteriors
    ss = steppingStoneSampler(file="output/out.pp", powerColumnName="power",
                              likelihoodColumnName="likelihood")
    
    # Compute the marginal likelihood
    ss.marginal()
    
    # Compute the standard error
    ss.stdError()                                               # delta approximation
    ss.stdError(bootstrap=TRUE)                                 # bootstrap (100 replicates)
    ss.stdError(bootstrap=TRUE, replicates=50, printFiles=TRUE) # bootstrap (50 replicates, save output)
  authors:
  see_also:
    - 'pathSampler'
    - 'powerPosterior'
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'steppingStoneSampler(String<any> filename, String<any> powerColumnName, String<any> likelihoodColumnName, String<any> separator)'
      arguments:
        - label: 'filename'
          description: 'The name of the file where the likelhood samples are stored.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'powerColumnName'
          description: 'The name of the column of the powers.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'likelihoodColumnName'
          description: 'The name of the column of the likelihood samples.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'separator'
          description: 'The field separator character. Values on each line of the file are separated by this character. If sep = "" the separator is ''white space'', that is one or more spaces, tabs, newlines or carriage returns.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
  methods:
    - name: 'marginal'
      return_type: 'Real'
      usage: 'marginal()'
      arguments:
    - name: 'stdError'
      return_type: 'Real'
      usage: 'stdError(Bool<any> bootstrap, Natural<any> replicates, Probability<any> blockLength, Bool<any> printFiles, Bool<any> verbose)'
      arguments:
        - label: 'bootstrap'
          description: 'Should we use the block bootstrap method to calculate the standard error?'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'replicates'
          description: 'How many block bootstrap replicates to generate. (Has effect only if bootstrap=TRUE)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default: '100'
          options:
        - label: 'blockLength'
          description: 'Average block length, given as a fraction of the total chain length. (Has effect only if bootstrap=TRUE)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.1'
          options:
        - label: 'printFiles'
          description: 'Should we save the bootstrap replicates as text files? (Has effect only if bootstrap=TRUE)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'FALSE'
          options:
        - label: 'verbose'
          description: 'Should we print the marginal likelihoods and 95% CI calculated from the bootstrap replicates? (Has effect only if bootstrap=TRUE)'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Bool'
          default: 'TRUE'
          options:
  references:
    - citation: 'lvarez-Carretero S, Tamuri AU, Battini M, Nascimento FF, Carlisle E, Asher RJ, Yang Z, Donoghue PCJ, dos Reis M (2022). A species-level timeline of mammal evolution integrating phylogenomic data. Nature, 602(7896):263-267.'
      doi: '10.1038/s41586-021-04341-1'
      url: 'https://www.nature.com/articles/s41586-021-04341-1'
    - citation: 'Fan Y, Wu R, Chen M-H, Kuo L, Lewis PO (2011). Choosing among partition models in Bayesian phylogenetics. Molecular Biology and Evolution, 28(1):523-532.'
      doi: '10.1093/molbev/msq224'
      url: 'https://academic.oup.com/mbe/article/28/1/523/983866'
    - citation: 'Politis DN, Romano JP (1994). The stationary bootstrap. Journal of the American Statistical Association, 89(428):1303-1313.'
      doi: '10.1080/01621459.1994.10476870'
      url: 'https://www.tandfonline.com/doi/abs/10.1080/01621459.1994.10476870'
    - citation: 'Xie W, Lewis PO, Fan Y, Kuo L, Chen M-H (2010). Improving marginal likelihood estimation for Bayesian phylogenetic model selection. Systematic Biology, 60(2):150-160.'
      doi: '10.1093/sysbio/syq085'
      url: 'https://academic.oup.com/sysbio/article-abstract/60/2/150/2461669'
- name: 'taxon'
  title: 'Taxon object'
  aliases:
  description: 'The taxon function creates a Taxon object.'
  details: 'Each Taxon object records that taxon''s name in addition to other information, such as age (which is non-zero for fossils). Character matrices and trees contain Taxon vectors (Taxon[]) that are used to match leaf nodes to data entries for phylogenetic analyses. For multispecies coalescent analyses, Taxon objects are also used to assign species memberships to individuals.'
  example: |
    # we can create a Taxon object
    taxon_gorilla = taxon("Gorilla_gorilla")
    # we can create a dummy vector of Taxon objects for simulation
    for (i in 1:10) { taxa[i] = taxon("Taxon"+i) }
    phy ~ dnBDP(lambda=1, mu=0, rootAge=1, taxa=taxa)
    # retrieve the taxon list for 'phy'
    phy.taxa()
  authors:
  see_also: 'readTaxonData'
  type_spec: 'RevObject'
  constructor:
    - usage: 'taxon(String<any> taxonName, String<any> speciesName, RealPos<any> age, RealPos<any> max)'
      arguments:
        - label: 'taxonName'
          description: 'The name of the taxon.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default:
          options:
        - label: 'speciesName'
          description: 'The name of the species it belongs to.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'taxonName'
          options:
        - label: 'age'
          description: 'The (minimum) age before the present when this taxon was sampled.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: '0'
          options:
        - label: 'max'
          description: 'The maximum age before the present when this taxon was sampled.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'RealPos'
          default: 'age/min'
          options:
  methods:
    - name: 'getAge'
      return_type: 'String'
      usage: 'getAge()'
      arguments:
    - name: 'getMaxAge'
      return_type: 'String'
      usage: 'getMaxAge()'
      arguments:
    - name: 'getMinAge'
      return_type: 'String'
      usage: 'getMinAge()'
      arguments:
    - name: 'getName'
      return_type: 'String'
      usage: 'getName()'
      arguments:
    - name: 'getSpeciesName'
      return_type: 'String'
      usage: 'getSpeciesName()'
      arguments:
    - name: 'setMaxAge'
      return_type: 'void'
      usage: 'setMaxAge(RealPos<any> a)'
      arguments:
        - label: 'a'
          description: 'The max age of the clade.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
    - name: 'setMinAge'
      return_type: 'void'
      usage: 'setMinAge(RealPos<any> a)'
      arguments:
        - label: 'a'
          description: 'The min age of the clade.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  references:
- name: 'tnExp'
  title: 'Exp-transformed distribution'
  aliases:
  description: 'Exp-transforms a given distribution.'
  details: |
    If X ~ dist then tnExp(dist) is the distribution of exp(X).
    
    The distribution `dist` can be either univariate (dnNormal) or
    multivariate (dnMultivariateNormal).
    
    This turns out to be the same as dnLog(dist), which provides a distribution
    that has distribution `dist` on the log-scale.
  example: |
    x ~ tnExp(dnNormal(0,1))          # Draw from the log-Normal distribution
    x ~ dnNormal(0,1) |> tnExp()      # Expressed using pipes.
    x ~ dnLognormal(0,1)              # This is equivalent.
    y ~ dnNormal(0,1)
    x := exp(y)                       # This is also equivalent.
    
    x ~ tnExp(dnGamma(2,3))           # There is no equivalent for this.
    x ~ dnIID(10,tnExp(dnGamma(2,3))) # Draw 10 log-Gamma(2,3) random variables.
    
    mu = [1.0, 2.0, 3.0, 4.0]
    Sigma ~ dnWishart(df=4, kappa=2, dim=4)
    x ~ dnMultivariateNormal(mu,Sigma) |> tnExp()
  authors:
  see_also: 'tnLog, tnLogit, tnInvlogit'
  type_spec:
    - 'Distribution__RealPos'
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'tnExp(Distribution__Real|Distribution__RealPos|Distribution__Probability<any> baseDistribution)'
      arguments:
        - label: 'baseDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
  methods:
  references:
- name: 'tnInvlogit'
  title: 'Invlogit-transformed distribution'
  aliases:
  description: 'Invlogit-transforms a given distribution.'
  details: |
    If X ~ dist then tnInvlogit(dist) is the distribution of exp(X)/(1+exp(X)).
    The inverse logit function is also called the logistic function.
    
    The distribution `dist` can be either univariate (dnNormal) or
    multivariate (MultivariateNormal).
  example: |
    p ~ tnInvlogit(dnNormal(0,1))      # The inverse-logit of a Normal random variable.
    p ~ dnNormal(0,1) |> tnInvlogit()  # Expressed using pipes.
    
    x ~ dnNormal(0,1)
    p := invlogit(x)                   # Expressed as a deterministic function of the log-odds.
    
    ps ~ dnIID(4,dnNormal(0,1)) |> tnInvlogit()
    
    mu = [1.0, 2.0, 3.0, 4.0]
    Sigma ~ dnWishart(df=4, kappa=2, dim=4)
    x ~ dnMultivariateNormal(mu,Sigma) |> tnInvlogit()
  authors:
  see_also: 'logistic, tnExp, tnLog, tnLogit'
  type_spec:
    - 'Distribution__Probability'
    - 'Distribution'
    - 'RevObject'
  domain: 'Probability'
  constructor:
    - usage: 'tnInvlogit(Distribution__Real|Distribution__RealPos|Distribution__Probability<any> baseDistribution)'
      arguments:
        - label: 'baseDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Real'
          default:
          options:
  methods:
  references:
- name: 'tnLog'
  title: 'Log-transformed distribution'
  aliases:
  description: 'Log-transforms a given distribution.'
  details: |
    If X ~ dist then tnLog(dist) is the distribution of log(X).
    
    The distribution `dist` can be either univariate (dnExponential) or
    multivariate (dnDirichlet).
    
    This is NOT the same as dnLog(dist), which provides a distribution
    that has distribution `dist` on the log-scale.
  example: |
    x ~ tnLog(dnExponential(1))       # The log of an Exponential random variable.
    x ~ dnExponential(1) |> tnLog()   # Expressed using pipes.
    
    y ~ dnExponential(1)
    x := log(y)                       # This is also equivalent.
    
    x ~ dnDirichlet([1,1,1,1]) |> tnLog()
  authors:
  see_also: 'tnExp, tnLogit, tnInvlogit'
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'tnLog(Distribution__RealPos|Distribution__Probability<any> baseDistribution)'
      arguments:
        - label: 'baseDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__RealPos'
          default:
          options:
  methods:
  references:
- name: 'tnLogit'
  title: 'Logit-transformed distribution'
  aliases:
  description: 'Logit-transforms a given distribution.'
  details: |
    If P ~ dist then tnLogit(dist) is the distribution of log(P/(1-P)).
    
    The distribution `dist` can be either univariate (dnBeta) or
    multivariate (dnDirichlet).
  example: |
    x ~ tnLogit(dnBeta(1,2))         # The log-odds of an Beta random variable.
    x ~ dnBeta(1,2)|> tnLogit()      # Expressed using pipes.
    
    p ~ dnBeta(1,2)
    x := logit(p)                    # Expressed as a deterministic function of the probability.
    
    xs ~ dnDirichlet([1,1,1,1]) |> tnLogit()
  authors:
  see_also: 'logit, tnExp, tnLog, tnInvlogitit'
  type_spec:
    - 'Distribution__Real'
    - 'Distribution'
    - 'RevObject'
  domain: 'Real'
  constructor:
    - usage: 'tnLogit(Distribution__Probability<any> baseDistribution)'
      arguments:
        - label: 'baseDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Probability'
          default:
          options:
  methods:
  references:
- name: 'tnScale'
  title: 'A scaled distribution'
  aliases:
  description: 'Rescales a given distribution.'
  details: 'If X ~ dist then tnScale(dist, lambda) is the distribution of X * lambda'
  example: |
    x ~ tnScale(dExponential(1),2)       # An Exponential(rate=0.5) random variable.
    x ~ dnExponential(1) |> tnScale(2)   # Expressed using pipes.
  authors:
  see_also: 'tnScale'
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'Probability'
  constructor:
    - usage: 'tnScale(Distribution__Probability<any> baseDistribution, Probability<any> lambda)'
      arguments:
        - label: 'baseDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__Probability'
          default:
          options:
        - label: 'lambda'
          description: 'The amount muled to base random variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Probability'
          default:
          options:
  methods:
  references:
- name: 'tnShift'
  title: 'A shifted distribution'
  aliases:
  description: 'Shifts a given distribution.'
  details: 'If X ~ dist then tnShift(dist, d) is the distribution of X + d'
  example: |
    x ~ tnShift(dExponential(1),2)       # An exponential variable starting at 2.
    x ~ dnExponential(1) |> tnShift(2)   # Expressed using pipes.
  authors:
  see_also: 'tnScale'
  type_spec:
    - 'Distribution'
    - 'RevObject'
  domain: 'RealPos'
  constructor:
    - usage: 'tnShift(Distribution__RealPos|Distribution__Probability<any> baseDistribution, RealPos<any> delta)'
      arguments:
        - label: 'baseDistribution'
          description: 'The distribution to be transformed.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'Distribution__RealPos'
          default:
          options:
        - label: 'delta'
          description: 'The amount added to base random variable.'
          dag_type: '<any>'
          pass_by: 'const reference'
          value_type: 'RealPos'
          default:
          options:
  methods:
  references:
- name: 'validationAnalysis'
  title:
  aliases:
  description:
  details:
  example:
  authors:
  see_also:
  type_spec:
    - 'WorkspaceToCoreWrapperObject'
    - 'WorkspaceObject'
    - 'RevObject'
  constructor:
    - usage: 'validationAnalysis(MonteCarloAnalysis<any> sampler, Natural<any> simulations, String<any> directory)'
      arguments:
        - label: 'sampler'
          description: 'The template Monte Carlo sampler instance.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'MonteCarloAnalysis'
          default:
          options:
        - label: 'simulations'
          description: 'How many replicate simulations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'directory'
          description: 'The directory for the output of the simulations.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'String'
          default: 'output'
          options:
  methods:
    - name: 'burnin'
      return_type: 'void'
      usage: 'burnin(Natural<any> generations, Natural<any> tuningInterval)'
      arguments:
        - label: 'generations'
          description: 'The number of generation to run this burnin simulation.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
        - label: 'tuningInterval'
          description: 'The interval when to update the tuning parameters of the moves.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'run'
      return_type: 'void'
      usage: 'run(Natural<any> generations)'
      arguments:
        - label: 'generations'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Natural'
          default:
          options:
    - name: 'summarize'
      return_type: 'void'
      usage: 'summarize(Probability<any> coverageProbability)'
      arguments:
        - label: 'coverageProbability'
          description: 'The number of generations to run.'
          dag_type: '<any>'
          pass_by: 'value'
          value_type: 'Probability'
          default: '0.9'
          options:
  references:
